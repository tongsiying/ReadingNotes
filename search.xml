<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>第4讲 总第14讲 函数依赖及其公理 定理</title>
      <link href="/ReadingNotes//23c9b8/"/>
      <url>/ReadingNotes//23c9b8/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/23c9b8/#前言" class="header_1">前言</a>&nbsp;<br><a href="/ReadingNotes/23c9b8/#基本内容" class="header_2">基本内容</a>&nbsp;<br><a href="/ReadingNotes/23c9b8/#重点与难点" class="header_2">重点与难点</a>&nbsp;<br><a href="/ReadingNotes/23c9b8/#函数依赖" class="header_1">函数依赖</a>&nbsp;<br><a href="/ReadingNotes/23c9b8/#-1-函数依赖的定义" class="header_2">(1)函数依赖的定义</a>&nbsp;<br><a href="/ReadingNotes/23c9b8/#示例" class="header_2">示例</a>&nbsp;<br><a href="/ReadingNotes/23c9b8/#-2-函数依赖的示例" class="header_2">(2)函数依赖的示例</a>&nbsp;<br><a href="/ReadingNotes/23c9b8/#表1" class="header_3">表1</a>&nbsp;<br><a href="/ReadingNotes/23c9b8/#表2" class="header_3">表2</a>&nbsp;<br><a href="/ReadingNotes/23c9b8/#-3-函数依赖的特性" class="header_2">(3)函数依赖的特性</a>&nbsp;<br><a href="/ReadingNotes/23c9b8/#-4-函数依赖的提取练习" class="header_2">(4)函数依赖的提取练习</a>&nbsp;<br><a href="/ReadingNotes/23c9b8/#完全函数依赖与传递函数依赖" class="header_1">完全函数依赖与传递函数依赖</a>&nbsp;<br><a href="/ReadingNotes/23c9b8/#-1-部分函数依赖与完全函数依赖的定义" class="header_2">(1)部分函数依赖与完全函数依赖的定义</a>&nbsp;<br><a href="/ReadingNotes/23c9b8/#-2-部分函数依赖与完全函数依赖的示例" class="header_2">(2)部分函数依赖与完全函数依赖的示例</a>&nbsp;<br><a href="/ReadingNotes/23c9b8/#-3-传递函数依赖的定义" class="header_2">(3)传递函数依赖的定义</a>&nbsp;<br><a href="/ReadingNotes/23c9b8/#-4-传递函数依赖的示例" class="header_2">(4)传递函数依赖的示例</a>&nbsp;<br><a href="/ReadingNotes/23c9b8/#函数依赖相关的几个重要概念" class="header_1">函数依赖相关的几个重要概念</a>&nbsp;<br><a href="/ReadingNotes/23c9b8/#-1-候选键的定义" class="header_2">(1)候选键的定义</a>&nbsp;<br><a href="/ReadingNotes/23c9b8/#主键" class="header_2">主键</a>&nbsp;<br><a href="/ReadingNotes/23c9b8/#主属性" class="header_2">主属性</a>&nbsp;<br><a href="/ReadingNotes/23c9b8/#超键" class="header_2">超键</a>&nbsp;<br><a href="/ReadingNotes/23c9b8/#-2-候选键的示例" class="header_2">(2)候选键的示例</a>&nbsp;<br><a href="/ReadingNotes/23c9b8/#-3-外键" class="header_2">(3)外键</a>&nbsp;<br><a href="/ReadingNotes/23c9b8/#-4-逻辑蕴涵的定义" class="header_2">(4)逻辑蕴涵的定义</a>&nbsp;<br><a href="/ReadingNotes/23c9b8/#-5-闭包的定义" class="header_2">(5)闭包的定义</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h2><ol><li>函数依赖</li><li>完全函数依赖与传递函数依赖</li><li>关于函数依赖的公理和定理</li><li>函数依赖集的最小覆盖</li></ol><h2 id="重点与难点"><a href="#重点与难点" class="headerlink" title="重点与难点"></a>重点与难点</h2><ul><li>一组概念:函数依赖、部分函数依赖和完全函数依赖、传递函数依赖、候选键、非主属性、逻辑蕴涵、闭包、属性闭包、覆盖、最小覆盖等</li><li>关于函数依赖的公理和定理,相关的证明</li><li>求属性闭包的算法、求最小覆盖的算法</li></ul><h1 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h1><h2 id="1-函数依赖的定义"><a href="#1-函数依赖的定义" class="headerlink" title="(1)函数依赖的定义"></a>(1)函数依赖的定义</h2><p>设$R(U)$是属性集合$U=\lbrace A_1,A_2,\cdots,A_n \rbrace $上的一个关系模式,$X$, $Y$是$U$上的两个子集,若对$R(U)$的任意一个可能的关系$r$,  $r$中不可能有<strong>两个元组</strong>满足<strong>在$X$中的属性值相等而在$Y$中的属性值不等</strong>,则称<strong>$X$函数决定$Y$</strong>或$Y$函数依赖于$X$, 记作$X \to Y$。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例：$U=\lbrace 学号,姓名,年龄,班号,班长,课号,成绩 \rbrace$</p><ul><li>学号函数决定姓名和年龄:<ul><li>$学号\to\lbrace 姓名,年龄\rbrace$</li></ul></li><li>学号函数决定班长:<ul><li>$班号\to班长$</li></ul></li><li>学号和课号函数决定成绩:<ul><li>$\lbrace 学号,课号\rbrace\to 成绩$</li></ul></li></ul><p>注：函数依赖的分析取决于对问题领域的限定和分析,取决于对业务规则的正确理解。<br>例如：问题领域中,学生是<strong>没有重名的</strong>,则有:<strong>年龄</strong>和<strong>家庭住址</strong>都函数依赖于<strong>姓名</strong>。<br>而在另一个问题领域中,学生是有重名的,则上述函数依赖是不成立的。</p><p>设计关系模式时,除给出属性全集外,还需给出数据依赖集合</p><h2 id="2-函数依赖的示例"><a href="#2-函数依赖的示例" class="headerlink" title="(2)函数依赖的示例"></a>(2)函数依赖的示例</h2><p>示例:下列的表就是问题领域, 则存在的函数依赖有哪些呢?</p><h3 id="表1"><a href="#表1" class="headerlink" title="表1"></a>表1</h3><p><img src="https://raw.githubusercontent.com/lanlan2017/images/master/RedingNotes/ShuJuKuXiTong/Zhong/4/-1.png" alt=""><br>由于属性A上没有重复值,所以属性A可以决定B,A可以决定C<br>当B相同的时候,A有不同的值,所以B不能决定A<br>当B属性值相同的时候,C上的对应属性也是相同的,所以B能决定C<br>$A \to B$,$B \to C$,$A \to C$</p><h3 id="表2"><a href="#表2" class="headerlink" title="表2"></a>表2</h3><p><img src="https://raw.githubusercontent.com/lanlan2017/images/master/RedingNotes/ShuJuKuXiTong/Zhong/4/2.png" alt=""><br>当属性A有相同的属性值时候,B上对应的属性值有不同值,所以A不能决定B<br>当属性A相同的时候,属性C对应的值也相同,所以A能决定C,$A \to C$<br>当属性A相同的时候,属性D对应的值也相同,所以A能决定D,$A \to D$<br>当属性B相同的时候,属性A对应的值不相同,所以B不能决定A,$B \nrightarrow A$<br>当属性B相同的时候,属性C对应的值不相同,所以B不能决定C<br>当属性B相同的时候,属性D对应的值相同,所以B能决定D,$B \to D$<br>当属性C相同的时候,属性A对应的值不相同,所以C不能决定A</p><h2 id="3-函数依赖的特性"><a href="#3-函数依赖的特性" class="headerlink" title="(3)函数依赖的特性"></a>(3)函数依赖的特性</h2><p>(1)对$X \to Y$,但$Y\require{cancel} \cancel{\subset}X$, 则称$X\to Y$为<strong>非平凡的函数依赖</strong>；<br>(2)若$X \to Y$,则任意两个元组,若X上值相等,则Y上值必然相等,则称X为<strong>决定因素</strong>；<br>(3)若$X\to Y$ ,$Y\to X$, 则记作$X \leftrightarrow Y$,互相决定<br>(4)若Y不函数依赖于X,则记作$X \nrightarrow Y$；<br>(5)$X\to Y$,有基于模式R的,则要求对任意的关系r成立；有基于具体关系r的,则要求对某一关系r成立；<br>(6)如一关系r的某属性集X,r中根本没有X上相等的两个元组存在,则$X\to Y$恒成立；</p><h2 id="4-函数依赖的提取练习"><a href="#4-函数依赖的提取练习" class="headerlink" title="(4)函数依赖的提取练习"></a>(4)函数依赖的提取练习</h2><p>请分析下列属性集上的函数依赖<br>$\textbf{学生(学号,姓名,班级,课号,课程名,成绩,教师,教师职务)}$<br>$\textbf{员工(员工码,姓名,出生日期,联系电话, 最后学历,毕业学校,培训日期,培训内容,职务变动日期,变动后职务 )}$<br>$\textbf{图书(书号,书名,出版日期,出版社,书架号,房间号)}$<br>$\textbf{客户(客户号,客户名称,类别,联系电话,产品编码,产品名称,数量,要货日期)}$</p><p>$\textbf{学生(学号,姓名,班级,课号,课程名,成绩,教师,教师职务)}$</p><ul><li>$学号\to \lbrace 姓名,班级 \rbrace$</li><li>$课号\to 课程名$或者:<ul><li>$\lbrace班级,课号\rbrace\to 教师$</li><li>$课号\to 教师$</li><li>$\lbrace学号,课号\rbrace\to 教师$<ul><li>这几个究竟选择哪一个,取决于对问题领域的理解.</li></ul></li></ul></li><li>$\lbrace学号,课号\rbrace\rightarrow 成绩$</li><li>$教师\to教师职务$</li><li>$\lbrace班级,课号\rbrace\to教师$</li></ul><p>$\textbf{客户(客户号,客户名称,类别,联系电话,产品编码,产品名称,数量,要货日期)}$</p><p>$客户号\to\lbrace客户名称,类别\rbrace$<br>$产品编码\to产品名称$<br>$\lbrace客户号,产品编码,要货日期\rbrace\to数量$</p><h1 id="完全函数依赖与传递函数依赖"><a href="#完全函数依赖与传递函数依赖" class="headerlink" title="完全函数依赖与传递函数依赖"></a>完全函数依赖与传递函数依赖</h1><h2 id="1-部分函数依赖与完全函数依赖的定义"><a href="#1-部分函数依赖与完全函数依赖的定义" class="headerlink" title="(1)部分函数依赖与完全函数依赖的定义"></a>(1)部分函数依赖与完全函数依赖的定义</h2><p>在$R(U)$中，</p><ul><li>若$X\to Y$并且对于$X$的任何真子集$X’ $都有$X’ \nrightarrow Y$,则称$Y$完全函数依赖于$X$, 记为：$X\xrightarrow{f}Y$。</li><li>否则称Y部分函数依赖于$X$, 记为：$X\xrightarrow{f}Y$.</li></ul><p>示例:$U=\lbrace学号,姓名,年龄,班号,班长,课号,成绩 \rbrace$</p><ul><li>$\lbrace学号,课号\rbrace \xrightarrow{f}U$<ul><li>单独的学号不能决定U,单独的课号(真子集)不能决定U,所以是完全函数依赖</li></ul></li><li>$\lbrace学号,课号\rbrace \xrightarrow{p} 姓名$<ul><li>单独的学号就可以决定姓名了,所以是部分函数依赖</li></ul></li><li>$\lbrace学号,课号\rbrace\xrightarrow{f} 成绩$<ul><li>单独的学号(真子集),单独的课号(真子集)都不能决定成绩,所以是完全函数依赖.</li></ul></li></ul><p><strong>部分依赖存在着<code>非受控冗余</code></strong><br><img src="https://raw.githubusercontent.com/lanlan2017/images/master/RedingNotes/ShuJuKuXiTong/Zhong/4/3.png" alt=""></p><h2 id="2-部分函数依赖与完全函数依赖的示例"><a href="#2-部分函数依赖与完全函数依赖的示例" class="headerlink" title="(2)部分函数依赖与完全函数依赖的示例"></a>(2)部分函数依赖与完全函数依赖的示例</h2><p>$学生(学号,姓名,班级,课号,课程名,成绩,教师,教师职务)$</p><ul><li>${学号, 课号}\xrightarrow{f} U$; 但 ${学号, 课号}\xrightarrow{p} 姓名$</li><li>${学号, 课号}\xrightarrow{p} 课程名$</li></ul><p>$员工(员工码,姓名,出生日期,联系电话, 最后学历,毕业学校,培训日期,培训内容)$</p><ul><li>${员工码, 培训日期} \xrightarrow{p} U$;单独的员工码无法决定培训内容,培训日期可以决定培训内容.所以员工码加上培训日期来可以决定U </li><li>${员工码, 培训日期} \xrightarrow{p} {姓名,出生日期 }$,单独的员工码就可以决定该员工的姓名和出生日期了,所以是部分函数决定</li></ul><p>$图书(书号,书名,出版日期,出版社,书架号,房间号)$</p><ul><li>$\lbrace书号,房间号,书架号\rbrace\to U$,书号可以决定书名,出版日期,出版社,</li></ul><p>$客户(客户号,客户名称,类别,联系电话,产品编码,产品名称,数量,要货日期)$</p><p>$学生(学号,姓名,系号,系主任)$</p><h2 id="3-传递函数依赖的定义"><a href="#3-传递函数依赖的定义" class="headerlink" title="(3)传递函数依赖的定义"></a>(3)传递函数依赖的定义</h2><p>在R(U)中，若$X\to Y$，$Y\to Z$ 且$Y\require{cancel} \cancel{\subset}X$,$Z\require{cancel} \cancel{\subset}Y$,$Z\require{cancel} \cancel{\subset}X$, $Y\nrightarrow X$, 则称Z传递函数依赖于X。</p><p>示例:$U=\lbrace学号,姓名,年龄,班号,班长,课号,成绩 \rbrace$<br>$学号\to班号$ ;$班号\to班长$,所以$学号\to班长$,(“班长”是传递依赖于 “学号”的。)</p><p>示例:$学生(学号,姓名,系号,系主任)$<br>$学号\to系号$; $系号\to系主任$,所以$学号\to系主任$(“系主任”是传递依赖于 “学号”的)</p><p><strong>传递依赖存在着非受控冗余</strong></p><h2 id="4-传递函数依赖的示例"><a href="#4-传递函数依赖的示例" class="headerlink" title="(4)传递函数依赖的示例"></a>(4)传递函数依赖的示例</h2><p>$\textbf{商店(商店,商品,商品经营部,经营部经理)}$</p><ul><li>$\lbrace商店,商品经营部\rbrace\to经营部经理$</li><li>$\lbrace商店,商品经营部\rbrace\to经营部经理$<br>所以有传递依赖:$\lbrace商店,商品\rbrace\to经营部经理$</li></ul><p>$\textbf{学生(学号,姓名,班级,班主任,课号,课程名,成绩,教师,教师职务)}$</p><ul><li>$学号\to班级;班级\to班主任$;</li><li>$\lbrace学号,课号\rbrace\to教师;教师\to教师职务$;<br>所以有传递依赖:$\lbrace学号,课号\rbrace\to教师职务$</li></ul><p>$\textbf{员工(员工码,姓名,部门,部门经理)}$</p><ul><li>$员工码\to部门$</li><li>$部门\to部门经理$<br>所以有传递依赖:$员工码\to部门经理$</li></ul><p>图书(书号,书名,出版日期,出版社,书架号,房间号,管理员)<br>客户(客户号,客户名称,类别,联系电话,产品编码,产品名称,数量,要货日期)</p><h1 id="函数依赖相关的几个重要概念"><a href="#函数依赖相关的几个重要概念" class="headerlink" title="函数依赖相关的几个重要概念"></a>函数依赖相关的几个重要概念</h1><h2 id="1-候选键的定义"><a href="#1-候选键的定义" class="headerlink" title="(1)候选键的定义"></a>(1)候选键的定义</h2><p>设K为R(U)中的属性或属性组合,若$K\xrightarrow{f}U$,则称K为(U)上的候选键(Candidate Key)。</p><ul><li>唯一性</li><li>最小性</li></ul><h2 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h2><p>(1)可<strong>任选一个候选键</strong>作为R的<strong>主键</strong>(Primary Key)；</p><h2 id="主属性"><a href="#主属性" class="headerlink" title="主属性"></a>主属性</h2><p>(2)包含在<strong>任一候选键中的属性</strong>称主属性(Prime Attribute),其他属性称<strong>非主属性</strong>；</p><h2 id="超键"><a href="#超键" class="headerlink" title="超键"></a>超键</h2><p>(3)若K是R的一个候选键,$S\supset K$, 则称S为R的一个超键(Super Key)。候选键是没有多余属性的超键,候选键带上任意个其他属性可被视为超键<br>唯一性,没有最小性</p><h2 id="2-候选键的示例"><a href="#2-候选键的示例" class="headerlink" title="(2)候选键的示例"></a>(2)候选键的示例</h2><p>$\textbf{学生(学号,年龄,家庭住址,课程号,成绩,教师,教师职务)}$<br>学生(学号,年龄,家庭住址,课程号,成绩,教师,教师职务)</p><ul><li>候选键:学号和课程号就可以决定所有的属性,所以学号和课程号就是一个候选键,$\lbrace学号,课程号\rbrace$</li><li>主属性:学号,课程号</li><li>非主属性:年龄,家庭住址,成绩,教师,教师职务.</li></ul><p>$\textbf{商店(商店,商品,商品经营部,商品经营部经理)}$<br>候选键是??,非主属性是??</p><ul><li>候选键:商店和商品可以决定商品经营部,商品经营部可以决定商品经营部经理,所以商店和商品可以决定所有的属性,所以候选键为商店和商品{商店,商品}</li><li>非主属性:商品经营部,商品经营部经理.</li></ul><p>$\textbf{学生(学号,姓名,所属系别,系主任)}$<br>候选键是??,非主属性是??<br>候选键:学号<br>非主属性:姓名,所属系别,系主任</p><h2 id="3-外键"><a href="#3-外键" class="headerlink" title="(3)外键"></a>(3)外键</h2><p>若R(U)中的属性或属性组合X并非R的候选键，但X却是另一关系的候选键，则称X为R的<strong>外来键</strong>(Foreign Key)，简称<strong>外键</strong>。<br>示例:<br>$R=\lbrace合同号,合同名,签订日期,{\color{red}{供应商名}}\rbrace$<br>$S=\lbrace供应商名,地址,执照号,法人代表\rbrace$<br>合同号是关系R个候选键:$合同号\xrightarrow{f} \lbrace合同号,合同名,签订日期,供应商名\rbrace$<br>供应商名是关键S的候选键:$供应商名\xrightarrow{f}\lbrace供应商名,地址,执照号,法人代表\rbrace$<br>所以供应商名,在关系R中是<strong>外键</strong></p><h2 id="4-逻辑蕴涵的定义"><a href="#4-逻辑蕴涵的定义" class="headerlink" title="(4)逻辑蕴涵的定义"></a>(4)逻辑蕴涵的定义</h2><p>设F是关系模式R(U)中的一个函数依赖集合，X,Y是R的属性子集，如果从F中的函数依赖能够<strong>推导出</strong>$X\to Y$，则称F逻辑蕴涵$X\to Y$, 或称$X\to Y$是F的逻辑蕴涵。记作$F\models X\to Y$。</p><p>省略</p><h2 id="5-闭包的定义"><a href="#5-闭包的定义" class="headerlink" title="(5)闭包的定义"></a>(5)闭包的定义</h2><p>被F<code>逻辑蕴涵</code>的所有<code>函数依赖</code><strong>集合</strong>称为F的闭包(Closure)，记作$F^+$</p><!-- RedingNotes/ShuJuKuXiTong/Zhong/4/ -->]]></content>
      
      
      <categories>
          
          <category> 数据库系统 </category>
          
          <category> 中 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第3讲 总第13讲 数据库设计过程</title>
      <link href="/ReadingNotes//ef76614/"/>
      <url>/ReadingNotes//ef76614/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/ef76614/#数据库设计的四个过程" class="header_1">数据库设计的四个过程</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#数据库设计过程之需求分析" class="header_1">数据库设计过程之需求分析</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#需求分析" class="header_2">需求分析</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#相关结果性内容" class="header_2">相关结果性内容</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#"源"清单" class="header_3">"源"清单</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#"属性"清单" class="header_3">"属性"清单</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#"属性"定义表" class="header_3">"属性"定义表</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#数据库设计过程之概念数据库设计" class="header_1">数据库设计过程之概念数据库设计</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#-1-概念数据库设计" class="header_2">(1)概念数据库设计</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#-2-概念数据库设计的两种设计思路" class="header_2">(2)概念数据库设计的两种设计思路</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#先局部后全局" class="header_3">先局部后全局</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#先全局后局部" class="header_3">先全局后局部</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#局部E-R模式设计" class="header_3">局部E-R模式设计</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#全局E-R模式设计" class="header_3">全局E-R模式设计</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#-3-概念数据库设计的可能冲突" class="header_2">(3)概念数据库设计的可能冲突</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#消除冲突" class="header_3">消除冲突</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#全局E-R模式优化" class="header_3">全局E-R模式优化</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#-4-相关结果性内容示意" class="header_2">(4)相关结果性内容示意</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#绘制不同层级的E-R图/IDEF1x图" class="header_3">绘制不同层级的E-R图/IDEF1x图</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#实体级图" class="header_4">实体级图</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#键级图" class="header_4">键级图</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#完整图" class="header_4">完整图</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#"实体"清单" class="header_3">"实体"清单</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#"实体"定义表" class="header_3">"实体"定义表</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#"实体-联系"矩阵" class="header_3">"实体-联系"矩阵</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#"实体-属性"矩阵" class="header_3">"实体-属性"矩阵</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#-5-小结" class="header_2">(5)小结</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#数据库设计过程之逻辑数据库设计" class="header_1">数据库设计过程之逻辑数据库设计</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#-1-逻辑数据库设计" class="header_2">(1)逻辑数据库设计</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#-2-E-R图向关系模式的转换" class="header_2">(2)E-R图向关系模式的转换</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#E-R图-Chen方法" class="header_3">E-R图(Chen方法)</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#关系模式-Schema" class="header_3">关系模式(Schema)</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#基本转换规则-实体-属性-关键字的转换" class="header_3">基本转换规则: 实体-属性-关键字的转换</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#示例" class="header_4">示例</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#基本转换规则-复合属性的转换" class="header_3">基本转换规则:复合属性的转换</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#示例" class="header_4">示例</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#基本转换规则-多值属性的转换" class="header_3">基本转换规则:多值属性的转换</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#示例" class="header_4">示例</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#基本转换规则-联系的转换" class="header_3">基本转换规则:联系的转换</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#一对一联系" class="header_4">一对一联系</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#部分参与" class="header_5">部分参与</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#全部参与" class="header_5">全部参与</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#一对多联系" class="header_4">一对多联系</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#多对多联系" class="header_3">多对多联系</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#基本转换规则-弱实体的转换" class="header_3">基本转换规则:弱实体的转换</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#基本转换规则-泛化与具体化实体的转换" class="header_3">基本转换规则:泛化与具体化实体的转换</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#权衡" class="header_4">权衡</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#方案1" class="header_5">方案1</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#方案2" class="header_5">方案2</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#基本转换规则-多元联系的转换" class="header_3">基本转换规则:多元联系的转换</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#2型转换示例" class="header_4">2型转换示例</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#-3-IDEF1X图向关系模式转换" class="header_2">(3)IDEF1X图向关系模式转换</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#-4-不正确设计数据库会引发的问题" class="header_2">(4)不正确设计数据库会引发的问题</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#冗余" class="header_3">冗余</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#非受控冗余" class="header_4">非受控冗余</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#受控冗余" class="header_4">受控冗余</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#删除异常" class="header_3">删除异常</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#插入异常" class="header_3">插入异常</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#如何避免数据库出现不一致的问题" class="header_3">如何避免数据库出现不一致的问题</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#当数据库设计满足规范时" class="header_4">当数据库设计满足规范时</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#当数据库设计不满足规范性" class="header_4">当数据库设计不满足规范性</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#数据库设计理论" class="header_2">数据库设计理论</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#数据依赖理论" class="header_3">数据依赖理论</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#关系范式理论" class="header_3">关系范式理论</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#模式分解理论" class="header_3">模式分解理论</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#小结" class="header_2">小结</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#数据库设计过程" class="header_3">数据库设计过程</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#逻辑数据库设计步骤" class="header_3">逻辑数据库设计步骤</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#数据库设计过程之物理数据库设计" class="header_1">数据库设计过程之物理数据库设计</a>&nbsp;<br><a href="/ReadingNotes/ef76614/#小结" class="header_2">小结</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="数据库设计的四个过程"><a href="#数据库设计的四个过程" class="headerlink" title="数据库设计的四个过程"></a>数据库设计的四个过程</h1><ul><li>需求分析<ul><li>收集需求和理解需求,”源”</li></ul></li><li>概念数据库设计<ul><li>建立概念模型,”E-R图/IDEF1x图”</li></ul></li><li>逻辑数据库设计<ul><li>建立逻辑模型,”关系模式”包括全局模式和用户模式(外模式)</li><li>表的定义;</li><li>表中数据项的定义</li><li>表中数据示例(测试用例)</li></ul></li><li>物理数据库设计<ul><li>建立物理模型,包括物理数据组织等,依赖于具体的DBMS.</li><li>相关命令:<code>Create Table</code>,<code>Create Index</code></li></ul></li></ul><h1 id="数据库设计过程之需求分析"><a href="#数据库设计过程之需求分析" class="headerlink" title="数据库设计过程之需求分析"></a>数据库设计过程之需求分析</h1><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ul><li><strong>目标</strong>:理解企业、理解企业业务过程与数据处理流程、理解数据处理的性能需求</li><li><strong>提交物</strong>:<strong>需求分析报告</strong></li><li>使以下内容清楚:<ul><li>企业的部门-岗位划分:不同岗位负责的各种日常管理信息表/报表</li><li>形成各种报表的基础数据表</li><li>各种数据表之间的处理关系(What—How)</li><li>围绕数据表的业务处理关系(Who—When—Where)</li><li>尚未实施但未来可能实施的需求</li><li>形成数据库设计的<code>&quot;源&quot;清单</code>和<code>&quot;属性&quot;清单</code>以及相关的详细描述,尤其是注意业务规则与属性处理规则</li><li>结合<strong>数据流图</strong>等辅助分析与理解</li></ul></li></ul><h2 id="相关结果性内容"><a href="#相关结果性内容" class="headerlink" title="相关结果性内容"></a>相关结果性内容</h2><h3 id="“源”清单"><a href="#“源”清单" class="headerlink" title="“源”清单"></a>“源”清单</h3><p>注意收集和理解:</p><ol><li>业务规则及其在表的处理方面的体现</li><li>不仅报表、单据是源,企业的查询需求与管理需求等也是源</li></ol><h3 id="“属性”清单"><a href="#“属性”清单" class="headerlink" title="“属性”清单"></a>“属性”清单</h3><p>注意命名:</p><ol><li>命名要规范,并且要含义明确</li><li>尤其要注意类似于”数量”这样的多含义属性,比如”计划数量””采购数量””到货数量””装配数量””完工数量””销售数量””发货数量”</li></ol><h3 id="“属性”定义表"><a href="#“属性”定义表" class="headerlink" title="“属性”定义表"></a>“属性”定义表</h3><p>注意:准确理解对属性的业务规则,尤其是<strong>约束规则</strong><br>例如:成绩只能取”优秀””良好””中等””及格””不及格”这五个值;<br>例如:工资只能升不能降, 年龄大于15且小于23岁等;<br>例如:编码属性的编码规则;<br>例如:分类属性的分类标准及分类值等;<br>例如:属性的处理规则,如填写规则、计算规则等</p><ul><li>了解部门-岗位划分</li><li>对每一岗位,收集”源”—形成源表</li><li>理解每一”源”<ul><li>源的属性构成</li><li>源的处理规则</li><li>源的属性处理规则</li><li>借助其他方法辅助理解,如数据流图、功能图等</li></ul></li><li>形成并提交<strong>需求分析报告</strong></li></ul><h1 id="数据库设计过程之概念数据库设计"><a href="#数据库设计过程之概念数据库设计" class="headerlink" title="数据库设计过程之概念数据库设计"></a>数据库设计过程之概念数据库设计</h1><h2 id="1-概念数据库设计"><a href="#1-概念数据库设计" class="headerlink" title="(1)概念数据库设计"></a>(1)概念数据库设计</h2><ul><li><strong>目标</strong>:进一步深入理解企业,对信息源进行抽象,<strong>发现信息(<code>属性</code>)之间的内在本质联系</strong>,这些本质联系可能隐藏于需求分析得到的信息源中。</li><li><strong>提交物</strong>:概念数据库设计报告</li><li>使以下内容清楚:<ul><li>各种实体的发现、划分和定义</li><li>各种实体属性的发现、分析和定义</li><li>各种实体联系的发现、分析和定义</li><li>外部视图(模式)和概念视图(模式)的定义</li></ul></li><li>用统一的表达方法,如<code>E-R</code>模型<code>/IDEF1X</code>模型给出描述;不仅绘制出来,而且绘制正确;</li></ul><p>用规范的数据模型表达,有助于更好的理解需求<br>数据模型不仅是自己理解而且要让相关人员理解</p><h2 id="2-概念数据库设计的两种设计思路"><a href="#2-概念数据库设计的两种设计思路" class="headerlink" title="(2)概念数据库设计的两种设计思路"></a>(2)概念数据库设计的两种设计思路</h2><ul><li>先局部后全局</li><li>先全局后局部</li></ul><h3 id="先局部后全局"><a href="#先局部后全局" class="headerlink" title="先局部后全局"></a>先局部后全局</h3><ol><li>需求调研/用户不完整的局部需求</li><li>设计外部模式或视图</li><li>外部模式或视图</li><li>合并视图</li><li>设计概念数据库模式</li><li>概念数据库模式</li></ol><h3 id="先全局后局部"><a href="#先全局后局部" class="headerlink" title="先全局后局部"></a>先全局后局部</h3><ol><li>需求调研/用户不完整的局部需求</li><li>合并局部需求</li><li>设计概念数据库模式</li><li>概念数据库模式</li><li>设计外部模式或视图</li><li>外部模式或视图</li></ol><h3 id="局部E-R模式设计"><a href="#局部E-R模式设计" class="headerlink" title="局部E-R模式设计"></a>局部E-R模式设计</h3><ol><li>需求分析的”源”</li><li>确定局部结构范围</li><li>实体定义</li><li>联系定义</li><li>属性分配</li><li>全局E-R模式设计</li></ol><h3 id="全局E-R模式设计"><a href="#全局E-R模式设计" class="headerlink" title="全局E-R模式设计"></a>全局E-R模式设计</h3><ol><li>局部E-R模式</li><li>确定公共实体类型</li><li>合并两个局部E-R模式</li><li>检查并消除<strong>冲突</strong></li><li>还有未合并的局部模式?如果有,则转到第3步,如果没有则继续下一步</li><li>全局E-R模式优化</li></ol><h2 id="3-概念数据库设计的可能冲突"><a href="#3-概念数据库设计的可能冲突" class="headerlink" title="(3)概念数据库设计的可能冲突"></a>(3)概念数据库设计的可能冲突</h2><h3 id="消除冲突"><a href="#消除冲突" class="headerlink" title="消除冲突"></a>消除冲突</h3><ul><li><strong>属性冲突</strong><ul><li>属性域的冲突:属性的类型、取值范围不同<ul><li>如不同学校的学号编码方式不同</li></ul></li><li>属性取值单位冲突<ul><li>如重量分别采用磅、千克</li></ul></li></ul></li><li><strong>结构冲突</strong><ul><li>同一对象在不同应用中的抽象不同<ul><li>如职工在某应用中是实体,在另一应用中则抽象为属性</li></ul></li><li>同一实体在不同E-R图中属性组成不同</li><li>实体之间的联系在不同E-R图中呈现不同的类型</li></ul></li><li><strong>命名冲突</strong><ul><li>同名异义:不同意义的对象具有相同的名字</li><li>异名同义:同一意义的对象具有不同的名字</li></ul></li></ul><h3 id="全局E-R模式优化"><a href="#全局E-R模式优化" class="headerlink" title="全局E-R模式优化"></a>全局E-R模式优化</h3><p>全局E-R模式优化</p><ol><li>全局E-R模式</li><li>合并实体类型</li><li>消除冗余属性</li><li>消除冗余联系</li><li>逻辑数据库设计</li></ol><h2 id="4-相关结果性内容示意"><a href="#4-相关结果性内容示意" class="headerlink" title="(4)相关结果性内容示意"></a>(4)相关结果性内容示意</h2><h3 id="绘制不同层级的E-R图-IDEF1x图"><a href="#绘制不同层级的E-R图-IDEF1x图" class="headerlink" title="绘制不同层级的E-R图/IDEF1x图"></a>绘制不同层级的E-R图/IDEF1x图</h3><p><strong>实体级图</strong>、<strong>键级图</strong>及<strong>完整图</strong>:</p><h4 id="实体级图"><a href="#实体级图" class="headerlink" title="实体级图"></a>实体级图</h4><p>以实体为建模单位的IDEF1x图</p><h4 id="键级图"><a href="#键级图" class="headerlink" title="键级图"></a>键级图</h4><p>以实体为建模单位并且<strong>标注<code>键</code>属性</strong>的IDEF1x图</p><h4 id="完整图"><a href="#完整图" class="headerlink" title="完整图"></a>完整图</h4><p>以实体为建模单位并且<strong>标注<code>所有</code>属性</strong>的IDEF1x图</p><h3 id="“实体”清单"><a href="#“实体”清单" class="headerlink" title="“实体”清单"></a>“实体”清单</h3><h3 id="“实体”定义表"><a href="#“实体”定义表" class="headerlink" title="“实体”定义表"></a>“实体”定义表</h3><h3 id="“实体-联系”矩阵"><a href="#“实体-联系”矩阵" class="headerlink" title="“实体-联系”矩阵"></a>“实体-联系”矩阵</h3><p>有联系的实体之间会有继承属性</p><h3 id="“实体-属性”矩阵"><a href="#“实体-属性”矩阵" class="headerlink" title="“实体-属性”矩阵"></a>“实体-属性”矩阵</h3><p>注释:O:实体的占有属性,I:实体的继承属性(通常就是外键),K:实体的主键属性</p><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="(5)小结"></a>(5)小结</h2><ol><li>依据需求分析报告</li><li>识别实体与联系</li><li>绘制E-R图/IDEF1x图用图表达业务规则</li><li>定义实体、联系及实体的属性构成,这部分最重要的是<strong>消除冲突</strong></li><li>形成并提交概念数据库设计报告</li></ol><ul><li>需求分析</li><li><strong>概念数据库设计</strong>&lt;-当前阶段</li><li>逻辑数据库设计</li><li>物理数据库设计</li></ul><h1 id="数据库设计过程之逻辑数据库设计"><a href="#数据库设计过程之逻辑数据库设计" class="headerlink" title="数据库设计过程之逻辑数据库设计"></a>数据库设计过程之逻辑数据库设计</h1><h2 id="1-逻辑数据库设计"><a href="#1-逻辑数据库设计" class="headerlink" title="(1)逻辑数据库设计"></a>(1)逻辑数据库设计</h2><ul><li><strong>目标</strong>:用指定DBMS要求的模式描述方法,给出概念数据库的逻辑模式描述。</li><li><strong>提交物</strong>:逻辑数据库设计报告</li><li>使以下内容清楚:<ul><li>将E-R/IDEF1X转换成逻辑模式</li><li>遵循关系范式的设计原则</li><li>也要注意折中,但折中时需要提示应用开发者或</li><li>使用者可能存在的问题</li><li>外模式和概念模式的定义</li></ul></li><li>用<strong>关系模型</strong>、网状模型或层次模型规定的模式描述方法进行描述</li></ul><h2 id="2-E-R图向关系模式的转换"><a href="#2-E-R图向关系模式的转换" class="headerlink" title="(2)E-R图向关系模式的转换"></a>(2)E-R图向关系模式的转换</h2><h3 id="E-R图-Chen方法"><a href="#E-R图-Chen方法" class="headerlink" title="E-R图(Chen方法)"></a>E-R图(Chen方法)</h3><p><img src="https://raw.githubusercontent.com/lanlan2017/images/master/RedingNotes/ShuJuKuXiTong/Zhong/2.png" alt="图片"></p><h3 id="关系模式-Schema"><a href="#关系模式-Schema" class="headerlink" title="关系模式(Schema)"></a>关系模式(Schema)</h3><script type="math/tex; mode=display">R(A_1:D_1,A_2:D_2,...,A_n:D_n)</script><p>其中</p><ul><li>$R$为关系模式的名称</li><li>$A_n$为关系模式的属性</li><li>$D_n$为属性$A_n$的取值范围(域)</li></ul><p>简记为:</p><script type="math/tex; mode=display">R(A_1,A_2,...,A_n)</script><h3 id="基本转换规则-实体-属性-关键字的转换"><a href="#基本转换规则-实体-属性-关键字的转换" class="headerlink" title="基本转换规则: 实体-属性-关键字的转换"></a>基本转换规则: 实体-属性-关键字的转换</h3><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><img src="https://raw.githubusercontent.com/lanlan2017/images/master/RedingNotes/ShuJuKuXiTong/Zhong/1.png" alt="图片"><br>$图书(\underline{书号},书名,出版日期,出版社)$<br>$读者(\underline{借书证号} ,姓名,年龄,性别,家庭住址)$<br>$书架(\underline{书架号,房间号} )$</p><h3 id="基本转换规则-复合属性的转换"><a href="#基本转换规则-复合属性的转换" class="headerlink" title="基本转换规则:复合属性的转换"></a>基本转换规则:复合属性的转换</h3><ul><li>将每个<strong>分量属性</strong>作为复合属性所在实体的属性</li><li>或者将<strong>复合属性本身</strong>作为所在实体的属性</li></ul><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p><img src="https://raw.githubusercontent.com/lanlan2017/images/master/RedingNotes/ShuJuKuXiTong/Zhong/3.png" alt="图片"><br>$学生(\underline{学号}, 姓名, 年, 月, 日)$<br>或者<br>$学生(\underline{学号}, 出生日期, 姓名)$</p><h3 id="基本转换规则-多值属性的转换"><a href="#基本转换规则-多值属性的转换" class="headerlink" title="基本转换规则:多值属性的转换"></a>基本转换规则:多值属性的转换</h3><p>将多值属性与所在实体的关键字一起组成一个<strong>新的关系</strong></p><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><p><img src="https://raw.githubusercontent.com/lanlan2017/images/master/RedingNotes/ShuJuKuXiTong/Zhong/4.png" alt="图片"></p><p>$学生(\underline{学号},姓名)$<br>$选课(\underline{学号,所选课程号})$</p><h3 id="基本转换规则-联系的转换"><a href="#基本转换规则-联系的转换" class="headerlink" title="基本转换规则:联系的转换"></a>基本转换规则:联系的转换</h3><h4 id="一对一联系"><a href="#一对一联系" class="headerlink" title="一对一联系"></a>一对一联系</h4><h5 id="部分参与"><a href="#部分参与" class="headerlink" title="部分参与"></a>部分参与</h5><p>若联系双方均<strong>部分参与(0..1)</strong>，则将联系定义为一个<strong>新的关系</strong>，属性为参与双方的关键字属性<br><img src="https://raw.githubusercontent.com/lanlan2017/images/master/RedingNotes/ShuJuKuXiTong/Zhong/5.png" alt="图片"><br>$职工(\underline{职工号},…)$<br>$配偶(\underline{丈夫职工号},\underline{妻子职工号})$</p><h5 id="全部参与"><a href="#全部参与" class="headerlink" title="全部参与"></a>全部参与</h5><p>若联系一方<strong>全部参与(1..1)</strong> ，则将联系另一方的关键字作为全部参与一方关系的属性<br><img src="https://raw.githubusercontent.com/lanlan2017/images/master/RedingNotes/ShuJuKuXiTong/Zhong/6.png" alt="图片"><br>$职工(\underline{职工号}, …)$<br>$部门(\underline{部门号}, 部门名, 职工号)$</p><h4 id="一对多联系"><a href="#一对多联系" class="headerlink" title="一对多联系"></a>一对多联系</h4><p>将<strong>单方</strong>参与实体的关键字作为<strong>多方</strong>参与实体对应关系的属性<br>多方实体继承单方实体的主关键字作为属性<br><img src="https://raw.githubusercontent.com/lanlan2017/images/master/RedingNotes/ShuJuKuXiTong/Zhong/7.png" alt="图片"><br>$教师(\underline{教工号}, …)$<br>$学生(\underline{学生号},学生名,班主任教工号)$</p><p><img src="https://raw.githubusercontent.com/lanlan2017/images/master/RedingNotes/ShuJuKuXiTong/Zhong/8.png" alt=""><br>$职工(\underline{职工号}，职工名，部门号，领导职工号)$</p><h3 id="多对多联系"><a href="#多对多联系" class="headerlink" title="多对多联系"></a>多对多联系</h3><p>将<strong>联系</strong>定义为<strong>新的关系</strong>，属性为参与<strong>双方实体的关键字</strong><br><img src="https://raw.githubusercontent.com/lanlan2017/images/master/RedingNotes/ShuJuKuXiTong/Zhong/9.png" alt="图片"><br>$学生(\underline{学生号}, …)$<br>$课程(\underline{课程号}, …)$<br>$选修(\underline{学生号}, \underline{课程号}, 成绩)$</p><p><img src="https://raw.githubusercontent.com/lanlan2017/images/master/RedingNotes/ShuJuKuXiTong/Zhong/10.png" alt="图片"><br>$零件(\underline{零件号}, …)$<br>$构成(\underline{父零件号},\underline{子零件号}, …)$</p><h3 id="基本转换规则-弱实体的转换"><a href="#基本转换规则-弱实体的转换" class="headerlink" title="基本转换规则:弱实体的转换"></a>基本转换规则:弱实体的转换</h3><p>所对应关系的关键字由<strong>弱实体</strong>本身的<strong>区分属性</strong>再加上所依赖的<strong>强实体的关键字</strong>构成<br><img src="https://raw.githubusercontent.com/lanlan2017/images/master/RedingNotes/ShuJuKuXiTong/Zhong/11.png" alt="图片"><br>$产品(\underline{产品名},价格,\underline{公司名})$<br>弱实体集(从属实体)与强实体集(独立实体)之间的联系已经在弱实体集所对应的关系中表示出来了</p><h3 id="基本转换规则-泛化与具体化实体的转换"><a href="#基本转换规则-泛化与具体化实体的转换" class="headerlink" title="基本转换规则:泛化与具体化实体的转换"></a>基本转换规则:泛化与具体化实体的转换</h3><ul><li>高层实体(泛化实体)和低层实体(具体化实体)分别转为不同的关系</li><li>低层实体所对应的关系包括高层实体的关键字</li></ul><p><img src="https://raw.githubusercontent.com/lanlan2017/images/master/RedingNotes/ShuJuKuXiTong/Zhong/12.png" alt="图片"><br>$学生(\underline{学号},姓名)$<br>$本科生(\underline{学号},军训)$<br>$研究生(\underline{学号},论文)$</p><p>如果泛化实体实例是具体化实体实例的全部，即一个高层实体实例至少属于一个低层实体，则可以不为高层实体建立关系，<strong>低层实体所对应的关系包括上层实体的<code>所有属性</code></strong></p><p><img src="https://raw.githubusercontent.com/lanlan2017/images/master/RedingNotes/ShuJuKuXiTong/Zhong/13.png" alt="图片"><br>学生(姓名,学号)  //如果概括是全部的,无须创建”学生”关系<br>$本科生(姓名,\underline{学号},军训)$<br>$研究生(姓名,\underline{学号},论文)$</p><h4 id="权衡"><a href="#权衡" class="headerlink" title="权衡"></a>权衡</h4><p>如何转换如下的E-R图<br><img src="https://raw.githubusercontent.com/lanlan2017/images/master/RedingNotes/ShuJuKuXiTong/Zhong/14.png" alt="图片"></p><h5 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h5><p>$person(\underline{name}, street, city)$<br>$customer(\underline{name}, credit-rating)$<br>$employee(\underline{name}, salary)$<br>缺点:查询employee的<strong>地址</strong>需要访问两个表(employee,和person)</p><h5 id="方案2"><a href="#方案2" class="headerlink" title="方案2"></a>方案2</h5><p>$person(\underline{name}, street, city)$<br>$customer(\underline{name}, street, city, credit-rating)$<br>$employee(\underline{name}, street, city, salary)$<br>如果泛化实体实例是具体化实体实例的全部,无须创建person表<br>缺点:如果一个人既是顾客又是员工,那么他的新将<strong>存储两次</strong></p><h3 id="基本转换规则-多元联系的转换"><a href="#基本转换规则-多元联系的转换" class="headerlink" title="基本转换规则:多元联系的转换"></a>基本转换规则:多元联系的转换</h3><ul><li>多元联系可以通过<strong>继承</strong>参与联系的<strong>各个实体的关键字</strong>而形成新的关系</li><li>这些继<strong>承过来的关键字可作为新关系的关键字</strong></li><li>也可以新增一个<strong>区分属性</strong>作为关键字</li><li>注意这两种转换的差异</li><li>多元联系更需注意分析参与联系的实体的最小基数和最大基数,如是否允许参与联系的多实体中有一个或多个实体不参与?</li><li>多元联系可以转换为多个<strong>二元联系</strong>进行处理</li></ul><p><img src="https://raw.githubusercontent.com/lanlan2017/images/master/RedingNotes/ShuJuKuXiTong/Zhong/15.png" alt="图片"></p><p>1型转换:$供应(\underline{工程项目号},\underline{供货商号},\underline{零件号},数量)$<br>2型转换:$供应(\underline{条目号},工程项目号,供货商号,零件号,数量)$</p><p>对于新增一个区分属性的2型转换,工程项目号,供货商号,零件号这些由于都是非主属性,所以<strong>可以为空</strong></p><h4 id="2型转换示例"><a href="#2型转换示例" class="headerlink" title="2型转换示例"></a>2型转换示例</h4><p><img src="https://raw.githubusercontent.com/lanlan2017/images/master/RedingNotes/ShuJuKuXiTong/Zhong/16.png" alt="图片"><br>可以得到如下关系模式<br><img src="https://raw.githubusercontent.com/lanlan2017/images/master/RedingNotes/ShuJuKuXiTong/Zhong/17.png" alt="图片"></p><h2 id="3-IDEF1X图向关系模式转换"><a href="#3-IDEF1X图向关系模式转换" class="headerlink" title="(3)IDEF1X图向关系模式转换"></a>(3)IDEF1X图向关系模式转换</h2><p>基本转换规则:只需关注实体转换成关系,而联系则无需关注</p><ul><li>IDEF1X图只需将实体转换成关系模式即可，而其联系的信息已经融入相关实体的关系描述中了</li><li>对IDEF1X图的分类联系，可以如E-R图中的泛化和具体化一样进行相关的处理；</li><li>对IDEF1X图的复合属性和多值属性，则如前面一样进行相关的处理</li></ul><p><img src="https://raw.githubusercontent.com/lanlan2017/images/master/RedingNotes/ShuJuKuXiTong/Zhong/18.png" alt="图片"></p><h2 id="4-不正确设计数据库会引发的问题"><a href="#4-不正确设计数据库会引发的问题" class="headerlink" title="(4)不正确设计数据库会引发的问题"></a>(4)不正确设计数据库会引发的问题</h2><h3 id="冗余"><a href="#冗余" class="headerlink" title="冗余"></a>冗余</h3><p><strong>冗余</strong>:数据库中存在大量冗余</p><h4 id="非受控冗余"><a href="#非受控冗余" class="headerlink" title="非受控冗余"></a>非受控冗余</h4><ul><li><strong>非受控冗余</strong></li><li>非受控冗余问题:<ul><li>当数据发生改变时,冗余的数据不会被数据库自动更新,需要数据库的用户来更新。</li><li>例如<strong>郑东</strong>这个老师,职称升级为教授时,需要修改多条记录,容易出错<br><img src="https://raw.githubusercontent.com/lanlan2017/images/master/RedingNotes/ShuJuKuXiTong/Zhong/19.png" alt="图片"></li></ul></li></ul><h4 id="受控冗余"><a href="#受控冗余" class="headerlink" title="受控冗余"></a>受控冗余</h4><ul><li>如Table中的<strong>外键</strong>(继承其他Table中的键值),外键可以自动更新.</li></ul><p>将上面的关系拆如下分成两个关系,虽然还是有冗余,但是要修改老师职称的话,只需要修改一条记录即可.<br><img src="https://raw.githubusercontent.com/lanlan2017/images/master/RedingNotes/ShuJuKuXiTong/Zhong/20.png" alt="图片"></p><h3 id="删除异常"><a href="#删除异常" class="headerlink" title="删除异常"></a>删除异常</h3><p><img src="https://raw.githubusercontent.com/lanlan2017/images/master/RedingNotes/ShuJuKuXiTong/Zhong/21.png" alt=""><br><strong>删除异常</strong>:当四系所有同学被删除后,则四系的有关信息则随之丢失。如上图所示.</p><h3 id="插入异常"><a href="#插入异常" class="headerlink" title="插入异常"></a>插入异常</h3><p>示例1:<br>如上图所示,当一名新同学入学时,尚未指定系,则因系的有关信息不完整,便无法输入到数据库中,<br>示例2:<br><img src="https://raw.githubusercontent.com/lanlan2017/images/master/RedingNotes/ShuJuKuXiTong/Zhong/22.png" alt="图片"></p><h3 id="如何避免数据库出现不一致的问题"><a href="#如何避免数据库出现不一致的问题" class="headerlink" title="如何避免数据库出现不一致的问题"></a>如何避免数据库出现不一致的问题</h3><h4 id="当数据库设计满足规范时"><a href="#当数据库设计满足规范时" class="headerlink" title="当数据库设计满足规范时"></a>当数据库设计满足规范时</h4><p>由DBMS或数据库本身来保证<br><img src="https://raw.githubusercontent.com/lanlan2017/images/master/RedingNotes/ShuJuKuXiTong/Zhong/23.png" alt="图片"></p><h4 id="当数据库设计不满足规范性"><a href="#当数据库设计不满足规范性" class="headerlink" title="当数据库设计不满足规范性"></a>当数据库设计不满足规范性</h4><p>由使用者或应用程序员使用过程中加以注意<br><img src="https://raw.githubusercontent.com/lanlan2017/images/master/RedingNotes/ShuJuKuXiTong/Zhong/24.png" alt="图片"></p><h2 id="数据库设计理论"><a href="#数据库设计理论" class="headerlink" title="数据库设计理论"></a>数据库设计理论</h2><p><img src="https://raw.githubusercontent.com/lanlan2017/images/master/RedingNotes/ShuJuKuXiTong/Zhong/25.png" alt="图片"></p><h3 id="数据依赖理论"><a href="#数据依赖理论" class="headerlink" title="数据依赖理论"></a>数据依赖理论</h3><ul><li>函数依赖</li><li>部分函数依赖/完全函数依赖</li><li>传递函数依赖</li><li>多值依赖</li><li>联结依赖</li></ul><h3 id="关系范式理论"><a href="#关系范式理论" class="headerlink" title="关系范式理论"></a>关系范式理论</h3><ul><li>1NF</li><li>2NF</li><li>3NF</li><li>BCNF</li><li>4NF</li><li>5NF</li></ul><h3 id="模式分解理论"><a href="#模式分解理论" class="headerlink" title="模式分解理论"></a>模式分解理论</h3><ul><li>无损连接分解</li><li>保持依赖分解</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><h3 id="数据库设计过程"><a href="#数据库设计过程" class="headerlink" title="数据库设计过程"></a>数据库设计过程</h3><ul><li>需求分析</li><li>概念数据库设计</li><li><strong>逻辑数据库设计</strong>&lt;—-当前位置</li><li>物理数据库设计</li></ul><h3 id="逻辑数据库设计步骤"><a href="#逻辑数据库设计步骤" class="headerlink" title="逻辑数据库设计步骤"></a>逻辑数据库设计步骤</h3><ol><li>依据概念数据库设计报告</li><li>将E-R图/IDEF1x图转换为<strong>关系模型</strong></li><li>使用数据库设计理论<strong>检查逻辑数据库设计的正确性</strong></li><li>定义<strong>全局模式</strong>和<strong>外模式</strong></li><li>形成并提交<strong>逻辑数据库设计报告</strong></li></ol><h1 id="数据库设计过程之物理数据库设计"><a href="#数据库设计过程之物理数据库设计" class="headerlink" title="数据库设计过程之物理数据库设计"></a>数据库设计过程之物理数据库设计</h1><ul><li>目标:结合指定DBMS物理数据库管理方法,给出概念数据库的物理模式描述。</li><li>提交物:物理数据库设计报告</li><li>使以下内容清楚：</li><li>DBMS选型<ul><li>确定数据库的存储结构，文件类型：如定长文件、不定长文件；堆文件、散列文件或B-Tree文件等</li><li>用Triggers, 设计一些完整性控制约束</li><li>确定数据库的高效访问方式(索引访问，直接访问……)</li><li>评估和设置磁盘空间需求</li><li>设计用户视图及访问控制规则，以进行安全性控制</li><li>建立索引</li><li>设计使数据库运行达到最佳效率的一些措施</li><li>设计备份Backup和恢复Recovery的步骤</li></ul></li><li>理解Oracle、Sybase或其他DBMS的物理数据库管理方式,这是数据库管理员(DBA)的基本责任。</li></ul><p>物理数据库设计与具体的数据库管理系统(Oracle,MySQL)相关</p><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><ol><li>依据逻辑数据库设计报告</li><li>利用具体DBMS，创建数据库/表</li><li>确定物理存储方式与存储空间</li><li>创建索引、视图等</li><li>形成并提交物理数据库设计报告</li></ol><p>这阶段需要的知识:</p><ul><li>数据库管理系统的实现技术—数据库存储与索引技术，查询实现与优化技术等</li><li>数据库系统理论 + 具体数据库管理系统软件产品相关的知识</li></ul><!-- RedingNotes/ShuJuKuXiTong/Zhong/ -->]]></content>
      
      
      <categories>
          
          <category> 数据库系统 </category>
          
          <category> 中 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>7.5 实体-联系图</title>
      <link href="/ReadingNotes//f9bf95b0/"/>
      <url>/ReadingNotes//f9bf95b0/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/f9bf95b0/#7-5-实体-联系图" class="header_1">7.5 实体-联系图</a>&nbsp;<br><a href="/ReadingNotes/f9bf95b0/#7-5-1-基本结构" class="header_1">7.5.1 基本结构</a>&nbsp;<br><a href="/ReadingNotes/f9bf95b0/#7-5-2-映射基数" class="header_1">7.5.2 映射基数</a>&nbsp;<br><a href="/ReadingNotes/f9bf95b0/#箭头线段形式" class="header_2">箭头线段形式</a>&nbsp;<br><a href="/ReadingNotes/f9bf95b0/#小结" class="header_2">小结</a>&nbsp;<br><a href="/ReadingNotes/f9bf95b0/#l-h表示形式" class="header_2">l..h表示形式</a>&nbsp;<br><a href="/ReadingNotes/f9bf95b0/#7-5-3-复杂的属性" class="header_1">7.5.3 复杂的属性</a>&nbsp;<br><a href="/ReadingNotes/f9bf95b0/#7-5-4-角色" class="header_1">7.5.4 角色</a>&nbsp;<br><a href="/ReadingNotes/f9bf95b0/#7-5-5-非二元的联系集" class="header_1">7.5.5 非二元的联系集</a>&nbsp;<br><a href="/ReadingNotes/f9bf95b0/#7-5-6-弱实体集" class="header_1">7.5.6 弱实体集</a>&nbsp;<br><a href="/ReadingNotes/f9bf95b0/#弱实体集" class="header_2">弱实体集</a>&nbsp;<br><a href="/ReadingNotes/f9bf95b0/#标识性联系" class="header_3">标识性联系</a>&nbsp;<br><a href="/ReadingNotes/f9bf95b0/#E-R图中弱实体集和强实体集的区别" class="header_2">E-R图中弱实体集和强实体集的区别</a>&nbsp;<br><a href="/ReadingNotes/f9bf95b0/#7-5-7-大学的E-R图" class="header_1">7.5.7 大学的E-R图</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="7-5-实体-联系图"><a href="#7-5-实体-联系图" class="headerlink" title="7.5 实体-联系图"></a>7.5 实体-联系图</h1><p>1.3.3节曾经简要地介绍过,<code>E-R</code>图(<code>E-R diagram</code>)可以图形化表示数据库的全局逻辑结构。<code>E-R</code>图既简单又清晰,这些是致使<code>E-R</code>模型广泛使用的重要性质。</p><h1 id="7-5-1-基本结构"><a href="#7-5-1-基本结构" class="headerlink" title="7.5.1 基本结构"></a>7.5.1 基本结构</h1><p><code>E-R</code>图包括如下几个主要构件:</p><ol><li>分成两部分的<strong><code>矩形</code>代表<code>实体集</code></strong>。本书中有阴影的第一部分包含实体集的名字,第二部分包含实体集中所有属性的名字。</li><li><strong>菱形</strong>代表<strong>联系集</strong>。</li><li>未分割的矩形代表联系集的属性。构成主码的属性以<code>下划线</code>标明。</li><li><code>线段</code>将实体集连接到联系集。</li><li><code>虚线</code>将联系集属性连接到联系集。</li><li><code>双线</code>显示实体在联系集中的参与度。</li><li><code>双菱形</code>代表连接到弱实体集的标志性联系集(我们将在7.5.6节讲述标志性联系集和弱实体</li></ol><p>考虑图7-7中的<code>ER</code>图,它由通过二元联系集<code>advisor</code>关联的两个实体集<code>instructor</code>和<code>student</code>组成。同<code>instructor</code>相关联的属性为<code>ID</code>、<code>name</code>和<code>salary</code>。同<code>student</code>相关联的属性为<code>ID</code>、<code>name</code>和<code>tot_cred.</code>。如图7-7所示,实体集的属性中那些组成主码的属性以下划线标明。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/ShuJuKuXiTongGaiNian/ch7/1.png" alt="这里有一张图片"><br><strong>如果一个联系集有关联的属性，那么我们将这些属性放入一个矩形中，并且用虚线将该矩形与代表联系集的菱形连接起来</strong>。例如，在图7-8中，我们有描述性属性<code>dame</code>附带到联系集 <code>advisor</code>上，表示教师成为导师的日期。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/ShuJuKuXiTongGaiNian/ch7/2.png" alt="这里有一张图片"></p><h1 id="7-5-2-映射基数"><a href="#7-5-2-映射基数" class="headerlink" title="7.5.2 映射基数"></a>7.5.2 映射基数</h1><h2 id="箭头线段形式"><a href="#箭头线段形式" class="headerlink" title="箭头线段形式"></a>箭头线段形式</h2><p>实体集<code>instructor</code>和<code>student</code>之间的联系集<code>advisor</code>可以是<strong>一对一</strong>、<strong>一对多</strong>、<strong>多对一</strong>或<strong>多对多</strong>的。为了区别这些类型，我们在所讨论的联系集和实体集之间画一个箭头（→）或一条线段（一），如下所示。<br><strong>一对一</strong>:我们从联系集 <code>advisor</code>向实体集 <code>instructor</code>和 <code>student</code>各画一个箭头(见图7-9a)。这表示一名教师可以指导最多一名学生,并且一名学生可以有最多一位导师。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/ShuJuKuXiTongGaiNian/ch7/3.png" alt="这里有一张图片"><br><strong>一对多</strong>:我们从联系集 <code>advisor</code>画一个箭头到实体集<code>instructor</code>,以及一条<code>线段</code>到实体集 <code>student</code>(见图7-9b)这表示一名教师可以指导多名学生,但一名学生可以有至多一位导师。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/ShuJuKuXiTongGaiNian/ch7/4.png" alt="这里有一张图片"><br><strong>多对一</strong>:我们从联系集<code>advisor</code>画一条<code>线段</code>到实体集<code>instructor</code>,以及一个<code>箭头</code>到实体集<code>student</code>。这表示一名教师可以指导至多一名学生,但一名学生可以有多位导师。<br><strong>多对多</strong>:我们从联系集<code>advisor</code>向实体集<code>instructor</code>和<code>student</code>各画一条<code>线段</code>(见图7-9c)。这表示一名教师可以指导多名学生,并且一名学生可以有多位导师。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/ShuJuKuXiTongGaiNian/ch7/5.png" alt="这里有一张图片"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><code>箭头</code>表示<code>一</code></li><li><code>线段</code>表示<code>多</code></li></ul><h2 id="l-h表示形式"><a href="#l-h表示形式" class="headerlink" title="l..h表示形式"></a>l..h表示形式</h2><p><code>ER</code>图还提供了一种描述每个实体参与联系集中的联系的次数的更复杂的约束的方法。实体集和二元联系集之间的一条边可以有一个关联的最大和最小的映射基数,用<code>l..h</code>的形式表示,其中</p><ul><li><code>l</code>表示<code>最小</code>的映射基数,</li><li>而<code>h</code>表示<code>最大</code>的映射基数。</li><li>最小值<code>l</code>为1表示这个实体集在该联系集中全部参与,即实体集中的每个实体在联系集中的至少一个联系中出现。</li><li>最大值<code>h</code>为1表示这个实体参与至多一个联系,而最大值为<code>*</code>代表没有限制。</li></ul><p>例如,考虑图7-10：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/ShuJuKuXiTongGaiNian/ch7/6.png" alt="这里有一张图片"><br>在<code>advisor</code>和<code>student</code>之间的边有<code>1..1</code>的基数约束,意味着基数的最小值和最大值都是1,也就是,每个学生必须有且仅有一个导师。<br>从<code>advisor</code>到<code>instructor</code>边上的约束<code>0..*</code>说明<code>教师可以有零个或多个学生</code>。因此, <code>advisor</code>联系是从<code>instructor</code>到<code>student</code>的一对多联系,更进一步地讲, <code>student</code>在<code>advisor</code>联系中的参与是全部的,表示<code>一个学生必须有一个导师</code>。<br>很容易将左侧边上的<code>0..*</code>曲解为联系<code>advisor</code>是从<code>instructor</code>到<code>student</code>多对一的,而这正好和正确的解释相反。<br>图7-10中的<code>E-R</code>图的<strong>另一种画法</strong>是在基数约束的位置画一条从<code>student</code>到<code>advisor</code>的双线,以及一个从<code>advisor</code>到<code>instructor</code>的箭头。这种画法可以强制实施同图7-10中所示约束完全一样的约束。</p><h1 id="7-5-3-复杂的属性"><a href="#7-5-3-复杂的属性" class="headerlink" title="7.5.3 复杂的属性"></a>7.5.3 复杂的属性</h1><p><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/ShuJuKuXiTongGaiNian/ch7/7.png" alt="这里有一张图片"><br>图7-11说明了怎样在<code>E-R</code>图中表示复合属性。这里一个具有子属性<code>first_name</code>、 <code>middle_initial</code>和<code>last_name</code>的复合属性<code>name</code>代替了<code>instructor</code>的简单属性<code>name</code>。再例如,假定我们给实体集<code>instructor</code>增加个地址。地址可以定义为具有属性<code>street</code>、<code>city</code>、<code>sate</code>和<code>a_code</code>的复合属性<code>address</code>属性<code>street</code>本身也是一个复合属性,其子属性为<code>street_number</code>、 <code>street_name</code>和<code>apartment_number</code>。<br>在图7-11还给出了一个由”<code>{phone_number}</code>“表示的多值属性<code>phone_number</code>和一个由”<code>{age()}</code>“表示的<strong>派生属性</strong><code>age</code>。</p><h1 id="7-5-4-角色"><a href="#7-5-4-角色" class="headerlink" title="7.5.4 角色"></a>7.5.4 角色</h1><p>在<code>E-R</code>图中,我们通过在菱形和矩形之间的连线上进行标注来表示角色。图7-12给出了<code>course</code>实体集和<code>prereq</code>联系集之间的角色标识<code>course id</code>和<code>prereq_id</code>。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/ShuJuKuXiTongGaiNian/ch7/8.png" alt="这里有一张图片"></p><h1 id="7-5-5-非二元的联系集"><a href="#7-5-5-非二元的联系集" class="headerlink" title="7.5.5 非二元的联系集"></a>7.5.5 非二元的联系集</h1><p>非二元的联系集也可以在<code>E-R</code>图中简单地表示。图7-13包含三个实体集<code>instructor</code>、 <code>student</code>和<code>project</code>,它们通过联系集<code>proi_ guide</code>相关联。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/ShuJuKuXiTongGaiNian/ch7/9.png" alt="这里有一张图片"><br>在非二元的联系集中,我们可以表示某些类型的多对一联系。假设一个<code>student</code>在每个项目上最多只能有一位导师。这种约束可用从<code>proj_guide</code>的边指向<code>instructor</code>的箭头来表示。</p><p>省略部分内容….</p><h1 id="7-5-6-弱实体集"><a href="#7-5-6-弱实体集" class="headerlink" title="7.5.6 弱实体集"></a>7.5.6 弱实体集</h1><p>考虑一个<code>section</code>实体,它由课程编号、学期、学年以及开课编号唯一标识。显然,开课实体和课程实体相关联。假定我们在实体集<code>section</code>和<code>course</code>之间创建了一个联系集<code>sec_course</code>。<br>现在,发现<code>sec_course</code>中的信息是冗余的,由于<code>section</code>已有属性<code>course_id</code>,它标识该开课所关联的课程。消除这种冗余的一个方法是删除联系<code>sec_course</code>;然而,这么做使得<code>section</code>和<code>course</code>之间的联系隐含于一个属性中,这并不是我们想要的。<br>消除这种冗余的另一个方法是<strong>在实体<code>section</code>中不保存属性<code>course_id</code>,而只保存剩下的属性<code>sec_id</code>,<code>year</code>以及<code>semester</code></strong>。然而,这样的话实体集<code>section</code>就没有足够的属性唯一标识一个指定的<code>section</code>实体;即使每个<code>section</code>实体都是唯一的,不同课程的开课也可能会有相同的<code>sec_id</code>、<code>year</code>以及<code>semester.</code>。为解决这个问题,我们将联系<code>sec_course</code>视为一个特殊的联系,它给唯一标识<code>section</code>实体提供额外信息,即<code>course_id</code>.</p><h2 id="弱实体集"><a href="#弱实体集" class="headerlink" title="弱实体集"></a>弱实体集</h2><ul><li><strong>没有足够的属性以形成<code>主码</code>的<code>实体集</code>称作弱实体集</strong>(<code>weak entity set</code>)。</li><li><strong>有主码的实体集称作强实体集</strong>(<code>strong entity set</code>)。</li></ul><p>弱实体集必须与另一个称作<strong>标识</strong>( <code>identifying</code>)或<strong>属主实体集</strong>(<code>owner entity set</code>)的实体集关联才能有意义。<br><strong>每个弱实体必须和一个标识实体关联</strong>;也就是说,<strong>弱实体集存在依赖</strong>(<code>existence dependent</code>)于标识实体集。<br>我们称<code>标识实体集</code>拥有(<code>own</code>)它所标识的<code>弱实体集</code>。</p><h3 id="标识性联系"><a href="#标识性联系" class="headerlink" title="标识性联系"></a>标识性联系</h3><p>将<code>弱实体集</code>与其<code>标识实体集</code>相联的<code>联系</code>称为<strong>标识性联系</strong>( <code>identifying relationship</code>)</p><p>标识性联系是从<code>弱实体集</code>到<code>标识实体集</code><strong>多对一</strong>的,并且弱实体集在联系中的参与是全部的。标识性联系集不应该有任何描述性属性,因为这种属性中的任意一个都可以与弱实体集相关联。<br>在我们的例子中, <code>section</code>的<code>标识实体集</code>是<code>course</code>,将<code>section</code>实体和它们对应的<code>course</code>实体关联在起的<code>sec_course</code>是<code>标识性联系</code>。<br>虽然弱实体集没有主码,但是我们仍需要区分依赖于特定强实体集的弱实体集中的实体的方法。弱实体集的<code>分辨符</code>(<code>discriminator</code>)是使得我们进行这种区分的属性集合。例如,弱实体集<code>section</code>的分辨符由属性<code>sec_id</code>、<code>year</code>以及<code>semester</code>组成,因为对每门课程来说,这个属性集唯一标识了这门课程的移一次开课。<strong>弱实体集的<code>分辨符</code>也称为该实体集的<code>部分码</code></strong></p><p><strong><code>弱实体集</code>的主码由<code>标识实体集的主码</code>加上<code>该弱实体集的分辨符</code>构成</strong>。在实体集<code>section</code>的例子中,它的主码是<code>{course_id,sec_id, year, semester}</code>,其中<code>course_id</code>是标识实体集<code>course</code>的主码,<code>sec_id,year, semester</code>区分同一门课程的不同<code>section</code>实体。<br>注意,我们可以选择使<code>sec_id</code>对于大学所提供的所有课程都不重复,在这种情况下实体集<code>section</code>将会具有一个主码。然而,一个<code>section</code>的存在在概念上仍依赖于一个<code>course</code>,通过使之成为弱实体集可以明确这种依赖关系。</p><h2 id="E-R图中弱实体集和强实体集的区别"><a href="#E-R图中弱实体集和强实体集的区别" class="headerlink" title="E-R图中弱实体集和强实体集的区别"></a>E-R图中弱实体集和强实体集的区别</h2><p>在<code>ER</code>图中,弱实体集和强实体集类似,以矩形表示,但是有两点主要的区别:</p><ul><li>弱实体集的<code>分辨符</code>以<code>虚下划线</code>标明,而不是实线。</li><li>关联<code>弱实体集</code>和<code>标识性强实体集</code>的联系集以<code>双菱形</code>表示。</li></ul><p>在图7-14中,弱实体集<code>section</code>通过联系集<code>sec_course</code>依赖于强实体集<code>course</code>。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/ShuJuKuXiTongGaiNian/ch7/10.png" alt="这里有一张图片"><br>该图还表明了如何使用<strong>双线表明全部参与</strong>;(弱)实体集<code>section</code>在联系<code>sec_course</code>中的参与是全部的,表示每次开课都必须通过<code>sec_course</code>同某门课程关联。最后,从<code>sec_course</code>指向<code>course</code>的<code>箭头</code>表示每次开课与单门课程相关联。<br><strong>弱实体集可以参与标识性联系以外的其他联系</strong>。例如, <code>section</code>实体可以和<code>time_slot</code>实体集参与个联系,以标识开课的时间。<br><strong>弱实体集可以作为属主与另一个弱实体集参与一个标识性联系</strong>。<br><strong>一个弱实体集也可能与不止一个标识实体集关联</strong>。这样,一个特定的弱实体将被一个实体的组合标识,其中每个标识实体集有一个实体在该组合中。<br><strong>弱实体集的主码可以由标识实体集的主码的并集加上弱实体集的分辨符组成</strong>。<br>在某些情况下,数据库设计者会选择将一个弱实体集表示为属主实体集的一个多值复合属性。<br>在我们的例子中,这种方法需要实体集<code>course</code>具有一个多值复合属性<code>section</code>。如果弱实体集只参与标识性联系,而且其属性不多,那么在建模时将其表示为一个属性更恰当。相反地,如果弱实体集参与到标识性联系以外的联系中,或者其属性较多,则建模时将其表示为弱实体集更恰当。很明显, <code>section</code>不符合建模成多值复合属性的要求,而将其建模为弱实体集更恰当。</p><h1 id="7-5-7-大学的E-R图"><a href="#7-5-7-大学的E-R图" class="headerlink" title="7.5.7 大学的E-R图"></a>7.5.7 大学的E-R图</h1><p>图7-15展示了本书迄今所使用的大学所对应的E-R图。除了增加了若干约束,以及<code>section</code>为弱实体以外,该<code>ER</code>图与我们在74节中看到的大学<code>E-R</code>模型的文字性描述等价。<br>在我们的大学数据库中,我们限制每名教师必须有且仅有一个相关联的系。因此,如图7-15所示,在<code>instructor</code>和<code>inst_dept</code>之间有一条双线,表示<code>instructor</code>在<code>inst_dept</code>中全部参与;即每名教师必须和一个系相关联。另外,存在一个从<code>inst_dept</code>到<code>department</code>的箭头,表示每个教师可以有至多一个相关联的系。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第二部分 数据库设计 </category>
          
          <category> 第7章 数据库设计和E-R模型 </category>
          
          <category> 7.5 实体-联系图 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>7.4 从实体集中删除冗余属性</title>
      <link href="/ReadingNotes//7ecbb3b1/"/>
      <url>/ReadingNotes//7ecbb3b1/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/7ecbb3b1/#7-4-从实体集中删除冗余属性" class="header_1">7.4 从实体集中删除冗余属性</a>&nbsp;<br><a href="/ReadingNotes/7ecbb3b1/#老师-系联系集" class="header_2">老师-系联系集</a>&nbsp;<br><a href="/ReadingNotes/7ecbb3b1/#学生-系联系集" class="header_2">学生-系联系集</a>&nbsp;<br><a href="/ReadingNotes/7ecbb3b1/#总体设计" class="header_1">总体设计</a>&nbsp;<br><a href="/ReadingNotes/7ecbb3b1/#实体集" class="header_2">实体集</a>&nbsp;<br><a href="/ReadingNotes/7ecbb3b1/#联系集" class="header_2">联系集</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="7-4-从实体集中删除冗余属性"><a href="#7-4-从实体集中删除冗余属性" class="headerlink" title="7.4 从实体集中删除冗余属性"></a>7.4 从实体集中删除冗余属性</h1><p>当我们<strong>使用E-R模型设计数据库时,我们通常<code>从确定那些应当包含的实体集开始</code></strong>。例如,在我们迄今所讨论的大学机构中,我们想要包含如 <code>student</code>和 <code>instructor</code>等实体集。当决定好实体集后,我们必须挑选适当的属性,这些属性要表示我们在数据库中所捕获的不同的值。在大学机构中,我们为<code>instructor</code>实体集设计了包括<code>ID</code>,<code>name</code>, <code>dept_name</code>以及 <code>salary</code>几个属性,我们还可以增加 <code>phone_number</code>,<code>office_number</code>, <code>home_page</code>等属性。要包含哪些属性的选择决定于了解企业结构的设计者。</p><p>一旦选择好实体和它们相应的属性,不同实体间的联系集就建立起来了。这些联系集有可能会导致不同实体集中的<strong>属性冗余</strong>,并需要将其从原始实体集中删除。</p><p>为了说明这一点,考虑实体集<code>instructor</code>和<code>department</code></p><ul><li>实体集<code>instructor</code>包含属性<code>ID</code>,<code>name</code>, <code>dept_name</code>以及<code>salary</code>,其中<code>ID</code>构成主码</li><li>实体集<code>department</code>包含属性<code>dept_name</code>, <code>building</code>以及<code>budget</code>,其中<code>dept_name</code>构成主码。</li></ul><h2 id="老师-系联系集"><a href="#老师-系联系集" class="headerlink" title="老师-系联系集"></a>老师-系联系集</h2><p>我们用关联<code>instructor</code>和<code>department</code>的<strong>联系集</strong><code>inst_dept</code>对每个<code>教师</code>都有一个关联的<code>系</code>的情况建模。<br>属性<code>dept_name</code>在两个实体集中都出现了。由于它是实体集<code>department</code>的主码,因此它在实体集<code>instructor</code>中是冗余的,需要将其移除。</p><p>从实体集<code>instructor</code>中移除属性<code>dept_name</code>可能不是那么直观,因为我们在前几章所用到的关系<code>instructor</code>中具有<code>dept_name</code>属性。我们将在后面看到,当我们从E-R图构建一个关系模式时,只有当每个教师最多只与一个系关联时,属性<code>dept_name</code>才会添加到关系<code>instructor</code>中。如果一个教师有多个关联的系时,教师与系之间的联系会记录在一个单独的关系<code>inst_dept</code>中。<br>将<code>教师</code>和<code>系</code>之间的关联统一看成联系,而不是<code>instructor</code>的一个属性,使得逻辑关系明确,并有助于避免过早地假设每个教师只与一个系关联。</p><h2 id="学生-系联系集"><a href="#学生-系联系集" class="headerlink" title="学生-系联系集"></a>学生-系联系集</h2><p>类似地,实体集<code>student</code>通过联系集<code>student_dept</code>与实体集<code>department</code>关联,因而<code>student</code>中不需要<code>dept_name</code>属性。</p><p>作为另一个例子,考虑<strong>开课</strong>(<code>section</code>)和<strong>开课的时段</strong>。每个<strong>时段</strong>都由<code>time_slot_id</code>标识,并且和上课时间的集合相关联,每次上课时间都由星期几,开始时间以及结束时间标识。我们打算使用多值复合属性对上课时间集合建模。假设我们对实体集<code>section</code>和<code>time_slot</code>按以下方式建模:</p><ul><li><strong>实体集</strong><code>section</code>包含属性<code>course_id</code>,<code>sec_id</code>, <code>semester</code>,<code>year</code>, <code>building</code>,<code>room_number</code>以及<code>time_slot_id</code>,其中<code>(course_id,sec_id,year,semester)</code>构成主码。</li><li><strong>实体集</strong><code>time_slot</code>包含主码属性<code>time_slot_id</code>,以及一个<strong>多值复合属性</strong><code>{(day,sant_time,end_time)}</code></li></ul><p>这些实体通过<strong>联系集</strong><code>sec_time_slot</code>相互关联。</p><p>属性<code>time_slot_id</code>在两个实体集中均出现。由于它是实体集<code>time_slot</code>的主码,因此它在实体集<code>section</code>中是冗余的,并且需要将其删除。</p><p>作为最后的例子,<br>假设我们有一个<strong>实体集</strong><code>classroon</code>,包含属性<code>building</code>,<code>room_number</code>以及<code>capacity</code>,主码由<code>building</code>和<code>room_number</code>组成。<br>再假设我们有一个<strong>联系集</strong><code>sec_class</code>,将<code>section</code>和<code>classroom</code>关联在起。那么属性<code>{building, room_number}</code>在实体集<code>section</code>中是冗余的。</p><h1 id="总体设计"><a href="#总体设计" class="headerlink" title="总体设计"></a>总体设计</h1><p><strong>一个好的实体-联系设计不包含冗余的属性</strong>。</p><h2 id="实体集"><a href="#实体集" class="headerlink" title="实体集"></a>实体集</h2><p>对于我们的大学的例子,我们在下面列出实体集以及它们的属性,主码以下划线标明。</p><ul><li><code>classroom</code>:包含属性<code>(<u>building</u>,<u>room_number</u>,capacity)</code></li><li><code>department</code>:包含属性<code>(<u>dept_name</u>,building, budget)</code>。</li><li><code>course</code>:包含属性<code>(<u>course_id</u>, title, credits)</code>。</li><li><code>instructor</code>:包含属性<code>(<u>ID</u>,name, salary)</code>。</li><li><code>section</code>:包含属性<code>(<u>course_id</u>, <u>sec_id</u>, <u>semester</u>,<u>year</u>)</code>。</li><li><code>student</code>:包含属性<code>(<u>ID</u>,name, tot_cred)</code>。</li><li><code>time_slot</code>:包含属性<code>(<u>time_slot_id</u>,{(day, start_time, end_time)})</code>。</li></ul><h2 id="联系集"><a href="#联系集" class="headerlink" title="联系集"></a>联系集</h2><p>我们设计的联系集如下。</p><ul><li><code>inst_dept</code>:关联教师和系</li><li><code>stud_dept</code>:关联学生和系。</li><li><code>teaches</code>:关联教师和开课。</li><li><code>takes</code>:关联学生和开课,包含描述性属性<code>grade</code></li><li><code>course_dept</code>:关联课程和系。</li><li><code>sec_course</code>:关联开课和课程。</li><li><code>sec_class</code>:关联开课和教室。</li><li><code>sec_time_slot</code>:关联开课和时段</li><li><code>advisor</code>:关联学生和教师。</li><li><code>prereg</code>:关联课程和先修课程。</li></ul><p>你可以验证<strong>没有任何一个实体集包含由联系集而造成冗余的属性</strong>;另外,你可以验证我们此前在第2章的图2-8中看到的大学数据库关系模式中的所有的信息(除了约束)全部包含在上述的设计中,只是关系设计中的几个属性被<code>ER</code>设计中的联系所替代。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第二部分 数据库设计 </category>
          
          <category> 第7章 数据库设计和E-R模型 </category>
          
          <category> 7.4 从实体集中删除冗余属性 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>7.3.3 码</title>
      <link href="/ReadingNotes//3a2eb64a/"/>
      <url>/ReadingNotes//3a2eb64a/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/3a2eb64a/#7-3-3-码" class="header_1">7.3.3 码</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="7-3-3-码"><a href="#7-3-3-码" class="headerlink" title="7.3.3 码"></a>7.3.3 码</h1><p>我们必须有一个区分给定实体集中的实体的方法。</p><ul><li>从概念上来说,<strong>各个实体是互异的</strong>;</li><li>但从数据库的观点来看,它们的区别必须<strong>通过其属性来表明</strong>。</li></ul><p>因此,一个实体的属性的值必须可以唯一标识该实体。也就是说,<strong>在一个实体集中不允许两个实体对于所有属性都具有完全相同的值</strong>。</p><p>2.3节定义的关系模式的码的概念直接适用于实体集。<strong>即实体的码是一个足以区分每个实体的<code>属性集</code></strong>。关系模式中的<code>超码</code>、<code>候选码</code>、<code>主码</code>的概念同样适用于实体集。</p><p><code>码</code>同样用于唯一地标识联系,并从而将联系互相区分开来。我们在下面定义联系的码的相应概念。实体集的<code>主码</code>使得我们可以区分实体集中不同的实体。我们需要一种类似的机制来区分联系集中不同的联系。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第二部分 数据库设计 </category>
          
          <category> 第7章 数据库设计和E-R模型 </category>
          
          <category> 7.3 约束 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>7.3.2 参与约束</title>
      <link href="/ReadingNotes//82cebc7a/"/>
      <url>/ReadingNotes//82cebc7a/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/82cebc7a/#7-3-2-参与约束" class="header_1">7.3.2 参与约束</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="7-3-2-参与约束"><a href="#7-3-2-参与约束" class="headerlink" title="7.3.2 参与约束"></a>7.3.2 参与约束</h1><p>如果实体集E中的每个实体都参与到联系集R的至少一个联系中,实体集E在联系集R中的参与称为全部(<code>total</code>)的。<br>如果E中只有部分实体参与到R的联系中,实体集E到联系集R的参与称为部分( <code>partial</code>)的。</p><p>例如,我们期望每个<code>student</code>实体通过<code>advisor</code>联系同至少一名教师相联系,因而<code>student</code>在联系集<code>advisor</code>中的参与是全部的。<br>相反地,一个<code>instructor</code>不是必须要指导一个学生。因此,很可能只有一部分<code>instructor</code>实体通过<code>advisor</code>联系同<code>student</code>实体集相关联,于是<code>instructor</code>在<code>advisor</code>联系集中的参与是部分的。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第二部分 数据库设计 </category>
          
          <category> 第7章 数据库设计和E-R模型 </category>
          
          <category> 7.3 约束 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>7.3 约束 7.3.1 映射基数</title>
      <link href="/ReadingNotes//272661d/"/>
      <url>/ReadingNotes//272661d/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/272661d/#7-3-约束" class="header_1">7.3 约束</a>&nbsp;<br><a href="/ReadingNotes/272661d/#7-3-1-映射基数" class="header_1">7.3.1 映射基数</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="7-3-约束"><a href="#7-3-约束" class="headerlink" title="7.3 约束"></a>7.3 约束</h1><p><code>E-R</code>企业模式可以定义一些<strong>数据库中的数据必须要满足的约束</strong>。这一节讨论映射基数以及参与约束。</p><h1 id="7-3-1-映射基数"><a href="#7-3-1-映射基数" class="headerlink" title="7.3.1 映射基数"></a>7.3.1 映射基数</h1><p>映射基数(<code>mapping cardinality</code>),或基数比率,表示一个实体通过一个联系集能关联的实体的个数。映射基数在描述二元联系集时非常有用,尽管它们可以用于描述涉及多于两个实体集的联系集在这一节中,我们将只集中在二元联系集上。<br>对于实体集A和B之间的二元联系集R来说,映射基数必然是以下情况之一:</p><ul><li><strong>一对一</strong>(<code>one-to-one</code>)。A中的一个实体至多与B中的一个实体相关联,并且B中的一个实体也至多与A中的一个实体相关联。</li><li><strong>一对多</strong>( <code>one-to-many</code>)。A中的一个实体可以与B中的任意数目(零个或多个)实体相关联,而B中的一个实体至多与A中的一个实体相关联</li><li><strong>多对一</strong>( <code>many-to-one</code>)。A中的一个实体至多与B中的一个实体相关联,而B中的一个实体可以与A中任意数目(零个或多个)实体相关联</li><li><strong>多对多</strong>(<code>many-to-many</code>)。A中的一个实体可以与B中任意数目(零个或多个)实体相关联,而且B中的一个实体也可以与A中任意数目(零个或多个)实体相关联</li></ul><p>显然,一个特定联系集的适当的映射基数依赖于该联系集所建模的现实世界的情况。<br>作为例子,考虑<code>advisor</code>联系集。</p><ul><li>如果在一所特定的大学中,一名学生只能由一名教师指导,而一名教师可以指导多个学生,那么<code>instructor</code>到<code>studen.</code>的联系集是<strong>一对多</strong>的。</li><li>如果一名学生可以由多名教师指导(比如学生可以由多名教师共同指导),那么此联系集是<strong>多对多</strong>的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第二部分 数据库设计 </category>
          
          <category> 第7章 数据库设计和E-R模型 </category>
          
          <category> 7.3 约束 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>7.2.3 属性</title>
      <link href="/ReadingNotes//c5abe413/"/>
      <url>/ReadingNotes//c5abe413/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/c5abe413/#7-2-3-属性" class="header_1">7.2.3 属性</a>&nbsp;<br><a href="/ReadingNotes/c5abe413/#属性的域" class="header_2">属性的域</a>&nbsp;<br><a href="/ReadingNotes/c5abe413/#属性类型分类" class="header_2">属性类型分类</a>&nbsp;<br><a href="/ReadingNotes/c5abe413/#简单-simple-和复合-composite-属性" class="header_3">简单(`simple`)和复合(`composite`)属性</a>&nbsp;<br><a href="/ReadingNotes/c5abe413/#什么是简单属性" class="header_4">什么是简单属性</a>&nbsp;<br><a href="/ReadingNotes/c5abe413/#什么是复合属性" class="header_4">什么是复合属性</a>&nbsp;<br><a href="/ReadingNotes/c5abe413/#使用复合属性的情况" class="header_4">使用复合属性的情况</a>&nbsp;<br><a href="/ReadingNotes/c5abe413/#复合属性的好处" class="header_5">复合属性的好处</a>&nbsp;<br><a href="/ReadingNotes/c5abe413/#复合属性可有层次" class="header_5">复合属性可有层次</a>&nbsp;<br><a href="/ReadingNotes/c5abe413/#单值-single-valued-和多值-multivalued-属性" class="header_3">单值( `single-valued`)和多值( `multivalued`)属性</a>&nbsp;<br><a href="/ReadingNotes/c5abe413/#如何表示多值属性" class="header_4">如何表示多值属性</a>&nbsp;<br><a href="/ReadingNotes/c5abe413/#给多值属性设置上下界" class="header_4">给多值属性设置上下界</a>&nbsp;<br><a href="/ReadingNotes/c5abe413/#派生-derived-属性" class="header_3">派生(`derived`)属性</a>&nbsp;<br><a href="/ReadingNotes/c5abe413/#基属性" class="header_4">基属性</a>&nbsp;<br><a href="/ReadingNotes/c5abe413/#派生属性的特点" class="header_4">派生属性的特点</a>&nbsp;<br><a href="/ReadingNotes/c5abe413/#null" class="header_3">null</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="7-2-3-属性"><a href="#7-2-3-属性" class="headerlink" title="7.2.3 属性"></a>7.2.3 属性</h1><h2 id="属性的域"><a href="#属性的域" class="headerlink" title="属性的域"></a>属性的域</h2><p>每个属性都有一个<strong>可取值的集合</strong>,称为该<strong>属性的<code>域</code></strong>(<code>domain</code>),或者<strong>值集</strong>( <code>value set</code>)。</p><ul><li><code>course_id</code>属性的域可能是特定长度的所有文本字符串的集合。</li><li>类似地,属性<code>semester</code>的域可能是集合{秋,冬,春,夏}中的字符串</li></ul><p>正规地说,<strong>实体集的属性是将实体集映射到域的函数</strong>。由于一个实体集可能有多个属性,因此每个实体可以用一组<strong>(<code>属性</code>,<code>数据值</code>)</strong>对来表示,实体集的每个属性对应一个这样的对。<br>例如,某个<code>instructor</code>实体可以用集合<code>{(ID,76766),(name, Crick),(dept_name,生物),( salary,72000)}</code>来描述,</p><ul><li>该实体描述了一个叫<code>Crick</code>的人,他的教师<code>编号</code>为76766,是<code>生物系</code>的成员,<code>工资</code>为<code>$72000</code>。</li></ul><p>从这里我们可以看出抽象模式与被建模的实际企业的结合<strong>。用来描述实体的属性值构成存储在数据库中的数据的一个重要部分</strong>。</p><h2 id="属性类型分类"><a href="#属性类型分类" class="headerlink" title="属性类型分类"></a>属性类型分类</h2><p>E-R模型中的属性可以按照如下的属性类型来进行划分:</p><h3 id="简单-simple-和复合-composite-属性"><a href="#简单-simple-和复合-composite-属性" class="headerlink" title="简单(simple)和复合(composite)属性"></a>简单(<code>simple</code>)和复合(<code>composite</code>)属性</h3><h4 id="什么是简单属性"><a href="#什么是简单属性" class="headerlink" title="什么是简单属性"></a>什么是简单属性</h4><p>在我们的例子中,迄今为止出现的属性都是<strong>简单属性</strong>,也就是说,<strong>简单属性不能划分为更小的部分</strong>。</p><h4 id="什么是复合属性"><a href="#什么是复合属性" class="headerlink" title="什么是复合属性"></a>什么是复合属性</h4><p><strong>复合(<code>composite</code>)属性可以再划分为更小的部分(即其他属性)</strong>。</p><p>例如,属性<code>name</code>可设计为一个包括<code>first_name</code>、 <code>middle_initial</code>和<code>last_name</code>的复合属性。</p><h4 id="使用复合属性的情况"><a href="#使用复合属性的情况" class="headerlink" title="使用复合属性的情况"></a>使用复合属性的情况</h4><p><strong>如果一个用户<code>希望在一些场景中引用完整的属性</code>,而<code>在另外的场景中仅引用属性的一部分</code>,则在设计模式中使用复合属性是一个好的选择</strong>。<br>假设我们要给<code>student</code>实体集增加个<strong>地址</strong>。地址可定义为包含属性<code>street</code>、<code>city</code>、<code>state</code>和<code>zip_code</code>的复合属性<code>address</code>。</p><h5 id="复合属性的好处"><a href="#复合属性的好处" class="headerlink" title="复合属性的好处"></a>复合属性的好处</h5><p>复合属性帮助我们<code>把相关属性聚集起来</code>,使模型更清晰。</p><h5 id="复合属性可有层次"><a href="#复合属性可有层次" class="headerlink" title="复合属性可有层次"></a>复合属性可有层次</h5><p>注意,<strong>复合属性可以是<code>有层次</code>的</strong>。在复合属性<code>address</code>中,其子属性<code>street</code>可以进一步分为<code>street_number</code>、<code>street_name</code>和<code>apartment_number</code>。</p><h3 id="单值-single-valued-和多值-multivalued-属性"><a href="#单值-single-valued-和多值-multivalued-属性" class="headerlink" title="单值( single-valued)和多值( multivalued)属性"></a>单值( <code>single-valued</code>)和多值( <code>multivalued</code>)属性</h3><p><strong>一个属性值只能对应一个一个特定实体的属性</strong>是单值(<code>single valued</code>)的属性。<br>例如,对某个特定的学生实体而言, <code>student_ID</code>属性只对应于一个学生<code>ID</code>。<br>而在某些情况下对某个特定实体而言,<strong>一个属性可能对应于一组值</strong>。<br>假设我们往<code>instructor</code>实体集添加一个<code>phone_number</code>属性,<code>每个教师可以有零个、个或多个电话号码</code>,不同的教师可以有不同数量的电话。这样的属性称作是多值( <code>multivalued</code>)的。<br>作为另一个例子,我们可以往实体集<code>instructor</code>中添加一个属性<code>dependent_name</code>,它列出所有的眷属。这个属性将是多值的,因为任何一个特定的教师可能有零个、一个或多个眷属</p><h4 id="如何表示多值属性"><a href="#如何表示多值属性" class="headerlink" title="如何表示多值属性"></a>如何表示多值属性</h4><p>为了表示一个属性是多值的,我们<strong>用花括号将属性名</strong>括住,例如:<code>{phone_number}</code>或者<code>{dependent_name}</code>。</p><h4 id="给多值属性设置上下界"><a href="#给多值属性设置上下界" class="headerlink" title="给多值属性设置上下界"></a>给多值属性设置上下界</h4><p>在适当的情况下,可以<strong>对一个多值属性的取值数目设置上、下界</strong>。<br>例如,<strong>一所大学可能将一个教师的电话号码个数限制在两个以内</strong>。在这个例子中设置限制表明<code>instructor</code>实体集的<code>phone_number</code>属性可以有0~2个值。</p><h3 id="派生-derived-属性"><a href="#派生-derived-属性" class="headerlink" title="派生(derived)属性"></a>派生(<code>derived</code>)属性</h3><p>这类<strong>属性的值可以从别的相关属性或实体派生出来</strong>。例如,让我们假设<code>instructor</code>实体集有一个属性<code>students_advised</code>,表示<strong>一个教师指导了多少个学生</strong>。我们<strong>可以通过统计与一个教师相关联的所有<code>student</code>实体的数目来得到这个属性的值</strong>。<br>又如,假设<code>instructor</code>实体集具有属性<code>age</code>,表示教师的年龄。如果<code>instructor</code>实体集还具有属性<code>date_of_birth</code>,我们就可以从当前的日期和<code>dae_ of_birth</code><strong>计算出</strong><code>age</code>。因此<code>age</code>就是派生属性。</p><h4 id="基属性"><a href="#基属性" class="headerlink" title="基属性"></a>基属性</h4><p>在这里, </p><ul><li><code>date_of_birth</code>可以称为基属性,或<code>存储的属性</code>。</li><li><code>age</code>称为<code>派生属性</code><h4 id="派生属性的特点"><a href="#派生属性的特点" class="headerlink" title="派生属性的特点"></a>派生属性的特点</h4><strong>派生属性的值不存储,而是在需要时计算出来</strong>。<h3 id="null"><a href="#null" class="headerlink" title="null"></a>null</h3>当实体在某个属性上没有值时使用空(<code>null</code>)值。</li><li>空值可以表示”不适用”,即该实体的这个属性不存在值。例如,一个人可能没有中间名字。</li><li>空值还可以用来表示属性值未知。未知的值<strong>可能是缺失的</strong>(值存在,但我们没有该信息),<strong>或不知道的</strong>(我们并不知道该值是否确实存在)。</li></ul><p>例如</p><ul><li>如果一个特定的教师的<code>name</code>值是空,我们推测这个值是<code>缺失的</code>,因为每个教师肯定有一个名字。</li><li>而<code>apartment_number</code>属性的空值<ul><li>可能意味着地址不包括房间号(不适用),</li><li>或房间号是存在的但是我们不知道是什么(缺失的),</li><li>或者我们不知道房间号是否是该教师的地址的一部分(不知道的)。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第二部分 数据库设计 </category>
          
          <category> 第7章 数据库设计和E-R模型 </category>
          
          <category> 7.2 实体-联系模型 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>7.2.2 联系集</title>
      <link href="/ReadingNotes//8c04dbed/"/>
      <url>/ReadingNotes//8c04dbed/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/8c04dbed/#7-2-2-联系集" class="header_1">7.2.2 联系集</a>&nbsp;<br><a href="/ReadingNotes/8c04dbed/#参与" class="header_2">参与</a>&nbsp;<br><a href="/ReadingNotes/8c04dbed/#角色" class="header_2">角色</a>&nbsp;<br><a href="/ReadingNotes/8c04dbed/#联系的描述性属性" class="header_2">联系的描述性属性</a>&nbsp;<br><a href="/ReadingNotes/8c04dbed/#二元联系集" class="header_2">二元联系集</a>&nbsp;<br><a href="/ReadingNotes/8c04dbed/#度" class="header_2">度</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="7-2-2-联系集"><a href="#7-2-2-联系集" class="headerlink" title="7.2.2 联系集"></a>7.2.2 联系集</h1><p>联系(<code>relationship</code>)是指多个实体间的相互关联。<br>例如,我们可以定义关联教师<code>Katz</code>和学生<code>Shankar</code>的联系<code>advisor</code>。这一联系指明<code>Katz</code>是学生<code>Shankar</code>的导师。<br>再看另一个例子,考虑实体集<code>student</code>和<code>section</code>。我们可以定义联系集<code>takes</code>来表示学生和该学生所注册的开课之间的关联。</p><h2 id="参与"><a href="#参与" class="headerlink" title="参与"></a>参与</h2><p>实体集之间的<strong>关联</strong>称为<strong>参与</strong>;也就是说,实体集<code>E1,E2,…,En</code>参与(<code>participate</code>)联系集R。<code>E-R</code>模式中的一个<strong>联系实例</strong>( <code>relationship instance</code>)表示在所建模的现实世界企业中命名实体间的一个关联。例如,一个教师<code>ID</code>为45565的<code>instructor</code>实体<code>Katz</code>和一个学生<code>ID</code>为12345的<code>student</code>实体<code>Shankar</code><strong>参与</strong>到<code>advisor</code>(指导)的一个联系实例中。这一联系实例表示在大学中<strong>教师<code>Katz</code> <code>指导</code>学生<code>Shankar</code></strong></p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><p><strong>实体在联系中扮演的<code>功能</code>称为<code>实体的角色</code></strong>(<code>role</code>)。由于参与一个联系集的实体集通常是互异的因此角色是隐含的并且一般并不指定。但是,当联系的含义需要解释时角色是很有用的。当参与联系集的实体集并非互异的时候就是这种情况;也就是说,同样的实体集以不同的角色不止一次的参与一个联系集。<br>在这类联系集中,即有时称作<strong>自环</strong>的( <code>recursive</code>)联系集中,有必要用显式的角色名来指明实体是如何参与联系实例的。<br>例如,考虑记录大学开设的所有课程的信息的实体集<code>course</code>。我们用<code>course</code>实体的有序对来建模联系集<code>prereq</code>,以描述<strong>一门课程(<code>C2</code>)是另一门课程(<code>C1</code>)的<code>先修课</code></strong>。<br>每对课程中的第一门课程具有课程<code>C1</code>的角色,<br>而第二门课程具有先修课<code>C2</code>的角色。<br>按照这种方式,所有的<code>prereg</code>联系通过<code>(C1,C2)</code>对来表示,这样可以排除了<code>(C2,C1)</code>对。</p><h2 id="联系的描述性属性"><a href="#联系的描述性属性" class="headerlink" title="联系的描述性属性"></a>联系的描述性属性</h2><p><code>联系</code>也可以具有<strong>描述性属性</strong>( <code>descriptive attribute</code>)。考虑实体集<code>instructor</code>和<code>student</code>之间的联系集<code>advisor</code>。我们可以将属性<code>date</code>与该联系关联起来,以表示<strong>教师成为学生的导师的日期</strong>。教师<code>Katz</code>对应的实体和学生<code>Shankar</code>对应的实体之间的联系<code>advisor</code>的属性<code>dae</code>的值为”<code>10 June 2007</code>“,表示<strong><code>Katz</code>于2007年6月10日成为<code>Shankar</code>的导师</strong>。</p><p>作为<strong>联系的描述性属性</strong>的一个更实际的例子,考虑实体集<code>student</code>和<code>section</code>参与一个联系集<code>takes</code>我们也许希望在这个联系中用一个描述性属性<code>grade</code>,来记录学生在这门课中取得的成绩。我们同样可以用一个描述性的属性<code>for_credit</code>来记录学生在这门课中是选修还是旁听(或出席)的情况。</p><p>给定的联系集中的一个联系实例必须是由其参与实体唯一标识的,而不必使用描述属性。为了理解这一点,假设我们要对一个教师成为一个特定学生的导师的所有日期建模。单值的属性<code>dae</code>只能保存一个日期。我们不能通过同一个教师和学生之间的多个联系实例来表示多个日期,因为这些联系实例仅使用参与的实体是无法唯一标识的。正确的处理方法是创建一个多值属性<code>dae</code>,它可以保存所有的日期。</p><h2 id="二元联系集"><a href="#二元联系集" class="headerlink" title="二元联系集"></a>二元联系集</h2><p>联系集<code>advisor</code>和<code>dept_advisor</code>给出了二元( <code>binary</code>)联系集的例子,即涉及两个实体集的联系集。数据库系统中的大部分联系集都是二元的。然而,有时联系集会涉及多于两个实体集。<br>例如,假设我们有一个代表在大学内开展的所有研究项目的实体集<code>project</code>,考虑实体集<code>instrustor</code>、<code>student</code>和<code>project</code>每个项目可以有多个参与的学生和多个参与的教师。另外,每个参与项目的学生必须有一个教师指导他在项目中的工作。目前,我们忽略项目和教师以及项目和学生这两个关联,而关注哪个教师在一个特定项目上指导哪个学生。为了表达这个信息,我们<strong>通过关联<code>proj_ guide</code>将三个实体集联系到一起,它表示<code>某个学生</code>在<code>某个项目上</code>接收了<code>某个教师</code>的指导</strong>。<br>注意,一个学生可以在不同的项目中有不同的教师作为导师,不能将这个联系描述成学生与教师之间的二元关系。</p><h2 id="度"><a href="#度" class="headerlink" title="度"></a>度</h2><p>参与联系集的实体集的数目称为联系集的度( <code>degree</code>)。二元联系集的度为2;三元联系集的度为3。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第二部分 数据库设计 </category>
          
          <category> 第7章 数据库设计和E-R模型 </category>
          
          <category> 7.2 实体-联系模型 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>7.2 实体-联系模型 7.2.1 实体集</title>
      <link href="/ReadingNotes//9965d025/"/>
      <url>/ReadingNotes//9965d025/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/9965d025/#7-2-实体-联系模型" class="header_1">7.2 实体-联系模型</a>&nbsp;<br><a href="/ReadingNotes/9965d025/#7-2-1-实体集" class="header_1">7.2.1 实体集</a>&nbsp;<br><a href="/ReadingNotes/9965d025/#什么是实体" class="header_2">什么是实体</a>&nbsp;<br><a href="/ReadingNotes/9965d025/#什么是实体集" class="header_2">什么是实体集</a>&nbsp;<br><a href="/ReadingNotes/9965d025/#外延" class="header_2">外延</a>&nbsp;<br><a href="/ReadingNotes/9965d025/#属性" class="header_2">属性</a>&nbsp;<br><a href="/ReadingNotes/9965d025/#属性值" class="header_2">属性值</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="7-2-实体-联系模型"><a href="#7-2-实体-联系模型" class="headerlink" title="7.2 实体-联系模型"></a>7.2 实体-联系模型</h1><p>实体-联系(<code>entity-relationship,E-R</code>)数据模型的提出旨在方便数据库的设计,它是通过允许定义代表数据库全局逻辑结构的企业模式实现的。<br><code>E-R</code>模型在将现实世界<code>企业的含义和交互</code>映射到<code>概念模式</code>上非常有用,因此,许多数据库设计工具都利用了<code>E-R</code>模型的概念。<br><code>E-R</code>数据模型釆用了三个基本概念:<code>实体集</code>、<code>联系集</code>和<code>属性</code>,我们首先对此进行学习;<br><code>E-R</code>模型还有一个相关联的<code>图形表示</code>(<code>E-R</code>图),我们在本章后面学习。</p><h1 id="7-2-1-实体集"><a href="#7-2-1-实体集" class="headerlink" title="7.2.1 实体集"></a>7.2.1 实体集</h1><h2 id="什么是实体"><a href="#什么是实体" class="headerlink" title="什么是实体"></a>什么是实体</h2><p>实体(<code>entity</code>)是现实世界中可区别于所有其他对象的一个”事物”或”对象”。<br>例如,大学中的每个人都是一个实体。每个实体有一组性质,其中一些性质的值可以唯一地标识一个实体。例如,个人可能具有<code>person_id</code>性质唯一标识这个人。因此, <code>person_id</code>的值677-89-9011将唯一标识大学中个特定的人。<br>与此类似,课程也可以看作实体,而<code>course_id</code>唯一标识了大学中的某个课程实体。<br>实体可以是实实在在的,如人或书;也可以是<code>抽象的</code>,如课程、课程段开课或者机票预订。</p><h2 id="什么是实体集"><a href="#什么是实体集" class="headerlink" title="什么是实体集"></a>什么是实体集</h2><p>实体集(<code>entity set</code>)是相同类型即具有相同性质(或属性)的一个<code>实体集合</code>。例如,一所给定大学的<code>所有教师的集合</code>可定义为<code>实体集``instructor</code>。类似地,实体集<code>student</code>可以表示大学中<strong>所有学生的集合</strong>。</p><h2 id="外延"><a href="#外延" class="headerlink" title="外延"></a>外延</h2><p>在建模的过程中,我么通常抽象地使用术语实体集,而不是指某个个别实体的特别集合。我们用术语<strong>实体集的<code>外延</code></strong>(<code>extension</code>)来指<strong>属于实体集的实体的实际集合</strong>。因此,<strong>大学中实际教师的集合构成了实体集<code>instructor</code>的<code>外延</code></strong>。我们在第2章看到过的联系和联系实例之间的区别和上述区别类似。</p><p>实体集不必互不相交。例如,可以定义大学里所有人的实体集( <code>person</code>)。一个<code>person</code>实体可以是<code>instructor</code>实体,可以是<code>student</code>实体,可以既是<code>instructor</code>实体又是<code>student</code>实体,也可以都不是。</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>实体通过一组属性(<code>attribute</code>)来表示。<strong>属性是实体集中每个成员所拥有的描述性性质</strong>。为某实体集指定一个属性表明数据库为该实体集中每个实体存储相似的信息;但每个实体在每个属性上都有各自的值。</p><ul><li>实体集<code>instructor</code>可能具有属性<code>ID</code>、<code>name</code>、 <code>dept_name</code>、和<code>salary</code>。在现实生活中,可能还有更多的属性,如街道号、房间号、州、邮政编码和国家,但是为了使我们的例子简单,我们省略了这些属性。</li><li><code>course</code>实体集可能的属性有<code>course_id</code>、<code>tile</code>、 <code>dept_name</code>和<code>credits</code></li></ul><h2 id="属性值"><a href="#属性值" class="headerlink" title="属性值"></a>属性值</h2><p>每个实体的每个属性都有一个值( <code>value</code>)。<br>例如,一个特定的<code>instructor</code>实体可能<code>ID</code>的值为<code>12121</code>,<code>name</code>的值为<code>王小明</code>,<code>dept_name</code>的值为<code>金融</code>, <code>salary</code>的值为90000。</p><p><code>ID</code>属性用来唯一地标识教师,因为可能会有多个教师拥有相同的名字。在美国,许多企业发现将个人的<code>社会保障号</code>用作其值唯一标识该人的属性很方便。一般来说,大学必须给每个教师创建和分配一个唯一的标识符。</p><p>因此,数据库包括一组实体集,每个实体集包括任意数量的相同类型的实体。图7-1为一个大学数据库的一部分,其中有两个实体集: <code>instructor</code>和<code>student</code>。为了使图示简单,只显示了两个实体集的部分属性。<br><strong>一个大学数据库可能包含许多其他的实体集</strong>。例如,除了跟踪记录教师和学生外,大学还具有课程信息,用实体集<code>course</code>来表示,它包括属性<code>accoun_ number</code>、 <code>course id</code>、 <code>title</code>、 <code>dept_name</code>和<code>credits</code>。<strong>在真实环境中,一个大学数据库可能会包含<code>数十个</code>实体集</strong>。</p><!--SSTStop-->]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第二部分 数据库设计 </category>
          
          <category> 第7章 数据库设计和E-R模型 </category>
          
          <category> 7.2 实体-联系模型 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>7.1 设计过程概览</title>
      <link href="/ReadingNotes//69c614d4/"/>
      <url>/ReadingNotes//69c614d4/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/69c614d4/#7-1-设计过程概览" class="header_1">7.1 设计过程概览</a>&nbsp;<br><a href="/ReadingNotes/69c614d4/#7-1-1-设计阶段" class="header_1">7.1.1 设计阶段</a>&nbsp;<br><a href="/ReadingNotes/69c614d4/#改变物理模式相对简单" class="header_2">改变物理模式相对简单</a>&nbsp;<br><a href="/ReadingNotes/69c614d4/#改变逻辑模式比较困难" class="header_2">改变逻辑模式比较困难</a>&nbsp;<br><a href="/ReadingNotes/69c614d4/#小结" class="header_2">小结</a>&nbsp;<br><a href="/ReadingNotes/69c614d4/#7-1-2-设计选择" class="header_1">7.1.2 设计选择</a>&nbsp;<br><a href="/ReadingNotes/69c614d4/#要避免的数据库模式缺陷" class="header_2">要避免的数据库模式缺陷</a>&nbsp;<br><a href="/ReadingNotes/69c614d4/#1-冗余" class="header_3">1 冗余</a>&nbsp;<br><a href="/ReadingNotes/69c614d4/#2-不完整" class="header_3">2 不完整</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="7-1-设计过程概览"><a href="#7-1-设计过程概览" class="headerlink" title="7.1 设计过程概览"></a>7.1 设计过程概览</h1><p>构建一个数据库应用是一个复杂的任务,包括</p><ul><li><strong>设计数据库模式</strong>,</li><li><strong>设计访问和更新数据的程序</strong>,</li><li>以及<strong>设计控制数据访问的安全模式</strong>。</li></ul><p>用户的需求在设计过程中扮演一个中心角色。本章主要关注于数据库模式的设计,不过本章后面会简要地概括其他几个设计任务。</p><h1 id="7-1-1-设计阶段"><a href="#7-1-1-设计阶段" class="headerlink" title="7.1.1 设计阶段"></a>7.1.1 设计阶段</h1><p>对于小型的应用,由一个理解应用需求的数据库设计者直接决定要构建的关系、关系的属性以及其上的约束,这样也许是可行的。但是,这种直接的设计过程在现实的应用中是困难的,由于现实的应用常常很复杂,通常没有一个人能够理解应用的所有数据需求。<br>数据库设计者必须与应用的用户进行交互以理解应用的需求,把它们以用户能够理解的高级别的形式表示出来,然后再将需求转化为较低级别的设计。<br>一个高层数据模型为数据库设计者提供了一个概念框架,在该框架中以系统的方式定义了数据库用户的数据需求,以及满足这些需求的数据库结构。</p><ul><li><strong>数据库设计的<code>最初阶段</code>需要完整地刻画未来数据库用户的数据需求</strong>。为完成这个任务,数据库设计者需要同应用领域的专家和用户进行深入的沟通。<strong>这一阶段的产品是用户需求规格说明</strong>。虽然存在图形方式的用户需求表示技术,但是在本章中,我们仅限于采用文字的方式来描述用户需求。</li><li>接下来,设计者<strong>选择数据模型</strong>,并采用所选数据模型的概念将这些需求转化为数据库的<strong>概念模式</strong>。<ul><li>在此<strong>概念设计</strong>(<code>conceptual-design</code>)阶段所产生的模式提供了一个对企业的详细综述。我们在本章中将研究的<strong><code>实体-联系模型</code>通常用于表示<code>概念设计</code></strong>。用实体-联系模型的术语来说,<strong>概念模式定义了数据库中表示的<code>实体</code>、<code>实体的属性</code>、<code>实体之间的联系</code>,以及<code>实体和联系上的约束</code></strong>。通常,<strong>概念设计阶段会导致实体-联系图的构建</strong>,它提供了对模式的图形化描述。设计者检查此模式以确保所有数据需求都满足,并且互相不冲突。还可以检查该设计以去除冗余的特征。<strong>在这个阶段关注的是描述<code>数据及其联系</code></strong>,而不是定义物理存储细节。</li></ul></li><li>完善的概念模式还指明企业的功能需求。在<strong>功能需求规格说明</strong>(<code>specification of functionalrequirement</code>)中,用户描述将在数据上进行的各类操作(或事务)。操作的例子包括修改或更新数据,搜索并取回特定数据,以及删除数据。在概念设计的这一阶段,设计者可以检查所设计的模式,以确保其满足功能需求。</li><li>从<strong>抽象数据模型</strong>到<strong>数据库实现</strong>的转换过程在最后两个设计阶段中进行。<ul><li>在<strong>逻辑设计阶段</strong>( <code>logical-design phase</code>)中,设计者将高层<code>概念模式</code>映射到将使用的数据库系统的实现<code>数据模型</code>上。实现数据模型通常是<code>关系数据模型</code>,<strong>该阶段通常包括将以<code>实体联系模型</code>定义的概念模式映射到<code>关系模式</code></strong>。</li><li>最后,设计者将所得到的系统特定的<strong>数据库模式</strong>使用到后续的<strong>物理设计阶段</strong>(<code>physical-design phase</code>)中。在该阶段,指明<strong>数据库的物理特征</strong>,这些特征包括<code>文件组织格式</code>和<code>索引结构的选择</code>,我们将在第10章和第11章讨论这些内容。</li></ul></li></ul><h2 id="改变物理模式相对简单"><a href="#改变物理模式相对简单" class="headerlink" title="改变物理模式相对简单"></a>改变物理模式相对简单</h2><p><strong>在应用建立之后,要改变数据库的<code>物理模式</code>相对地比较简单</strong>。</p><h2 id="改变逻辑模式比较困难"><a href="#改变逻辑模式比较困难" class="headerlink" title="改变逻辑模式比较困难"></a>改变逻辑模式比较困难</h2><p>但是,由于可能影响到应用程序代码中散布的大量的査询和更新操作,因此<strong>改变逻辑模式的任务执行起来常常更加困难</strong>。<br>因此,<strong>在建立后续的数据库应用之前,慎重实施数据库设计阶段是非常重要的</strong>。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li>概念设计阶段,得到E-R图</li><li>逻辑设计结果,根据E-R图得到关系模式</li><li>物理设计阶段,指定数据库的物理特征,如文件的组织格式,索引结构的选择</li></ol><h1 id="7-1-2-设计选择"><a href="#7-1-2-设计选择" class="headerlink" title="7.1.2 设计选择"></a>7.1.2 设计选择</h1><p>数据库设计过程的一个主要部分是决定如何在设计中表示各种类型的”事物”,比如人、地方、产品,诸如此类。<br><strong>我们使用实体(<code>eniy</code>)这个术语来指示所有可明确识别的个体</strong>。在一个大学数据库中,实体的例子将包括教师、学生、系、课程和开课°。这些各种各样的实体以多种方式互相<code>关联</code>,而所有这些方式都需要在数据库设计中反映出来。例如,一名学生在一次开课中选课,而一名教师在一次开课中授课,授课和选课就是实体间联系的实例。</p><h2 id="要避免的数据库模式缺陷"><a href="#要避免的数据库模式缺陷" class="headerlink" title="要避免的数据库模式缺陷"></a>要避免的数据库模式缺陷</h2><p>在设计一个数据库模式的时候,我们必须确保避免两个主要的缺陷。</p><h3 id="1-冗余"><a href="#1-冗余" class="headerlink" title="1 冗余"></a>1 冗余</h3><p>一个不好的设计可能会重复信息。例如,如果对于每一次开课我们都存储课程编号和课程名称,那么对于每一次开课我们就冗余地(即多次地、不必要地)存储了课程名称。对每次开课仅存储课程编号,并在一个课程实体中将课程名称和课程编号关联一次就足够了。</p><pre><code>- 冗余也可能出现在关系模式中。在目前我们所使用的大学的例子中,我们有一个开课信息的关系和一个课程信息的关系。假设换一个做法,我们只有一个关系,对一门课程的每一次开课我们将全部课程信息(课程编号、课程名、系名、学分)重复一次。很明显,关于课程的信息将冗余地存储。- 信息的这种冗余表达的最大问题是当对一条信息进行更新但没有将这条信息的所有拷贝都更新时,这条信息的拷贝会变得不一致。例如,拥有同一个课程编号的几次不同的开课可能会拥有不同的课程名称,于是会搞不清楚课程的正确名称是什么。理想的情况下,信息应该只出现在一个地方。</code></pre><h3 id="2-不完整"><a href="#2-不完整" class="headerlink" title="2 不完整"></a>2 不完整</h3><p>一个不好的设计可能会使得企事业机构的某些方面难于甚至无法建模。例如,假设在上述案例(1)中,我们只有对应于开课的实体,而没有对应于课程的实体。从关系的角度说,这就是假设我们有单个关系,对一门课程的每一次开课都重复存储课程的所有信息。那么一门新课程的信息将无法表示,除非开设了该课程。我们可能会尝试将开课信息设置为空值的方法来解决这个有问题的设计。这种绕开问题的措施不仅不吸引人,而且有可能由于主码约束而无法实行。</p><p><strong>仅仅避免不好的设计是不够的</strong>。可能存在大量好的设计,我们必须从中选择一个。作为一个简单的例子,考虑买了某产品的一个客户。该产品的销售是客户和产品之间的联系吗?还是销售本身是一个与客户和产品都相关的实体?这个选择,虽然简单,却可能对企业某些方面建模的好坏有很大的影响。考虑为一个现实企业中的大量实体和联系做类似这样的选择的需要,不难看出数据库设计是一个很有挑战性的问题。事实上我们将看到,它需要科学和”好的品味”的结合。</p><!--SSTStop-->]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第二部分 数据库设计 </category>
          
          <category> 第7章 数据库设计和E-R模型 </category>
          
          <category> 7.1 设计过程概览 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第7章 数据库设计和E-R模型 概述</title>
      <link href="/ReadingNotes//d272dc27/"/>
      <url>/ReadingNotes//d272dc27/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/d272dc27/#7-0-第7章-概述" class="header_1">7.0 第7章 概述</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="7-0-第7章-概述"><a href="#7-0-第7章-概述" class="headerlink" title="7.0 第7章 概述"></a>7.0 第7章 概述</h1><p>到现在为止,在本书中我们已经假想了一个给定的数据库模式并研究了如何表述<code>查询</code>和<code>更新</code>。<br>我们现在考虑究竟<strong>如何设计一个数据库模式</strong>。在本章中,我们关注于<strong>实体-联系(<code>E-R</code>)数据模型</strong>,它提供了一个找出在数据库中表示的实体以及实体间如何关联的方法。最终,<strong>数据库设计将会表示为一个关系数据库设计和一个与之关联的约束集合</strong>。<strong>本章讲述一个E-R设计如何转换成一个关系模式的集合以及如何在该设计中找到某些约束</strong>。然后,第8章详细考查一个关系模式的集合是否为个好的或不好的数据库设计,并研究使用更广的约束集合来构建好的设计的过程。这两章覆盖数据库设计的基本概念。</p><!--SSTStop-->]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第二部分 数据库设计 </category>
          
          <category> 第7章 数据库设计和E-R模型 </category>
          
          <category> 7.0 第7章 概述 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第二部分 数据库设计</title>
      <link href="/ReadingNotes//9e671765/"/>
      <url>/ReadingNotes//9e671765/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/9e671765/#第二部分-数据库设计" class="header_1">第二部分 数据库设计</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="第二部分-数据库设计"><a href="#第二部分-数据库设计" class="headerlink" title="第二部分 数据库设计"></a>第二部分 数据库设计</h1><p><strong>设计数据库系统的目的</strong>是<strong>为了管理大量信息</strong>。这些大量的信息并不是孤立存在的,而是某些企业业务的一部分。这些企业的终端产品可能是来自数据库中的信息;也可能是某些设备或服务,数据库则仅为其扮演一个支持者的角色。</p><ul><li>本部分的前两章关注于数据库模式的设计。<strong>第7章讲</strong>述的<strong>实体-联系模型</strong>(<code>E-R</code>)是一种高层数据模型,与把所有数据用表来表示的方法不同,它将称作实体的基本对象和这些对象之间的联系区分开来。<strong>该模型通常用作数据库模式设计的第一步</strong>。</li><li>先前的章节曾非正式地介绍了关系数据库设计——关系模式的设计。然而,还存在<strong>用于区分好的数据库设计和不好的数据库设计的基本原理。这些原理被形式化为若干”<code>范式</code>“</strong>,这些范式提供了在不一致的可能性和特定查询效率之间的不同权衡。<strong>第8章讲述关系模式的规范化设计</strong>。</li><li>设计一个完整的数据库应用环境,并满足被建模企业的需求,需要关注更广泛的问题很多这样的问题将在<strong>第9章</strong>讲述。该章首先介绍<strong>基于<code>Web</code>的应用程序接口的设计</strong>,然后描述如何利用多个抽象层次来构建大型应用。最后,给出了在应用程序级别和数据库级别的安全性的详细讨论。<!--SSTStop--></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第二部分 数据库设计 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>6.4 总结</title>
      <link href="/ReadingNotes//7b7c551d/"/>
      <url>/ReadingNotes//7b7c551d/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/7b7c551d/#6-3-域关系演算" class="header_1">6.3 域关系演算</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="6-3-域关系演算"><a href="#6-3-域关系演算" class="headerlink" title="6.3 域关系演算"></a>6.3 域关系演算</h1><ul><li><strong>关系代数</strong>(<code>relational algebra</code>)<strong>定义了一套在表上运算且输出结果也是表的代数运算</strong>。这些运算可以混合使用来得到表达所希望查询的表达式。关<strong>系代数定义了<code>关系查询语言</code>中使用的基本运算</strong>。</li><li>关系代数运算可以分为<ul><li>基本运算。</li><li>附加的运算,可以用基本运算表达。</li><li>扩展的运算,其中的一些扩展了关系代数的表达能力。</li></ul></li><li>关系代数是一种简洁的、<strong>形式化</strong>的语言,不适合于那些偶尔使用数据库系统的用户。因此,商用数据库系统采用有更多”语法修饰”的语言。从第3章到第5章我们讨论了最有影响力的语言——<code>SQL</code>它是基于关系代数的。</li><li><strong>元组关系演算</strong>( <code>tuple relational calculus</code>)和<strong>域关系演算</strong>(<code>domain relational calculus</code>)是<strong>非过程化语言</strong>,代表了<strong>关系查询语言</strong>所需的基本能力。基本关系代数是一种过程化语言,在能力上等价于被限制在安全表达式范围内的关系演算的这两种形式。</li><li><strong>关系演算</strong>是简洁的、形式化的语言,并不适合于那些偶尔使用数据库系统的用户。这两种形式化语言构成了两种更易使用的语言<code>QBE</code>和<code>Datalog</code>的基础,我们将在附录B中介绍它们。</li></ul><!--SSTStop-->]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第6章 形式化关系查询语言 </category>
          
          <category> 6.4 总结 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第6章 形式化关系查询语言</title>
      <link href="/ReadingNotes//613d089b/"/>
      <url>/ReadingNotes//613d089b/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/613d089b/#第6章-形式化关系查询语言" class="header_1">第6章 形式化关系查询语言</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="第6章-形式化关系查询语言"><a href="#第6章-形式化关系查询语言" class="headerlink" title="第6章 形式化关系查询语言"></a>第6章 形式化关系查询语言</h1><p>从第2章~第5章,我们介绍了关系模型,并详细讲述了<code>SQL</code>。在本章中我们将介绍<code>SQL</code>所基于的形式化模型,同时它也是其他关系查询语言的基础。<br>本章内容包括<strong>三种形式化语言</strong>。</p><ul><li>我们首先介绍<strong>关系代数</strong>,它为广泛应用的<code>SQL</code>查询语言打下了基础。</li><li>然后我们学习<strong>元组关系演算</strong>和<strong>域关系演算</strong>,它们都是基于<strong>数学逻辑</strong>的声明式查询语言。<!--SSTStop--></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第6章 形式化关系查询语言 </category>
          
          <category> 6.0 本章概述 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>6.1 关系代数</title>
      <link href="/ReadingNotes//e61ae316/"/>
      <url>/ReadingNotes//e61ae316/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/e61ae316/#6-1-关系代数" class="header_1">6.1 关系代数</a>&nbsp;<br><a href="/ReadingNotes/e61ae316/#6-1-1-基本运算" class="header_1">6.1.1 基本运算</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="6-1-关系代数"><a href="#6-1-关系代数" class="headerlink" title="6.1 关系代数"></a>6.1 关系代数</h1><p>关系代数是一种<code>过程化``查询</code>语言。它包括一个运算的集合,这些<strong>运算以一个或两个关系为输入,产生一个新的关系作为结果</strong>。<br>关系代数基本运算有:<code>选择</code>、<code>投影</code>、<code>并</code>、<code>集合差</code>、<code>笛卡儿积</code>和<code>更名</code>。<br>在基本运算以外,还有一些其他运算,即<code>集合交</code>、<code>自然连接</code>和<code>赋值</code>。我们将用基本运算来定义这些运算。</p><h1 id="6-1-1-基本运算"><a href="#6-1-1-基本运算" class="headerlink" title="6.1.1 基本运算"></a>6.1.1 基本运算</h1><p>省略,后面有空再更新…<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第6章 形式化关系查询语言 </category>
          
          <category> 6.1 关系代数 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5.6 联机分析处理OLAP</title>
      <link href="/ReadingNotes//cb831521/"/>
      <url>/ReadingNotes//cb831521/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/cb831521/#5-6-联机分析处理OLAP" class="header_1">5.6 联机分析处理OLAP</a>&nbsp;<br><a href="/ReadingNotes/cb831521/#5-6-1-联机分析处理" class="header_1">5.6.1 联机分析处理</a>&nbsp;<br><a href="/ReadingNotes/cb831521/#5-6-2-交叉表与关系表" class="header_1">5.6.2 交叉表与关系表</a>&nbsp;<br><a href="/ReadingNotes/cb831521/#-OLAP-的实现" class="header_1">`OLAP`的实现</a>&nbsp;<br><a href="/ReadingNotes/cb831521/#5-6-3-SQL中的OLAP" class="header_1">5.6.3 SQL中的OLAP</a>&nbsp;<br><a href="/ReadingNotes/cb831521/#-DECODE-函数" class="header_1">`DECODE`函数</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="5-6-联机分析处理OLAP"><a href="#5-6-联机分析处理OLAP" class="headerlink" title="5.6 联机分析处理OLAP"></a>5.6 联机分析处理OLAP</h1><h1 id="5-6-1-联机分析处理"><a href="#5-6-1-联机分析处理" class="headerlink" title="5.6.1 联机分析处理"></a>5.6.1 联机分析处理</h1><h1 id="5-6-2-交叉表与关系表"><a href="#5-6-2-交叉表与关系表" class="headerlink" title="5.6.2 交叉表与关系表"></a>5.6.2 交叉表与关系表</h1><h1 id="OLAP的实现"><a href="#OLAP的实现" class="headerlink" title="OLAP的实现"></a><code>OLAP</code>的实现</h1><h1 id="5-6-3-SQL中的OLAP"><a href="#5-6-3-SQL中的OLAP" class="headerlink" title="5.6.3 SQL中的OLAP"></a>5.6.3 SQL中的OLAP</h1><h1 id="DECODE函数"><a href="#DECODE函数" class="headerlink" title="DECODE函数"></a><code>DECODE</code>函数</h1>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第5章 高级SQL </category>
          
          <category> 5.6 联机分析处理OLAP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5.7 总结</title>
      <link href="/ReadingNotes//1ec4e9fd/"/>
      <url>/ReadingNotes//1ec4e9fd/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/1ec4e9fd/#5-7-总结" class="header_1">5.7 总结</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="5-7-总结"><a href="#5-7-总结" class="headerlink" title="5.7 总结"></a>5.7 总结</h1><ul><li><code>SQL</code>查询可以从宿主语言通过<strong>嵌入</strong>和<strong>动态</strong><code>SQL</code>激发。<code>ODBC</code>和<code>JDBC</code>标准给C、<code>Java</code>等语言的应用程序定义接入<code>SQL</code>数据库的应用程序接口。程序员越来越多地通过这些<code>API</code>来访问数据库。</li><li><strong>函数</strong>和<strong>过程</strong>可以用<code>SQL</code>提供的过程扩展来定义,它允许迭代和条件( <code>if-then-else</code>)语句。</li><li><strong>触发器</strong>定义了<strong>当某个事件发生而且满足相应条件时自动执行的动作</strong>。触发器有很多用处,例如实现业务规则、审计日志,甚至执行数据库系统外的操作。虽然触发器只是在不久前作为<code>SQL:1999</code>的一部分加入<code>SQL</code>标准的,但是大多数数据库系统已经支持触发器很久了。</li><li>一些查询,如传递闭包,或者可以用迭代表示,或者可以用递归<code>SQL</code>查询表示。递归可以用递归视图,或者用递归的<code>with</code>子句定义。</li><li><code>SQL</code>支持一些高级的聚集特性,包括排名和分窗査询,这些特性简化了一些聚集操作的表达方式并提供了更高效的求值方法。</li><li>联机分析处理(<code>OLAP</code>)工具帮助分析人员用不同的方式查看汇总数据,使他们能够洞察一个组织的运行。<ol><li><code>OLAP</code>工具工作在以维属性和度量属性为特性的多维数据之上。</li><li><strong>数据立方体</strong>由以不同方式汇总的多维数据构成。预先计算数据立方体有助于提高汇总数据的查询速度。</li><li>交叉表的显示允许用户一次查看多维数据的两个维及其汇总数据。</li><li>下钻、上卷、切片和切块是用户使用<code>OLAP</code>工具时执行的一些操作。</li></ol></li><li>从<code>SQL</code>:1999标准开始,<code>SQL</code>提供了一系列的用于数据分析的操作符,其中包括<code>cube</code>和<code>rop</code>操作。有些系统还支持<code>pivot</code>子句,可以很方便地生成交叉表。<!--SSTStop--></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第5章 高级SQL </category>
          
          <category> 5.7 总结 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5.5 高级聚集特性</title>
      <link href="/ReadingNotes//32ce3a6/"/>
      <url>/ReadingNotes//32ce3a6/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/32ce3a6/#5-5-高级聚集特性" class="header_1">5.5 高级聚集特性</a>&nbsp;<br><a href="/ReadingNotes/32ce3a6/#5-5-1-排名" class="header_1">5.5.1 排名</a>&nbsp;<br><a href="/ReadingNotes/32ce3a6/#5-5-2-分窗" class="header_1">5.5.2 分窗</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="5-5-高级聚集特性"><a href="#5-5-高级聚集特性" class="headerlink" title="5.5 高级聚集特性"></a>5.5 高级聚集特性</h1><p>此前我们已经看到,<code>SQL</code>对聚集的支持是十分强大的,可以很便捷地完成一般性的任务。然而,<strong>有些任务很难用基本的聚集特性来高效实现</strong>。在本节中,我们将研究为完成这些任务而向<code>SQL</code>中引人的一些特性。</p><h1 id="5-5-1-排名"><a href="#5-5-1-排名" class="headerlink" title="5.5.1 排名"></a>5.5.1 排名</h1><p>从一个大的集合中找出某值的<code>位置</code>是一个常见的操作。<br>例如,我们可能希望基于学生的平均绩点(<code>GPA</code>)赋予他们在班级中的名次:<code>GPA</code>最高的学生排名第1,次高分学生排名第2,等等。</p><p>另一种相关的查询类型是<strong>找某个值在一个(允许重复值的)集合中所处的<code>百分点</code></strong>,比如排在后<code>1/3</code>、中间<code>1/3</code>或是前<code>1/3</code>。虽然这样的查询可用构造<code>SQL</code>语句来完成,但表达困难且计算效率低。编程人员通常借助于<strong>将部分代码写在<code>SQL</code>中,另一部分代码写在程序设计语言中的方式去实现</strong>它。</p><p>我们在这里讨论<code>SQL</code>中如何对这类查询进行直接表达。</p><p>在我们的大学例子中,关系<code>takes</code>存储了每个学生在所选的每一门课程上所获得的成绩。为了演示排名,我们假设有一个视图<code>student_grades(ID,GPA)</code>,它给出了每个学生的平均绩点。<br>排名是用<code>order by</code>说明来实现的。下面的查询给出了每个学生的名次。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">ID</span>, <span class="keyword">rank</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span>(GPA) dese ) <span class="keyword">as</span> s_rank</span><br><span class="line"><span class="keyword">from</span> student_grades;</span><br></pre></td></tr></table></figure><br>注意这里没有定义输出中的元组顺序,所以元组可能不按名次排序。需要<strong>使用一个附加的<code>order by</code>子句得到排序的元组</strong>,如下所示:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">ID</span>,<span class="keyword">rank</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span>( GPA) <span class="keyword">desc</span>) <span class="keyword">as</span> s_rank</span><br><span class="line"><span class="keyword">from</span> student_grades</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> s_rank;</span><br></pre></td></tr></table></figure><br>省略后面再过来看.</p><h1 id="5-5-2-分窗"><a href="#5-5-2-分窗" class="headerlink" title="5.5.2 分窗"></a>5.5.2 分窗</h1><p>省略.</p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第5章 高级SQL </category>
          
          <category> 5.5 高级聚集特性 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5.4 递归查询</title>
      <link href="/ReadingNotes//7e860377/"/>
      <url>/ReadingNotes//7e860377/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/7e860377/#5-4-递归查询" class="header_1">5.4 递归查询</a>&nbsp;<br><a href="/ReadingNotes/7e860377/#5-4-1-用迭代来计算传递闭包" class="header_1">5.4.1 用迭代来计算传递闭包</a>&nbsp;<br><a href="/ReadingNotes/7e860377/#5-4-2-SQL中的递归" class="header_1">5.4.2 SQL中的递归</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="5-4-递归查询"><a href="#5-4-递归查询" class="headerlink" title="5.4 递归查询"></a>5.4 递归查询</h1><p>有空再看</p><h1 id="5-4-1-用迭代来计算传递闭包"><a href="#5-4-1-用迭代来计算传递闭包" class="headerlink" title="5.4.1 用迭代来计算传递闭包"></a>5.4.1 用迭代来计算传递闭包</h1><p>有空再看</p><h1 id="5-4-2-SQL中的递归"><a href="#5-4-2-SQL中的递归" class="headerlink" title="5.4.2 SQL中的递归"></a>5.4.2 SQL中的递归</h1><p>有空再看</p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第5章 高级SQL </category>
          
          <category> 5.4 递归查询 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5.3.3 何时不用触发器</title>
      <link href="/ReadingNotes//7e5aa449/"/>
      <url>/ReadingNotes//7e5aa449/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/7e5aa449/#5-3-3-何时不用触发器" class="header_1">5.3.3 何时不用触发器</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="5-3-3-何时不用触发器"><a href="#5-3-3-何时不用触发器" class="headerlink" title="5.3.3 何时不用触发器"></a>5.3.3 何时不用触发器</h1><p>触发器有很多合适的用途,例如我们刚刚在5.3.2节中看到的那些,然而有<strong>一些场合最好用别的技术来处理</strong>。比如,我们<strong>可以用触发器替代级联特性来实现外码约束的<code>on delete cascade</code>特性</strong>。然而这样不仅需要完成更大的工作量,而且使数据库中实现的约束集合对于数据库用户来说更加难以理解。</p><p>举另外一个例子,<strong>可以用触发器来维护物化视图</strong>。例如,如果我们希望能够<strong>快速得到每节课所注册的学生总数</strong>,我们可以创建一个<strong>关系</strong>来实现这个功能:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">section_registration( course_id, sec_id, semester, year, total_students);</span><br></pre></td></tr></table></figure><br>它由以下查询所定义:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> course_id, sec_id, semester, <span class="keyword">year</span>, <span class="keyword">count</span>(<span class="keyword">ID</span>) <span class="keyword">as</span> total_students</span><br><span class="line"><span class="keyword">from</span> takes</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> course_id, sec_id, semester, <span class="keyword">year</span>;</span><br></pre></td></tr></table></figure><br>在对关系<code>takes</code>进行<code>插入</code>、<code>删除</code>或<code>更新</code>时,每门课的<code>total_students</code>的值必须由触发器来维护到最新状态。维护时可能要对<code>section_regustration</code>做<code>插入</code>、<code>更新</code>或<code>删除</code>,这些都相应地写在触发器里。<br>然而,许多数据库现在支持物化视图,由数据库系统自动维护(见4.2.3节)。因此<strong>没必要编写代码让触发器来维护这样的物化视图</strong>。</p><p><strong>触发器也被用来复制或者备份数据库</strong>;在每一个关系的插入、删除或更新的操作上创建触发器,将改变记录在称为<code>change</code>或<code>deta</code>的关系上。一个单独的进程将这些改变复制到数据库的副本。然而,<strong>现代的数据库系统提供内置的数据库复制工具,使得复制在大多数情况下不必使用触发器</strong>。本书将在第19章详细讨论复制数据库。<br>触发器的另一个问题是当数据从一个备份的拷贝中加载,或者一个站点上的数据库更新复制到备份站点的时候,触发器动作的非故意执行。在该情况下,触发器动作已经执行了,通常不应该再次执行。<strong>在加载数据的时候,触发器应当显式设为无效</strong>。<strong>对于要接管主系统的备份复制系统,触发器应该一开始就设为无效,而在备份站点接管了主系统的业务后,再设为有效</strong>。作为取代的方法,<strong>一些数据库系统允许触发器定义为<code>not for replication</code>,保证触发器不会在数据库备份的时候在备份站点执行</strong>。另一些数据库系统提供了一个系统变量用于指明该数据库是一个副本,数据库动作在其上是重放;触发器会检查这个变量,如果为真则退出执行。这<strong>两种解决方案都不需要显式地将触发器设为失效或有效</strong>。<br>写触发器时,应特别小心,这是因为在运行期间一个触发器错误会导致引发该触发器的动作语句失败。而且,<strong>一个触发器的动作可以引发另一个触发器</strong>。<strong>在最坏的情况下,这甚至会导致一个无限的触发链</strong>。例如,假设在一个关系上的插入触发器里有一个动作引起在同一关系上的另一个(新的)插人,该新插入动作也会引起另一个新插人,如此无穷循环下去。有些数据库系统会限制这种触发器链的长度(例如16或32),把超过此长度的触发器链看作是一个错误。另一些系统把引用特定关系的触发器标记为错误,对该关系的修改导致了位于链首的触发器被执行。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第5章 高级SQL </category>
          
          <category> 5.3 触发器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5.3.2 SQL中的触发器</title>
      <link href="/ReadingNotes//d6c8406d/"/>
      <url>/ReadingNotes//d6c8406d/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/d6c8406d/#5-3-2-SQL中的触发器" class="header_1">5.3.2 SQL中的触发器</a>&nbsp;<br><a href="/ReadingNotes/d6c8406d/#非标准的触发器语法" class="header_1">非标准的触发器语法</a>&nbsp;<br><a href="/ReadingNotes/d6c8406d/#使触发器无效" class="header_1">使触发器无效</a>&nbsp;<br><a href="/ReadingNotes/d6c8406d/#删除触发器" class="header_1">删除触发器</a>&nbsp;<br><a href="/ReadingNotes/d6c8406d/#参考资料" class="header_1">参考资料</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="5-3-2-SQL中的触发器"><a href="#5-3-2-SQL中的触发器" class="headerlink" title="5.3.2 SQL中的触发器"></a>5.3.2 SQL中的触发器</h1><p>现在我们来看如何在<code>SQL</code>中实现触发器。我们在这里介绍的是<code>SQL</code>标准定义的语法,但是大部分数据库实现的是非标准版本的语法。尽管这里所述的语法可能不被这些系统支持,但是我们阐述的概念对于不同的实现方法都是适用的。我们将在本章末尾讨论非标准的触发器实现。<br>图5-8展示了如何使用触发器来确保关系<code>section</code>中属性<code>time_sotd</code>的参照完整性。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 在插入时启动触发器</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> timeslot_check <span class="keyword">after</span> <span class="keyword">insert</span> <span class="keyword">on</span> <span class="keyword">section</span></span><br><span class="line">    <span class="comment">-- 过渡变量：插入完成后存储所插入行的值</span></span><br><span class="line">    <span class="keyword">referencing</span> <span class="keyword">new</span> <span class="keyword">row</span> <span class="keyword">as</span> nrow</span><br><span class="line">    <span class="comment">-- 对每一个插入行迭代</span></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span> </span><br><span class="line">    <span class="comment">-- time_slot_id不存在该id</span></span><br><span class="line">    <span class="keyword">when</span> (nrow.time_slot_id <span class="keyword">not</span> <span class="keyword">in</span> </span><br><span class="line">            (<span class="keyword">select</span> time_slot_id <span class="keyword">from</span> time_slot))</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">rollback</span></span><br><span class="line">    <span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></p><p>图中第一个触发器的定义指明该触发器在任何一次对关系<code>section</code>的插入操作执行之后被启动,以确保所插入元组的<code>time slot id</code>字段是合法的。一个<code>SQL</code>插人语句可以向关系中插入多个元组,在触发器代码中的<code>foreach row</code>语句可以显式地在每一个被插入的行上进行迭代。 <code>referencing new row as</code>语句建立了一个变量<code>mo</code>(称为过渡变量<code>transition variable</code>),用来在插入完成后存储所插入行的值。<br>这里省略大部分,有空再补上.</p><h1 id="非标准的触发器语法"><a href="#非标准的触发器语法" class="headerlink" title="非标准的触发器语法"></a>非标准的触发器语法</h1><h1 id="使触发器无效"><a href="#使触发器无效" class="headerlink" title="使触发器无效"></a>使触发器无效</h1><p>触发器可以设为有效或者无效:默认情况下它们在创建时是有效的,但是可以通过使用<code>alter trigger trigger_name disable</code>(某些数据库使用另一种语法,比如<code>disable trigger trigger_name</code>)将其设为无效。<br>设为无效的触发器可以重新设为有效。</p><h1 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h1><p>通过使用命令<code>drop trigger trigger_name</code>,触发器也可以被丢弃,即将其永久移除。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/Reese1995/article/details/77656173" target="_blank" rel="noopener">《数据库系统概念（第六版）》读书笔记——第6章：高级SQL</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第5章 高级SQL </category>
          
          <category> 5.3 触发器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5.3 触发器 5.3.1 对触发器的需求</title>
      <link href="/ReadingNotes//f7b4974f/"/>
      <url>/ReadingNotes//f7b4974f/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/f7b4974f/#5-3-触发器" class="header_1">5.3 触发器</a>&nbsp;<br><a href="/ReadingNotes/f7b4974f/#5-3-1-对触发器的需求" class="header_1">5.3.1 对触发器的需求</a>&nbsp;<br><a href="/ReadingNotes/f7b4974f/#实现完整性约束" class="header_2">实现完整性约束</a>&nbsp;<br><a href="/ReadingNotes/f7b4974f/#自动执行任务" class="header_2">自动执行任务</a>&nbsp;<br><a href="/ReadingNotes/f7b4974f/#自动计算总学分" class="header_3">自动计算总学分</a>&nbsp;<br><a href="/ReadingNotes/f7b4974f/#自动库存补充" class="header_3">自动库存补充</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="5-3-触发器"><a href="#5-3-触发器" class="headerlink" title="5.3 触发器"></a>5.3 触发器</h1><p>触发器( <code>trigger</code>)是一条语句,<strong>当对数据库作修改时,它<code>自动</code>被系统执行</strong>。要设置触发器机制,必须满足两个要求:</p><ol><li>指明什么条件下执行触发器。它被分解为一个引起触发器被检测的<code>事件</code>和一个触发器执行必须满足的<code>条件</code>。</li><li>指明触发器执行时的动作。</li></ol><p>一旦我们把一个触发器输入数据库,只要指定的事件发生,相应的条件满足,数据库系统就有责任去执行它。</p><h1 id="5-3-1-对触发器的需求"><a href="#5-3-1-对触发器的需求" class="headerlink" title="5.3.1 对触发器的需求"></a>5.3.1 对触发器的需求</h1><h2 id="实现完整性约束"><a href="#实现完整性约束" class="headerlink" title="实现完整性约束"></a>实现完整性约束</h2><p>触发器可以<strong>用来实现未被<code>SQL</code>约束机制指定的某些完整性约束</strong>。</p><h2 id="自动执行任务"><a href="#自动执行任务" class="headerlink" title="自动执行任务"></a>自动执行任务</h2><p>它还是一种非常有用的机制,用来<strong>当满足特定条件时对用户发警报或自动开始执行某项任务</strong>。</p><h3 id="自动计算总学分"><a href="#自动计算总学分" class="headerlink" title="自动计算总学分"></a>自动计算总学分</h3><p>例如,我们可以设计一个触发器,只要有元组被插入<code>takes</code>关系中,就更新<code>student</code>关系中选课的学生所对应的元组,把该课的学分加入这个学生的总学分中。</p><h3 id="自动库存补充"><a href="#自动库存补充" class="headerlink" title="自动库存补充"></a>自动库存补充</h3><p>作为另一个应用触发器的例子,假设一个仓库希望每种物品的库存保持一个最小量;当某种物品的库存少于最小值的时候,自动发出一个订货单。在更新某种物品的库存的时候,触发器会比较这种物品的当前库存和它的最小库存,如果库存数量等于或小于最小值,就会生成一个新的订单。</p><p>注意,<strong>触发器系统通常不能执行数据库以外的更新</strong>,因此,在上面的<code>库存补充</code>的例子中,我们不能用一个触发器去直接在外部世界下订单,而是在存放订单的关系中添加一个关系记录。我们必须另外创建一个持久运行的系统进程来周期性扫描该关系并订购产品。</p><p>某些数据库系统提供了内置的支持,可以使用上述方法从<code>SQL</code>查询和触发器中发送电子邮件。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第5章 高级SQL </category>
          
          <category> 5.3 触发器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5.2.3 外部语言过程</title>
      <link href="/ReadingNotes//dae426a0/"/>
      <url>/ReadingNotes//dae426a0/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/dae426a0/#5-2-3-外部语言过程" class="header_1">5.2.3 外部语言过程</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="5-2-3-外部语言过程"><a href="#5-2-3-外部语言过程" class="headerlink" title="5.2.3 外部语言过程"></a>5.2.3 外部语言过程</h1><p>不朗读文本内容<br><!--SSTStop--><br>尽管对<code>SQL</code>的过程化扩展非常有用,然而可惜的是这些并不被跨数据库的标准的方法所支持。即使是最基本的特性在不同数据库产品中都可能有不同的语法和语义。所以,程序员必须针对每个数据库产品学习一门新语言。还有另一种方案可以解决语言支持的问题,即在一种命令式程序设计语言中定义过程,然后从<code>SQL</code>查询和触发器的定义中来调用它。<br><code>SQL</code>允许我们用一种程序设计语言定义函数,比如<code>Java</code>、C#、C或C++。这种方式定义的函数会比<code>SQL</code>中定义的函数效率更高,无法在<code>SQL</code>中执行的计算可以由这些函数执行。</p><p>外部过程和函数确切的语法决定于所使用的特定数据库系统<br>此处省略一些东西<br>用程序设计语言定义并在数据库系统之外编译的函数可以由数据库系统代码来加载和执行。不过这么做<strong>存在危险</strong>,那就是程序中的错误可能破坏数据库内部的结构,并且绕过数据库系统的访问-控制功能。<strong>如果数据库系统关心执行的效率胜过安全性则可以采用这种方式执行过程</strong>。<br>关心安全性的数据库系统一般会将这些代码作为一个单独进程的一部分来执行,通过进程间通信,传入参数的值,取回结果。然而,<strong>进程间通信的时间代价相当高</strong>;在典型的<code>CPU</code>体系结构中,一个进程通信所需的时间可以执行数万到数十万条指令。<br>如果代码用<code>Java</code>或C#这种”安全”的语言书写,则会有第三种可能:在数据库进程本身的沙盒( <code>sandbox</code>)内执行代码。沙盒允许<code>Java</code>或C#代码访问它的内存区域,但阻止代码直接在查询执行过程的内存中做任何读操作或者更新操作,或者访问文件系统中的文件。(在如C这种语言中创建一个沙盒是不可能的,因为C语言允许通过指针不加限制地访问内存。)避免进程间通信能够大大降低函数调用的时间代价。<br>当今的一些数据库系统支持外部语言例程在查询执行过程中的沙盒里运行。例如, <code>Oracle</code>和<code>IBM DB2</code>允许<code>Java</code>函数作为数据库过程中的一部分运行。 <code>Microsoft SQL Server</code>允许过程编译成通用语言运行程序(<code>CLR</code>)来在数据库过程中执行;这样的过程可以用C#或<code>Visual Basic</code>编写。 <code>PostgreSQL</code>允许在<code>Perl</code>、 <code>Python</code>和<code>Tcl</code>等多种语言中定义函数。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第5章 高级SQL </category>
          
          <category> 5.2 函数和过程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5.2.2 支持过程和函数的语言构造</title>
      <link href="/ReadingNotes//41fc986/"/>
      <url>/ReadingNotes//41fc986/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/41fc986/#5-2-2-支持过程和函数的语言构造" class="header_1">5.2.2 支持过程和函数的语言构造</a>&nbsp;<br><a href="/ReadingNotes/41fc986/#变量的声明和赋值" class="header_2">变量的声明和赋值</a>&nbsp;<br><a href="/ReadingNotes/41fc986/#复合语句" class="header_2">复合语句</a>&nbsp;<br><a href="/ReadingNotes/41fc986/#复合语句作为单一的事务来执行" class="header_2">复合语句作为单一的事务来执行</a>&nbsp;<br><a href="/ReadingNotes/41fc986/#while循环和repeat循环" class="header_2">while循环和repeat循环</a>&nbsp;<br><a href="/ReadingNotes/41fc986/#退出循环" class="header_3">退出循环</a>&nbsp;<br><a href="/ReadingNotes/41fc986/#跳过当前循环进入下一次循环" class="header_3">跳过当前循环进入下一次循环</a>&nbsp;<br><a href="/ReadingNotes/41fc986/#条件语句" class="header_2">条件语句</a>&nbsp;<br><a href="/ReadingNotes/41fc986/#-if-then-else-语句" class="header_3">`if-then-else`语句</a>&nbsp;<br><a href="/ReadingNotes/41fc986/#-case-语句" class="header_3">`case`语句</a>&nbsp;<br><a href="/ReadingNotes/41fc986/#信号" class="header_2">信号</a>&nbsp;<br><a href="/ReadingNotes/41fc986/#过程和函数的非标准语法" class="header_1">过程和函数的非标准语法</a>&nbsp;<br><a href="/ReadingNotes/41fc986/#参考链接" class="header_1">参考链接</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="5-2-2-支持过程和函数的语言构造"><a href="#5-2-2-支持过程和函数的语言构造" class="headerlink" title="5.2.2 支持过程和函数的语言构造"></a>5.2.2 支持过程和函数的语言构造</h1><p><code>SQL</code>所支持的构造赋予了它与通用程序设计语言相当的几乎所有的功能。<code>SQL</code>标准中处理这些构造的部分称为持久存储模块( <code>Persistent Storage Module,PSM</code>)。</p><h2 id="变量的声明和赋值"><a href="#变量的声明和赋值" class="headerlink" title="变量的声明和赋值"></a>变量的声明和赋值</h2><p>变量通过<code>declare</code>语句进行声明,可以是任意的合法<code>SQL</code>类型。<br>使用<code>set</code>语句进行赋值。</p><h2 id="复合语句"><a href="#复合语句" class="headerlink" title="复合语句"></a>复合语句</h2><p>一个复合语句有<code>begin…end</code>的形式,在<code>begin</code>和<code>end</code>之间会包含复杂的<code>SQL</code>语句。如我们在5.2.1节中曾看到的那样,可以在复合语句中声明局部变量。</p><h2 id="复合语句作为单一的事务来执行"><a href="#复合语句作为单一的事务来执行" class="headerlink" title="复合语句作为单一的事务来执行"></a>复合语句作为单一的事务来执行</h2><p>一个形如<code>begin atomic … end</code>的可以确保复合语句中包含的所有语句作为单一的事务来执行。</p><h2 id="while循环和repeat循环"><a href="#while循环和repeat循环" class="headerlink" title="while循环和repeat循环"></a>while循环和repeat循环</h2><p><code>SQL:1999</code>支持<code>while</code>语句和<code>repeat</code>语句,语法如下:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while 布尔表达式 <span class="keyword">do</span></span><br><span class="line">    语句序列;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">while</span>;</span><br></pre></td></tr></table></figure><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">repeat </span><br><span class="line">    语句序列;</span><br><span class="line">until 布尔表达式</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">repeat</span>;</span><br></pre></td></tr></table></figure><br>还有<code>for</code>循环,它允许对查询的所有结果重复执行:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> n <span class="built_in">integer</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">for r as</span><br><span class="line">    <span class="keyword">select</span> budget <span class="keyword">from</span> department</span><br><span class="line">        <span class="keyword">where</span> dept_name=<span class="string">'Music'</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">set</span> n=n-r.budget</span><br><span class="line"> <span class="keyword">end</span> <span class="keyword">for</span>;</span><br></pre></td></tr></table></figure><br>程序每次获取查询结果的一行,并存入<code>for</code>循环变量(在上面例子中指<code>r</code>)中。</p><h3 id="退出循环"><a href="#退出循环" class="headerlink" title="退出循环"></a>退出循环</h3><p>语句<code>leave</code>可用来退出循环,</p><h3 id="跳过当前循环进入下一次循环"><a href="#跳过当前循环进入下一次循环" class="headerlink" title="跳过当前循环进入下一次循环"></a>跳过当前循环进入下一次循环</h3><p>而<code>iterate</code>表示跳过剩余语句从循环的开始进入下一个元组。</p><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><h3 id="if-then-else语句"><a href="#if-then-else语句" class="headerlink" title="if-then-else语句"></a><code>if-then-else</code>语句</h3><!--replace:elseif=else if--><p><code>SQL</code>支持的条件语句包括<code>if-then-else</code>语句,语法如下:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if 布尔表达式</span><br><span class="line">    then 语句或复合语句</span><br><span class="line">elseif 布尔表达式</span><br><span class="line">    then 语句或复合语句</span><br><span class="line">else 语句或复合语句</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span>;</span><br></pre></td></tr></table></figure></p><h3 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a><code>case</code>语句</h3><p><code>SQL</code>也支持<code>case</code>语句,类似于<code>C</code> <code>C++</code>语言中的<code>case</code>语句(加上我们在第3章看到的<code>cae</code>表达式)。</p><p>图5-7提供了一个有关<code>SQL</code>的过程化结构的更大型一点的例子。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 确认选课的学生数未超过该课所在教室的容量</span></span><br><span class="line"><span class="comment">-- 完成学生对该课的注册</span></span><br><span class="line"><span class="comment">-- 返回错误代码(&gt;=0成功,&lt;0失败)</span></span><br><span class="line"><span class="comment">-- 以out参数的形式返回失败原因</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> registerStudent(</span><br><span class="line">        <span class="keyword">in</span> s_id <span class="built_in">varchar</span>(<span class="number">5</span>),</span><br><span class="line">        <span class="keyword">in</span> s_courseid <span class="built_in">varchar</span>(<span class="number">8</span>),</span><br><span class="line">        <span class="keyword">in</span> s_secid <span class="built_in">varchar</span>(<span class="number">8</span>),</span><br><span class="line">        <span class="keyword">in</span> s_semester <span class="built_in">varchar</span>(<span class="number">6</span>),</span><br><span class="line">        <span class="keyword">in</span> s_year <span class="built_in">numeric</span>(<span class="number">4</span>, <span class="number">0</span>),</span><br><span class="line">        <span class="keyword">out</span> errorMsg <span class="built_in">varchar</span>(<span class="number">100</span>))</span><br><span class="line"><span class="keyword">returns</span> <span class="built_in">integer</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="comment">-- 选课的学生数</span></span><br><span class="line">    <span class="keyword">declare</span> currEnrol <span class="built_in">int</span>;</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">into</span> currEnrol</span><br><span class="line">    <span class="keyword">from</span> takes</span><br><span class="line">    <span class="keyword">where</span> courseid = s_courseid <span class="keyword">and</span></span><br><span class="line">          sec_id =s_secid <span class="keyword">and</span></span><br><span class="line">          semester = s_semester <span class="keyword">and</span></span><br><span class="line">          <span class="keyword">year</span> = s_year;</span><br><span class="line">    <span class="comment">-- 该课所在教室的容量</span></span><br><span class="line">    <span class="keyword">declare</span> <span class="keyword">limit</span> <span class="built_in">int</span>;</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">capacity</span> <span class="keyword">into</span> <span class="keyword">limit</span> </span><br><span class="line">    <span class="keyword">from</span> classroom <span class="keyword">natural</span> <span class="keyword">join</span> <span class="keyword">section</span></span><br><span class="line">    <span class="keyword">where</span> courseid = s_courseid <span class="keyword">and</span></span><br><span class="line">          sec_id = s_secid <span class="keyword">and</span></span><br><span class="line">          semester = s_semester <span class="keyword">and</span></span><br><span class="line">          <span class="keyword">year</span> = s_year;</span><br><span class="line">    if (currEnrol &lt; limit)</span><br><span class="line">        <span class="keyword">begin</span> </span><br><span class="line">            <span class="keyword">insert</span> <span class="keyword">into</span> takes <span class="keyword">values</span> </span><br><span class="line">        (s_id, s_courseid, s_secid, s_semester, s_year, <span class="literal">null</span>);</span><br><span class="line">            return (0);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- 否则,已经达到课程容量上线</span></span><br><span class="line">    <span class="keyword">set</span> errorMsg = <span class="string">'Enrollment limit reached for course'</span> ||</span><br><span class="line">        s_courseid || <span class="string">'section'</span> || s_secid;</span><br><span class="line">    return (-1);</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><br>图中定义的函数<code>registerStudent</code>首先确认选课的学生数没有超过该课所在教室的容量,然后完成学生对该课的注册。函数返回一个错误代码,这个值大于等于0表示成功,返回负值表示出错,同时以<code>out</code>参数的形式返回消息来说明失败的原因。</p><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p><code>SQL</code>程序语言还支持发信号通知异常条件(<code>exception condition</code>),以及声明句柄( <code>handler</code>)来处理异常,代码如下:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> out_of_classroom_ seats condition</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">exit</span> <span class="keyword">handler</span> <span class="keyword">for</span> out_of_classroom_seats</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">sequence</span> <span class="keyword">of</span> elements</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><br>在<code>begin</code>和<code>end</code>之间的语句可以执行<code>signal out_of_classroom_seats</code>来引发一个异常。这个句柄说明,如果条件发生,将会采取动作终止<code>begin end</code>中的语句。<br>另一个可选的动作将是<code>continue</code>,它继续从引发异常的语句的下一条语句开始执行。除了明确定义的条件,还有一些预定义的条件,比如<code>sqlexception</code>、 <code>sqlwarning</code>和<code>not found</code></p><h1 id="过程和函数的非标准语法"><a href="#过程和函数的非标准语法" class="headerlink" title="过程和函数的非标准语法"></a>过程和函数的非标准语法</h1><p>尽管<code>SQL</code>标准为过程和函数定义了语法,但是很多教据库并不严格遵照标准,在语法支持方面存在很多变化。这种情况的原因之一是<strong>这些数据库通常在语法标准制定之前就已经引入了对过程和函数的支持机制,然后一直沿用最初的语法</strong>。在这里把每个数据库所支持的语法罗列出来并不现实,更多信息请查看相关语言的参考资料。<br><!--SSTStop--></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/Reese1995/article/details/77656173" target="_blank" rel="noopener">https://blog.csdn.net/Reese1995/article/details/77656173</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第5章 高级SQL </category>
          
          <category> 5.2 函数和过程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统概念原书 第6版 图5-5 创建函数的SQL代码报错</title>
      <link href="/ReadingNotes//6b42b3d6/"/>
      <url>/ReadingNotes//6b42b3d6/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/6b42b3d6/#数据库系统概念原书-第6版-图5-5-创建函数的SQL代码报错" class="header_1">数据库系统概念原书 第6版 图5-5 创建函数的SQL代码报错</a>&nbsp;<br><a href="/ReadingNotes/6b42b3d6/#问题描述" class="header_2">问题描述</a>&nbsp;<br><a href="/ReadingNotes/6b42b3d6/#解决方案" class="header_2">解决方案</a>&nbsp;<br><a href="/ReadingNotes/6b42b3d6/#新问题" class="header_2">新问题</a>&nbsp;<br><a href="/ReadingNotes/6b42b3d6/#解决方案" class="header_2">解决方案</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="数据库系统概念原书-第6版-图5-5-创建函数的SQL代码报错"><a href="#数据库系统概念原书-第6版-图5-5-创建函数的SQL代码报错" class="headerlink" title="数据库系统概念原书 第6版 图5-5 创建函数的SQL代码报错"></a>数据库系统概念原书 第6版 图5-5 创建函数的SQL代码报错</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><strong>数据库系统概念原书 第6版 图5-5 SQL中定义的函数</strong>中定义存储过程的<code>SQL</code>代码如下.<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> dept_count(dept_name <span class="built_in">varchar</span>(<span class="number">20</span>))</span><br><span class="line"><span class="keyword">returns</span> <span class="built_in">integer</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> d_count <span class="built_in">integer</span>;</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">into</span> d_count</span><br><span class="line">        <span class="keyword">from</span> instructor</span><br><span class="line">        <span class="keyword">where</span> instructor.dept_name = dept_name</span><br><span class="line">    <span class="keyword">return</span> d_count;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><br>但是我在<code>MySQL 8.0</code>中运行上述命令,报错如下:<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1064</span> - You have an error <span class="keyword">in</span> your SQL syntax; check the manual that corresponds to your MySQL server version <span class="keyword">for</span> the right syntax to use near 'return d_count; end' <span class="built_in">at</span> line <span class="number">8</span></span><br></pre></td></tr></table></figure></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>这是因为<code>select</code>语句没有以分号结束,修改为如下即可:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> dept_count(dept_name <span class="built_in">varchar</span>(<span class="number">20</span>))</span><br><span class="line"><span class="keyword">returns</span> <span class="built_in">integer</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> d_count <span class="built_in">integer</span>;</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">into</span> d_count</span><br><span class="line">        <span class="keyword">from</span> instructor</span><br><span class="line">        <span class="keyword">where</span> instructor.dept_name = dept_name;</span><br><span class="line">    return d_count;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></p><h2 id="新问题"><a href="#新问题" class="headerlink" title="新问题"></a>新问题</h2><p>不过还是有错误:<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1418</span> - This function has none of DETERMINISTIC, NO SQL, or READS SQL DATA <span class="keyword">in</span> its declaration and binary logging is enabled (you *might* want to use the less safe log_bin_trust_function_creators variable)</span><br></pre></td></tr></table></figure></p><h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h2><p>执行下面的语句,然后再执行创建存储过程的语句即可.<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> log_bin_trust_function_creators = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">SET</span> GLOBAL log_bin_trust_function_creators = <span class="number">1</span>;</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0</span>.<span class="number">00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; create function dept_count(dept_name varchar(<span class="number">20</span>))</span><br><span class="line">returns integer</span><br><span class="line">begin</span><br><span class="line">    declare d_count integer;</span><br><span class="line">    select count(*) into d_count</span><br><span class="line">        from instructor</span><br><span class="line">        where instructor.dept_name = dept_name;</span><br><span class="line">    return d_count;</span><br><span class="line">end;</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0</span>.<span class="number">02</span> sec)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第5章 高级SQL </category>
          
          <category> 5.2 函数和过程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5.2 函数和过程</title>
      <link href="/ReadingNotes//2ddaa0b5/"/>
      <url>/ReadingNotes//2ddaa0b5/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/2ddaa0b5/#5-2-函数和过程" class="header_1">5.2 函数和过程</a>&nbsp;<br><a href="/ReadingNotes/2ddaa0b5/#使用函数和过程的好处" class="header_2">使用函数和过程的好处</a>&nbsp;<br><a href="/ReadingNotes/2ddaa0b5/#如何定义函数-过程-和方法" class="header_2">如何定义函数 过程 和方法</a>&nbsp;<br><a href="/ReadingNotes/2ddaa0b5/#不同的数据库实现的SQL语法可能不同" class="header_2">不同的数据库实现的SQL语法可能不同</a>&nbsp;<br><a href="/ReadingNotes/2ddaa0b5/#5-2-1-声明和调用SQL函数和过程" class="header_1">5.2.1 声明和调用SQL函数和过程</a>&nbsp;<br><a href="/ReadingNotes/2ddaa0b5/#表函数" class="header_2">表函数</a>&nbsp;<br><a href="/ReadingNotes/2ddaa0b5/#带参数的视图" class="header_2">带参数的视图</a>&nbsp;<br><a href="/ReadingNotes/2ddaa0b5/#过程" class="header_2">过程</a>&nbsp;<br><a href="/ReadingNotes/2ddaa0b5/#调用存储过程" class="header_2">调用存储过程</a>&nbsp;<br><a href="/ReadingNotes/2ddaa0b5/#存储过程和函数可"重载"" class="header_2">存储过程和函数可"重载"</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="5-2-函数和过程"><a href="#5-2-函数和过程" class="headerlink" title="5.2 函数和过程"></a>5.2 函数和过程</h1><p>我们已经介绍了<code>SQL</code>语言的几个内建函数。在本节中,我们将演示开发者如何来编写他们自己的函数和过程,把它们存储在数据库里并在<code>SQL</code>语句中调用。<br><strong>函数对于<code>特定的数据类型</code>比如图像和几何对象来说特别有用</strong>。例如,用在地图数据库中的一个线段数据类型可能有一个相关函数用于判断两个线段是否交叠,一个图像数据类型可能有一个相关函数用于比较两幅图的相似性。</p><h2 id="使用函数和过程的好处"><a href="#使用函数和过程的好处" class="headerlink" title="使用函数和过程的好处"></a>使用函数和过程的好处</h2><p><strong>函数和过程允许”业务逻辑”作为存储过程记录在数据库中,并在数据库内执行</strong>。<br>例如,大学里通常有许多规章制度,规定在一个学期里每个学生能选多少课,在一年里一个全职的教师至少要上多少节课,一个学生最多可以在多少个专业中注册,等等。尽管这样的业务逻辑能够被写成程序设计语言过程并完全存储在数据库以外,但把它们定义成数据库中的存储过程有几个优点。例如,它<strong>允许多个应用访问这些过程,允许当业务规则发生变化时进行单个点的改变,而不必改变应用系统的其他部分</strong>。<br>应用代码可以调用存储过程,而不是直接更新数据库关系</p><h2 id="如何定义函数-过程-和方法"><a href="#如何定义函数-过程-和方法" class="headerlink" title="如何定义函数 过程 和方法"></a>如何定义函数 过程 和方法</h2><p><code>SQL</code>允许定义函数、过程和方法。可以通过<code>SQL</code>的有关过程的组件来定义,也可以通过外部的程序设计语言来定义,例如<code>Java</code>、C或C++。我们首先查看<code>SQL</code>中的定义,然后在5.2.3节了解如何使用外部语言中的定义。</p><h2 id="不同的数据库实现的SQL语法可能不同"><a href="#不同的数据库实现的SQL语法可能不同" class="headerlink" title="不同的数据库实现的SQL语法可能不同"></a>不同的数据库实现的SQL语法可能不同</h2><p>我们在这里介绍的是<code>SQL</code>标准所定义的语法,然而大多数数据库都实现了它们自己的非标准版本的语法。例如<code>Oracle(PL/SQL)</code>、 <code>Microsoft SQL Sever(TransactSQL)</code>和<code>PostgreSQL(PL/ pgSQL)</code>所支持的过程语言都与我们在这里描述的标准语法有所差别。我们将在后面用<code>Oracle</code>来举例说明某些不同之处更进一步的详细信息可参见各自的系统手册。尽管我们介绍的部分语法在这些系统上并不支持,但是所阐述的概念在不同的实现上都是适用的,只是语法上有所区别。</p><h1 id="5-2-1-声明和调用SQL函数和过程"><a href="#5-2-1-声明和调用SQL函数和过程" class="headerlink" title="5.2.1 声明和调用SQL函数和过程"></a>5.2.1 声明和调用SQL函数和过程</h1><p>假定我们想要这样一个函数:给定一个系的名字,返回该系的教师数目。我们可以如下所示定义函数:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> dept_count(dept_name <span class="built_in">varchar</span>(<span class="number">20</span>))</span><br><span class="line"><span class="keyword">returns</span> <span class="built_in">integer</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> d_count <span class="built_in">integer</span>;</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">into</span> d_count</span><br><span class="line">        <span class="keyword">from</span> instructor</span><br><span class="line">        <span class="keyword">where</span> instructor.dept_name = dept_name;</span><br><span class="line">    return d_count;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><br>这个函数可以用在<strong>返回教师数大于12的所有系的名称和预算</strong>的查询中:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> dept_name,budget</span><br><span class="line">    <span class="keyword">from</span> department</span><br><span class="line">    <span class="keyword">where</span> dept_count(dept_name)&gt;<span class="number">12</span>;</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select dept_name,budget</span><br><span class="line">    from department</span><br><span class="line">    where dept_count(dept_name)&gt;<span class="number">12</span>;</span><br><span class="line">Empty <span class="built_in">set</span></span><br></pre></td></tr></table></figure></p><h2 id="表函数"><a href="#表函数" class="headerlink" title="表函数"></a>表函数</h2><p><code>SQL</code>标准支持<strong>返回关系作为结果的函数</strong>;这种函数称为<strong>表函数</strong>(<code>table functions</code>)。考虑图5-6中定义的函数:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> instructor_of(dept_name <span class="built_in">varchar</span>(<span class="number">20</span>))</span><br><span class="line">    <span class="keyword">returns</span> <span class="keyword">table</span>(</span><br><span class="line">        <span class="keyword">ID</span> <span class="built_in">varchar</span>(<span class="number">5</span>),</span><br><span class="line">        <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>),</span><br><span class="line">        dept_name <span class="built_in">varchar</span>(<span class="number">20</span>),</span><br><span class="line">        salary <span class="built_in">numeric</span>(<span class="number">8</span>,<span class="number">2</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">table</span>(</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">ID</span>,<span class="keyword">name</span>,dept_name,salary</span><br><span class="line">        <span class="keyword">from</span> instructor</span><br><span class="line">        <span class="keyword">where</span> instructor.dept_name=instructor_of.dept <span class="keyword">name</span>;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><br>该函数<strong>返回一个包含某特定系的所有教师的表</strong>。注意,<strong>使用函数的参数时需要加上函数名</strong>作为前缀( <code>instructor_of.dept_name</code>)。<br>这种函数可以如下在一个查询中使用:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">table</span>(instructor_of(<span class="string">'Finance'</span>));</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">经过的测试MySQL的函数好像不能返回表,也就是MySQL不支持**返回关系作为结果的函数**</span><br></pre></td></tr></table></figure></p><h2 id="带参数的视图"><a href="#带参数的视图" class="headerlink" title="带参数的视图"></a>带参数的视图</h2><p>这个査询返回’<code>金融</code>‘系的所有教师。在上面的简单情况下直接写这个查询而不用以表为值的函数也是很直观的。<br>但通常<strong>以表为值的函数可以被看作带参数的视图</strong>( <code>parameterized view</code>),它通过允许参数把视图的概念更加一般化</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p><code>SQL</code>也支持过程。 <code>dept_count</code>函数也可以写成一个过程:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span></span><br><span class="line">    dept_count_proc(<span class="keyword">in</span> dept_name <span class="built_in">varchar</span>(<span class="number">20</span>), <span class="keyword">out</span> d_count <span class="built_in">integer</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">into</span> d_count</span><br><span class="line">    <span class="keyword">where</span> instructor.dept_name=dept_count_proc.dept_name;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create procedure</span><br><span class="line">    dept_count_proc( <span class="keyword">in</span> dept_name varchar(<span class="number">20</span>), out d_count integer)</span><br><span class="line">begin</span><br><span class="line">    select count(*) into d_count</span><br><span class="line">    where instructor.dept_name=dept_count_proc.dept_name;</span><br><span class="line">end;</span><br><span class="line">Query OK, <span class="number">0</span> rows affected</span><br></pre></td></tr></table></figure><ul><li>关键字<code>in</code>表示待赋值的参数</li><li>关键字<code>out</code>为返回结果</li></ul><h2 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h2><p>可以从一个<code>SQL</code>过程中或者从嵌入式<code>SQL</code>中使用<code>call</code>语句调用过程:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> d_count <span class="built_in">integer</span>;</span><br><span class="line"><span class="keyword">call</span> dept_count_proc(<span class="string">'Physics'</span>, d_count);</span><br></pre></td></tr></table></figure><br>过程和函数可以通过动态<code>SQL</code>触发,如5.1.1.4节中<code>JDBC</code>语法所示.</p><h2 id="存储过程和函数可”重载”"><a href="#存储过程和函数可”重载”" class="headerlink" title="存储过程和函数可”重载”"></a>存储过程和函数可”重载”</h2><ul><li><strong><code>SQL</code>允许多个过程同名,只要同名过程的参数个数不同</strong>。名称和参数个数用于标识一个过程。</li><li><strong><code>SQL</code>也允许多个函数同名,只要这些同名的不同函数的参数个数不同</strong>,或者对于那些有相同参数个数的函数,至少有一个参数的类型不同。</li></ul><!--SSTStop-->]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第5章 高级SQL </category>
          
          <category> 5.2 函数和过程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5.1.3 嵌入式SQL</title>
      <link href="/ReadingNotes//29029c86/"/>
      <url>/ReadingNotes//29029c86/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/29029c86/#5-1-3-嵌入式SQL" class="header_1">5.1.3 嵌入式SQL</a>&nbsp;<br><a href="/ReadingNotes/29029c86/#宿主语言" class="header_2">宿主语言</a>&nbsp;<br><a href="/ReadingNotes/29029c86/#嵌入是-SQL" class="header_2">嵌入是`SQL`</a>&nbsp;<br><a href="/ReadingNotes/29029c86/#嵌入式-SQL-与-JDBC-或-ODBC-的主要区别" class="header_2">嵌入式`SQL`与`JDBC`或`ODBC`的主要区别</a>&nbsp;<br><a href="/ReadingNotes/29029c86/#-EXEC-SQL-语句" class="header_2">`EXEC SQL`语句</a>&nbsp;<br><a href="/ReadingNotes/29029c86/#嵌入式-SQL-语法依赖于宿主语言" class="header_2">嵌入式`SQL`语法依赖于宿主语言</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="5-1-3-嵌入式SQL"><a href="#5-1-3-嵌入式SQL" class="headerlink" title="5.1.3 嵌入式SQL"></a>5.1.3 嵌入式SQL</h1><p><code>SQL</code>标准定义了嵌入<code>SQL</code>到许多不同的语言中,例如C、C++、 <code>Cobol</code>、 <code>Pascal</code>、<code>Java</code>、<code>PL/I</code>和<code>Fortran</code>。</p><h2 id="宿主语言"><a href="#宿主语言" class="headerlink" title="宿主语言"></a>宿主语言</h2><p><code>SQL</code>查询所嵌入的语言被称为宿主语言,</p><h2 id="嵌入是SQL"><a href="#嵌入是SQL" class="headerlink" title="嵌入是SQL"></a>嵌入是<code>SQL</code></h2><p>宿主语言中使用的<code>SQL</code>结构被称为嵌入式<code>SQL</code>.</p><p>使用宿主语言写出的程序可以通过嵌入式<code>SQL</code>的语法访问和修改数据库中的数据。</p><h2 id="嵌入式SQL与JDBC或ODBC的主要区别"><a href="#嵌入式SQL与JDBC或ODBC的主要区别" class="headerlink" title="嵌入式SQL与JDBC或ODBC的主要区别"></a>嵌入式<code>SQL</code>与<code>JDBC</code>或<code>ODBC</code>的主要区别</h2><p>一个<strong>使用嵌入式<code>SQL</code>的程序在编译前必须先由一个特殊的预处理器进行处理</strong>。嵌入的<code>SQL</code>请求被宿主语言的声明以及允许运行时刻执行数据库访问的过程调用所代替。然后,所产生的程序<strong>由宿主语言编译器编译</strong>。这是嵌入式<code>SQL</code>与<code>JDBC</code>或<code>ODBC</code>的主要区别。</p><ul><li>在<code>JDBC</code>中,<code>SQL</code>语句是<strong>在运行时被解释的</strong>(即使是利用预备语句特性对其进行准备也是如此)</li><li>当使用嵌入式<code>SQL</code>时,一些<code>SQL</code>相关的错误(包括数据类型错误<strong>)可以在编译过程中被发现</strong>。</li></ul><h2 id="EXEC-SQL语句"><a href="#EXEC-SQL语句" class="headerlink" title="EXEC SQL语句"></a><code>EXEC SQL</code>语句</h2><p>为使预处理器识别嵌入式<code>SQL</code>请求,我们使用<code>EXEC SQL</code>语句,格式如下<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL&lt;嵌入式SQL语句&gt;;</span><br></pre></td></tr></table></figure></p><h2 id="嵌入式SQL语法依赖于宿主语言"><a href="#嵌入式SQL语法依赖于宿主语言" class="headerlink" title="嵌入式SQL语法依赖于宿主语言"></a>嵌入式<code>SQL</code>语法依赖于宿主语言</h2><p>嵌入式<code>SQL</code>的确切语法<strong>依赖于宿主语言</strong>。例如,当宿主语言是<code>Cobol</code>时,语句中的分号用<code>END-EXEC</code>来代替。</p><p>嵌入式SQL的相关的东西先省略,这里了解一下即可,后面用到再说.<br><!--SSTStop--><br>我们在应用程序中合适的地方插入<code>SQL INCLUDE SQLCA</code>语句,表示预处理器应该在此处插入特殊变量以用于程序和数据库系统间的通信。</p><p>在执行任何<code>SQL</code>语句之前,程序必须首先连接到数据库。这是用下面语句实现的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL connect to server user user-name using password;</span><br></pre></td></tr></table></figure><br>这里, <code>server</code>标识将要建立连接的服务器。<br>在嵌入的<code>SQL</code>语句中可以使用宿主语言的变量,不过前面要加上冒号(:)以区别于<code>SQL</code>变量。如此使用的变量必须声明在一个<code>DECLARE</code>区段里,见下面的代码。不过声明变量的语法还是因循宿主语言的惯例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL BEGIN DECLARE SECTION;</span><br><span class="line">int credit amount;</span><br><span class="line">EXEC SQL END DECLARE SECTION;</span><br></pre></td></tr></table></figure><br>嵌入式<code>SQL</code>语句的格式和本章描述的<code>SQL</code>语句类似。但这儿要指出几点重要的不同之处。<br>为了表示关系査询,我们使用<strong>声明游标</strong>(<code>declare cursor</code>)语句。然而这时并不计算查询的结果,而程序必须用<code>open</code>和<code>fetch</code>语句(本章后面将讨论)得到结果元组。接下来我们将看到,使用游标的方法与<code>JDBC</code>中对结果集的迭代处理是很相似的。<br>考虑我们使用的大学模式。假设我们有一个宿主变量<code>credit_amount</code>,声明方法如前所见,我们想找出学分高于<code>credit_amount</code>的所有学生的名字。我们可写出查询语句如下:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL <span class="keyword">declare</span> c <span class="keyword">cursor</span> <span class="keyword">for</span></span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">ID</span>,<span class="keyword">name</span></span><br><span class="line">    <span class="keyword">from</span> student</span><br><span class="line">    <span class="keyword">where</span> tot_cred &gt;:credit_amount;</span><br></pre></td></tr></table></figure><br>上述表达式中的变量<code>c</code>被称为该查询的游标(<code>cursor</code>)。我们使用这个变量来标识该查询,然后用<code>open</code>语句来执行查询。<br>我们的例子中的<code>open</code>语句如下:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL open c;</span><br></pre></td></tr></table></figure><br>这条语句使得数据库系统执行这条查询并把执行结果存于一个临时关系中。当<code>open</code>语句被执行的时候,宿主变量(<code>credit_amount</code>)的值就会被应用到查询中。<br>如果<code>SQL</code>查询出错,数据库系统将在<code>SQL</code>通信区域(<code>SQCA</code>)的变量中存储一个错误诊断信息。<br>然后我们利用一系列的<code>fetch</code>语句把结果元组的值赋给宿主语言的变量。 <code>fetch</code>语句要求结果关系的每一个属性有一个宿主变量相对应。在我们的查询例子中,需要一个变量存储I的值,另一个变量存储<code>name</code>的值。假设这两个变量分别是<code>si</code>和<code>sn</code>,并且都已经在<code>DECLARE</code>区段中被声明。那么以下语句:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL fetch c into:si,:sn;</span><br></pre></td></tr></table></figure><br>产生结果关系中的一个元组。接下来应用程序就可以利用宿主语言的特性对<code>si</code>和<code>sn</code>进行操作了。<br>条单一的<code>feth</code>请求只能得到一个元组。如果我们想得到所有的结果元组,程序中必须包含对所有元组执行的一个循环。嵌入式<code>SoL</code>为程序员提供了对这种循环进行管理的支持。虽然关系在概念上是一个集合,查询结果中的元组还是有一定的物理顺序的。执行<code>SQL</code>的<code>open</code>语句后,游标指向结果的第一个元组。执行一条<code>fetch</code>语句后,游标指向结果中的下一个元组。当后面不再有待处理的元组时,</p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第5章 高级SQL </category>
          
          <category> 5.1 使用程序设计语言访问数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5.1.2 ODBC</title>
      <link href="/ReadingNotes//e08bb061/"/>
      <url>/ReadingNotes//e08bb061/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/e08bb061/#5-1-2-ODBC" class="header_1">5.1.2 ODBC</a>&nbsp;<br><a href="/ReadingNotes/e08bb061/#1-建立一个和服务器的链接" class="header_2">1 建立一个和服务器的链接</a>&nbsp;<br><a href="/ReadingNotes/e08bb061/#2-通过-SQLExecDirect-语句把命令发送到数据库" class="header_2">2 通过`SQLExecDirect`语句把命令发送到数据库</a>&nbsp;<br><a href="/ReadingNotes/e08bb061/#3-断开连接释放句柄" class="header_2">3 断开连接释放句柄</a>&nbsp;<br><a href="/ReadingNotes/e08bb061/#-ADO-NET" class="header_2">`ADO.NET`</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="5-1-2-ODBC"><a href="#5-1-2-ODBC" class="headerlink" title="5.1.2 ODBC"></a>5.1.2 ODBC</h1><p><strong>开放数据库互连</strong>(<code>Open DataBase Connectivity</code>,<code>ODBC</code>)标准定义了一个<code>API</code>,应用程序用它来打开一个数据库连接、发送查询和更新,以及获取返回结果等。应用程序(例如图形界面、统计程序包或者电子表格)可以使用相同的<code>ODBC API</code>来访问任何一个支持<code>ODBC</code>标准的数据库。<br>每一个支持<code>ODBC</code>的数据库系统都提供一个和客户端程序相连接的库,当客户端发出一个<code>ODBC API</code>请求,库中的代码就可以和服务器通信来执行被请求的动作并取回结果.</p><h2 id="1-建立一个和服务器的链接"><a href="#1-建立一个和服务器的链接" class="headerlink" title="1 建立一个和服务器的链接"></a>1 建立一个和服务器的链接</h2><!--SSTStop--><p>利用<code>ODBC</code>和服务器通信的第一步是,建立一个和服务器的连接。</p><p>为了实现这一步,程序先分配一个<code>SQL</code>的环境变量,然后是一个数据库连接句柄。<code>ODBC</code>定义了<code>HENV</code>、<code>HDBC</code>和<code>RETCODE</code>几种类型。程序随后利用<code>SQLConnect</code>打开和数据库的连接,这个调用有几个参数,包括数据库的连接句柄、要连接的服务器、用户的身份和密码等。常数<code>SQL_ NTS</code>表示前面参数是一个以n结尾的字符串。</p><!--SSTStart--><h2 id="2-通过SQLExecDirect语句把命令发送到数据库"><a href="#2-通过SQLExecDirect语句把命令发送到数据库" class="headerlink" title="2 通过SQLExecDirect语句把命令发送到数据库"></a>2 通过<code>SQLExecDirect</code>语句把命令发送到数据库</h2><!--SSTStop--><p>一旦一个连接建立了,C语言就可以通过<code>SQLExecDirect</code>语句把命令发送到数据库。</p><p>因为C语言的变量可以和查询结果的属性绑定,所以当一个元组被<code>SQLFetch</code>语句取回的时候,结果中相应的属性的值就可以放到对应的C变量里了。 <code>SQLBindCol</code>做这项工作;在<code>SQLBindCol</code>函数里面第二个参数代表选择属性中哪一个位置的值,第三个参数代表<code>SQL</code>应该把属性转化成什么类型的C变量。再下一个参数给出了存放变量的地址。对于诸如字符数组这样的变长类型,最后两个参数还要给出变量的最大长度和一个位置来存放元组取回时的实际长度。如果长度域返回一个负值,那么代表着这个值为空(<code>mu</code>)。对于定长类型的变量如整型或浮点型,最大长度的域被忽略,然而当长度域返回一个负值时表示该值为空值。</p><p><code>SQLFetch</code>在<code>while</code>循环中一直执行,直到<code>SQLFetch</code>返回一个非<code>sQL_ SUCCESS</code>的值,在每一次<code>fetch</code>过程中,程序把值存放在调用<code>SQLBindCol</code>所说明的C变量中并把它们打印出来。<br><!--SSTStart--></p><h2 id="3-断开连接释放句柄"><a href="#3-断开连接释放句柄" class="headerlink" title="3 断开连接释放句柄"></a>3 断开连接释放句柄</h2><p>在会话结束的时候,程序释放语句的句柄,断开与数据库的连接,同时释放连接和<code>SQL</code>环境句柄。好的编程风格要求检查每一个函数的结果,确保它们没有错误,为了简洁,我们在这里忽略了大部分检查。<br><!--SSTStop--><br>可以创建带有参数的<code>SQL</code>语句,例如, <code>insert into department values(?,?,?)</code>。问号是为将来提供值的占位符。上面的语句可以先被”准备”,也就是在数据库中先编译,然后可以通过为占位符提供具体值来反复执行——在该例中,为<code>department</code>关系提供系名、楼宇名和预算数。</p><p><code>ODBC</code>为各种不同的任务定义了函数,例如查找数据库中所有的关系,以及查找数据库中某个关系的列的名称和类型,或者一个查询结果的列的名称和类型。<br>在默认情况下,每一个<code>SQL</code>语句都被认为是一个自动提交的独立事务。调用<code>sQLSet ConnectOption(comn, SQL_ AUTOCOMMIT,0)</code>可以关闭连接<code>com</code>的自动提交,事务必须通过显式地调用<code>SQLTransact(comn, SQL _COMMIT)</code>来提交或通过显式地调用<code>SQLTransact(comn, SQL_ROLLBACK)</code>来回滚。<br><code>ODBC</code>标准定义了符合性级别( <code>conformance level</code>),用于指定标准定义的功能的子集。一个<code>ODBC</code>实现可以仅提供核心级特性,也可以提供更多的高级特性( <code>level</code> 1或<code>level2</code>)。 <code>level I</code>需要支持取得目录的有关信息,例如什么关系存在,它们的属性是什么类型的等。 <code>level</code>2需要更多的特性,例如发送和提取参数值数组以及检索有关目录的更详细信息的能力.<br><code>SQL</code>标准定义了调用级接口( <code>Call level Interface,CI</code>),它与<code>ODBC</code>接口类似。</p><h2 id="ADO-NET"><a href="#ADO-NET" class="headerlink" title="ADO.NET"></a><code>ADO.NET</code></h2><p><code>ADO.NET API</code>是为<code>Visual basic.NET</code>和C#语言设计的,它提供了一系列访问数据的函数,与<code>JDBC</code>在上层架构没有什么不同,只是在细节上有差别。像<code>JDBC</code>和<code>ODBC</code>一样,<code>ADO.NET API</code>可以访问<code>SL</code>查询的结果,以及元数据,但使用起来比<code>ODBC</code>简单得多。可以使用<code>ADO.NET API</code>来访问支持<code>ODBC</code>的数据库,此时,<code>ADO.NET</code>调用被转换成<code>ODBC</code>调用。<code>ADO.NET API</code>也可以用在某些非关系教据源上,例如微软的<code>OLE</code>-<code>DB</code>、<code>XML</code>(在第23章介绍),以及微软最近开发的实体框架。有关<code>ADO.NET</code>的更多信息请参考文献注解。</p><!--SSTStart--><p>我这里主要是用<code>java</code>来操作数据库,<code>ODBC</code>这里了解个大概即可<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第5章 高级SQL </category>
          
          <category> 5.1 使用程序设计语言访问数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5.1.1 JDBC</title>
      <link href="/ReadingNotes//51c132fd/"/>
      <url>/ReadingNotes//51c132fd/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/51c132fd/#5-1-1-JDBC" class="header_1">5.1.1 JDBC</a>&nbsp;<br><a href="/ReadingNotes/51c132fd/#5-1-1-1-连接到数据库" class="header_1">5.1.1.1 连接到数据库</a>&nbsp;<br><a href="/ReadingNotes/51c132fd/#如何打开一个数据库连接" class="header_2">如何打开一个数据库连接</a>&nbsp;<br><a href="/ReadingNotes/51c132fd/#必须在连接数据库之前完成驱动程序的加载" class="header_2">必须在连接数据库之前完成驱动程序的加载</a>&nbsp;<br><a href="/ReadingNotes/51c132fd/#Class-forName加载驱动" class="header_3">Class.forName加载驱动</a>&nbsp;<br><a href="/ReadingNotes/51c132fd/#要实现在java类路径中放入驱动程序jar包" class="header_3">要实现在java类路径中放入驱动程序jar包</a>&nbsp;<br><a href="/ReadingNotes/51c132fd/#其他数据库的驱动名称" class="header_3">其他数据库的驱动名称</a>&nbsp;<br><a href="/ReadingNotes/51c132fd/#协议" class="header_3">协议</a>&nbsp;<br><a href="/ReadingNotes/51c132fd/#5-1-1-2-向数据库系统中传递SQL语句" class="header_1">5.1.1.2 向数据库系统中传递SQL语句</a>&nbsp;<br><a href="/ReadingNotes/51c132fd/#通过数据库连接创建Statement对象" class="header_2">通过数据库连接创建Statement对象</a>&nbsp;<br><a href="/ReadingNotes/51c132fd/#-executeQuery-方法执行查询语句" class="header_2">`executeQuery`方法执行查询语句</a>&nbsp;<br><a href="/ReadingNotes/51c132fd/#-executeUpdate-方法执行费非查询语句-更新-插入删除-建表等" class="header_2">`executeUpdate`方法执行费非查询语句 更新 插入删除 建表等</a>&nbsp;<br><a href="/ReadingNotes/51c132fd/#5-1-1-3-获取查询结果" class="header_1">5.1.1.3 获取查询结果</a>&nbsp;<br><a href="/ReadingNotes/51c132fd/#executeQuery方法返回结果集" class="header_2">executeQuery方法返回结果集</a>&nbsp;<br><a href="/ReadingNotes/51c132fd/#结果集的next方法" class="header_2">结果集的next方法</a>&nbsp;<br><a href="/ReadingNotes/51c132fd/#结果集的get方法" class="header_2">结果集的get方法</a>&nbsp;<br><a href="/ReadingNotes/51c132fd/#结果集get方法的参数" class="header_2">结果集get方法的参数</a>&nbsp;<br><a href="/ReadingNotes/51c132fd/#java成宿结束后一定要关闭数据库连接" class="header_2">java成宿结束后一定要关闭数据库连接</a>&nbsp;<br><a href="/ReadingNotes/51c132fd/#5-1-1-4-预备语句" class="header_1">5.1.1.4 预备语句</a>&nbsp;<br><a href="/ReadingNotes/51c132fd/#使用Connection类的prepareStatement方法创建PreparedStatement对象" class="header_2">使用Connection类的prepareStatement方法创建PreparedStatement对象</a>&nbsp;<br><a href="/ReadingNotes/51c132fd/#优先使用预备语句" class="header_2">优先使用预备语句</a>&nbsp;<br><a href="/ReadingNotes/51c132fd/#预备语句更加高效" class="header_2">预备语句更加高效</a>&nbsp;<br><a href="/ReadingNotes/51c132fd/#预备语句可检查用户输入" class="header_2">预备语句可检查用户输入</a>&nbsp;<br><a href="/ReadingNotes/51c132fd/#预备语句可防止SQL注入" class="header_2">预备语句可防止SQL注入</a>&nbsp;<br><a href="/ReadingNotes/51c132fd/#一次执行多条SQL语句的情况" class="header_2">一次执行多条SQL语句的情况</a>&nbsp;<br><a href="/ReadingNotes/51c132fd/#5-1-1-5-可调用语句" class="header_1">5.1.1.5 可调用语句</a>&nbsp;<br><a href="/ReadingNotes/51c132fd/#5-1-1-6-元数据特性" class="header_1">5.1.1.6 元数据特性</a>&nbsp;<br><a href="/ReadingNotes/51c132fd/#结果集元数据-ResultsetMetaData" class="header_2">结果集元数据 ResultsetMetaData</a>&nbsp;<br><a href="/ReadingNotes/51c132fd/#如何获取ResultsetMetaData对象-Resultset-getMetaData-方法" class="header_3">如何获取ResultsetMetaData对象 `Resultset.getMetaData`方法</a>&nbsp;<br><a href="/ReadingNotes/51c132fd/#数据库元数据-DatabaseMetaData" class="header_2">数据库元数据 DatabaseMetaData</a>&nbsp;<br><a href="/ReadingNotes/51c132fd/#如何获取-DatabaseMetaData-Connection实例-getMetaData-方法" class="header_3">如何获取`DatabaseMetaData` `Connection实例.getMetaData`方法</a>&nbsp;<br><a href="/ReadingNotes/51c132fd/#其他获取数据库本省信息的方法" class="header_3">其他获取数据库本省信息的方法</a>&nbsp;<br><a href="/ReadingNotes/51c132fd/#模板" class="header_4">模板</a>&nbsp;<br><a href="/ReadingNotes/51c132fd/#获取数据库其他信息" class="header_3">获取数据库其他信息</a>&nbsp;<br><a href="/ReadingNotes/51c132fd/#元数据信息可以是代码更通用" class="header_3">元数据信息可以是代码更通用</a>&nbsp;<br><a href="/ReadingNotes/51c132fd/#5-1-1-7-其他特性" class="header_1">5.1.1.7 其他特性</a>&nbsp;<br><a href="/ReadingNotes/51c132fd/#打开或关闭自动提交" class="header_2">打开或关闭自动提交</a>&nbsp;<br><a href="/ReadingNotes/51c132fd/#关闭自动提交-开启事务" class="header_3">关闭自动提交 开启事务</a>&nbsp;<br><a href="/ReadingNotes/51c132fd/#开始自动提交" class="header_3">开始自动提交</a>&nbsp;<br><a href="/ReadingNotes/51c132fd/#处理大对象数据" class="header_2">处理大对象数据</a>&nbsp;<br><a href="/ReadingNotes/51c132fd/#读取数据库中的大对象数据" class="header_3">读取数据库中的大对象数据</a>&nbsp;<br><a href="/ReadingNotes/51c132fd/#将大对象数据写入数据库中" class="header_3">将大对象数据写入数据库中</a>&nbsp;<br><a href="/ReadingNotes/51c132fd/#行集row-set" class="header_2">行集row set</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="5-1-1-JDBC"><a href="#5-1-1-JDBC" class="headerlink" title="5.1.1 JDBC"></a>5.1.1 JDBC</h1><p><code>JDBC</code>标准定义了<code>Java</code>程序连接数据库服务器的应用程序接口(<code>Application Program Interface,API</code>),<code>JDBC</code>原来是<code>Java</code>数据库连接(<code>Java Database Connectivity</code>)的缩写,但其全称现在已经不用了)。<br><code>Java</code>程序必须引用<code>java.sql.*</code>,它包含了<code>JDBC</code>所提供功能的接口定义。</p><h1 id="5-1-1-1-连接到数据库"><a href="#5-1-1-1-连接到数据库" class="headerlink" title="5.1.1.1 连接到数据库"></a>5.1.1.1 连接到数据库</h1><p>要在<code>Java</code>程序中访问数据库,首先要打开一个数据库连接。这一步需要选择要使用哪个数据库,例如,可以是你的机器上的一个<code>Oracle</code>实例,也可以是运行在另一台机器上的一个<code>PostgreSQL</code>数据库。只有在打开数据库连接以后,<code>Java</code>程序才能执行<code>SQL</code>语句。</p><h2 id="如何打开一个数据库连接"><a href="#如何打开一个数据库连接" class="headerlink" title="如何打开一个数据库连接"></a>如何打开一个数据库连接</h2><p>可以通过调用<code>java.sql</code>包中的<code>DriverManager</code>类的<code>getConnection</code>方法来打开一个数据库连接。该方法有三个参数:</p><ol><li><code>URL</code>:<code>getConnection</code>方法的第一个参数是以字符串类型表示的<code>URL</code>,指明服务器所在的<strong>主机名称</strong>以及可能包含的其他信息,例如:<ul><li>与数据库通信所用的协议,</li><li>数据库系统用来通信的端口号,</li><li>还有服务器端使用的特定数据库。</li></ul></li></ol><p>注意<code>JDBC</code>只是指定<code>API</code>而不指定通信协议。一个<code>JDBC</code>驱动器可能支持多种协议,我们必须指定一个数据库和驱动器都支持的协议。协议的详细内容是由<code>提供商</code>设定的。</p><ol><li>数据库用户:<code>getConnection</code>方法的第二个参数用于指定一个数据库用户标识,它为字符串类型</li><li>密码:<code>getConnection</code>方法的第三个参数是密码,它也是字符串类型。(注意,把密码直接写在<code>JDBC</code>代码中会增加安全性隐患,因为你的代码有可能会被某些未被授权的用户所访问。)</li></ol><h2 id="必须在连接数据库之前完成驱动程序的加载"><a href="#必须在连接数据库之前完成驱动程序的加载" class="headerlink" title="必须在连接数据库之前完成驱动程序的加载"></a>必须在连接数据库之前完成驱动程序的加载</h2><p>每个支持<code>JDBC</code>的数据库产品都会提供一个<code>JDBC</code>驱动程序(<code>JDBC driver</code>),该<strong>驱动程序必须被动态加载才能实现<code>Java</code>对数据库的访问</strong>。事实上,<strong>必须在连接数据库之前完成驱动程序的加载</strong>。</p><h3 id="Class-forName加载驱动"><a href="#Class-forName加载驱动" class="headerlink" title="Class.forName加载驱动"></a>Class.forName加载驱动</h3><p>调用<code>Class.forName</code>方法完成驱动程序的加载,在调用时需要通过参数来<strong>指定一个实现了<code>java.sql.Driver</code>接口的实体类</strong>。<code>java.sql.Driver</code>接口的功能是为了实现不同层面的操作之间的转换,一边是与产品类型无关的<code>JDBC</code>操作,另一边是与产品相关的、在所使用的特定数据库管理系统中完成的操作。</p><h3 id="要实现在java类路径中放入驱动程序jar包"><a href="#要实现在java类路径中放入驱动程序jar包" class="headerlink" title="要实现在java类路径中放入驱动程序jar包"></a>要实现在java类路径中放入驱动程序jar包</h3><p><code>Oracle</code>的驱动程序:<code>oracle.jdbe.driver.OracleDriver</code>。该驱动程序包含在一个<code>.jar</code>文件里,可以从提供商的网站下载,然后放在<code>Java</code>的类路径( <code>classpath</code>)里,用于<code>Java</code>编译器访问。</p><h3 id="其他数据库的驱动名称"><a href="#其他数据库的驱动名称" class="headerlink" title="其他数据库的驱动名称"></a>其他数据库的驱动名称</h3><div class="table-container"><table><thead><tr><th style="text-align:left">数据库</th><th style="text-align:left">对应的驱动名称</th></tr></thead><tbody><tr><td style="text-align:left"><code>IBM DB2</code>数据库驱动</td><td style="text-align:left"><code>com.ibm.db2.jdbe.app.DB2Driver</code>;</td></tr><tr><td style="text-align:left"><code>Microsoft SQL Server</code>数据库驱动</td><td style="text-align:left"><code>com.microsoft.sqlserver.jdbc.SQLServerDriver</code>;</td></tr><tr><td style="text-align:left"><code>Postgre SQL</code>数据库驱动</td><td style="text-align:left"><code>org.postgresqL.Driver</code>;</td></tr><tr><td style="text-align:left"><code>MySQL</code>数据库驱动</td><td style="text-align:left"><code>com.mysql.jdbc.Driver</code>;</td></tr></tbody></table></div><p><code>Sun</code>公司还提供了一种”<strong>桥接驱动器</strong>“,可以把<code>JDBC</code>调用转换成<code>ODBC</code>。该驱动仅是用于那些支持<code>ODBC</code>但不支持<code>JDBC</code>的厂商。</p><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>用来与数据库交换信息的具体协议并没有在<code>JDBC</code>标准中定义,而是由所使用的驱动程序决定的。有些驱动程序支持多种协议,使用哪一种更合适取决于所连接的数据库支持什么协议。<br>我们的例子里在打开一个数据库连接时,<strong>字符串<code>jdbe:oracle:thin</code>指定了<code>Oracle</code>支持的一个特定协议</strong>。</p><h1 id="5-1-1-2-向数据库系统中传递SQL语句"><a href="#5-1-1-2-向数据库系统中传递SQL语句" class="headerlink" title="5.1.1.2 向数据库系统中传递SQL语句"></a>5.1.1.2 向数据库系统中传递SQL语句</h1><h2 id="通过数据库连接创建Statement对象"><a href="#通过数据库连接创建Statement对象" class="headerlink" title="通过数据库连接创建Statement对象"></a>通过数据库连接创建Statement对象</h2><p>旦打开了一个数据库连接,程序就可以利用该连接来向数据库发送<code>SQL</code>语句用于执行。这是通过<code>Statement</code>类的一个实例来完成的。一个<code>Statement</code>对象并不代表<code>SQL</code>语句本身,而是实现了可以被<code>Java</code>程序调用的一些方法,通过参数来传递<code>SQL</code>语句并被数据库系统所执行。我们的例子<strong>在连接变量</strong><code>conn</code>上<strong>创建</strong>了一个<code>Statement</code>句柄(<code>stmt</code>)。<br>使用</p><h2 id="executeQuery方法执行查询语句"><a href="#executeQuery方法执行查询语句" class="headerlink" title="executeQuery方法执行查询语句"></a><code>executeQuery</code>方法执行查询语句</h2><p>用<code>executeUpdate</code>方法来执行查询语句,返回一个结果集。</p><h2 id="executeUpdate方法执行费非查询语句-更新-插入删除-建表等"><a href="#executeUpdate方法执行费非查询语句-更新-插入删除-建表等" class="headerlink" title="executeUpdate方法执行费非查询语句 更新 插入删除 建表等"></a><code>executeUpdate</code>方法执行费非查询语句 更新 插入删除 建表等</h2><p><code>executeUpdate</code>方法可以执行像更新(<code>update</code>)、插入(<code>insert</code>)、删除(<code>delete</code>)、创建表(<code>create table</code>)等这样的<strong>非查询性语句</strong>。</p><ul><li>对于更新插入或删除<code>executeUpdate</code>方法它返回一个整数,表示被插入、更新或者删除的元组个数。</li><li>对于<code>DDL</code>语句,<code>executeUpdate</code>方法返回值是0</li></ul><h1 id="5-1-1-3-获取查询结果"><a href="#5-1-1-3-获取查询结果" class="headerlink" title="5.1.1.3 获取查询结果"></a>5.1.1.3 获取查询结果</h1><h2 id="executeQuery方法返回结果集"><a href="#executeQuery方法返回结果集" class="headerlink" title="executeQuery方法返回结果集"></a>executeQuery方法返回结果集</h2><p>示例程序用<code>stmt.executeQuery</code>来执行一次查询。它可以把<strong>结果中的元组集合</strong>提取到<code>Resultset</code>对象变量<code>rset</code>中并每次取出一个进行处理。</p><h2 id="结果集的next方法"><a href="#结果集的next方法" class="headerlink" title="结果集的next方法"></a>结果集的next方法</h2><p>结果集的<code>next</code>方法用来查看在集合中是否还存在至少一个尚未取回的元组,如果存在的话就取出。<code>next</code>方法的返回值是一个布尔变量,表示是否从结果集中取回了个元组。</p><h2 id="结果集的get方法"><a href="#结果集的get方法" class="headerlink" title="结果集的get方法"></a>结果集的get方法</h2><p>可以通过一系列的名字以<code>get</code>为前缀的方法来得到所获取元组的各个属性。方法<code>setstring</code>可以返回所有的基本<code>SQL</code>数据类型的属性(被转换成<code>Java</code>中的<code>String</code>类型的值),当然也可以使用像<code>getFloat</code>那样一些约束性更强的方法。</p><h2 id="结果集get方法的参数"><a href="#结果集get方法的参数" class="headerlink" title="结果集get方法的参数"></a>结果集get方法的参数</h2><p>这些不同的<code>get</code>方法的<code>参数</code>既可以是一个字<strong>符串类型的属性名称</strong>,又可以是一个<strong>整数</strong>,用来表示所需获取的属性在元组中的位置。图5-1给出了两种<strong>在元组中提取属性值</strong>的办法:<br><strong>利用属性名提取</strong>( <code>dept_name</code>)或者<strong>利用属性位置提取</strong>(2,代表第二个属性)。</p><h2 id="java成宿结束后一定要关闭数据库连接"><a href="#java成宿结束后一定要关闭数据库连接" class="headerlink" title="java成宿结束后一定要关闭数据库连接"></a>java成宿结束后一定要关闭数据库连接</h2><p><code>Java</code>程序结束的时候<strong>语句</strong>和<strong>连接</strong>都将被关闭。注意关闭连接是很重要的,因为数据库连接的个数是有限制的;未关闭的连接可能导致超过这一限制。如果发生这种情况,应用将不能再打开任何数据库连接。</p><h1 id="5-1-1-4-预备语句"><a href="#5-1-1-4-预备语句" class="headerlink" title="5.1.1.4 预备语句"></a>5.1.1.4 预备语句</h1><p>我们也可以通过以”<code>?</code>“来代表以后再给出的实际值,而创建一个预备语句。<br>数据库系统在准备查询语句的时候对它进行编译。在每次执行该语句时(用新值替换”?”),数据库可以重用预先编译的查询的形式,应用新值进行查询。<br>图5-2的代码框架给出了如何使用预备语句的示例。</p><h2 id="使用Connection类的prepareStatement方法创建PreparedStatement对象"><a href="#使用Connection类的prepareStatement方法创建PreparedStatement对象" class="headerlink" title="使用Connection类的prepareStatement方法创建PreparedStatement对象"></a>使用Connection类的prepareStatement方法创建PreparedStatement对象</h2><p>可以使用<code>Connection</code>类的<code>prepareStatement</code>方法来提交<code>SQL</code>语句用于编译。它返回一个<code>PreparedStatement</code>类的对象。此时还没有执行<code>SQL</code>语句。执行需要<code>PreparedStatement</code>类的两个方法<code>executeQuery</code>和<code>executeUpdate</code>。<br>但是在它们被调用之前,我们必须使用<code>PreparedStatement</code>类的方法来为”<code>?</code>“参数设定具体的值。 </p><p><code>setString</code>方法以及诸如<code>setInt</code>等用于其他的<code>SQL</code>基本类型的其他类似的方法使我们能够为参数指定值。</p><ul><li><code>set</code>第一个参数用来确定我们为哪个”<code>?</code>“设定值,<ul><li>如果给第1个问号设置值,则<code>set</code>方法的第一个参数设置为1</li></ul></li><li><code>set</code>方法的第二个参数是我们要设定的值。</li></ul><h2 id="优先使用预备语句"><a href="#优先使用预备语句" class="headerlink" title="优先使用预备语句"></a>优先使用预备语句</h2><h2 id="预备语句更加高效"><a href="#预备语句更加高效" class="headerlink" title="预备语句更加高效"></a>预备语句更加高效</h2><p>在同一查询编译一次然后设置不同的参数值执行多次的情况下,<strong>预备语句使得执行更加高效</strong>。</p><h2 id="预备语句可检查用户输入"><a href="#预备语句可检查用户输入" class="headerlink" title="预备语句可检查用户输入"></a>预备语句可检查用户输入</h2><p>然而,预备语句有一个更加重要的优势,预备语句可以用户输入,<br>即使是只运行一次,预备语句都是执行<code>SQL</code>查询的首选方法。假设我们读取了一个用户输入的值,然后使用<code>Java</code>的字符串操作来构造<code>SQL</code>语句。如果用户输入了某些特殊字符,例如一个单引号,除非我们采取额外工作对用户输入进行检查,否则生成的<code>SQL</code>语句会出现语法错误。<br><strong><code>setString</code>方法为我们自动完成检查,并插入需要的转义字符,以确保语法的正确性</strong>。</p><h2 id="预备语句可防止SQL注入"><a href="#预备语句可防止SQL注入" class="headerlink" title="预备语句可防止SQL注入"></a>预备语句可防止SQL注入</h2><p>一种叫做<code>SQL</code>注入(<code>SQL injecton</code>)的技术可以被恶意黑客用来窃取数据或损坏数据库。<br>假设一个<code>Java</code>程序输入一个字符串<code>name</code>,并且构建下面的查询:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"<span class="keyword">select</span> * <span class="keyword">from</span> instructor <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'"+name+"'</span>;"</span><br></pre></td></tr></table></figure><br>如果用户没有输人一个名字,而是输入:<br><code>x&#39; or &#39;y&#39;=&#39;y&#39;</code><br>这样,产生的查询语句就变成:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> instructor <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'x'</span> <span class="keyword">or</span> <span class="string">'y'</span>=<span class="string">'y'</span>;</span><br></pre></td></tr></table></figure><br>在生成的查询中, <code>where</code>子句总是真,所以查询结果返回整个<code>instructor</code>关系。<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from instructor where name='x' or 'y'='y';</span><br><span class="line">+-------+------------+------------+-----------+</span><br><span class="line">| ID    | name       | dept_name  | salary    |</span><br><span class="line">+-------+------------+------------+-----------+</span><br><span class="line">| <span class="number">10101</span> | Srinivasan | <span class="built_in">Comp</span>. Sci. | <span class="number">65000</span>.<span class="number">00</span>  |</span><br><span class="line">| <span class="number">12121</span> | Wu         | Finance    | <span class="number">90000</span>.<span class="number">00</span>  |</span><br><span class="line">| <span class="number">15151</span> | Mozart     | Music      | <span class="number">40000</span>.<span class="number">00</span>  |</span><br><span class="line">| <span class="number">22222</span> | Einstein   | Physics    | <span class="number">95000</span>.<span class="number">00</span>  |</span><br><span class="line">| <span class="number">25566</span> | Brown      | Biology    | <span class="number">100000</span>.<span class="number">00</span> |</span><br><span class="line">| <span class="number">30765</span> | Green      | Music      | NULL      |</span><br><span class="line">| <span class="number">32343</span> | El Said    | History    | <span class="number">60000</span>.<span class="number">00</span>  |</span><br><span class="line">| <span class="number">33456</span> | Gold       | Physics    | <span class="number">87000</span>.<span class="number">00</span>  |</span><br><span class="line">| <span class="number">45565</span> | Katz       | <span class="built_in">Comp</span>. Sci. | <span class="number">75000</span>.<span class="number">00</span>  |</span><br><span class="line">| <span class="number">58583</span> | Califieri  | History    | <span class="number">62000</span>.<span class="number">00</span>  |</span><br><span class="line">| <span class="number">76543</span> | Singh      | Finance    | <span class="number">80000</span>.<span class="number">00</span>  |</span><br><span class="line">| <span class="number">76766</span> | Crick      | Biology    | <span class="number">72000</span>.<span class="number">00</span>  |</span><br><span class="line">| <span class="number">83821</span> | Brandt     | <span class="built_in">Comp</span>. Sci. | <span class="number">92000</span>.<span class="number">00</span>  |</span><br><span class="line">| <span class="number">98345</span> | Kim        | Elec. Eng. | <span class="number">80000</span>.<span class="number">00</span>  |</span><br><span class="line">+-------+------------+------------+-----------+</span><br><span class="line"><span class="number">14</span> rows <span class="keyword">in</span> <span class="built_in">set</span> (<span class="number">0</span>.<span class="number">05</span> sec)</span><br></pre></td></tr></table></figure><br>更诡计多端的恶意用户甚至可以编写输入值以输出更多的数据。使用预备语句就可以防止这类问题,因为输入的字符串<code>setString</code>方法将被插入<code>转义字符</code>,因此最后的查询变为:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> instructor <span class="keyword">where</span> <span class="keyword">name</span> =<span class="string">'x\'</span> <span class="keyword">or</span> \<span class="string">'Y\'</span>=\<span class="string">'Y'</span>;</span><br></pre></td></tr></table></figure><br>这是无害的查询语句,返回结果为空集。<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from instructor where name ='x\' or \'Y\'=\'Y';</span><br><span class="line">Empty <span class="built_in">set</span></span><br></pre></td></tr></table></figure></p><h2 id="一次执行多条SQL语句的情况"><a href="#一次执行多条SQL语句的情况" class="headerlink" title="一次执行多条SQL语句的情况"></a>一次执行多条SQL语句的情况</h2><p>比较老的系统允许<strong>多个由分号隔开的语句在一次调用里被执行</strong>。<br>此功能正逐渐被淘汰,因为恶意的黑客会利用<code>SQL</code>注入技术插入整个<code>SQL</code>语句。由于这些语句在<code>Java</code>程序所有者的权限上运行,像删除表(<code>drop table</code>)这样毁灭性的<code>SQL</code>语句会被执行。<strong><code>SQL</code>应用程序开发者必须警惕这种潜在的安全漏洞</strong>。</p><h1 id="5-1-1-5-可调用语句"><a href="#5-1-1-5-可调用语句" class="headerlink" title="5.1.1.5 可调用语句"></a>5.1.1.5 可调用语句</h1><p><code>JDBC</code>还提供了<code>CallableStatement</code>接口来允许调用<code>SQL</code>的存储过程和函数(稍后在5.2节描述)。此接口对函数和过程所扮演的角色跟<code>prepareStatement</code>对查询所扮演的角色一样。<br>函数返回值和过程的对外参数的数据类型必须先用方法<code>registerOutParameter()</code>注册,它们可以用与结果集用的方法类似的<code>get</code>方法获取。请参看<code>JDBC</code>手册以获得更细节的信息。</p><h1 id="5-1-1-6-元数据特性"><a href="#5-1-1-6-元数据特性" class="headerlink" title="5.1.1.6 元数据特性"></a>5.1.1.6 元数据特性</h1><p>正如我们此前提到的,一个<code>Java</code>应用程序不包含数据库中存储的数据的声明。这些声明是<code>SQL</code>数据定义语言(<code>DDL</code>)的一部分。因此,使用<code>JDBC</code>的<code>Java</code>程序必须</p><ul><li>要么将关于数据库模式的假设硬编码到程序中,</li><li>要么直接在运行时从数据库系统中得到那些信息。</li></ul><p>后一种方法更可取,因为它使得应用程序可以更健壮地处理数据库模式的变化。</p><h2 id="结果集元数据-ResultsetMetaData"><a href="#结果集元数据-ResultsetMetaData" class="headerlink" title="结果集元数据 ResultsetMetaData"></a>结果集元数据 ResultsetMetaData</h2><p>回想一下,当我们提交一个使用<code>executeQuery</code>方法的查询时,查询结果被封装在一个<code>Resultset</code>对象中。</p><h3 id="如何获取ResultsetMetaData对象-Resultset-getMetaData方法"><a href="#如何获取ResultsetMetaData对象-Resultset-getMetaData方法" class="headerlink" title="如何获取ResultsetMetaData对象 Resultset.getMetaData方法"></a>如何获取ResultsetMetaData对象 <code>Resultset.getMetaData</code>方法</h3><p>接口<code>Resultset</code>有一个<code>getMetaData()</code>方法,它返回一个包含<strong>结果集元数据</strong>的<code>ResultsetMetaData</code>对象。 <code>ResultSetMetaData</code>进一步又包含查找<strong>结果集元数据</strong>的方法,例如结果的<strong>列数</strong>、某个特定<strong>列的名称</strong>,或者某个特定<strong>列的数据类型</strong>。这样,即使不知道结果的模式,我们也可以方便地执行查询。</p><p>实例省略</p><p><code>ResultSetMetaData</code>对象的<code>getColumnCount</code>方法返回<strong>结果关系的属性个数</strong>(元数)。<br>这使得我们能够遍历每个属性(请注意,和<code>JDBC</code>的惯例一致,我们从1开始)。对于每一个属性,我们采用<code>getColumnName</code>和<code>getColumnTypeName</code>两个方法分别得到属性的名称和属性的数据类型。</p><h2 id="数据库元数据-DatabaseMetaData"><a href="#数据库元数据-DatabaseMetaData" class="headerlink" title="数据库元数据 DatabaseMetaData"></a>数据库元数据 DatabaseMetaData</h2><p><code>DatabaseMetaData</code>接口提供了查找<strong>数据库元数据</strong>的机制。</p><h3 id="如何获取DatabaseMetaData-Connection实例-getMetaData方法"><a href="#如何获取DatabaseMetaData-Connection实例-getMetaData方法" class="headerlink" title="如何获取DatabaseMetaData Connection实例.getMetaData方法"></a>如何获取<code>DatabaseMetaData</code> <code>Connection实例.getMetaData</code>方法</h3><p>接口<code>Connection</code>包含一个<code>getMetaData</code>方法用于返回一个<code>DatabaseMetaData</code>对象。接口<code>DatabaseMetaData</code>进一步又含有大量的方法可以用于获取程序所连接的<strong>数据库</strong>和<strong>数据库系统</strong>的元数据。<br>例如,有些方法可以返回<strong>数据库系统的产品名称和版本号</strong>。另外一些方法可以用来<strong>查询数据库系统所支持的特性</strong>。</p><h3 id="其他获取数据库本省信息的方法"><a href="#其他获取数据库本省信息的方法" class="headerlink" title="其他获取数据库本省信息的方法"></a>其他获取数据库本省信息的方法</h3><p>还有<strong>其他可以返回数据库本身信息的方法</strong>,下面的代码显示了如何<strong>找出数据库中的关系的列(属性)信息</strong>。变量<code>com</code>假定存储了一个已经打开的数据库连接。方法<code>getColumns</code>有四个参数:</p><ul><li>一个目录名称(<code>null</code>表示目录名称被忽略)、</li><li>一个模式名称模板、</li><li>一个表名称模板,</li><li>以及一个列名称模板。</li></ul><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><p><code>模式名称</code>、<code>表名称</code>和<code>列名称</code>的<code>模板</code>可以用于指定一个名字或一个模板。</p><p><strong>模板</strong>可以使用<code>SQL</code>字符串匹配特殊字符如”<code>%</code>“和”<code>_</code>“;例如模板”<code>%</code>“匹配所有的名字。<br><strong>只有满足特定名称或模板的模式中的表的列才会被检索到</strong>。</p><p>结果集中的每行包含一个<code>列的信息</code>。<br>结果集中的行包括若干个列,如目录名称、模式、表和列、列的类型,等等。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DatabaseMetaData dbmd = conn.getMetaData();</span><br><span class="line">ResultSet rs = dbmd.getColumns(<span class="keyword">null</span>, <span class="string">"univdb"</span>, <span class="string">"department"</span>, <span class="string">"%"</span>);</span><br><span class="line"><span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">    System.out.println(rs.getString(<span class="string">"COLUMN_NAME"</span>));</span><br><span class="line">    System.out.println(rs.getString(<span class="string">"TYPE_NAME"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="获取数据库其他信息"><a href="#获取数据库其他信息" class="headerlink" title="获取数据库其他信息"></a>获取数据库其他信息</h3><p><code>DatabaseMetaData</code>还提供了获取数据库信息的一些其他方法,比如,可以用来<strong>获取关系</strong>(<code>get Tables()</code>),<strong>外码参照</strong>( <code>getCrossReference()</code>)、<strong>授权</strong>、<strong>数据库限制</strong>如最大连接数等的元数据。<br>元数据接口可以用于许多不同的任务。例如,它们可以用于<strong>编写数据库的浏览器</strong>,该浏览器允许用户找出一个数据库中的关系表,检查它们的模式,检查表中的行,用选择操作查看想要的行,等等。</p><h3 id="元数据信息可以是代码更通用"><a href="#元数据信息可以是代码更通用" class="headerlink" title="元数据信息可以是代码更通用"></a>元数据信息可以是代码更通用</h3><p>元数据信息可以用于使这些任务的代码更通用;</p><ul><li>例如,用来显示一个关系中的行的代码可以用这样的方法编写使得它能够在所有可能的关系上工作,无论这些关系的模式是什么。</li><li>类似地,可以编写这样的代码,它获得一个査询字符串,执行查询,然后把结果打印成一个格式化的表;无论提交了的实际查询是什么,这段代码都可以工作。</li></ul><h1 id="5-1-1-7-其他特性"><a href="#5-1-1-7-其他特性" class="headerlink" title="5.1.1.7 其他特性"></a>5.1.1.7 其他特性</h1><p><code>JDBC</code>提供了一些其他特性,如可<strong>更新的结果集</strong>(<code>updatable result sets</code>)。它可以从一个在数据库关系上执行选择和/或投影操作的查询中创建一个可更新的结果集。然后,<strong>一个对结果集中的元组的更新将引起对数据库关系中相应元组的更新</strong>。<br>回想一下4.3节,事务把多个操作封装成一个可以被提交或者回滚的原子单元<br>默认情况下,每个<code>SQL</code>语句都被作为一个自动提交的独立的事务来对待。</p><h2 id="打开或关闭自动提交"><a href="#打开或关闭自动提交" class="headerlink" title="打开或关闭自动提交"></a>打开或关闭自动提交</h2><p><code>JDBC</code>的<code>Connection</code>接口中的方法<code>setAutoCommit()</code>允许打开或关闭这种行为。</p><h3 id="关闭自动提交-开启事务"><a href="#关闭自动提交-开启事务" class="headerlink" title="关闭自动提交 开启事务"></a>关闭自动提交 开启事务</h3><p>因此,如果<code>con</code>是一个打开的连接,则<code>conn.setAutoCommit(false)</code>将关闭自动提交。然后事务必须用<code>conn.commit()</code>显式提交或用<code>conn.rollback()</code>回滚。</p><h3 id="开始自动提交"><a href="#开始自动提交" class="headerlink" title="开始自动提交"></a>开始自动提交</h3><p>自动提交可以用<code>conn.setAutoCommit(true)</code>来打开。</p><h2 id="处理大对象数据"><a href="#处理大对象数据" class="headerlink" title="处理大对象数据"></a>处理大对象数据</h2><h3 id="读取数据库中的大对象数据"><a href="#读取数据库中的大对象数据" class="headerlink" title="读取数据库中的大对象数据"></a>读取数据库中的大对象数据</h3><p><code>JDBC</code>提供处理大对象的接口而不要求在内存中创建整个大对象。为了获取大对象, <code>Resultset</code>接口提供方法<code>getBlob()</code>和<code>getClob()</code>,它们与<code>getString()</code>方法相似,但是分别返回类型为<code>Blob</code>和<code>Clob</code>的对象。这些对象并不存储整个大对象,而是存储这些大对象的<strong>定位器</strong>,即指向数据库中实际大对象的逻辑指针。<strong>从这些大对象中获取数据与从文件或者输入流中获取数据非常相似</strong>,可以采用像<code>getBytes</code>和<code>getSubString</code>这样的方法来实现。</p><h3 id="将大对象数据写入数据库中"><a href="#将大对象数据写入数据库中" class="headerlink" title="将大对象数据写入数据库中"></a>将大对象数据写入数据库中</h3><p>反向操作时,为了<strong>向数据库里存储大对象</strong>,可以用<code>PreparedStatement</code>类的方法<code>setBlob(int parameterIndex, InputStream inputStream)</code>把一个类型为二进制大对象(<code>blob</code>)的数据库列与一个输入流关联起来。<br>当预备语句被执行时,数据从输入流被读取,然后被写入数据库的二进制大对象中。与此相似,使用方法<code>setClob</code>可以<strong>设置字符大对象</strong>(<code>clob</code>)列,该方法的参数包括该列的序号和一个字符串流。</p><h2 id="行集row-set"><a href="#行集row-set" class="headerlink" title="行集row set"></a>行集row set</h2><p><code>JDBC</code>还提供了<strong>行集</strong>( <code>row set</code>)特性<strong>,允许把<code>结果集</code>打包起来发送给其他应用程序</strong>。<strong>行集既可以向后又可以向前扫描,并且可被修改。行集一旦被下载下来就不再是数据库本身的内容了</strong>,所以我们在这里并不对其做详细介绍。</p><!--SSTStop-->]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第5章 高级SQL </category>
          
          <category> 5.1 使用程序设计语言访问数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5.1 使用程序设计语言访问数据库</title>
      <link href="/ReadingNotes//34951b9e/"/>
      <url>/ReadingNotes//34951b9e/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/34951b9e/#5-1-使用程序设计语言访问数据库" class="header_1">5.1 使用程序设计语言访问数据库</a>&nbsp;<br><a href="/ReadingNotes/34951b9e/#为什么数据库程序员必须能够使用通用程序设计语言" class="header_2">为什么数据库程序员必须能够使用通用程序设计语言</a>&nbsp;<br><a href="/ReadingNotes/34951b9e/#通用编程语言中访问-SQL-的方法" class="header_2">通用编程语言中访问`SQL`的方法</a>&nbsp;<br><a href="/ReadingNotes/34951b9e/#把-SQL-与通用程序语言相结合的问题" class="header_2">把`SQL`与通用程序语言相结合的问题</a>&nbsp;<br><a href="/ReadingNotes/34951b9e/#可先学习数据库设计-在看本章" class="header_2">可先学习数据库设计 在看本章</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="5-1-使用程序设计语言访问数据库"><a href="#5-1-使用程序设计语言访问数据库" class="headerlink" title="5.1 使用程序设计语言访问数据库"></a>5.1 使用程序设计语言访问数据库</h1><h2 id="为什么数据库程序员必须能够使用通用程序设计语言"><a href="#为什么数据库程序员必须能够使用通用程序设计语言" class="headerlink" title="为什么数据库程序员必须能够使用通用程序设计语言"></a>为什么数据库程序员必须能够使用通用程序设计语言</h2><p><code>SQL</code>提供了一种强大的声明性查询语言。实现相同的查询,用<code>SQL</code>写查询语句比用通用程序设计语言要简单得多。然而,数据库程序员必须能够使用通用程序设计语言,原因至少有以下两点:</p><ol><li>因为<code>SQL</code>没有提供通用程序设计语言那样的表达能力,所以<code>SQL</code>并不能表达所有查询要求。也就是说,有可能存在这样的查询,可以用C、<code>Java</code>或<code>Cobol</code>编写,而用<code>SQL</code>做不到。要写这样的查询,我们可以将<code>SQL</code>嵌入到一种更强大的语言中。</li><li>非声明性的动作(例如打印一份报告、和用户交互,或者把一次查询的结果送到一个图形用户界面中)都不能用<code>SQL</code>实现。一个应用程序通常包括很多部分,查询或更新数据只是其中之一,而其他部分则用通用程序设计语言实现。对于集成应用来说,必须用某种方法把<code>SQL</code>与通用编程语言结合起来。</li></ol><h2 id="通用编程语言中访问SQL的方法"><a href="#通用编程语言中访问SQL的方法" class="headerlink" title="通用编程语言中访问SQL的方法"></a>通用编程语言中访问<code>SQL</code>的方法</h2><p>可以通过以下两种方法从通用编程语言中访问<code>SQL</code>:</p><ol><li>动态<code>SQL</code>:通用程序设计语言可以通过函数(对于过程式语言)或者方法(对于面向对象的语言)来连接数据库服务器并与之交互。利用动态<code>SQL</code>可以在运行时以字符串形式构建<code>SQL</code>查询,提交查询,然后把结果存入程序变量中,每次一个元组。动态<code>SQL</code>的<code>SQL</code>组件允许程序在运行时构建和提交<code>SQL</code>查询。<ul><li>在这一章中,我们将介绍两种用于连接到<code>SQL</code>数据库并执行查询和更新的标准。一种是<code>Java</code>语言的应用程序接口<code>JDBC</code>(5.1.1节)。另一种是<code>ODBC</code>(5.1.2节),<code>ODBC</code>最初是为C语言开发的,后来扩展到其他语言如C++、C#和<code>Visual basic</code>。</li></ul></li><li>嵌入式<code>SQL</code>:与动态<code>SQL</code>类似,嵌人式<code>SL</code>提供了另外一种使程序与数据库服务器交互的手段。然而,嵌入式<code>S0L</code>语句必须在编译时全部确定,并交给预处理器。预处理程序提交<code>SQL</code>语句到数据库系统进行预编译和优化,然后它把应用程序中的<code>SQL</code>语句替换成相应的代码和函数,最后调用程序语言的编译器进行编译。5.1.3节涵盖嵌入式<code>SQL</code>的内容。</li></ol><h2 id="把SQL与通用程序语言相结合的问题"><a href="#把SQL与通用程序语言相结合的问题" class="headerlink" title="把SQL与通用程序语言相结合的问题"></a>把<code>SQL</code>与通用程序语言相结合的问题</h2><p>把<code>SQL</code>与通用程序语言相结合的主要挑战是:<br>这些语言<strong>处理数据的方式互不兼容</strong>。</p><ul><li>在<code>SOL</code>中,数据的主要类型是<strong>关系</strong>。<code>SQL</code>语句在关系上进行操作,并返回关系作为结果。</li><li>程序设计语言通常<strong>一次操作一个变量</strong>,这些变量大致相当于关系中一个元组的一个属性的值。</li><li>因此,为了在同一应用中整合这两类语言,必须提供一种转换机制,使得程序语言可以处理查询的返回结果</li></ul><h2 id="可先学习数据库设计-在看本章"><a href="#可先学习数据库设计-在看本章" class="headerlink" title="可先学习数据库设计 在看本章"></a>可先学习数据库设计 在看本章</h2><p>注意关于章节的先后顺序:<br>数据库设计(第7章和第8章)可以脱离本章独立学习。<br>完全可以先学习数据库设计,再读本章内容。然而,对于强调编程能力的课程而言,在学习了5.1节之后可以做更多的实验练习,所以我们建议在学习数据库设计之前先掌握这部分的内容。</p><!--SSTStop-->]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第5章 高级SQL </category>
          
          <category> 5.1 使用程序设计语言访问数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5.0 第5章 高级SQL概述</title>
      <link href="/ReadingNotes//f0c457d2/"/>
      <url>/ReadingNotes//f0c457d2/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/f0c457d2/#第5章-高级SQL" class="header_1">第5章 高级SQL</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="第5章-高级SQL"><a href="#第5章-高级SQL" class="headerlink" title="第5章 高级SQL"></a>第5章 高级SQL</h1><p>在第3章和第4章我们详细地介绍了<code>SQL</code>的基本结构。在本章中我们将介绍<code>SQL</code>的一些高级特性。</p><ul><li>本章首先介绍如何<strong>使用通用程序设计语言来访问<code>SQL</code></strong>,这对于构建用数据库存取数据的应用有重要意义。</li><li>我们将介绍两种<strong>在数据库中执行程序代码</strong>的方法:<ul><li>一种是通过扩展<code>SQL</code>语言来支持程序的操作;</li><li>另一种是在数据库中执行程序语言中定义的函数。</li></ul></li><li>接下来本章将介绍<strong>触发器</strong>,用于说明当特定事件(例如在某个表上进行元组插入、删除或更新操作)发生时<strong>自动执行</strong>的操作。</li><li>然后本章将讨论<strong>递归查询</strong>和<code>SQL</code>支持的<strong>高级聚集</strong>特性。</li><li>最后,我们将<strong>对联机分析处理</strong>(<code>OLAP</code>)系统加以介绍,它可用于海量数据的交互分析。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第5章 高级SQL </category>
          
          <category> 5.0 第5章 高级SQL概述 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.7 总结</title>
      <link href="/ReadingNotes//f10682c3/"/>
      <url>/ReadingNotes//f10682c3/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/f10682c3/#4-7-总结" class="header_1">4.7 总结</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="4-7-总结"><a href="#4-7-总结" class="headerlink" title="4.7 总结"></a>4.7 总结</h1><ul><li><code>SQL</code>支持包括<code>内连接</code>、<code>外连接</code>在内的几种连接类型,以及几种形式的连接条件。</li><li><strong><code>视图关系</code>可以定义为<code>包含查询结果的关系</code></strong>。视图是有用的,它可以隐藏不需要的信息,可以把信息从多个关系收集到一个单一的视图中。</li><li><strong>事务是一个査询和更新的序列</strong>,它们共同执行某项任务。事务可以被提交或回滚。当一个事务被回滚,该事务执行的所有更新所带来的影响将被撤销。</li><li><strong>完整性约束</strong>保证授权用户对数据库所做的改变不会导致数据<strong>一致性</strong>的破坏。</li><li><strong>参照完整性约束</strong>保证出<strong>现在一个关系的给定属性集上的值同样出现在另一个关系的特定属性集上</strong>。</li><li><strong>域约束</strong>指定了在一个属性上可能取值的集合。这种约束也可以禁止在特定属性上使用空值。</li><li><strong>断言</strong>是描述性表达式,它指定了我们要求总是为真的谓词。</li><li><code>SQL</code>数据定义语言提供对定义诸如<code>date</code>和<code>time</code>那样的固有域类型以及用户定义域类型的支持。</li><li>通过<code>SQL</code>授权机制,可以按照在数据库中不同数据值上数据库用户所允许的访问类型对他们进行区分。</li><li>获得了某种形式<strong>授权</strong>的用户可能允许将此授权传递给其他用户。但是,对于权限怎样在用户间传递我们必须很小心,以保证这样的权限在将来的某个时候可以被收回。</li><li><strong>角色</strong>有助于根据用户在组织机构中所扮演的角色,把<strong>一组权限</strong>分配给用户<!--SSTStop--></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第4章 中级SQL </category>
          
          <category> 4.7 总结 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.6.6 权限的收回</title>
      <link href="/ReadingNotes//54af8ee3/"/>
      <url>/ReadingNotes//54af8ee3/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/54af8ee3/#4-6-6-权限的收回" class="header_1">4.6.6 权限的收回</a>&nbsp;<br><a href="/ReadingNotes/54af8ee3/#默认级联收回" class="header_2">默认级联收回</a>&nbsp;<br><a href="/ReadingNotes/54af8ee3/#如何防止级联回收" class="header_2">如何防止级联回收</a>&nbsp;<br><a href="/ReadingNotes/54af8ee3/#级联收回的问题" class="header_2">级联收回的问题</a>&nbsp;<br><a href="/ReadingNotes/54af8ee3/#通过一个角色来授权" class="header_2">通过一个角色来授权</a>&nbsp;<br><a href="/ReadingNotes/54af8ee3/#将会话和当前角色进行关联" class="header_3">将会话和当前角色进行关联</a>&nbsp;<br><a href="/ReadingNotes/54af8ee3/#如何授权给角色" class="header_3">如何授权给角色</a>&nbsp;<br><a href="/ReadingNotes/54af8ee3/#授权给角色可以避免级联回收的问题" class="header_3">授权给角色可以避免级联回收的问题</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="4-6-6-权限的收回"><a href="#4-6-6-权限的收回" class="headerlink" title="4.6.6 权限的收回"></a>4.6.6 权限的收回</h1><p>假设数据库管理员决定收回用户U1的授权。由于U4从U1处获得过授权,因此其权限也应该被收回。可是,U5既从U1处又从U2处获得过授权。由于数据库管理员没有从U2处收回<code>teaches</code>上的更新权限,U5继续拥有<code>teaches</code>上的更新权限。如果U2最终从U5处收回授权,则U5失去权限。<br>对狡猾的用户可能企图通过相互授权来破坏权限收回规则。例如,如果U2最初由数据库管理员授予了一种权限,U2进而把此权限授予给U3。假设U3现在把此权限授回给U2。如果数据库管理员从U2收回权限,看起来好像U2保留了通过U3获得的授权。然而,注意一旦管理员从U2收回权限,在授权图中就不存在从根到U2或U3的路径了。这样,<code>SQL</code>保证从这两个用户那里都收回了权限。</p><h2 id="默认级联收回"><a href="#默认级联收回" class="headerlink" title="默认级联收回"></a>默认级联收回</h2><p>正如我们刚才看到的那样,从一个用户/角色那里收回权限可能导致其他用户/角色也失去该权限。这一行为称作<strong>级联收回</strong>。在大多数的数据库系统中,<strong>级联是默认行为</strong>。</p><h2 id="如何防止级联回收"><a href="#如何防止级联回收" class="headerlink" title="如何防止级联回收"></a>如何防止级联回收</h2><p>然而, <code>revoke</code>语句可以申明<code>restrict</code>来防止级联收回:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">revoke</span> <span class="keyword">select</span></span><br><span class="line"><span class="keyword">on</span> department</span><br><span class="line"><span class="keyword">from</span> Amit,Satoshi restrict;</span><br></pre></td></tr></table></figure><br>注意一些数据库实现不支持上述语法;它们采用另一种方式:收回权限本身,然后不带<code>grant option</code>重新授权。</p><h2 id="级联收回的问题"><a href="#级联收回的问题" class="headerlink" title="级联收回的问题"></a>级联收回的问题</h2><p>级联收回在许多情况下是不合适的。假定<code>Satoshi</code>具有<code>dean</code>角色,他将<code>instructor</code>授给<code>Amit</code>,后来<code>dean</code>角色从<code>Satoshi</code>收回(也许由于<code>Satoshi</code>离开了大学);<code>Amit</code>继续被雇佣为教职工,并且还应该保持<code>dean</code>角色。</p><h2 id="通过一个角色来授权"><a href="#通过一个角色来授权" class="headerlink" title="通过一个角色来授权"></a>通过一个角色来授权</h2><p>为了处理以上情况,<code>SQL</code>允许权限由一个<strong>角色授予</strong>,而不是由用户来授予。<code>SQL</code>有一个与会话所关联的当前角色的概念。默认情况下,一个会话所关联的当前角色是空的(某些特殊情况除外)。</p><h3 id="将会话和当前角色进行关联"><a href="#将会话和当前角色进行关联" class="headerlink" title="将会话和当前角色进行关联"></a>将会话和当前角色进行关联</h3><p><strong>执行<code>set role role_name</code>可以设置一个会话所关联的当前角色</strong>。这个指定的角色必须已经授予给用户,否则<code>set role</code>语句执行失败。</p><h3 id="如何授权给角色"><a href="#如何授权给角色" class="headerlink" title="如何授权给角色"></a>如何授权给角色</h3><p>如果要<strong>在授予权限时将授权人设置为一个会话所关联的当前角色</strong>,并且当前角色不为空的话,我们可以在授权语句后面加上:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">granted by current_role</span><br></pre></td></tr></table></figure><br>子句</p><h3 id="授权给角色可以避免级联回收的问题"><a href="#授权给角色可以避免级联回收的问题" class="headerlink" title="授权给角色可以避免级联回收的问题"></a>授权给角色可以避免级联回收的问题</h3><p>假设将角色<code>instructor</code>(或其他权限)授给<code>Amit</code>是用<code>granted by current_role</code>子句实现的,当前角色被设置为<code>dean</code>而不是授权人(用户<code>Satoshi</code>),这样,即使在<code>Satoshi</code>的权限被收回后,<code>Amit</code>仍然能够保持<code>instructor</code>角色。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第4章 中级SQL </category>
          
          <category> 4.6 授权 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.6.5 权限的转移</title>
      <link href="/ReadingNotes//f539374f/"/>
      <url>/ReadingNotes//f539374f/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/f539374f/#4-6-5-权限的转移" class="header_1">4.6.5 权限的转移</a>&nbsp;<br><a href="/ReadingNotes/f539374f/#对象创建者拥有该对象的所有的权限" class="header_2">对象创建者拥有该对象的所有的权限</a>&nbsp;<br><a href="/ReadingNotes/f539374f/#授权图" class="header_2">授权图</a>&nbsp;<br><a href="/ReadingNotes/f539374f/#顶点" class="header_3">顶点</a>&nbsp;<br><a href="/ReadingNotes/f539374f/#根" class="header_3">根</a>&nbsp;<br><a href="/ReadingNotes/f539374f/#实例" class="header_3">实例</a>&nbsp;<br><a href="/ReadingNotes/f539374f/#用户具有权限的充分必要条件" class="header_3">用户具有权限的充分必要条件</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="4-6-5-权限的转移"><a href="#4-6-5-权限的转移" class="headerlink" title="4.6.5 权限的转移"></a>4.6.5 权限的转移</h1><p>获得了某些形式授权的用户可能被允许将此授权传递给其他用户。</p><ul><li>在默认方式下,被授予权限的用户/角色无权把得到的权限再授予给另外的用户/角色。</li><li>如果我们在授权时允许接受者把得到的权限再传递给其他用户,我们可以在相应的<code>grant</code>命令后面附加<code>with grant option</code>子句。</li></ul><p>例如,如果我们希望授予<code>Amit</code>在<code>departmen</code>上的<code>select</code>权限,并且允许<code>Amit</code>将该权限授予给其他用户,我们可以写:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span></span><br><span class="line"><span class="keyword">on</span> department <span class="keyword">to</span></span><br><span class="line">Amit <span class="keyword">with</span> <span class="keyword">grant</span> <span class="keyword">option</span>;</span><br></pre></td></tr></table></figure></p><h2 id="对象创建者拥有该对象的所有的权限"><a href="#对象创建者拥有该对象的所有的权限" class="headerlink" title="对象创建者拥有该对象的所有的权限"></a>对象创建者拥有该对象的所有的权限</h2><p>一个对象(关系/视图/角色)的创建者拥有该对象上的全部权限,包括给其他用户授权的权限。<br>作为一个例子,考虑大学数据库中<code>teaches</code>关系上更新权限的授予。假设最初数据库管理员将<code>teaches</code>上的更新权限授给用户U1、U2和U3,他们接下来又可以将这一授权传递给其他用户。</p><h2 id="授权图"><a href="#授权图" class="headerlink" title="授权图"></a>授权图</h2><p>指定权限从一个用户到另一个用户的传递可以表示为授权图(<code>authorization graph</code>)。</p><h3 id="顶点"><a href="#顶点" class="headerlink" title="顶点"></a>顶点</h3><p>图中的<code>顶点</code>代表的是<code>用户</code>。</p><h3 id="根"><a href="#根" class="headerlink" title="根"></a>根</h3><p>授权图中的根就是代表数据库管理员的顶点</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>考虑<code>teaches</code>上更新权限所对应的授权图。如果用户<code>Ui</code>,将<code>teaches</code>上的更新权限授给<code>Uj</code>,则图中包含边<code>Ui</code>→<code>Uj</code>。图的根是数据库管理员。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/ShuJuKuXiTongGaiNian/ch4/1.png" alt="这里有一张图片"><br>在图4-10所示的示例图中,注意U1和U2都给用户U5授权了;而U4只从U1处获得了授权。</p><h3 id="用户具有权限的充分必要条件"><a href="#用户具有权限的充分必要条件" class="headerlink" title="用户具有权限的充分必要条件"></a>用户具有权限的充分必要条件</h3><p>当且仅当<code>存在</code>从授权图的根到代表该用户顶点的<code>路径</code>。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第4章 中级SQL </category>
          
          <category> 4.6 授权 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.6.4 模式的授权</title>
      <link href="/ReadingNotes//551e0b85/"/>
      <url>/ReadingNotes//551e0b85/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/551e0b85/#4-6-4-模式的授权" class="header_1">4.6.4 模式的授权</a>&nbsp;<br><a href="/ReadingNotes/551e0b85/#references权限" class="header_2">references权限</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="4-6-4-模式的授权"><a href="#4-6-4-模式的授权" class="headerlink" title="4.6.4 模式的授权"></a>4.6.4 模式的授权</h1><p><code>SQL</code>标准为数据库模式指定了一种基本的授权机制:<br>只有<strong>模式的拥有者</strong>才能够执行对模式的任何修改,诸如:</p><ul><li>创建或删除关系,</li><li>增加或删除关系的属性,</li><li>以及增加或删除索引。</li></ul><h2 id="references权限"><a href="#references权限" class="headerlink" title="references权限"></a>references权限</h2><p>然而,<code>SQL</code>提供了一种<code>references</code>权限,允许用户在创建关系时声明外码。<code>SQL</code>的<code>references</code>权限可以与<code>update</code>权限类似的方式授予到特定属性上。<br>下面的<code>grant</code>语句允许用户<code>Mariano</code>创建这样的关系,它能够参照<code>department</code>关系的码<code>dept_name</code>:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">references</span>(dept_name)</span><br><span class="line"><span class="keyword">on</span> department</span><br><span class="line"><span class="keyword">to</span> Mariano;</span><br></pre></td></tr></table></figure><br>初看起来,似乎没有理由不允许用户创建参照了其他关系的外码。但是,回想一下<strong>外码约束限制了被参照关系上的删除和更新操作</strong>。假定<code>Mariano</code>在关系r中创建了一个外码,它参照<code>department</code>关系的<code>dept_name</code>属性,然后在r中插入一条属于<code>Geology</code>系的元组。那么就再也不可能从<code>department</code>关系中将<code>geology</code>系删除,除非同时也修改关系r。这样, <code>Mariano</code>定义的外码限制了其他用户将来的行为;因此,需要有<code>references</code>权限。<br>继续使用<code>department</code>关系的例子,如果要创建关系r上的<code>check</code>约束,并且该约束有参照<code>department</code>的子查询,那么还需要有<code>department</code>上的<code>references</code>权限。其原因与外码约束的情况类似,因为<strong>参照了一个关系的<code>check</code>约束限制了对该关系可能的更新</strong><br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第4章 中级SQL </category>
          
          <category> 4.6 授权 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.6.3 视图的授权</title>
      <link href="/ReadingNotes//28f0e5b2/"/>
      <url>/ReadingNotes//28f0e5b2/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/28f0e5b2/#4-6-3-视图的授权" class="header_1">4.6.3 视图的授权</a>&nbsp;<br><a href="/ReadingNotes/28f0e5b2/#创建视图的用户不会得到该视图上的全部权限" class="header_2">创建视图的用户不会得到该视图上的全部权限</a>&nbsp;<br><a href="/ReadingNotes/28f0e5b2/#用户对视图的权限从定义视图的关系中继承得到" class="header_2">用户对视图的权限从定义视图的关系中继承得到</a>&nbsp;<br><a href="/ReadingNotes/28f0e5b2/#函数和过程的权限默认和创建者的权限一样" class="header_2">函数和过程的权限默认和创建者的权限一样</a>&nbsp;<br><a href="/ReadingNotes/28f0e5b2/#设置函数和过程的权限与调用者的权限一样" class="header_2">设置函数和过程的权限与调用者的权限一样</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="4-6-3-视图的授权"><a href="#4-6-3-视图的授权" class="headerlink" title="4.6.3 视图的授权"></a>4.6.3 视图的授权</h1><p>在我们的大学例子中,考虑有一位工作人员,他需要知道一个给定系(比如<code>Geology</code>系)里所有员工的工资。该工作人员无权看到其他系中员工的相关信息。因此,该工作人员对<code>instructor</code>关系的直接访问必须被禁止。但是,如果他要访问<code>Geology</code>系的信息,就必须得到在一个视图上的访问权限,我们称该视图为<code>geo_instructor</code>,它仅由属于<code>Geology</code>系的那些<code>instructor</code>元组构成。该视图可以用<code>SQL</code>定义如下:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> geo_instructor</span><br><span class="line"><span class="keyword">as</span>(</span><br><span class="line">    <span class="keyword">select</span> *</span><br><span class="line">    <span class="keyword">from</span> instructor</span><br><span class="line">    <span class="keyword">where</span> dept_name=<span class="string">'Geology'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><br>假设该工作人员提出如下<code>SQL</code>查询:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> geo_instructor;</span><br></pre></td></tr></table></figure><br>显然,该工作人员有权看到此查询的结果。但是,当查询处理器将此查询转换为数据库中实际关系上的査询时,它产生了一个在<code>instructor</code>上的查询。这样,系统必须在开始查询处理以前,就检查该工作人员查询的权限。</p><h2 id="创建视图的用户不会得到该视图上的全部权限"><a href="#创建视图的用户不会得到该视图上的全部权限" class="headerlink" title="创建视图的用户不会得到该视图上的全部权限"></a>创建视图的用户不会得到该视图上的全部权限</h2><p><strong>创建视图的用户不需要获得该视图上的全部权限</strong>。他得到的那些权限不会为他提供超越他已有权限的额外授权。</p><h2 id="用户对视图的权限从定义视图的关系中继承得到"><a href="#用户对视图的权限从定义视图的关系中继承得到" class="headerlink" title="用户对视图的权限从定义视图的关系中继承得到"></a>用户对视图的权限从定义视图的关系中继承得到</h2><p>例如,<strong>如果一个创建视图的用户在用来定义视图的关系上没有<code>update</code>权限的话,那么他不能得到视图上的<code>update</code>权限</strong>。<br>如果用户创建一个视图,而此用户在该视图上不能获得任何权限,系统会拒绝这样的视图创建请求。<br>在我们的<code>geo_instructor</code>视图例子中,视图的创建者必须在<code>instructor</code>关系上具有<code>select</code>权限。</p><h2 id="函数和过程的权限默认和创建者的权限一样"><a href="#函数和过程的权限默认和创建者的权限一样" class="headerlink" title="函数和过程的权限默认和创建者的权限一样"></a>函数和过程的权限默认和创建者的权限一样</h2><p>正如我们将在5.2节看到的那样,<code>SQL</code>支持创建<code>函数</code>和<code>过程</code>,在函数和过程中可以包括<code>查询</code>与<code>更新</code>。在函数或过程上可以授予<code>execute</code>权限,以允许用户执行该函数或过程。在默认情况下,和视图类似,<strong>函数和过程具有其创建者所拥有的所有权限</strong>。在效果上,<strong>该函数或过程的运行就像其被创建者调用了那样</strong>。</p><h2 id="设置函数和过程的权限与调用者的权限一样"><a href="#设置函数和过程的权限与调用者的权限一样" class="headerlink" title="设置函数和过程的权限与调用者的权限一样"></a>设置函数和过程的权限与调用者的权限一样</h2><p>尽管此行为在很多情况下是恰当的,但是它并不总是恰当的。从<code>SQL:2003</code>开始,如果函数定义有一个额外的<code>sql security invoker</code>子句,那么它就在调用该函数的用户的权限下执行,而不是在函数定义者的权限下执行。这就允许创建的函数库能够在与调用者相同的权限下运行。</p><!--SSTStop-->]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第4章 中级SQL </category>
          
          <category> 4.6 授权 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.6.2 角色</title>
      <link href="/ReadingNotes//d81d2aeb/"/>
      <url>/ReadingNotes//d81d2aeb/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/d81d2aeb/#4-6-2-角色" class="header_1">4.6.2 角色</a>&nbsp;<br><a href="/ReadingNotes/d81d2aeb/#方式1" class="header_2">方式1</a>&nbsp;<br><a href="/ReadingNotes/d81d2aeb/#方式2" class="header_2">方式2</a>&nbsp;<br><a href="/ReadingNotes/d81d2aeb/#角色" class="header_2">角色</a>&nbsp;<br><a href="/ReadingNotes/d81d2aeb/#方式3" class="header_2">方式3</a>&nbsp;<br><a href="/ReadingNotes/d81d2aeb/#如何创建角色" class="header_2">如何创建角色</a>&nbsp;<br><a href="/ReadingNotes/d81d2aeb/#角色可以授予用户-角色可以授予其他角色" class="header_2">角色可以授予用户 角色可以授予其他角色</a>&nbsp;<br><a href="/ReadingNotes/d81d2aeb/#一个用户或角色拥有的权限" class="header_2">一个用户或角色拥有的权限</a>&nbsp;<br><a href="/ReadingNotes/d81d2aeb/#角色链-后面角色继承得到前面角色的权限" class="header_2">角色链 后面角色继承得到前面角色的权限</a>&nbsp;<br><a href="/ReadingNotes/d81d2aeb/#-SQL-标准中没有基于角色的授权概念" class="header_2">`SQL`标准中没有基于角色的授权概念</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="4-6-2-角色"><a href="#4-6-2-角色" class="headerlink" title="4.6.2 角色"></a>4.6.2 角色</h1><p>考虑在一个大学里不同人所具有的真实世界角色。每个教师必须在同一组关系上具有同种类型的权限。</p><h2 id="方式1"><a href="#方式1" class="headerlink" title="方式1"></a>方式1</h2><p>单独给每一个新的教师授予所有这些权限.</p><h2 id="方式2"><a href="#方式2" class="headerlink" title="方式2"></a>方式2</h2><p>一种更好的方式是</p><ul><li>指明所有教师应该被授予的权限,</li><li>并单独标示出哪些数据库用户是教师。</li></ul><p>系统可以利用这两条信息来确定每位教师的权限。当雇佣了一位新的教师时,必须给他分配一个用户标识符,并且必须将他标示为一位教师,而不需要重新单独授予教师权限。</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><p><strong>角色</strong>(<code>role</code>)的概念适用于此观念。<strong>在数据库中建立一个<code>角色集</code>,可以给角色授予权限,就和给每个用户授权的方式完全一样。每个数据库用户被授予一组他有权扮演的角色</strong>(也可能是空的)。</p><p>在我们的大学数据库里,角色的例子可以包括<code>instructor</code>、 <code>teaching_assistant</code>、 <code>student</code>、<code>dean</code>和<code>department_chair</code>。</p><h2 id="方式3"><a href="#方式3" class="headerlink" title="方式3"></a>方式3</h2><p>另一个不是很合适的方法是建立一个<code>instructor</code>用户标识,允许每位教师用<code>instructor</code>用户标识来连接数据库。该方式的问题是它不可能鉴别出到底是哪位教师执行了数据库更新,从而导致安全隐患。使用角色的好处是需要用户用他们自己的用户标识来连接数据库。</p><h2 id="如何创建角色"><a href="#如何创建角色" class="headerlink" title="如何创建角色"></a>如何创建角色</h2><p>任何可以授予给用户的权限都可以授予给角色。给用户授予角色就跟给用户授权一样。<br>在<code>SQL</code>中创建角色如下所示:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">role</span> instructor;</span><br></pre></td></tr></table></figure><br>然后角色就可以像用户那样被授予权限,如在这样的语句中:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span></span><br><span class="line"><span class="keyword">on</span> takes</span><br><span class="line"><span class="keyword">to</span> instructor;</span><br></pre></td></tr></table></figure><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create role instructor;</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; grant select</span><br><span class="line">on takes</span><br><span class="line">to instructor;</span><br><span class="line">Query OK, 0 rows affected (0.02 sec);</span><br></pre></td></tr></table></figure></p><h2 id="角色可以授予用户-角色可以授予其他角色"><a href="#角色可以授予用户-角色可以授予其他角色" class="headerlink" title="角色可以授予用户 角色可以授予其他角色"></a>角色可以授予用户 角色可以授予其他角色</h2><p>角色可以授予给用户,也可以授予给其他角色,如这样的语句:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">role</span> dean;</span><br><span class="line"><span class="keyword">grant</span> dean</span><br><span class="line">    <span class="keyword">to</span> Amit;</span><br><span class="line"><span class="keyword">grant</span> instructor</span><br><span class="line">    <span class="keyword">to</span> deangrant;</span><br><span class="line"><span class="keyword">grant</span> dean</span><br><span class="line">    <span class="keyword">to</span> Satoshi;</span><br></pre></td></tr></table></figure></p><h2 id="一个用户或角色拥有的权限"><a href="#一个用户或角色拥有的权限" class="headerlink" title="一个用户或角色拥有的权限"></a>一个用户或角色拥有的权限</h2><p>因此,一个用户或一个角色的拥有的权限包括:</p><ul><li>所有<code>直接授予</code>该用户或该角色的权限。</li><li>其他<code>角色授予</code>给该用户或该角色的权限。</li></ul><h2 id="角色链-后面角色继承得到前面角色的权限"><a href="#角色链-后面角色继承得到前面角色的权限" class="headerlink" title="角色链 后面角色继承得到前面角色的权限"></a>角色链 后面角色继承得到前面角色的权限</h2><p>注意可能存在着一个<strong>角色链</strong>;例如,</p><ul><li>角色<code>teaching_assistant</code>可能被授予所有的角色<code>instructor</code>。</li><li>接着,角色<code>instructor</code>被授予所有的角色<code>dean</code>。</li></ul><p>这样,角色<code>dean</code>就继承了所有被授予给角色<code>instructor</code>和<code>teaching_assistant</code>的权限,还包括直接赋给<code>dean</code>的权限。</p><p>当一个用户登录到数据库系统时,在此会话中用户执行的动作拥有所有直接授予该用户的权限,以及所有(直接地或通过其他角色间接地)授予该用户所拥有角色的权限。</p><p>这样,如果一个用户<code>Amit</code>被授予了角色<code>dean</code>,用户<code>Amit</code>就拥有所有直接授予给<code>Amit</code>的权限,以及授予给<code>dean</code>的权限,再加上授予给<code>instructor</code>和<code>teaching_assistant</code>的权限.</p><h2 id="SQL标准中没有基于角色的授权概念"><a href="#SQL标准中没有基于角色的授权概念" class="headerlink" title="SQL标准中没有基于角色的授权概念"></a><code>SQL</code>标准中没有基于角色的授权概念</h2><p>值得注意的是,<strong>基于角色的授权概念并没有在<code>SQL</code>中指定</strong>,但在很多的共享应用中,基于角色的授权被广泛应用于存取控制。</p><!--SSTStop-->]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第4章 中级SQL </category>
          
          <category> 4.6 授权 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.6 授权 4.6.1 权限的授予与收回</title>
      <link href="/ReadingNotes//bfa99204/"/>
      <url>/ReadingNotes//bfa99204/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/bfa99204/#4-6-授权" class="header_1">4.6 授权</a>&nbsp;<br><a href="/ReadingNotes/bfa99204/#对-数据-的授权" class="header_2">对`数据`的授权</a>&nbsp;<br><a href="/ReadingNotes/bfa99204/#数据库模式上的授权" class="header_2">数据库模式上的授权</a>&nbsp;<br><a href="/ReadingNotes/bfa99204/#权限转授-权限回收" class="header_2">权限转授 权限回收</a>&nbsp;<br><a href="/ReadingNotes/bfa99204/#数据库管理员" class="header_2">数据库管理员</a>&nbsp;<br><a href="/ReadingNotes/bfa99204/#4-6-1-权限的授予与收回" class="header_1">4.6.1 权限的授予与收回</a>&nbsp;<br><a href="/ReadingNotes/bfa99204/#授予权限" class="header_2">授予权限</a>&nbsp;<br><a href="/ReadingNotes/bfa99204/#select权限" class="header_2">select权限</a>&nbsp;<br><a href="/ReadingNotes/bfa99204/#update权限" class="header_2">update权限</a>&nbsp;<br><a href="/ReadingNotes/bfa99204/#在关系上的指定属性列表上授权update" class="header_3">在关系上的指定属性列表上授权update</a>&nbsp;<br><a href="/ReadingNotes/bfa99204/#默认在关系上的全部属性上授权update" class="header_3">默认在关系上的全部属性上授权update</a>&nbsp;<br><a href="/ReadingNotes/bfa99204/#insert权限" class="header_2">insert权限</a>&nbsp;<br><a href="/ReadingNotes/bfa99204/#delete权限" class="header_2">delete权限</a>&nbsp;<br><a href="/ReadingNotes/bfa99204/#对public用户授权" class="header_2">对public用户授权</a>&nbsp;<br><a href="/ReadingNotes/bfa99204/#-MySQL-8-0-grant语句报错-You-are-not-allowed-to-create-a-user-with-GRANT" class="header_2">`MySQL` 8.0 grant语句报错: You are not allowed to create a user with GRANT</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="4-6-授权"><a href="#4-6-授权" class="headerlink" title="4.6 授权"></a>4.6 授权</h1><p>我们可能会给一个用户在数据库的某些部分授予几种形式的权限。</p><h2 id="对数据的授权"><a href="#对数据的授权" class="headerlink" title="对数据的授权"></a>对<code>数据</code>的授权</h2><p>对<code>数据</code>的授权包括:</p><ul><li>授权<code>读取</code>数据。</li><li>授权<code>插入</code>新数据。</li><li>授权<code>更新</code>数据。</li><li>授权<code>删除</code>数据。</li></ul><p>每种类型的授权都称为一个权限(<code>privilege</code>)。我们可以在数据库的某些特定部分(如一个关系或视图)上授权给用户所有这些类型的权限,或者完全不授权,或者这些权限的一个组合。<br>当用户提交查询或更新时,<code>SQL</code>执行先基于该用户曾获得过的权限来检查此查询或更新是否是授权过的。<strong>如果查询或更新没有经过授权,那么将拒绝执行这个查询或更新</strong>。</p><h2 id="数据库模式上的授权"><a href="#数据库模式上的授权" class="headerlink" title="数据库模式上的授权"></a>数据库模式上的授权</h2><p>除了在数据上的授权之外,用户还可以被授予在<code>数据库模式</code>上的权限,例如,可以允许用户<code>创建</code>、<code>修改</code>或<code>删除</code>关系。</p><h2 id="权限转授-权限回收"><a href="#权限转授-权限回收" class="headerlink" title="权限转授 权限回收"></a>权限转授 权限回收</h2><p>拥有某些形式的权限的用户还可以把这样的<code>权限转授</code>(授予)给其他用户,或者撤销收回)一种此前授出的权限。本节我们将学习每个这样的权限是如何用<code>SQL</code>来指定的。</p><h2 id="数据库管理员"><a href="#数据库管理员" class="headerlink" title="数据库管理员"></a>数据库管理员</h2><p>最大的授权形式是被授予<strong>数据库管理员</strong>的。数据库管理员可以<code>授权新用户</code>、<code>重构数据库</code>,等等这种权限方式和操作系统中的超级用户、管理员或操作员的权限是类似的。</p><h1 id="4-6-1-权限的授予与收回"><a href="#4-6-1-权限的授予与收回" class="headerlink" title="4.6.1 权限的授予与收回"></a>4.6.1 权限的授予与收回</h1><p><code>SQL</code>标准包括<code>select</code>、 <code>insert</code>、 <code>update</code>和<code>delete</code>权限。<br>(<code>all privileges</code>)可以用作全部允许的权限的简写形式。<strong>一个创建了新关系的用户将自动被授予该关系上的全部权限</strong><br><code>SQL</code>数据定义语言包括<code>授予</code>和<code>收回权限</code>的命令。</p><h2 id="授予权限"><a href="#授予权限" class="headerlink" title="授予权限"></a>授予权限</h2><p><code>grant</code>语句用来授予权限。此语句的基本形式为<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> 权限列表</span><br><span class="line"><span class="keyword">on</span> 关系名或视图名</span><br><span class="line"><span class="keyword">to</span> 用户或角色列表;</span><br></pre></td></tr></table></figure><br><strong>权限列表</strong>使得一个命令可以授予多个权限。<br><strong>角色</strong>的概念将在后面4.6.2节讨论。</p><h2 id="select权限"><a href="#select权限" class="headerlink" title="select权限"></a>select权限</h2><p>关系上的<code>select</code>权限用于读取关系中的元组。下面的<code>grant</code>语句授予数据库用户<code>Amit</code>和<code>Satoshi</code>在<code>partment</code>关系上的<code>select</code>权限:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span></span><br><span class="line"><span class="keyword">on</span> department</span><br><span class="line"><span class="keyword">to</span> Amit,Satoshi;</span><br></pre></td></tr></table></figure><br>该授权使得这些用户可以在<code>department</code>关系上执行查询。</p><h2 id="update权限"><a href="#update权限" class="headerlink" title="update权限"></a>update权限</h2><p>关系上的<code>update</code>权限允许用户修改关系中的任意元组。<br><code>update</code>权限既可以在关系的全部的属性上授予,又可以只在某些属性上授予。</p><h3 id="在关系上的指定属性列表上授权update"><a href="#在关系上的指定属性列表上授权update" class="headerlink" title="在关系上的指定属性列表上授权update"></a>在关系上的指定属性列表上授权update</h3><p>如果<code>grant</code>语句中包括<code>update</code>权限,将被授予<code>update</code>权限的<code>属性列表</code>可以出现在紧跟关键字<code>update</code>的括号中。</p><h3 id="默认在关系上的全部属性上授权update"><a href="#默认在关系上的全部属性上授权update" class="headerlink" title="默认在关系上的全部属性上授权update"></a>默认在关系上的全部属性上授权update</h3><p>属性列表是可选项,如果省略属性列表,则授予的是关系中全部属性上的<code>update</code>权限。<br>下面的<code>grant</code>语句授予用户<code>Amit</code>和<code>Satoshi</code>在<code>department</code>关系的<code>budget</code>属性上的更新权限:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">update</span>(budget)</span><br><span class="line"><span class="keyword">on</span> department</span><br><span class="line"><span class="keyword">to</span> Amit,Satoshi;</span><br></pre></td></tr></table></figure></p><h2 id="insert权限"><a href="#insert权限" class="headerlink" title="insert权限"></a>insert权限</h2><p>关系上的<code>insert</code>权限允许用户往关系中插入元组。 <code>insert</code>权限也可以<code>指定属性列表</code>;对关系所作的任何插入必须只针对这些属性,系统将其余属性要么赋默认值(如果这些属性上定义了默认值),要么赋<code>null</code>;   </p><h2 id="delete权限"><a href="#delete权限" class="headerlink" title="delete权限"></a>delete权限</h2><p>关系上的<code>delete</code>权限允许用户从关系中删除元组。</p><h2 id="对public用户授权"><a href="#对public用户授权" class="headerlink" title="对public用户授权"></a>对public用户授权</h2><p>用户名<code>public</code>指系统的所有当前用户和将来的用户。因此,对<code>public</code>的授权隐含着对所有当前用户和将来用户的授权。</p><p>我们使用<code>revoke</code>语句来收回权限。此语句的形式与<code>grant</code>几乎是一样的:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">revoke</span> 权限列表</span><br><span class="line"><span class="keyword">on</span> 关系名或视图名</span><br><span class="line"><span class="keyword">from</span> 用户或角色列表;</span><br></pre></td></tr></table></figure><br>因此,要收回前面我们所授予的那些权限,我们书写下列语句:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">revoke</span> <span class="keyword">select</span></span><br><span class="line"><span class="keyword">on</span> department</span><br><span class="line"><span class="keyword">from</span> Amit,Satoshi;</span><br></pre></td></tr></table></figure><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">revoke</span> <span class="keyword">update</span>(budget)</span><br><span class="line"><span class="keyword">on</span> department</span><br><span class="line"><span class="keyword">from</span> Amit,Satoshi;</span><br></pre></td></tr></table></figure><br>如果被收回权限的用户已经把权限授予了其他用户,权限的收回会更加复杂。我们将在4.6.5节回到这个问题。</p><h2 id="MySQL-8-0-grant语句报错-You-are-not-allowed-to-create-a-user-with-GRANT"><a href="#MySQL-8-0-grant语句报错-You-are-not-allowed-to-create-a-user-with-GRANT" class="headerlink" title="MySQL 8.0 grant语句报错: You are not allowed to create a user with GRANT"></a><code>MySQL</code> 8.0 grant语句报错: You are not allowed to create a user with GRANT</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; grant select</span><br><span class="line">on department</span><br><span class="line">to Amit,Satoshi;</span><br><span class="line"><span class="number">1410</span> - You are <span class="keyword">not</span> allowed to create a user with GRANT</span><br></pre></td></tr></table></figure><p>这是因为<code>MySQL 8.0</code>以前的版本可以使用<code>grant</code>在授权的时候<code>隐式的创建用户</code>,<code>MySQL 8.0</code>以后已经不支持,所以必须先创建用户,然后再授权。</p><!--SSTStop-->]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第4章 中级SQL </category>
          
          <category> 4.6 授权 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.5.7 模式 目录与环境</title>
      <link href="/ReadingNotes//10747125/"/>
      <url>/ReadingNotes//10747125/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/10747125/#4-5-7-模式-目录与环境" class="header_1">4.5.7 模式 目录与环境</a>&nbsp;<br><a href="/ReadingNotes/10747125/#关系名字的全称" class="header_2">关系名字的全称</a>&nbsp;<br><a href="/ReadingNotes/10747125/#默认目录中的关系可以省略目录名" class="header_2">默认目录中的关系可以省略目录名</a>&nbsp;<br><a href="/ReadingNotes/10747125/#访问其他非默认模式中的关系必须指定模式名" class="header_2">访问其他非默认模式中的关系必须指定模式名</a>&nbsp;<br><a href="/ReadingNotes/10747125/#默认模式中的关系也省略模式名" class="header_2">默认模式中的关系也省略模式名</a>&nbsp;<br><a href="/ReadingNotes/10747125/#使用目录和模式可以解决命名冲突" class="header_2">使用目录和模式可以解决命名冲突</a>&nbsp;<br><a href="/ReadingNotes/10747125/#-SQL-环境" class="header_2">`SQL`环境</a>&nbsp;<br><a href="/ReadingNotes/10747125/#如何创建和删除模式" class="header_2">如何创建和删除模式</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="4-5-7-模式-目录与环境"><a href="#4-5-7-模式-目录与环境" class="headerlink" title="4.5.7 模式 目录与环境"></a>4.5.7 模式 目录与环境</h1><p>要理解模式和目录的形成,需要考虑文件系统中文件是如何命名的。<strong>早期的文件系统是平面的</strong>,也就是说,<strong>所有的文件都存储在同一个目录下</strong>。当然,当代的文件系统有一个目录(或者文件夹)结构,文件都存储在子目录下。要单独命名一个文件,我们必须指定文件的完整路径名,例如,<code>/usersavi/db-book/chapter3.tex</code>。<br>跟早期文件系统一样,早期数据库系统也只为所有关系提供一个<strong>命名空间</strong>。用户不得不相互协调以保证他们没有对不同的关系使用同样的名字。当代数据库系统提供了<strong>三层结构</strong>的<strong>关系命名机制</strong>。</p><ol><li>最顶层由<strong>目录</strong>(<code>catalog</code>)构成,一些数据库实现用术语”数据库”代替术语”目录”</li><li>每个目录都可以包含<strong>模式</strong>(<code>schema</code>)。</li><li>诸如<code>关系</code>和<code>视图</code>那样的<code>SQL</code>对象都包含在模式中。</li></ol><p>要在数据库上做任何操作,用户(或程序)都必须先连接到数据库。为了验证用户身份,用户必须提供用户名以及密码(通常情况下)。<strong>每个用户都有一个默认的目录和模式</strong>,这个组合对用户来说是唯一的。<strong>当一个用户连接到数据库系统时,将为该连接设置好默认的目录和模式</strong>。这对应于当用户登录进一个操作系统时,把当前目录设置为用户的主(<code>home</code>)目录。</p><h2 id="关系名字的全称"><a href="#关系名字的全称" class="headerlink" title="关系名字的全称"></a>关系名字的全称</h2><p>为了唯一标识出一个关系,必须使用一个名字,它包含三部分,例如:<br><code>catalog5.univ_shema.course</code></p><h2 id="默认目录中的关系可以省略目录名"><a href="#默认目录中的关系可以省略目录名" class="headerlink" title="默认目录中的关系可以省略目录名"></a>默认目录中的关系可以省略目录名</h2><p>当名字的目录部分被认为是<strong>连接的默认目录时,可以省略目录部分</strong>。这样如果<code>catalog5</code>是默认目录,我们可以用<code>univ_shema.course</code>来唯一标识上述关系。</p><h2 id="访问其他非默认模式中的关系必须指定模式名"><a href="#访问其他非默认模式中的关系必须指定模式名" class="headerlink" title="访问其他非默认模式中的关系必须指定模式名"></a>访问其他非默认模式中的关系必须指定模式名</h2><p>如果用户想访问存在于另外的模式中的关系,而不是该用户的默认模式,那就必须指定模式的名字。</p><h2 id="默认模式中的关系也省略模式名"><a href="#默认模式中的关系也省略模式名" class="headerlink" title="默认模式中的关系也省略模式名"></a>默认模式中的关系也省略模式名</h2><p>然而,<strong>如果一个关系存在于特定用户的默认模式中,那么连模式的名字也可以省略</strong>。这样,如果<code>catalog5</code>是默认目录并且<code>univ_schema</code>是<strong>默认模式</strong>,我们可以只用<code>course</code>。</p><h2 id="使用目录和模式可以解决命名冲突"><a href="#使用目录和模式可以解决命名冲突" class="headerlink" title="使用目录和模式可以解决命名冲突"></a>使用目录和模式可以解决命名冲突</h2><p>当有多个目录和模式可用时,不同应用和不同用户可以独立工作而不必担心命名冲突。不仅如此,一个应用的多个版本(一个产品版本,其他是测试版本)可以在同一个数据库系统上运行。</p><h2 id="SQL环境"><a href="#SQL环境" class="headerlink" title="SQL环境"></a><code>SQL</code>环境</h2><ul><li><strong>默认目录和默认模式</strong>是为每个连接建立的<code>SQL</code>环境( <code>SQL environment</code>)的一部分。</li><li>除了默认目录和默认模式,<strong><code>SQL</code>环境</strong>还包括<code>用户标识</code>(也称为<strong>授权标识符</strong>)。</li><li><strong>所有通常的<code>SQL</code>语句</strong>,包括<code>DDL</code>和<code>DML</code>语句,<strong>都在一个模式的环境中运行</strong>。 </li></ul><h2 id="如何创建和删除模式"><a href="#如何创建和删除模式" class="headerlink" title="如何创建和删除模式"></a>如何创建和删除模式</h2><p>我们可以用<code>create schema</code>和<code>drop schema</code>语句来<strong>创建和删除模式</strong>。</p><ul><li>在大多数数据库系统中,<strong>模式还随着用户账户的创建而<code>自动创建</code></strong>,此时模式名被置为<code>用户账号名</code>。</li><li>模式要么建立在默认目录中,要么建立在创建用户账户时所指定的目录中。</li><li>新创建的模式成为用户账户的<code>默认模式</code>。</li></ul><p><strong>创建和删除目录</strong>依据实现的不同而不同,这不是<code>SQL</code>标准中的一部分。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第4章 中级SQL </category>
          
          <category> 4.5 SQL的数据类型与模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.5.6 create table的扩展</title>
      <link href="/ReadingNotes//27f1fe58/"/>
      <url>/ReadingNotes//27f1fe58/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/27f1fe58/#4-5-6-create-table的扩展" class="header_1">4.5.6 create table的扩展</a>&nbsp;<br><a href="/ReadingNotes/27f1fe58/#创建与现有的某个表的模式相同的表-create-table-like" class="header_2">创建与现有的某个表的模式相同的表 create table like</a>&nbsp;<br><a href="/ReadingNotes/27f1fe58/#create-table-like只复制表结构不复制表数据" class="header_3">create table like只复制表结构不复制表数据</a>&nbsp;<br><a href="/ReadingNotes/27f1fe58/#instructor和temp_instructor具有相同的表结构" class="header_4">instructor和temp_instructor具有相同的表结构</a>&nbsp;<br><a href="/ReadingNotes/27f1fe58/#temp_instructor表中不会从instructor表中复制数据" class="header_4">temp_instructor表中不会从instructor表中复制数据</a>&nbsp;<br><a href="/ReadingNotes/27f1fe58/#把查询的结果存储成一个新表-create-table-as" class="header_2">把查询的结果存储成一个新表 create table as</a>&nbsp;<br><a href="/ReadingNotes/27f1fe58/#-MySQL-中的写法" class="header_3">`MySQL`中的写法</a>&nbsp;<br><a href="/ReadingNotes/27f1fe58/#create-table-as的表结构是查询结果对应的表结构-与原表不同" class="header_3">create table as的表结构是查询结果对应的表结构 与原表不同</a>&nbsp;<br><a href="/ReadingNotes/27f1fe58/#t1表存放查询得到的数据" class="header_3">t1表存放查询得到的数据</a>&nbsp;<br><a href="/ReadingNotes/27f1fe58/#-create-table-as-与-create-table-like-的区别" class="header_2">`create table as`与`create table like`的区别</a>&nbsp;<br><a href="/ReadingNotes/27f1fe58/#create-table-as和create-view的区别" class="header_2">create table as和create view的区别</a>&nbsp;<br><a href="/ReadingNotes/27f1fe58/#参考资料" class="header_2">参考资料</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="4-5-6-create-table的扩展"><a href="#4-5-6-create-table的扩展" class="headerlink" title="4.5.6 create table的扩展"></a>4.5.6 create table的扩展</h1><h2 id="创建与现有的某个表的模式相同的表-create-table-like"><a href="#创建与现有的某个表的模式相同的表-create-table-like" class="headerlink" title="创建与现有的某个表的模式相同的表 create table like"></a>创建与现有的某个表的模式相同的表 create table like</h2><p>应用常常要求<strong>创建与现有的某个表的模式相同的表</strong>。<code>SQL</code>提供了一个<code>create table like</code>的扩展来支持这项任务:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> temp_instructor <span class="keyword">like</span> instructor;</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table temp_instructor like instructor;</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0</span>.<span class="number">06</span> sec)</span><br></pre></td></tr></table></figure></p><h3 id="create-table-like只复制表结构不复制表数据"><a href="#create-table-like只复制表结构不复制表数据" class="headerlink" title="create table like只复制表结构不复制表数据"></a>create table like只复制表结构不复制表数据</h3><h4 id="instructor和temp-instructor具有相同的表结构"><a href="#instructor和temp-instructor具有相同的表结构" class="headerlink" title="instructor和temp_instructor具有相同的表结构"></a>instructor和temp_instructor具有相同的表结构</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show create table instructor \G;</span><br><span class="line">*************************** <span class="number">1</span>. row ***************************</span><br><span class="line"><span class="function">       Table: <span class="title">instructor</span></span></span><br><span class="line"><span class="function"><span class="title">Create</span> <span class="title">Table</span>: <span class="title">CREATE</span> <span class="title">TABLE</span> `<span class="title">instructor</span>` (</span></span><br><span class="line"><span class="function">  `<span class="title">ID</span>` <span class="title">varchar</span>(5) <span class="title">CHARACTER</span> <span class="title">SET</span> <span class="title">utf8</span> <span class="title">COLLATE</span> <span class="title">utf8_general_ci</span> <span class="title">NOT</span> <span class="title">NULL</span> <span class="title">COMMENT</span> '老师的主键',</span></span><br><span class="line"><span class="function">  `<span class="title">name</span>` <span class="title">varchar</span>(20) <span class="title">CHARACTER</span> <span class="title">SET</span> <span class="title">utf8</span> <span class="title">COLLATE</span> <span class="title">utf8_general_ci</span> <span class="title">NOT</span> <span class="title">NULL</span> <span class="title">COMMENT</span> '老师的姓名',</span></span><br><span class="line"><span class="function">  `<span class="title">dept_name</span>` <span class="title">varchar</span>(20) <span class="title">CHARACTER</span> <span class="title">SET</span> <span class="title">utf8</span> <span class="title">COLLATE</span> <span class="title">utf8_general_ci</span> <span class="title">DEFAULT</span> <span class="title">NULL</span> <span class="title">COMMENT</span> '老师所在的系',</span></span><br><span class="line"><span class="function">  `<span class="title">salary</span>` <span class="title">decimal</span>(8,2) <span class="title">DEFAULT</span> <span class="title">NULL</span> <span class="title">COMMENT</span> '老师的工资',</span></span><br><span class="line"><span class="function">  <span class="title">PRIMARY</span> <span class="title">KEY</span> (`<span class="title">ID</span>`),</span></span><br><span class="line"><span class="function">  <span class="title">KEY</span> `<span class="title">dept_name</span>` (`<span class="title">dept_name</span>`),</span></span><br><span class="line"><span class="function">  <span class="title">CONSTRAINT</span> `<span class="title">instructor_ibfk_1</span>` <span class="title">FOREIGN</span> <span class="title">KEY</span> (`<span class="title">dept_name</span>`) <span class="title">REFERENCES</span> `<span class="title">department</span>` (`<span class="title">dept_name</span>`) <span class="title">ON</span> <span class="title">DELETE</span> <span class="title">SET</span> <span class="title">NULL</span>,</span></span><br><span class="line"><span class="function">  <span class="title">CONSTRAINT</span> `<span class="title">instructor_chk_1</span>` <span class="title">CHECK</span> ((`<span class="title">salary</span>` &gt; 29000))</span></span><br><span class="line"><span class="function">) <span class="title">ENGINE</span>=<span class="title">InnoDB</span> <span class="title">DEFAULT</span> <span class="title">CHARSET</span>=<span class="title">utf8</span></span></span><br><span class="line"><span class="function">1 <span class="title">row</span> <span class="title">in</span> <span class="title">set</span> (0.00 <span class="title">sec</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">ERROR</span>:</span></span><br><span class="line"><span class="function"><span class="title">No</span> <span class="title">query</span> <span class="title">specified</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show create table temp_instructor \G;</span><br><span class="line">*************************** <span class="number">1</span>. row ***************************</span><br><span class="line"><span class="function">       Table: <span class="title">temp_instructor</span></span></span><br><span class="line"><span class="function"><span class="title">Create</span> <span class="title">Table</span>: <span class="title">CREATE</span> <span class="title">TABLE</span> `<span class="title">temp_instructor</span>` (</span></span><br><span class="line"><span class="function">  `<span class="title">ID</span>` <span class="title">varchar</span>(5) <span class="title">CHARACTER</span> <span class="title">SET</span> <span class="title">utf8</span> <span class="title">COLLATE</span> <span class="title">utf8_general_ci</span> <span class="title">NOT</span> <span class="title">NULL</span> <span class="title">COMMENT</span> '老师的主键',</span></span><br><span class="line"><span class="function">  `<span class="title">name</span>` <span class="title">varchar</span>(20) <span class="title">CHARACTER</span> <span class="title">SET</span> <span class="title">utf8</span> <span class="title">COLLATE</span> <span class="title">utf8_general_ci</span> <span class="title">NOT</span> <span class="title">NULL</span> <span class="title">COMMENT</span> '老师的姓名',</span></span><br><span class="line"><span class="function">  `<span class="title">dept_name</span>` <span class="title">varchar</span>(20) <span class="title">CHARACTER</span> <span class="title">SET</span> <span class="title">utf8</span> <span class="title">COLLATE</span> <span class="title">utf8_general_ci</span> <span class="title">DEFAULT</span> <span class="title">NULL</span> <span class="title">COMMENT</span> '老师所在的系',</span></span><br><span class="line"><span class="function">  `<span class="title">salary</span>` <span class="title">decimal</span>(8,2) <span class="title">DEFAULT</span> <span class="title">NULL</span> <span class="title">COMMENT</span> '老师的工资',</span></span><br><span class="line"><span class="function">  <span class="title">PRIMARY</span> <span class="title">KEY</span> (`<span class="title">ID</span>`),</span></span><br><span class="line"><span class="function">  <span class="title">KEY</span> `<span class="title">dept_name</span>` (`<span class="title">dept_name</span>`),</span></span><br><span class="line"><span class="function">  <span class="title">CONSTRAINT</span> `<span class="title">temp_instructor_chk_1</span>` <span class="title">CHECK</span> ((`<span class="title">salary</span>` &gt; 29000))</span></span><br><span class="line"><span class="function">) <span class="title">ENGINE</span>=<span class="title">InnoDB</span> <span class="title">DEFAULT</span> <span class="title">CHARSET</span>=<span class="title">utf8</span></span></span><br><span class="line"><span class="function">1 <span class="title">row</span> <span class="title">in</span> <span class="title">set</span> (0.00 <span class="title">sec</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">ERROR</span>:</span></span><br><span class="line"><span class="function"><span class="title">No</span> <span class="title">query</span> <span class="title">specified</span></span></span><br></pre></td></tr></table></figure><h4 id="temp-instructor表中不会从instructor表中复制数据"><a href="#temp-instructor表中不会从instructor表中复制数据" class="headerlink" title="temp_instructor表中不会从instructor表中复制数据"></a>temp_instructor表中不会从instructor表中复制数据</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from instructor;</span><br><span class="line">+-------+------------+------------+-----------+</span><br><span class="line">| ID    | name       | dept_name  | salary    |</span><br><span class="line">+-------+------------+------------+-----------+</span><br><span class="line">| <span class="number">10101</span> | Srinivasan | <span class="built_in">Comp</span>. Sci. | <span class="number">65000</span>.<span class="number">00</span>  |</span><br><span class="line">| <span class="number">12121</span> | Wu         | Finance    | <span class="number">90000</span>.<span class="number">00</span>  |</span><br><span class="line">| <span class="number">15151</span> | Mozart     | Music      | <span class="number">40000</span>.<span class="number">00</span>  |</span><br><span class="line">| <span class="number">22222</span> | Einstein   | Physics    | <span class="number">95000</span>.<span class="number">00</span>  |</span><br><span class="line">| <span class="number">25566</span> | Brown      | Biology    | <span class="number">100000</span>.<span class="number">00</span> |</span><br><span class="line">| <span class="number">30765</span> | Green      | Music      | NULL      |</span><br><span class="line">| <span class="number">32343</span> | El Said    | History    | <span class="number">60000</span>.<span class="number">00</span>  |</span><br><span class="line">| <span class="number">33456</span> | Gold       | Physics    | <span class="number">87000</span>.<span class="number">00</span>  |</span><br><span class="line">| <span class="number">45565</span> | Katz       | <span class="built_in">Comp</span>. Sci. | <span class="number">75000</span>.<span class="number">00</span>  |</span><br><span class="line">| <span class="number">58583</span> | Califieri  | History    | <span class="number">62000</span>.<span class="number">00</span>  |</span><br><span class="line">| <span class="number">76543</span> | Singh      | Finance    | <span class="number">80000</span>.<span class="number">00</span>  |</span><br><span class="line">| <span class="number">76766</span> | Crick      | Biology    | <span class="number">72000</span>.<span class="number">00</span>  |</span><br><span class="line">| <span class="number">83821</span> | Brandt     | <span class="built_in">Comp</span>. Sci. | <span class="number">92000</span>.<span class="number">00</span>  |</span><br><span class="line">| <span class="number">98345</span> | Kim        | Elec. Eng. | <span class="number">80000</span>.<span class="number">00</span>  |</span><br><span class="line">+-------+------------+------------+-----------+</span><br><span class="line"><span class="number">14</span> rows <span class="keyword">in</span> <span class="built_in">set</span> (<span class="number">0</span>.<span class="number">04</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from temp_instructor;</span><br><span class="line">Empty <span class="built_in">set</span></span><br></pre></td></tr></table></figure><h2 id="把查询的结果存储成一个新表-create-table-as"><a href="#把查询的结果存储成一个新表-create-table-as" class="headerlink" title="把查询的结果存储成一个新表 create table as"></a>把查询的结果存储成一个新表 create table as</h2><p>当书写一个复杂查询时,<strong>把查询的结果存储成一个新表</strong>通常是很有用的;这个表通常是临时的。这里需要两条语句,一条用于创建表(具有合适的列),另一条用于把查询结果插入到表中。<code>SQL:2003</code>提供了一种更简单的技术来<strong>创建包含查询结果的表</strong>。例如,下面的语句创建了表<code>t1</code>,该表包含一个查询的结果。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1 <span class="keyword">as</span> (</span><br><span class="line">    <span class="keyword">select</span> * </span><br><span class="line">    <span class="keyword">from</span> instructor</span><br><span class="line">    <span class="keyword">where</span> dept_name =<span class="string">'Music'</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">with</span> <span class="keyword">data</span>;</span><br></pre></td></tr></table></figure><br>在默认情况下,列的名称和数据类型是从查询结果中推导出来的。通过在关系名后面列出列名,可以给列显式指派名字。<br>正如<code>SQL:2003</code>标准所定义的,如果省略<code>with data</code>子句,表会被创建,但不会载入数据。但<strong>即使在省略<code>with data</code>子句的情况下,很多数据库实现还是通过默认方式往表中加载了数据</strong>。注意几种数据库实现都用不同语法支持<code>create table…like</code>和<code>create table…as</code>的功能;请参考相应的系统手册以获得进一步细节。</p><h3 id="MySQL中的写法"><a href="#MySQL中的写法" class="headerlink" title="MySQL中的写法"></a><code>MySQL</code>中的写法</h3><p><code>MySQL</code>中好像不执行<code>with data</code>子句,省略上面的<code>with data</code>子句也可以将查询的结果存储成新的表:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1 <span class="keyword">as</span> (</span><br><span class="line">    <span class="keyword">select</span> * </span><br><span class="line">    <span class="keyword">from</span> instructor</span><br><span class="line">    <span class="keyword">where</span> dept_name =<span class="string">'Music'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><h3 id="create-table-as的表结构是查询结果对应的表结构-与原表不同"><a href="#create-table-as的表结构是查询结果对应的表结构-与原表不同" class="headerlink" title="create table as的表结构是查询结果对应的表结构 与原表不同"></a>create table as的表结构是查询结果对应的表结构 与原表不同</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show create table instructor \G;</span><br><span class="line">*************************** <span class="number">1</span>. row ***************************</span><br><span class="line"><span class="function">       Table: <span class="title">instructor</span></span></span><br><span class="line"><span class="function"><span class="title">Create</span> <span class="title">Table</span>: <span class="title">CREATE</span> <span class="title">TABLE</span> `<span class="title">instructor</span>` (</span></span><br><span class="line"><span class="function">  `<span class="title">ID</span>` <span class="title">varchar</span>(5) <span class="title">CHARACTER</span> <span class="title">SET</span> <span class="title">utf8</span> <span class="title">COLLATE</span> <span class="title">utf8_general_ci</span> <span class="title">NOT</span> <span class="title">NULL</span> <span class="title">COMMENT</span> '老师的主键',</span></span><br><span class="line"><span class="function">  `<span class="title">name</span>` <span class="title">varchar</span>(20) <span class="title">CHARACTER</span> <span class="title">SET</span> <span class="title">utf8</span> <span class="title">COLLATE</span> <span class="title">utf8_general_ci</span> <span class="title">NOT</span> <span class="title">NULL</span> <span class="title">COMMENT</span> '老师的姓名',</span></span><br><span class="line"><span class="function">  `<span class="title">dept_name</span>` <span class="title">varchar</span>(20) <span class="title">CHARACTER</span> <span class="title">SET</span> <span class="title">utf8</span> <span class="title">COLLATE</span> <span class="title">utf8_general_ci</span> <span class="title">DEFAULT</span> <span class="title">NULL</span> <span class="title">COMMENT</span> '老师所在的系',</span></span><br><span class="line"><span class="function">  `<span class="title">salary</span>` <span class="title">decimal</span>(8,2) <span class="title">DEFAULT</span> <span class="title">NULL</span> <span class="title">COMMENT</span> '老师的工资',</span></span><br><span class="line"><span class="function">  <span class="title">PRIMARY</span> <span class="title">KEY</span> (`<span class="title">ID</span>`),</span></span><br><span class="line"><span class="function">  <span class="title">KEY</span> `<span class="title">dept_name</span>` (`<span class="title">dept_name</span>`),</span></span><br><span class="line"><span class="function">  <span class="title">CONSTRAINT</span> `<span class="title">instructor_ibfk_1</span>` <span class="title">FOREIGN</span> <span class="title">KEY</span> (`<span class="title">dept_name</span>`) <span class="title">REFERENCES</span> `<span class="title">department</span>` (`<span class="title">dept_name</span>`) <span class="title">ON</span> <span class="title">DELETE</span> <span class="title">SET</span> <span class="title">NULL</span>,</span></span><br><span class="line"><span class="function">  <span class="title">CONSTRAINT</span> `<span class="title">instructor_chk_1</span>` <span class="title">CHECK</span> ((`<span class="title">salary</span>` &gt; 29000))</span></span><br><span class="line"><span class="function">) <span class="title">ENGINE</span>=<span class="title">InnoDB</span> <span class="title">DEFAULT</span> <span class="title">CHARSET</span>=<span class="title">utf8</span></span></span><br><span class="line"><span class="function">1 <span class="title">row</span> <span class="title">in</span> <span class="title">set</span> (0.00 <span class="title">sec</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">ERROR</span>:</span></span><br><span class="line"><span class="function"><span class="title">No</span> <span class="title">query</span> <span class="title">specified</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show create table t1 \G;</span><br><span class="line">*************************** <span class="number">1</span>. row ***************************</span><br><span class="line"><span class="function">       Table: <span class="title">t1</span></span></span><br><span class="line"><span class="function"><span class="title">Create</span> <span class="title">Table</span>: <span class="title">CREATE</span> <span class="title">TABLE</span> `<span class="title">t1</span>` (</span></span><br><span class="line"><span class="function">  `<span class="title">ID</span>` <span class="title">varchar</span>(5) <span class="title">CHARACTER</span> <span class="title">SET</span> <span class="title">utf8</span> <span class="title">COLLATE</span> <span class="title">utf8_general_ci</span> <span class="title">NOT</span> <span class="title">NULL</span> <span class="title">COMMENT</span> '老师的主键',</span></span><br><span class="line"><span class="function">  `<span class="title">name</span>` <span class="title">varchar</span>(20) <span class="title">CHARACTER</span> <span class="title">SET</span> <span class="title">utf8</span> <span class="title">COLLATE</span> <span class="title">utf8_general_ci</span> <span class="title">NOT</span> <span class="title">NULL</span> <span class="title">COMMENT</span> '老师的姓名',</span></span><br><span class="line"><span class="function">  `<span class="title">dept_name</span>` <span class="title">varchar</span>(20) <span class="title">CHARACTER</span> <span class="title">SET</span> <span class="title">utf8</span> <span class="title">COLLATE</span> <span class="title">utf8_general_ci</span> <span class="title">DEFAULT</span> <span class="title">NULL</span> <span class="title">COMMENT</span> '老师所在的系',</span></span><br><span class="line"><span class="function">  `<span class="title">salary</span>` <span class="title">decimal</span>(8,2) <span class="title">DEFAULT</span> <span class="title">NULL</span> <span class="title">COMMENT</span> '老师的工资'</span></span><br><span class="line"><span class="function">) <span class="title">ENGINE</span>=<span class="title">InnoDB</span> <span class="title">DEFAULT</span> <span class="title">CHARSET</span>=<span class="title">utf8</span></span></span><br><span class="line"><span class="function">1 <span class="title">row</span> <span class="title">in</span> <span class="title">set</span> (0.00 <span class="title">sec</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">ERROR</span>:</span></span><br><span class="line"><span class="function"><span class="title">No</span> <span class="title">query</span> <span class="title">specified</span></span></span><br></pre></td></tr></table></figure><h3 id="t1表存放查询得到的数据"><a href="#t1表存放查询得到的数据" class="headerlink" title="t1表存放查询得到的数据"></a>t1表存放查询得到的数据</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * </span><br><span class="line">from instructor</span><br><span class="line">where dept_name ='Music';</span><br><span class="line">+-------+--------+-----------+----------+</span><br><span class="line">| ID    | name   | dept_name | salary   |</span><br><span class="line">+-------+--------+-----------+----------+</span><br><span class="line">| <span class="number">15151</span> | Mozart | Music     | <span class="number">40000</span>.<span class="number">00</span> |</span><br><span class="line">| <span class="number">30765</span> | Green  | Music     | NULL     |</span><br><span class="line">+-------+--------+-----------+----------+</span><br><span class="line"><span class="number">2</span> rows <span class="keyword">in</span> <span class="built_in">set</span> (<span class="number">0</span>.<span class="number">03</span> sec)</span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table t1 as (</span><br><span class="line">    select * </span><br><span class="line">    from instructor</span><br><span class="line">    where dept_name ='Music'</span><br><span class="line">);</span><br><span class="line">Query OK, <span class="number">2</span> rows affected (<span class="number">0</span>.<span class="number">06</span> sec)</span><br><span class="line"><span class="function">Records: 2  <span class="title">Duplicates</span>: 0  <span class="title">Warnings</span>: 0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">mysql</span>&gt; <span class="title">select</span> * <span class="title">from</span> <span class="title">t1</span>;</span></span><br><span class="line"><span class="function">+-------+--------+-----------+----------+</span></span><br><span class="line"><span class="function">| <span class="title">ID</span>    | <span class="title">name</span>   | <span class="title">dept_name</span> | <span class="title">salary</span>   |</span></span><br><span class="line"><span class="function">+-------+--------+-----------+----------+</span></span><br><span class="line"><span class="function">| 15151 | <span class="title">Mozart</span> | <span class="title">Music</span>     | 40000.00 |</span></span><br><span class="line"><span class="function">| 30765 | <span class="title">Green</span>  | <span class="title">Music</span>     | <span class="title">NULL</span>     |</span></span><br><span class="line"><span class="function">+-------+--------+-----------+----------+</span></span><br><span class="line"><span class="function">2 <span class="title">rows</span> <span class="title">in</span> <span class="title">set</span> (0.03 <span class="title">sec</span>)</span></span><br></pre></td></tr></table></figure><h2 id="create-table-as与create-table-like的区别"><a href="#create-table-as与create-table-like的区别" class="headerlink" title="create table as与create table like的区别"></a><code>create table as</code>与<code>create table like</code>的区别</h2><ul><li>相同点：<ul><li>都是创建一个新表</li></ul></li><li>不同点<ul><li><code>create table as</code> 只是复制原数据，其实就是新建一个表来保存查询的结果</li><li><code>create table like</code> 产生与源表相同的<strong>表结构</strong>，包括<code>索引</code>和<code>主键</code>,但是<code>create table like</code>只是复制表结构,并没有复制表中的数据.</li></ul></li></ul><h2 id="create-table-as和create-view的区别"><a href="#create-table-as和create-view的区别" class="headerlink" title="create table as和create view的区别"></a>create table as和create view的区别</h2><p>上述<code>create table … as</code>语句与<code>create view</code>语句非常相似,并且都用查询来定义。<br>两者主要的区别在于:</p><ul><li><code>create table … as</code>语句创建的表的内容在建时表的时候就确定下来了</li><li><code>create view</code>语句创建的视图的内容总是反映当前查询的结果。</li></ul><!--SSTStop--><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/ec0ee80b560c" target="_blank" rel="noopener">https://www.jianshu.com/p/ec0ee80b560c</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第4章 中级SQL </category>
          
          <category> 4.5 SQL的数据类型与模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.5.5 用户定义的类型</title>
      <link href="/ReadingNotes//ee1aa265/"/>
      <url>/ReadingNotes//ee1aa265/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/ee1aa265/#4-5-5-用户定义的类型" class="header_1">4.5.5 用户定义的类型</a>&nbsp;<br><a href="/ReadingNotes/ee1aa265/#独特类型" class="header_2">独特类型</a>&nbsp;<br><a href="/ReadingNotes/ee1aa265/#如何自定义新类型" class="header_2">如何自定义新类型</a>&nbsp;<br><a href="/ReadingNotes/ee1aa265/#删除或就该自定义类型" class="header_2">删除或就该自定义类型</a>&nbsp;<br><a href="/ReadingNotes/ee1aa265/#域" class="header_2">域</a>&nbsp;<br><a href="/ReadingNotes/ee1aa265/#域和自定义类型的区别" class="header_2">域和自定义类型的区别</a>&nbsp;<br><a href="/ReadingNotes/ee1aa265/#在数据库实现中对类型和域的支持" class="header_1">在数据库实现中对类型和域的支持</a>&nbsp;<br><a href="/ReadingNotes/ee1aa265/#-PostgreSQL" class="header_2">`PostgreSQL`</a>&nbsp;<br><a href="/ReadingNotes/ee1aa265/#-IBM-DB2" class="header_2">`IBM DB2`</a>&nbsp;<br><a href="/ReadingNotes/ee1aa265/#-SQL-Server" class="header_2">`SQL Server`</a>&nbsp;<br><a href="/ReadingNotes/ee1aa265/#Oracle" class="header_2">Oracle</a>&nbsp;<br><a href="/ReadingNotes/ee1aa265/#-MySQL" class="header_2">`MySQL`</a>&nbsp;<br><a href="/ReadingNotes/ee1aa265/#面向对象类型" class="header_2">面向对象类型</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="4-5-5-用户定义的类型"><a href="#4-5-5-用户定义的类型" class="headerlink" title="4.5.5 用户定义的类型"></a>4.5.5 用户定义的类型</h1><p><code>SQL</code>支持<strong>两种</strong>形式的用户定义数据类型。</p><ul><li>第一种称为独特类型( <code>distinct type</code>),我们将在这里介绍。</li><li>另一种称为结构化数据类型( <code>structured data type</code>),允许创建<code>具有嵌套</code>记录结构、<code>数组</code>和<code>多重集的复杂数据类型</code>。</li></ul><p>在本章我们不介绍结构化数据类型,而是在后面第22章描述。<br><strong>一些属性可能会有相同的数据类型</strong>。例如,用于学生名和教师名的<code>name</code>属性就可能有相同的域:所有人名的集合。<br>然而, <code>budget</code>和<code>dept_name</code>的域肯定应该是不同的。<code>name</code>和 <code>dept_name</code>是否应该有相同的域,这一点就不那么明显了。在实现层,教师姓名和系的名字都是字符串。然而,我们通常不认为“<strong>找出所有与某个系同名的教师</strong>”是一个有意义的查询。因此,如果我们在概念层而不是物理层来看待数据库的话,<code>name</code>和 <code>dept_name</code>应该有不同的域。</p><h2 id="独特类型"><a href="#独特类型" class="headerlink" title="独特类型"></a>独特类型</h2><p>更重要的是,在现实中,把一个教师的姓名赋给一个系名可能是一个程序上的错误;<br>类似地,把个以美元表示的货币值直接与一个以英镑表示的货币值进行比较几乎可以肯定是程序上的错误。<br>一个好的类型系统应该能够检测出这类赋值或比较。为了支持这种检测,<code>SQL</code>提供了<strong>独特类型</strong>(<code>distincttype</code>)的概念。</p><h2 id="如何自定义新类型"><a href="#如何自定义新类型" class="headerlink" title="如何自定义新类型"></a>如何自定义新类型</h2><p>可以用<code>create type</code>子句来定义新类型。例如,下面的语句:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">type</span> Dollars <span class="keyword">as</span> <span class="built_in">numeric</span>(<span class="number">12</span>,<span class="number">2</span>) <span class="keyword">final</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">type</span> Pounds <span class="keyword">as</span> <span class="built_in">numeric</span>(<span class="number">12</span>,<span class="number">2</span>) <span class="keyword">final</span>;</span><br></pre></td></tr></table></figure><br>把两个用户定义类型<code>Dollars</code>和<code>Pounds</code>定义为总共12位数字的十进制数,其中两位放在十进制小数点后。(在此关键字<code>final</code>并不是真的有意义,它是<code>SQL:1999</code>标准要求的,其原因我们不在这里讨论了;一些系统实现允许忽略血<code>final</code>关键字。)然后新创建的类型就可以用作关系属性的类型。例如,我们可以把<code>department</code>表定义为:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> department (</span><br><span class="line">    dept_name <span class="built_in">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    building <span class="built_in">varchar</span>(<span class="number">15</span>),</span><br><span class="line">    budget Dollars</span><br><span class="line">);</span><br></pre></td></tr></table></figure><br>尝试为<code>Pounds</code>类型的变量赋予一个<code>Dollars</code>类型的值会导致一个编译时错误,尽管这两者都是相同的数值类型。这样的赋值很可能是由程序错误引起的,或许是程序员忘记了货币之间的区别。为不同的货币声明不同的类型能帮助发现这些错误。<br>由于有强类型检查,表达式( <code>department.budget+20</code>)将不会被接受,因为属性和整型常数20具有不同的类型。一种类型的数值可以被<strong>转换</strong>(也即<code>cast</code>)到另一个域,如下所示:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cast(department.budget to numeric( 12, 2));</span><br></pre></td></tr></table></figure><br>我们可以在数值类型上做加法,但是为了把结果存回到一个<code>Dollars</code>类型的属性中,我们需要用另一个类型转换表达式来把数值类型转换回<code>Dollars</code>类型。</p><h2 id="删除或就该自定义类型"><a href="#删除或就该自定义类型" class="headerlink" title="删除或就该自定义类型"></a>删除或就该自定义类型</h2><p><code>SQL</code>提供了<code>drop type</code>和<code>alter type</code>子句来删除或修改以前创建过的类型。</p><h2 id="域"><a href="#域" class="headerlink" title="域"></a>域</h2><p>在把用户定义类型加入到<code>SQL</code>(在<code>SQL:1999</code>中)之前,<code>SQL</code>有一个相似但稍有不同的概念:<code>域</code>(<code>domain</code>)(<code>domain</code>在<code>SQL-92</code>中引入),它可以在基本类型上施加完整性约束。例如,我们可以定义一个域<code>DDollars</code>,如下所示:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">domain</span> DDollars <span class="keyword">as</span> <span class="built_in">numeric</span>(<span class="number">12</span>, <span class="number">2</span>) <span class="keyword">not</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></p><h2 id="域和自定义类型的区别"><a href="#域和自定义类型的区别" class="headerlink" title="域和自定义类型的区别"></a>域和自定义类型的区别</h2><p><code>DDollars</code>域可以用作属性类型,正如我们用<code>Dollars</code>类型一样。然而,类型和域之间有两个重大的差别</p><ol><li><strong>在域上可以声明约束</strong>,例如<code>not null</code>,也可以为<strong>域类型变量定义默认值</strong>,然而<strong>在用户自定义类型上<code>不能</code>声明约束或默认值</strong>。设计用户定义类型不仅是用它来指定属性类型,而且还将它用在不能施加约束的地方对<code>SQL</code>进行过程扩展。</li><li><strong>域并不是<code>强类型</code>的</strong>。因此一个域类型的值可以被赋给另一个域类型,只要它们的基本类型是相容的</li></ol><p>当把<code>check</code>子句应用到域上时,允许模式设计者指定一个谓词,被声明为来自该域的任何变量都必须满足这个谓词。例如, <code>check</code>子句可以保证教师工资域中只允许出现大于给定值的值:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">domain</span> YearlySalary <span class="built_in">numeric</span>(<span class="number">8</span>,<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">constraint</span> salary_value_test <span class="keyword">check</span>(<span class="keyword">value</span> &gt;<span class="number">29000.00</span>);</span><br></pre></td></tr></table></figure><br><code>YearlySalary</code>域有一个约束来保证年薪大于或等于290000美元。 <code>constraint salary_value_test</code>子句是可选的,它用来将该约束命名为<code>salary_value_test</code>。系统用这个名字来指出一个更新违反了哪个约束。<br>作为另一个例子,使用<code>in</code>子句可以限定一个域只包含指定的一组值</p><h1 id="在数据库实现中对类型和域的支持"><a href="#在数据库实现中对类型和域的支持" class="headerlink" title="在数据库实现中对类型和域的支持"></a>在数据库实现中对类型和域的支持</h1><p>尽管本节描述的<code>create type</code>和<code>create domain</code>结构是<code>SQL</code>标准的部分,但这里描迷的这些结构形式还没有被大多数数据库实现完全支持。</p><h2 id="PostgreSQL"><a href="#PostgreSQL" class="headerlink" title="PostgreSQL"></a><code>PostgreSQL</code></h2><p><code>PostgreSQL</code>支持<code>create domain</code>结构,但是其<code>create type</code>结构具有不同的语法和解释。</p><h2 id="IBM-DB2"><a href="#IBM-DB2" class="headerlink" title="IBM DB2"></a><code>IBM DB2</code></h2><p><code>IBM DB2</code>支持<code>create type</code>的一个版本,它使用<code>create distinct type</code>语法,但不支持<code>create domain</code>。</p><h2 id="SQL-Server"><a href="#SQL-Server" class="headerlink" title="SQL Server"></a><code>SQL Server</code></h2><p>微软的<code>SQL Server</code>实现了<code>create type</code>结构的一个版本,支持<code>域约束</code>,与<code>SQL</code>的<code>create domain</code>结构类似。</p><h2 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h2><p><code>Oracle</code>不支持在此描述的任何一种结构。</p><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a><code>MySQL</code></h2><p>经过我的测试<code>MySQL</code>也不支持自定义类型<code>create type</code>结构和自定义域<code>create domain</code>结构。</p><h2 id="面向对象类型"><a href="#面向对象类型" class="headerlink" title="面向对象类型"></a>面向对象类型</h2><p>然而,<code>SQL</code>还定义了一个更复杂的<strong>面向对象类型</strong>系统,我们将在后面第22章学习。通过使用不同形式的<code>create type</code>结构, <code>Oracle</code>、 <code>IBM DB2</code>、 <code>PostgreSQL</code>和<code>SQL Server</code>都支持<code>面向对象类型系统</code>。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第4章 中级SQL </category>
          
          <category> 4.5 SQL的数据类型与模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.5.4 大对象类型</title>
      <link href="/ReadingNotes//f4ff90ef/"/>
      <url>/ReadingNotes//f4ff90ef/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/f4ff90ef/#4-5-4-大对象类型" class="header_1">4.5.4 大对象类型</a>&nbsp;<br><a href="/ReadingNotes/f4ff90ef/#字符大对象clob-二进制大对象blob" class="header_2">字符大对象clob 二进制大对象blob</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="4-5-4-大对象类型"><a href="#4-5-4-大对象类型" class="headerlink" title="4.5.4 大对象类型"></a>4.5.4 大对象类型</h1><h2 id="字符大对象clob-二进制大对象blob"><a href="#字符大对象clob-二进制大对象blob" class="headerlink" title="字符大对象clob 二进制大对象blob"></a>字符大对象clob 二进制大对象blob</h2><p>许多当前的数据库应用需要存储可能很大(<code>KB</code>级)的属性,例如一张照片;或者非常大的属性(<code>MB</code>级甚至<code>GB</code>级)。例如高清晰度的医学图像或视频片断。因此<code>SQL</code>提供<strong>字符数据的大对象数据类型</strong>(<code>clob</code>)和<strong>二进制数据的大对象数据类型</strong>(<code>blob</code>)。在这些数据类型中字符”<code>LOB</code>“代表” <code>Large OBject</code>“。例如,我们可以声明属性:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">book_rewiew clob(10KB)</span><br><span class="line">image blob(10MB)</span><br><span class="line">movie blob(2GB)</span><br></pre></td></tr></table></figure><br>对于包含大对象(好几个<code>MB</code>甚至<code>GB</code>)的结果元组而言,<strong>把整个大对象放入内存中是非常低效和不现实的</strong>。<br>相反,一个应用通常用一个<code>SQL</code>查询来检索出一个大对象的”<strong>定位器</strong>“,然后在宿主语言中用这个定位器来操纵对象,应用本身也是用宿主语言书写的。例如,<code>JDBC</code>应用编程接口(5.1.1节描述)允许获取一个定位器而不是整个大对象;然后用这个定位器来一点一点地取出这个大对象,而不是次取出全部,这很像用一个<code>read</code>函数调用从操作系统文件中读取数据。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第4章 中级SQL </category>
          
          <category> 4.5 SQL的数据类型与模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.5.3 创建索引</title>
      <link href="/ReadingNotes//cfd0af58/"/>
      <url>/ReadingNotes//cfd0af58/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/cfd0af58/#4-5-3-创建索引" class="header_1">4.5.3 创建索引</a>&nbsp;<br><a href="/ReadingNotes/cfd0af58/#什么是索引" class="header_2">什么是索引</a>&nbsp;<br><a href="/ReadingNotes/cfd0af58/#索引的作用" class="header_2">索引的作用</a>&nbsp;<br><a href="/ReadingNotes/cfd0af58/#如何创建索引" class="header_2">如何创建索引</a>&nbsp;<br><a href="/ReadingNotes/cfd0af58/#查询是自动使用索引" class="header_2">查询是自动使用索引</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="4-5-3-创建索引"><a href="#4-5-3-创建索引" class="headerlink" title="4.5.3 创建索引"></a>4.5.3 创建索引</h1><p>许多查询只涉及文件中的少量记录。例如,像这样的查询”<strong>找出<code>Physics</code>系的所有教师</strong>“,或”<strong>找出<code>ID</code>为22201的学生的<code>tot_cred</code>值</strong>“,只涉及学生记录中的一小部分。<br>如果系统读取每条记录并逐个检查其<code>ID</code>域是否为”22201”,或者<code>dept_name</code>域是否取值为” <code>Physics</code>“,这样的方式是很低效的。</p><h2 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h2><p><code>在关系的属性上</code>所创建的<strong>索引</strong>(<code>index</code>)是一种数据结构,</p><h2 id="索引的作用"><a href="#索引的作用" class="headerlink" title="索引的作用"></a>索引的作用</h2><p>索引允许数据库系统<code>高效地</code>找到关系中那些在<code>索引属性</code>上取给定值的元组,而不用扫描关系中的所有元组。<br>例如,如果我们在<code>student</code>关系的属性<code>ID</code>上创建了索引,数据库系统不用读取<code>student</code>关系中的所有元组,就可以直接找到任何像22201或4553那样具有指定ID值的记录。</p><p>索引也可以建立在一个<strong>属性列表</strong>上,例如在<code>student</code>的属性<code>name</code>和<code>dept_name</code>上。</p><p>我们将在后面第11章学习索引是如何实现的,包括一种被称作<code>B+</code>树的索引,它是一种特别的广泛使用的索引类型。</p><h2 id="如何创建索引"><a href="#如何创建索引" class="headerlink" title="如何创建索引"></a>如何创建索引</h2><p>尽管<code>SQL</code>语言没有给出创建索引的正式语法定义,但很多数据库都支持使用如下所示的语法形式来创建索引:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> studentID_index</span><br><span class="line">    <span class="keyword">on</span> student(<span class="keyword">ID</span>);</span><br></pre></td></tr></table></figure><br>上述语句在<code>student</code>关系的属性<code>ID</code>上创建了一个名为<code>studentID_index</code>的索引。</p><h2 id="查询是自动使用索引"><a href="#查询是自动使用索引" class="headerlink" title="查询是自动使用索引"></a>查询是自动使用索引</h2><p>如果用户提交的<code>SQL</code>查询可以从索引的使用中获益,那么<strong><code>SQL</code>查询处理器就会自动使用索引</strong>。例如,给定的<code>SQL</code>査询是选出<code>ID</code>为22201的<code>student</code>元组,<code>SQL</code>查询处理器就会使用上面定义的<code>studentID_index</code>索引来找到所需元组,而不用读取整个关系。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第4章 中级SQL </category>
          
          <category> 4.5 SQL的数据类型与模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.5.2 默认值</title>
      <link href="/ReadingNotes//23a0cb2d/"/>
      <url>/ReadingNotes//23a0cb2d/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/23a0cb2d/#4-5-2-默认值" class="header_1">4.5.2 默认值</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="4-5-2-默认值"><a href="#4-5-2-默认值" class="headerlink" title="4.5.2 默认值"></a>4.5.2 默认值</h1><p><code>SQL</code>允许为属性指定默认值,如下面的<code>create table</code>语句所示:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(</span><br><span class="line">    <span class="keyword">ID</span> <span class="built_in">varchar</span>(<span class="number">5</span>),</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    dept_name <span class="built_in">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    tot_cred <span class="built_in">numeric</span>(<span class="number">3</span>,<span class="number">0</span>) <span class="keyword">default</span> <span class="number">0.</span> ,</span><br><span class="line">    primary <span class="keyword">key</span>(<span class="keyword">ID</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><br><code>tot_cred</code>属性的默认值被声明为<code>0</code>。这样,当一个元组被插入到<code>student</code>关系中,如果没有给出<code>tot_cred</code>属性的值,那么该元组在此属性上的取值就被置为<code>0</code>。<br>下面的插入语句说明了在插入操作中如何省略<code>tot_cred</code>属性的值:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(<span class="keyword">ID</span>, <span class="keyword">name</span>, dept_name)</span><br><span class="line">    <span class="keyword">values</span>(<span class="string">'12789'</span>,<span class="string">'Newman'</span>,<span class="string">'Comp. sci. '</span>);</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into student(ID, name, dept_name)</span><br><span class="line">    values('<span class="number">12789</span>','Newman','<span class="built_in">Comp</span>. sci. ');</span><br><span class="line">Query OK, <span class="number">1</span> row affected (<span class="number">0</span>.<span class="number">01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from student;</span><br><span class="line">+-------+--------+-------------+----------+</span><br><span class="line">| ID    | name   | dept_name   | tot_cred |</span><br><span class="line">+-------+--------+-------------+----------+</span><br><span class="line">| <span class="number">12789</span> | Newman | <span class="built_in">Comp</span>. sci.  | <span class="number">0</span>        |</span><br><span class="line">+-------+--------+-------------+----------+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> <span class="built_in">set</span> (<span class="number">0</span>.<span class="number">02</span> sec)</span><br></pre></td></tr></table></figure><br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第4章 中级SQL </category>
          
          <category> 4.5 SQL的数据类型与模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.5 SQL的数据类型与模式</title>
      <link href="/ReadingNotes//1d2f522e/"/>
      <url>/ReadingNotes//1d2f522e/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/1d2f522e/#4-5-SQL的数据类型与模式" class="header_1">4.5 SQL的数据类型与模式</a>&nbsp;<br><a href="/ReadingNotes/1d2f522e/#4-5-1-SQL中的日期和时间类型" class="header_1">4.5.1 SQL中的日期和时间类型</a>&nbsp;<br><a href="/ReadingNotes/1d2f522e/#字符串转成日期和时间类型" class="header_2">字符串转成日期和时间类型</a>&nbsp;<br><a href="/ReadingNotes/1d2f522e/#从日期和时间中提取年月日时分秒等信息" class="header_2">从日期和时间中提取年月日时分秒等信息</a>&nbsp;<br><a href="/ReadingNotes/1d2f522e/#SQL中获取当然日期和事件的函数" class="header_2">SQL中获取当然日期和事件的函数</a>&nbsp;<br><a href="/ReadingNotes/1d2f522e/#SQL支持的数据运算" class="header_2">SQL支持的数据运算</a>&nbsp;<br><a href="/ReadingNotes/1d2f522e/#什么是-时间间隔-类型" class="header_3">什么是`时间间隔`类型</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="4-5-SQL的数据类型与模式"><a href="#4-5-SQL的数据类型与模式" class="headerlink" title="4.5 SQL的数据类型与模式"></a>4.5 SQL的数据类型与模式</h1><p>在第3章中,我们介绍了一些<code>SQL</code>支持的固有数据类型,如整数类型、实数类型和字符类型。<code>SQL</code>还支持一些其他的固有数据类型,我们将在下面描述。我们还将描述如何<strong>在<code>SQL</code>中创建基本的<code>用户定义类型</code></strong>。</p><h1 id="4-5-1-SQL中的日期和时间类型"><a href="#4-5-1-SQL中的日期和时间类型" class="headerlink" title="4.5.1 SQL中的日期和时间类型"></a>4.5.1 SQL中的日期和时间类型</h1><p>除了我们在3.2节介绍过的基本数据类型以外,<code>SQL</code>标准还支持与<code>日期</code>和<code>时间</code>相关的几种数据类型:<br><code>date</code>:日历日期,包括年(四位)、月和日。<br><code>time</code>:一天中的时间,包括小时、分和秒。可以用变量<code>time(p)</code>来表示秒的小数点后的数字位数(这里默认值为0)。通过指定<code>time with timezone</code>,还可以把时区信息连同时间一起存储。<br><code>timestamp</code>:<code>date</code>和<code>time</code>的组合。可以用变量<code>timestamp(p)</code>来表示秒的小数点后的数字位数(这里默认值为<code>6</code>)。如果指定<code>with timezone</code>,则时区信息也会被存储。</p><p>日期和时间类型的值可按如下方式说明:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">date '2001-04-25'</span><br><span class="line">time '09:30:00'</span><br><span class="line">timestamp '2001-04-25 10:29:01.45'</span><br></pre></td></tr></table></figure><br>日期类型必须按照如上年月日的格式顺序指定。<code>time</code>和<code>timestamp</code>的秒部分可能会有小数部分,像上述时间戳中的情况一样。</p><h2 id="字符串转成日期和时间类型"><a href="#字符串转成日期和时间类型" class="headerlink" title="字符串转成日期和时间类型"></a>字符串转成日期和时间类型</h2><p>我们可以利用<code>cast e as t</code>形式的表达式来将一个字符串(或字符串表达式)<code>e</code>转换成类型<code>t</code>,其中<code>t</code>是<code>date</code>、<code>time</code>、 <code>timestamp</code>中的一种。字符串必须符合正确的格式,像本段开头说的那样。当需要时,时区信息可以从系统设置中得到。</p><h2 id="从日期和时间中提取年月日时分秒等信息"><a href="#从日期和时间中提取年月日时分秒等信息" class="headerlink" title="从日期和时间中提取年月日时分秒等信息"></a>从日期和时间中提取年月日时分秒等信息</h2><p>我们可以利用<code>extract(field from d)</code>,从<code>date</code>或<code>time</code>值<code>d</code>中提取出单独的域,这里的域可以是<code>year</code>、 <code>month</code>、<code>day</code>、<code>hour</code>、 <code>minute</code>或者<code>second</code>中的任意一种。时区信息可以用<code>timezone_hour</code>和<code>timezone_minute</code>来提取。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select extract(year from current_date());</span><br><span class="line">+-----------------------------------+</span><br><span class="line">| extract(year from current_date()) |</span><br><span class="line">+-----------------------------------+</span><br><span class="line">|                              <span class="number">2019</span> |</span><br><span class="line">+-----------------------------------+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> <span class="built_in">set</span> (<span class="number">0</span>.<span class="number">02</span> sec)</span><br></pre></td></tr></table></figure><h2 id="SQL中获取当然日期和事件的函数"><a href="#SQL中获取当然日期和事件的函数" class="headerlink" title="SQL中获取当然日期和事件的函数"></a>SQL中获取当然日期和事件的函数</h2><p><code>SQL</code>定义了一些函数以获取当前日期和时间。例如, </p><ul><li><code>current_date</code>返回当前日期, </li><li><code>current_time</code>返回当前时间(带有时区),</li><li>还有<code>localtime</code>返回当前的本地时间(不带时区)。</li><li>时间戳(日期加上时间)由<code>current_timestamp</code>(带有时区)</li><li>以及<code>localtimestamp</code>(本地日期和时间,不带时区)</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select current_date();</span><br><span class="line">+----------------+</span><br><span class="line">| current_date() |</span><br><span class="line">+----------------+</span><br><span class="line">| <span class="number">2019</span>-<span class="number">10</span>-<span class="number">21</span>     |</span><br><span class="line">+----------------+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> <span class="built_in">set</span> (<span class="number">0</span>.<span class="number">02</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select current_time();</span><br><span class="line">+----------------+</span><br><span class="line">| current_time() |</span><br><span class="line">+----------------+</span><br><span class="line">| <span class="number">18</span>:<span class="number">44</span>:<span class="number">48</span>       |</span><br><span class="line">+----------------+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> <span class="built_in">set</span> (<span class="number">0</span>.<span class="number">01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select localtime();</span><br><span class="line">+---------------------+</span><br><span class="line">| localtime()         |</span><br><span class="line">+---------------------+</span><br><span class="line">| <span class="number">2019</span>-<span class="number">10</span>-<span class="number">21</span> <span class="number">18</span>:<span class="number">45</span>:<span class="number">00</span> |</span><br><span class="line">+---------------------+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> <span class="built_in">set</span> (<span class="number">0</span>.<span class="number">02</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select current_timestamp();</span><br><span class="line">+---------------------+</span><br><span class="line">| current_timestamp() |</span><br><span class="line">+---------------------+</span><br><span class="line">| <span class="number">2019</span>-<span class="number">10</span>-<span class="number">21</span> <span class="number">18</span>:<span class="number">45</span>:<span class="number">11</span> |</span><br><span class="line">+---------------------+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> <span class="built_in">set</span> (<span class="number">0</span>.<span class="number">02</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select localtimestamp();</span><br><span class="line">+---------------------+</span><br><span class="line">| localtimestamp()    |</span><br><span class="line">+---------------------+</span><br><span class="line">| <span class="number">2019</span>-<span class="number">10</span>-<span class="number">21</span> <span class="number">18</span>:<span class="number">45</span>:<span class="number">29</span> |</span><br><span class="line">+---------------------+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> <span class="built_in">set</span> (<span class="number">0</span>.<span class="number">03</span> sec)</span><br></pre></td></tr></table></figure><h2 id="SQL支持的数据运算"><a href="#SQL支持的数据运算" class="headerlink" title="SQL支持的数据运算"></a>SQL支持的数据运算</h2><p><code>SQL</code>允许在上面列出的所有类型上进行<strong>比较运算</strong>,也允许在各种<strong>数字类型</strong>上进行<strong>算术运算</strong>和<strong>比较运算</strong>。<code>SQL</code>还支持<code>interval</code>数据类型,它允许在日期、时间和<strong>时间间隔</strong>上进行<strong>计算</strong>。</p><h3 id="什么是时间间隔类型"><a href="#什么是时间间隔类型" class="headerlink" title="什么是时间间隔类型"></a>什么是<code>时间间隔</code>类型</h3><p>例如,假设x和y都是<code>date</code>类型,那么x-y就是时间间隔类型,其值为<strong>从日期x到日期y<code>间隔</code>的天数</strong>。类似地,在<strong>日期或时间上加减一个<code>时间间隔</code>将分别得到新的日期或时间</strong><br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第4章 中级SQL </category>
          
          <category> 4.5 SQL的数据类型与模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.4.7 复杂check条件与断言</title>
      <link href="/ReadingNotes//708bdc81/"/>
      <url>/ReadingNotes//708bdc81/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/708bdc81/#4-4-7-复杂check条件与断言" class="header_1">4.4.7 复杂check条件与断言</a>&nbsp;<br><a href="/ReadingNotes/708bdc81/#复杂check条件" class="header_2">复杂check条件</a>&nbsp;<br><a href="/ReadingNotes/708bdc81/#断言" class="header_2">断言</a>&nbsp;<br><a href="/ReadingNotes/708bdc81/#断言-示例" class="header_2">断言 示例</a>&nbsp;<br><a href="/ReadingNotes/708bdc81/#第一个断言-实现" class="header_3">第一个断言 实现</a>&nbsp;<br><a href="/ReadingNotes/708bdc81/#只有不破坏断言的数据库修改才被允许" class="header_2">只有不破坏断言的数据库修改才被允许</a>&nbsp;<br><a href="/ReadingNotes/708bdc81/#可以通过触发器来实现和断言等价的功能" class="header_2">可以通过触发器来实现和断言等价的功能</a>&nbsp;<br><a href="/ReadingNotes/708bdc81/#-MySQL-不支持断言-create-assertion" class="header_2">`MySQL`不支持断言`create assertion`</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="4-4-7-复杂check条件与断言"><a href="#4-4-7-复杂check条件与断言" class="headerlink" title="4.4.7 复杂check条件与断言"></a>4.4.7 复杂check条件与断言</h1><h2 id="复杂check条件"><a href="#复杂check条件" class="headerlink" title="复杂check条件"></a>复杂check条件</h2><p>本节描述<code>SQL</code>标准所支持的另外一些用于声明完整性约束的结构。然而,读者应该注意的是,这结构目前还没有被大多数数据库系统支持。<br>正如<code>SQL</code>标准所定义的, <code>check</code>子句中的谓词可以是<strong>包含子查询的任意谓词</strong>。如果一个数据库实现支持在<code>check</code>子句中出现子查询,我们就可以在关系<code>section</code>上声明如下所示的参照完整性约束:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">check</span>( time_slot_id <span class="keyword">in</span>( <span class="keyword">select</span> time_slot_id <span class="keyword">from</span> time_slot ))</span><br></pre></td></tr></table></figure><br>这个<code>check</code>条件检测在<code>section</code>关系中每个元组的<code>time_slot_id</code>的确是在<code>time_slot</code>关系中某个时间段的标识。<br>因此这个条件不仅在<code>section</code>中插入或修改元组时需要检测,而且在<code>time_slot</code>关系改变时也需要检测(如在<code>time_slot</code>关系中,当一个元组被删除或修改的情况下)。<br>在我们的大学模式上,另一个自然的约束是:<strong>每个课程段都需要有至少一位教师来讲授</strong>。<br>为了强制实现此约束,一种方案是声明<code>section</code>关系的属性集<code>(course_d,seed, semester,yea)</code>为外码,它参照<code>teaches</code>关系中的相应属性。遗憾的是,这些属性并未构成<code>teaches</code>关系的主码。如果数据库系统支持在<code>check</code>约束中出现子查询的话,可以使用与<code>time_slot</code>属性类似的<code>check</code>约束来强制实现上述约束。<br>复杂<code>check</code>条件在我们希望确保数据完整性的时候是很有用的,但<code>其检测开销可能会很大</code>。例如<code>check</code>子句中的谓词不仅需要在<code>section</code>关系发生更新时计算,而且也可能在<code>time_slot</code>关系发生更新时检测,因为<code>time_slot</code>在子查询中被引用了。</p><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p><strong>一个断言(<code>assertion</code>)就是一个谓词</strong>,是一种<strong>命名约束</strong>，它表达了<strong>数据库状态必须满足的逻辑条件</strong><br><strong><code>域约束</code>和<code>参照完整性约束</code>是断言的<code>特殊形式</code></strong>。</p><h2 id="断言-示例"><a href="#断言-示例" class="headerlink" title="断言 示例"></a>断言 示例</h2><p>我们前面用大量篇幅介绍了这几种形式的断言,是因为它们容易检测并且适用于很多数据库应用。但是,还有许多约束不能仅用这几种特殊形式来表达。如有两个这样的例子:</p><ul><li>对于<code>student</code>关系中的每个元组,它在属性<code>tot_cred</code>上的取值必须等于该生所成功修完课程的学分总和。</li><li>每位教师不能在同一个学期的同一个时间段在两个不同的教室授课。</li></ul><p><code>SQL</code>中的断言为如下形式:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">assertion</span> &lt;<span class="keyword">assertion</span>-<span class="keyword">name</span>&gt; &lt;<span class="keyword">check</span> predicate&gt;;</span><br></pre></td></tr></table></figure></p><h3 id="第一个断言-实现"><a href="#第一个断言-实现" class="headerlink" title="第一个断言 实现"></a>第一个断言 实现</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">assertion</span> credits_earned_constraint <span class="keyword">check</span>(</span><br><span class="line"> <span class="keyword">not</span> <span class="keyword">exists</span>(</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">ID</span></span><br><span class="line">        <span class="keyword">from</span> student</span><br><span class="line">        <span class="keyword">where</span> tot_cred&lt;&gt;(</span><br><span class="line">            <span class="keyword">select</span> <span class="keyword">sum</span>(credits)</span><br><span class="line">                <span class="keyword">from</span> takes <span class="keyword">natural</span> <span class="keyword">join</span> course</span><br><span class="line">                <span class="keyword">where</span> student.ID= takes.ID</span><br><span class="line">                        <span class="keyword">and</span> grade <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">                        <span class="keyword">and</span> grade &lt;&gt;<span class="string">'F'</span></span><br><span class="line">        )</span><br><span class="line">))</span><br></pre></td></tr></table></figure><h2 id="只有不破坏断言的数据库修改才被允许"><a href="#只有不破坏断言的数据库修改才被允许" class="headerlink" title="只有不破坏断言的数据库修改才被允许"></a>只有不破坏断言的数据库修改才被允许</h2><p>当创建断言时,系统要检测其有效性。如果断言有效,则今后只有不破坏断言的数据库修改才被允许。如果断言较复杂,则检测会带来相当大的开销。因此,使用断言应该特别小心。<br>由于检测和维护断言的开销较大,一些系统开发者省去了对一般性断言的支持,或者只提供易于检测的特殊形式的断言。<br><strong>目前,还没有一个广泛使用的数据库系统支持在<code>check</code>子句的谓词中使用子查询或<code>create assertion</code>结构</strong>。</p><h2 id="可以通过触发器来实现和断言等价的功能"><a href="#可以通过触发器来实现和断言等价的功能" class="headerlink" title="可以通过触发器来实现和断言等价的功能"></a>可以通过触发器来实现和断言等价的功能</h2><p>然而,如果数据库系统支持触发器的话,<strong>可以通过使用触发器来实现等价的功能</strong>,<br>触发器将在5.3节介绍,5.3节还将介绍如何用触发器来实现<code>time_slot_id</code>上的参照完整性约束。</p><h2 id="MySQL不支持断言create-assertion"><a href="#MySQL不支持断言create-assertion" class="headerlink" title="MySQL不支持断言create assertion"></a><code>MySQL</code>不支持断言<code>create assertion</code></h2><p>经过我的测试<code>MySQL 8.0</code>好像不支持<code>create assertion</code>断言。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第4章 中级SQL </category>
          
          <category> 4.4 完整性约束 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.4.6 事务中对完整性约束的违反</title>
      <link href="/ReadingNotes//224c5d49/"/>
      <url>/ReadingNotes//224c5d49/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/224c5d49/#4-4-6-事务中对完整性约束的违反" class="header_1">4.4.6 事务中对完整性约束的违反</a>&nbsp;<br><a href="/ReadingNotes/224c5d49/#1-延迟约束检查到事务结束时" class="header_2">1. 延迟约束检查到事务结束时</a>&nbsp;<br><a href="/ReadingNotes/224c5d49/#2-通过设置null来让事务不违反完整性约束" class="header_3">2. 通过设置null来让事务不违反完整性约束</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="4-4-6-事务中对完整性约束的违反"><a href="#4-4-6-事务中对完整性约束的违反" class="headerlink" title="4.4.6 事务中对完整性约束的违反"></a>4.4.6 事务中对完整性约束的违反</h1><p><strong>事务可能包括几个步骤,在某一步之后完整性约束也许会暂时被违反,但是后面的某一步也许就会消除这个违反</strong>。</p><p>例如,假设我们有一个主码为<code>name</code>的<code>person</code>关系,还有一个属性是<code>ouse,</code>并且<code>spouse</code>是在<code>person</code>上的一个外码。也就是说,约束要求<code>spouse</code>属性必须包含在<code>person</code>表里出现的名字假设我们希望在上述关系中插入两个元组,一个是关于<code>John</code>的,另一个是关于<code>Mary</code>的,这两个元组的配偶属性分别设置为<code>Mary</code>和<code>John,</code>以此表示<code>John</code>和<code>Mary</code>彼此之间的婚姻关系。<strong>无论先插入哪个元组,插入第一个元组的时候都会违反外码约束。在插入第二个元组后,外码约束又会满足了</strong>。</p><h2 id="1-延迟约束检查到事务结束时"><a href="#1-延迟约束检查到事务结束时" class="headerlink" title="1. 延迟约束检查到事务结束时"></a>1. 延迟约束检查到事务结束时</h2><p>为了处理这样的情况,<code>SQL</code>标准允许将<code>initially deferred</code>子句加入到约束声明中;<br><strong>这样完整性约束不是在事务的中间步骤上检查,而是在事务结束的时候检查</strong>。<br>一个约束可以被指定为可延迟的(<code>deferrable</code>),这意味着默认情况下它会被立即检查,但是在需要的时候可以延迟检查。<br>对于声明为可延迟的约束,执行<code>set constraints constrain-list deferred</code>语句作为事务的一部分,会导致<strong>对指定约束的检查被延迟到该事务结束时执行</strong>。<br>然而,读者应该注意的是<strong>默认的方式是立即检查约束,而且许多数据库实现不支持延迟约束检查</strong>。</p><h3 id="2-通过设置null来让事务不违反完整性约束"><a href="#2-通过设置null来让事务不违反完整性约束" class="headerlink" title="2. 通过设置null来让事务不违反完整性约束"></a>2. 通过设置null来让事务不违反完整性约束</h3><p>如果<code>spouse</code>属性可以被赋为<code>null</code>,我们可以用另一种方式来避开在上面例子中的问题:<br>在插入<code>John</code>和<code>Mary</code>元组时,我们设置其<code>spouse</code>属性为<code>null</code>,然后再更新它们的值。然而,这个技术需要更大的编程量,而且如果属性不能设为<code>null</code>的话,此方法就不可行。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第4章 中级SQL </category>
          
          <category> 4.4 完整性约束 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.4.5 参照完整性</title>
      <link href="/ReadingNotes//80c6a36e/"/>
      <url>/ReadingNotes//80c6a36e/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/80c6a36e/#4-4-5-参照完整性" class="header_1">4.4.5 参照完整性</a>&nbsp;<br><a href="/ReadingNotes/80c6a36e/#参照完整性是什么" class="header_2">参照完整性是什么</a>&nbsp;<br><a href="/ReadingNotes/80c6a36e/#什么是外码" class="header_2">什么是外码</a>&nbsp;<br><a href="/ReadingNotes/80c6a36e/#参照完整性约束" class="header_2">参照完整性约束</a>&nbsp;<br><a href="/ReadingNotes/80c6a36e/#参照完整性约束和外码约束的区别" class="header_2">参照完整性约束和外码约束的区别</a>&nbsp;<br><a href="/ReadingNotes/80c6a36e/#个人总结" class="header_3">个人总结</a>&nbsp;<br><a href="/ReadingNotes/80c6a36e/#references子句" class="header_2">references子句</a>&nbsp;<br><a href="/ReadingNotes/80c6a36e/#references子句指定的被参照关系的属性列表必须是候选码" class="header_3">references子句指定的被参照关系的属性列表必须是候选码</a>&nbsp;<br><a href="/ReadingNotes/80c6a36e/#参照的属性不是候选码-的情况" class="header_2">参照的属性不是候选码 的情况</a>&nbsp;<br><a href="/ReadingNotes/80c6a36e/#外码定义-示例" class="header_2">外码定义 示例</a>&nbsp;<br><a href="/ReadingNotes/80c6a36e/#违反参照完整性约束时的做法" class="header_2">违反参照完整性约束时的做法</a>&nbsp;<br><a href="/ReadingNotes/80c6a36e/#做法1-拒绝" class="header_3">做法1 拒绝</a>&nbsp;<br><a href="/ReadingNotes/80c6a36e/#做法2-修改参照关系中的元组来恢复完整性" class="header_3">做法2 修改参照关系中的元组来恢复完整性</a>&nbsp;<br><a href="/ReadingNotes/80c6a36e/#级联删除" class="header_4">级联删除</a>&nbsp;<br><a href="/ReadingNotes/80c6a36e/#级联更新" class="header_4">级联更新</a>&nbsp;<br><a href="/ReadingNotes/80c6a36e/#设置为空或默认值" class="header_4">设置为空或默认值</a>&nbsp;<br><a href="/ReadingNotes/80c6a36e/#级联更新或删除会传递" class="header_3">级联更新或删除会传递</a>&nbsp;<br><a href="/ReadingNotes/80c6a36e/#级联更新或级联删除也无法解决-则撤销所有级联操作" class="header_3">级联更新或级联删除也无法解决 则撤销所有级联操作</a>&nbsp;<br><a href="/ReadingNotes/80c6a36e/#外码可以为null" class="header_2">外码可以为null</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="4-4-5-参照完整性"><a href="#4-4-5-参照完整性" class="headerlink" title="4.4.5 参照完整性"></a>4.4.5 参照完整性</h1><h2 id="参照完整性是什么"><a href="#参照完整性是什么" class="headerlink" title="参照完整性是什么"></a>参照完整性是什么</h2><p>我们常常希望<strong>保证在一个关系中给定属性集上的取值也在另一关系的特定属性集的取值中出现</strong>。这种情况称为<strong>参照完整性</strong>(<code>referential integrity</code>)。<br>正如我们此前在<code>3.2.2</code>节所见,外码可以用作为<code>SQL</code>中<code>create table</code>语句一部分的<code>foreign key</code>子句来声明。<br>我们用大学数据库<code>SQL DLL</code>定义的一部分来说明外码声明:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> course(</span><br><span class="line">    course_id <span class="built_in">varchar</span>(<span class="number">8</span>), </span><br><span class="line">    title <span class="built_in">varchar</span>(<span class="number">50</span>), </span><br><span class="line">    dept_name <span class="built_in">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    credits <span class="built_in">numeric</span>(<span class="number">2</span>,<span class="number">0</span>) <span class="keyword">check</span> (credits &gt; <span class="number">0</span>),</span><br><span class="line">    primary <span class="keyword">key</span> (course_id),</span><br><span class="line">    <span class="keyword">foreign</span> <span class="keyword">key</span> (dept_name)</span><br><span class="line">        <span class="keyword">references</span> department(dept_name)</span><br><span class="line">        <span class="keyword">on</span> <span class="keyword">delete</span> <span class="keyword">set</span> <span class="literal">null</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><br><code>course</code>表的定义中有一个声明”<code>foreign key(dept_name) references department</code>“。这个外码声明表示,在每个课程元组中指定的系名必须在<code>department</code>关系中存在。没有这个约束,就可能会为一门课程指定一个不存在的系名。</p><h2 id="什么是外码"><a href="#什么是外码" class="headerlink" title="什么是外码"></a>什么是外码</h2><p>更一般地,令关系<code>r1</code>和<code>r2</code>的属性集分别为<code>R1</code>和<code>R2</code>,主码分别为<code>K1</code>和<code>K2</code>。如果要求对<code>r2</code>中任意元组<code>t2</code>,均存在<code>r1</code>中元组<code>t1</code>使得<code>t1.K1=t2.α</code>,我们称<code>R2</code>的子集<code>α</code>为参照关系<code>r1</code>中<code>K1</code>的外码(<code>foreigkey</code>)。</p><h2 id="参照完整性约束"><a href="#参照完整性约束" class="headerlink" title="参照完整性约束"></a>参照完整性约束</h2><p>这种要求称为<strong>参照完整性约束</strong>(<code>referential-intergrity constraint)</code>或<strong>子集依赖</strong>( <code>subset dependency</code>)。</p><p><strong>子集依赖</strong>这种称法是由于上述参照完整性可以表示为这样一种要求:<code>r2</code>中<code>α</code>上的取值集合必须是<code>r1</code>中<code>K1</code>上的取值集合的<code>子集</code>。<br>请注意,为使参照完整性约束有意义,<code>α</code>和<code>K1</code>必须是相容的属性集;也就是说,<br>要么<code>α</code>等于<code>K1</code>,<br>要么它们必须包含相同数目的属性,并且对应属性的类型必须相容(这里我们假设<code>α</code>和<code>K,</code>是有序的)。</p><h2 id="参照完整性约束和外码约束的区别"><a href="#参照完整性约束和外码约束的区别" class="headerlink" title="参照完整性约束和外码约束的区别"></a>参照完整性约束和外码约束的区别</h2><ul><li>默认情况下,<code>SQL</code>中<strong><code>外码参照的是</code>被参照表中的<code>主码属性</code></strong>。</li><li>不同于外码约束,<strong>参照完整性约束</strong>通常<strong>不要求<code>K1</code>是<code>r1</code>的主码</strong>;其结果是,<code>r1</code>中可能有不止个元组在属性<code>K1</code>上取值相同。</li></ul><h3 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h3><ul><li>参照完整性约束要求有就行了,这可能会有重复.</li><li>外码约束不仅要有,还要唯一</li></ul><h2 id="references子句"><a href="#references子句" class="headerlink" title="references子句"></a>references子句</h2><p><code>SQL</code>还支持一个<strong>可以<code>显式指定被参照关系的属性列表</code>的<code>references</code>子句</strong>。</p><h3 id="references子句指定的被参照关系的属性列表必须是候选码"><a href="#references子句指定的被参照关系的属性列表必须是候选码" class="headerlink" title="references子句指定的被参照关系的属性列表必须是候选码"></a>references子句指定的被参照关系的属性列表必须是候选码</h3><p>然而,这个指定的属性列表必须声明为被参照关系的<strong>候选码</strong>,要么使用<code>primary key</code>约束,要么使用<code>unique</code>约束。</p><h2 id="参照的属性不是候选码-的情况"><a href="#参照的属性不是候选码-的情况" class="headerlink" title="参照的属性不是候选码 的情况"></a>参照的属性不是候选码 的情况</h2><p>在更为普遍的参照完整性约束形式中,被<strong>参照的属性不必是候选码</strong>,这样的形式还<strong>不能在<code>SQL</code>中直接声明</strong>。<code>SQL</code>标准提供了另外的结构用于实现这样的约束,<code>4.4.7</code>节将描述这样的结构。</p><h2 id="外码定义-示例"><a href="#外码定义-示例" class="headerlink" title="外码定义 示例"></a>外码定义 示例</h2><p>我们可以使用如下的简写形式作为属性定义的一部分,并声明该属性为外码:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">depr_name varchar(20)</span><br><span class="line">    references department</span><br></pre></td></tr></table></figure></p><h2 id="违反参照完整性约束时的做法"><a href="#违反参照完整性约束时的做法" class="headerlink" title="违反参照完整性约束时的做法"></a>违反参照完整性约束时的做法</h2><h3 id="做法1-拒绝"><a href="#做法1-拒绝" class="headerlink" title="做法1 拒绝"></a>做法1 拒绝</h3><p>当违反参照完整性约束时,通常的处理是拒绝执行导致完整性破坏的操作(即进行更新操作的事务被回滚)。</p><h3 id="做法2-修改参照关系中的元组来恢复完整性"><a href="#做法2-修改参照关系中的元组来恢复完整性" class="headerlink" title="做法2 修改参照关系中的元组来恢复完整性"></a>做法2 修改参照关系中的元组来恢复完整性</h3><p>但是,在<code>foreign key</code>子句中可以指明:如果被参照关系上的删除或更新动作违反了约束,那么系统必须<strong>采取一些步骤通过修改参照关系中的元组来恢复完整性约束</strong>,而不是拒绝这样的动作。考虑在关系<code>course</code>上的如下完整性约束定义:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> course(</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">foreign</span> <span class="keyword">key</span> (dept_name)</span><br><span class="line">        <span class="keyword">references</span> department(dept_name)</span><br><span class="line">        <span class="keyword">on</span> <span class="keyword">delete</span> <span class="keyword">cascade</span></span><br><span class="line">        <span class="keyword">on</span> <span class="keyword">update</span> <span class="keyword">cascade</span>,</span><br><span class="line">    ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><h4 id="级联删除"><a href="#级联删除" class="headerlink" title="级联删除"></a>级联删除</h4><p>由于有了与外码声明相关联的<code>on delete cascade</code>子句,<br>如果删除<code>department</code>中的元组导致了此参照完整性约束被违反,则删除并不被系统拒绝,<br>而是对<code>course</code>关系作”级联”删除,即删除course关系中参照<code>被删除系名</code>的元组。</p><h4 id="级联更新"><a href="#级联更新" class="headerlink" title="级联更新"></a>级联更新</h4><p>类似地,如果更新被参照字段时违反了约束,则更新操作并不被系统拒绝,<br>而是将<code>course</code>中参照的元组的<code>dept_name</code>字段也改为新值。</p><h4 id="设置为空或默认值"><a href="#设置为空或默认值" class="headerlink" title="设置为空或默认值"></a>设置为空或默认值</h4><p><code>SQL</code>还允许<code>foreign key</code>子句指明除<code>cascade</code>以外的其他动作,例如:</p><ul><li>用<code>set null</code>代替上面的<code>cascade</code>,这样如果约束被违反:可将参照域(<code>dept_name</code>)置为<code>null</code>,</li><li>用<code>set default</code>代替上面的<code>cascade</code>,这样如果约束被违反:可将参照域(<code>dept_name</code>)置为<strong>域的默认值</strong>。</li></ul><h3 id="级联更新或删除会传递"><a href="#级联更新或删除会传递" class="headerlink" title="级联更新或删除会传递"></a>级联更新或删除会传递</h3><p>如果存在涉及多个关系的外码依赖链,则在链一端所做的删除或更新可能传至整个链。</p><h3 id="级联更新或级联删除也无法解决-则撤销所有级联操作"><a href="#级联更新或级联删除也无法解决-则撤销所有级联操作" class="headerlink" title="级联更新或级联删除也无法解决 则撤销所有级联操作"></a>级联更新或级联删除也无法解决 则撤销所有级联操作</h3><p>如果个级联更新或删除导致的对约束的违反不能通过进一步的级联操作解决,则系统中止该事务。于是,该事务所做的所有改变及级联动作将被撤销。</p><h2 id="外码可以为null"><a href="#外码可以为null" class="headerlink" title="外码可以为null"></a>外码可以为null</h2><ul><li>空值使得<code>SQL</code>中参照约束的语义复杂化了。外码中的属性允许为<code>null,</code>只要它们没有被声明为<code>not null</code>。</li><li>如果给定元组中<code>外码</code>的所有列上均取<code>非空值</code>,则对该元组采用外码约束的通常定义。</li><li>如果某外码列为<code>null</code>,则该元组自动被认为满足约束</li><li>这样的规定有时不一定是正确的选择,因此<code>SQL</code>也提供一些结构使你可以改变对空值的处理，我们在此不讨论这样的结构。</li></ul><!--SSTStop-->]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第4章 中级SQL </category>
          
          <category> 4.4 完整性约束 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.4.2 not null约束 4.4.3 unique约束 4.4.4 check子句</title>
      <link href="/ReadingNotes//84fd5ff1/"/>
      <url>/ReadingNotes//84fd5ff1/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/84fd5ff1/#4-4-2-not-null约束" class="header_1">4.4.2 not null约束</a>&nbsp;<br><a href="/ReadingNotes/84fd5ff1/#not-null约束写法" class="header_2">not null约束写法</a>&nbsp;<br><a href="/ReadingNotes/84fd5ff1/#主码不用声明not-null" class="header_2">主码不用声明not null</a>&nbsp;<br><a href="/ReadingNotes/84fd5ff1/#4-4-3-unique约束" class="header_1">4.4.3 unique约束</a>&nbsp;<br><a href="/ReadingNotes/84fd5ff1/#unique声明的属性形成候选码" class="header_2">unique声明的属性形成候选码</a>&nbsp;<br><a href="/ReadingNotes/84fd5ff1/#unique中的属性可以为null" class="header_2">unique中的属性可以为null</a>&nbsp;<br><a href="/ReadingNotes/84fd5ff1/#4-4-4-check子句" class="header_1">4.4.4 check子句</a>&nbsp;<br><a href="/ReadingNotes/84fd5ff1/#实例-在建表时指定check子句" class="header_2">实例 在建表时指定check子句</a>&nbsp;<br><a href="/ReadingNotes/84fd5ff1/#验证" class="header_2">验证</a>&nbsp;<br><a href="/ReadingNotes/84fd5ff1/#不满足check子句的插入会被拒绝" class="header_3">不满足check子句的插入会被拒绝</a>&nbsp;<br><a href="/ReadingNotes/84fd5ff1/#满足check子句的插入才会通过" class="header_3">满足check子句的插入才会通过</a>&nbsp;<br><a href="/ReadingNotes/84fd5ff1/#目前check子句谓词不能是子查询" class="header_2">目前check子句谓词不能是子查询</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="4-4-2-not-null约束"><a href="#4-4-2-not-null约束" class="headerlink" title="4.4.2 not null约束"></a>4.4.2 not null约束</h1><p>正如我们在第3章中讨论过的,<strong>空值是所有域的成员</strong>,因此在默认情况下是<code>SQL</code>中每个属性的合法值。然而对于一些属性来说,空值可能是不合适的。<br>考虑<code>student</code>关系中的一个元组,其中<code>name</code>是<code>null</code>。这样的元组给出了一个未知学生的学生信息;因此它不含有有用的信息。<br>类似地,我们不会希望系的预算为<code>null</code>。</p><h2 id="not-null约束写法"><a href="#not-null约束写法" class="headerlink" title="not null约束写法"></a>not null约束写法</h2><p>在这些情况下,我们希望禁止空值,我们可以通过如下声明来通过限定属性<code>name</code>和<code>budget</code>的域来排除空值:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name varchar(20) not null</span><br><span class="line">budget numeric(12,2) not null</span><br></pre></td></tr></table></figure></p><h2 id="主码不用声明not-null"><a href="#主码不用声明not-null" class="headerlink" title="主码不用声明not null"></a>主码不用声明not null</h2><p><code>not null</code>声明禁止在该属性上插入空值。任何可能导致向一个声明为<code>not null</code>的属性插入空值的数据库修改都会产生错误诊断信息。<br>许多情况下我们希望避免空值。尤其是<strong><code>SQL</code>禁止在关系模式的<code>主码</code>中出现<code>空值</code></strong>。因此,在我们的大学例子中,在<code>department</code>关系上如果声明属性<code>dept_name</code>为<code>department</code>的主码,那它就不能为空。因此<strong>主码(<code>dept_name</code>)不必显式地声明为<code>not null</code></strong></p><h1 id="4-4-3-unique约束"><a href="#4-4-3-unique约束" class="headerlink" title="4.4.3 unique约束"></a>4.4.3 unique约束</h1><p><code>SQL</code>还支持下面这种完整性约束:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unique(A1,A2,...,An)</span><br></pre></td></tr></table></figure></p><h2 id="unique声明的属性形成候选码"><a href="#unique声明的属性形成候选码" class="headerlink" title="unique声明的属性形成候选码"></a>unique声明的属性形成候选码</h2><p><code>unique</code>声明指出属性<code>A1,A2,...,An</code>形成了一个<strong>候选码</strong>;<br>即<strong>在关系中没有两个元组能在所有列出的属性<code>A1,A2,...,An</code>上取值相同</strong>。</p><h2 id="unique中的属性可以为null"><a href="#unique中的属性可以为null" class="headerlink" title="unique中的属性可以为null"></a>unique中的属性可以为null</h2><p>然而<code>候选码属性</code>可以为<code>null</code>,除非它们已被显式地声明为<code>not null</code>。<br>回忆一下,<strong>空值不等于其他的任何值</strong>。(这里对空值的处理与<code>3.8.4</code>节中定义的<code>unique</code>结构一样。)</p><h1 id="4-4-4-check子句"><a href="#4-4-4-check子句" class="headerlink" title="4.4.4 check子句"></a>4.4.4 check子句</h1><p>当应用于关系声明时, <code>check(P)</code>子句指定一个谓词<code>P,</code>关系中的每个元组都必须满足谓词<code>P</code>。<br><strong>通常用<code>check</code>子句用来<code>保证属性值满足指定的条件</code></strong>。<br>实际上创建了一个强大的类型系统。例如,在创建关系<code>department</code>的<code>create table</code>命令中的<code>check(budget&gt;0)</code>子句将保证<code>budget</code>上的取值是正数。</p><h2 id="实例-在建表时指定check子句"><a href="#实例-在建表时指定check子句" class="headerlink" title="实例 在建表时指定check子句"></a>实例 在建表时指定check子句</h2><p>作为另一个例子,考虑如下语句:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">section</span> (</span><br><span class="line">    course_id <span class="built_in">varchar</span>(<span class="number">8</span>), </span><br><span class="line">    sec_id <span class="built_in">varchar</span>(<span class="number">8</span>),</span><br><span class="line">    semester <span class="built_in">varchar</span>(<span class="number">6</span>),</span><br><span class="line">    <span class="keyword">year</span> <span class="built_in">numeric</span>(<span class="number">4</span>,<span class="number">0</span>),</span><br><span class="line">    building <span class="built_in">varchar</span>(<span class="number">15</span>),</span><br><span class="line">    room_number <span class="built_in">varchar</span>(<span class="number">7</span>),</span><br><span class="line">    time_slot_id <span class="built_in">varchar</span>(<span class="number">4</span>),</span><br><span class="line">    primary <span class="keyword">key</span> (course_id, sec_id, semester, <span class="keyword">year</span>),</span><br><span class="line">    <span class="keyword">check</span> (semester <span class="keyword">in</span> (<span class="string">'Fall'</span>, <span class="string">'Winter'</span>, <span class="string">'Spring'</span>, <span class="string">'Summer'</span>))</span><br><span class="line">);</span><br></pre></td></tr></table></figure><br>这里我们用<code>check</code>子句模拟了一个枚举类型,通过指定<code>semester</code>必须是’<code>Fall</code>‘、 <code>Winter</code>、 <code>Spring</code>或’ <code>Summer</code>‘中的一个来实现。这样, <code>check</code>子句允许以有力的方式对属性域加以限制。</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>以下在<code>MySQL 8.0</code>中验证通过</p><h3 id="不满足check子句的插入会被拒绝"><a href="#不满足check子句的插入会被拒绝" class="headerlink" title="不满足check子句的插入会被拒绝"></a>不满足check子句的插入会被拒绝</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">section</span></span><br><span class="line">    <span class="keyword">values</span>(<span class="string">'1111'</span>,<span class="string">'2222'</span>,<span class="string">'3333'</span>,<span class="number">2019</span>,<span class="string">'大楼'</span>,<span class="string">'4444'</span>,<span class="string">'5555'</span>);</span><br></pre></td></tr></table></figure><p>这个插入语句试图向<code>semester</code>属性赋值<code>3333</code>,这不满足<code>check</code>子句的要求,系统会拒绝插入操作.<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into section values('<span class="number">1111</span>','<span class="number">2222</span>','<span class="number">3333</span>',<span class="number">2019</span>,'大楼','<span class="number">4444</span>','<span class="number">5555</span>');</span><br><span class="line"><span class="number">3819</span> - Check constraint 'section_chk_1' is violated.</span><br></pre></td></tr></table></figure></p><h3 id="满足check子句的插入才会通过"><a href="#满足check子句的插入才会通过" class="headerlink" title="满足check子句的插入才会通过"></a>满足check子句的插入才会通过</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">section</span></span><br><span class="line">    <span class="keyword">values</span>(<span class="string">'1111'</span>,<span class="string">'2222'</span>,<span class="string">'Fall'</span>,<span class="number">2019</span>,<span class="string">'大楼'</span>,<span class="string">'4444'</span>,<span class="string">'5555'</span>);</span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into section values('<span class="number">1111</span>','<span class="number">2222</span>','Fall',<span class="number">2019</span>,'大楼','<span class="number">4444</span>','<span class="number">5555</span>');</span><br><span class="line">Query OK, <span class="number">1</span> row affected (<span class="number">0</span>.<span class="number">01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from section;</span><br><span class="line">+-----------+--------+----------+------+----------+-------------+--------------+</span><br><span class="line">| course_id | sec_id | semester | year | building | room_number | time_slot_id |</span><br><span class="line">+-----------+--------+----------+------+----------+-------------+--------------+</span><br><span class="line">| <span class="number">1111</span>      | <span class="number">2222</span>   | Fall     | <span class="number">2019</span> | 大楼     | <span class="number">4444</span>        | <span class="number">5555</span>         |</span><br><span class="line">+-----------+--------+----------+------+----------+-------------+--------------+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> <span class="built_in">set</span> (<span class="number">0</span>.<span class="number">04</span> sec)</span><br></pre></td></tr></table></figure><h2 id="目前check子句谓词不能是子查询"><a href="#目前check子句谓词不能是子查询" class="headerlink" title="目前check子句谓词不能是子查询"></a>目前check子句谓词不能是子查询</h2><p>根据<code>SQL</code>标准, <code>check</code>子句中的谓词可以是包括子查询在内的任意谓词。然而,当前还没有一个广泛使用的数据库产品允许<code>check</code>子句包含子查询的谓词。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第4章 中级SQL </category>
          
          <category> 4.4 完整性约束 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.4 完整性约束 4.4.1 单个关系上的约束</title>
      <link href="/ReadingNotes//4286b88a/"/>
      <url>/ReadingNotes//4286b88a/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/4286b88a/#4-4-完整性约束" class="header_1">4.4 完整性约束</a>&nbsp;<br><a href="/ReadingNotes/4286b88a/#完整性约束例子" class="header_2">完整性约束例子</a>&nbsp;<br><a href="/ReadingNotes/4286b88a/#创建关系时指定完整性约束" class="header_2">创建关系时指定完整性约束</a>&nbsp;<br><a href="/ReadingNotes/4286b88a/#创建关系后指定完整性约束" class="header_2">创建关系后指定完整性约束</a>&nbsp;<br><a href="/ReadingNotes/4286b88a/#创建关系后指定的完整性约束有什么要求" class="header_3">创建关系后指定的完整性约束有什么要求</a>&nbsp;<br><a href="/ReadingNotes/4286b88a/#4-4-1-单个关系上的约束" class="header_1">4.4.1 单个关系上的约束</a>&nbsp;<br><a href="/ReadingNotes/4286b88a/#可以在创建关系时指定的完整性约束" class="header_2">可以在创建关系时指定的完整性约束</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="4-4-完整性约束"><a href="#4-4-完整性约束" class="headerlink" title="4.4 完整性约束"></a>4.4 完整性约束</h1><p><strong>完整性约束保证授权用户对数据库所做的修改不会破坏数据的<code>一致性</code></strong>。因此,<strong>完整性约束防止的是对数据的意外破坏</strong>。</p><h2 id="完整性约束例子"><a href="#完整性约束例子" class="headerlink" title="完整性约束例子"></a>完整性约束例子</h2><p>完整性约束的例子有:</p><ul><li>教师姓名不能为<code>null</code></li><li>任意两位教师不能有相同的教师标识。</li><li><code>course</code>关系中的每个系名必须在<code>department</code>关系中有一个对应的系名。</li><li>一个系的预算必须大于<code>0.00</code>美元。</li></ul><p>一般说来,一个完整性约束可以是属于数据库的任意谓词。但检测任意谓词的代价可能太高。因此,<strong>大多数数据库系统允许用户指定那些只需极小开销就可以检测的完整性约束</strong>。<br>在<code>3.2.2</code>节我们已经见过了一些完整性约束的形式。本节我们将学习更多的完整性约束形式。在第8章我们学习另一种被称作<code>函数依赖</code>的完整性约束形式,它主要应用在<code>模式设计</code>的过程中。</p><h2 id="创建关系时指定完整性约束"><a href="#创建关系时指定完整性约束" class="headerlink" title="创建关系时指定完整性约束"></a>创建关系时指定完整性约束</h2><p>完整性约束通常被看成是数据库模式设计过程的一部分,它作为用于创建关系的<code>create table</code>命令的一部分被声明。</p><h2 id="创建关系后指定完整性约束"><a href="#创建关系后指定完整性约束" class="headerlink" title="创建关系后指定完整性约束"></a>创建关系后指定完整性约束</h2><p>然而,完整性约束也可以通过使用<code>alter table table-name add constrain</code>命令施加到已有关系上,其中<code>constrant</code>可以是关系上的任意约束。</p><h3 id="创建关系后指定的完整性约束有什么要求"><a href="#创建关系后指定的完整性约束有什么要求" class="headerlink" title="创建关系后指定的完整性约束有什么要求"></a>创建关系后指定的完整性约束有什么要求</h3><p>当执行<code>alter table table-name add constrain</code>命令时,系统首先保证关系满足新指定的约束。如果满足,那么新增约束被施加到关系上;如果不满足,则拒绝添加新的约束。</p><h1 id="4-4-1-单个关系上的约束"><a href="#4-4-1-单个关系上的约束" class="headerlink" title="4.4.1 单个关系上的约束"></a>4.4.1 单个关系上的约束</h1><p>我们在<code>3.2</code>节中描述了如何用<code>create table</code>命令定义关系表。 <code>create table</code>命令还可以包括完整性约束语句。</p><h2 id="可以在创建关系时指定的完整性约束"><a href="#可以在创建关系时指定的完整性约束" class="headerlink" title="可以在创建关系时指定的完整性约束"></a>可以在创建关系时指定的完整性约束</h2><p>除了<code>主码约束</code>之外,还有许多其他可以包括在<code>create table</code>命令中的约束。允许的完整性约束包括:</p><ol><li><code>not null</code>，</li><li><code>unique</code>，</li><li><code>check(&lt;谓词&gt;)</code>。</li></ol><p>我们将在下面的几节中讨论上述每一种约束。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第4章 中级SQL </category>
          
          <category> 4.4 完整性约束 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.3 事务</title>
      <link href="/ReadingNotes//2e30f7e8/"/>
      <url>/ReadingNotes//2e30f7e8/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/2e30f7e8/#4-3-事务" class="header_1">4.3 事务</a>&nbsp;<br><a href="/ReadingNotes/2e30f7e8/#结束事务" class="header_2">结束事务</a>&nbsp;<br><a href="/ReadingNotes/2e30f7e8/#系统出现不一致例子" class="header_2">系统出现不一致例子</a>&nbsp;<br><a href="/ReadingNotes/2e30f7e8/#银行例子" class="header_3">银行例子</a>&nbsp;<br><a href="/ReadingNotes/2e30f7e8/#大学应用例子" class="header_3">大学应用例子</a>&nbsp;<br><a href="/ReadingNotes/2e30f7e8/#原子性" class="header_2">原子性</a>&nbsp;<br><a href="/ReadingNotes/2e30f7e8/#不是commit或Rollback的命令出错时是提交还是回滚得看具体的数据库实现" class="header_2">不是commit或Rollback的命令出错时是提交还是回滚得看具体的数据库实现</a>&nbsp;<br><a href="/ReadingNotes/2e30f7e8/#默认一条-SQL-语句一个事务" class="header_2">默认一条`SQL`语句一个事务</a>&nbsp;<br><a href="/ReadingNotes/2e30f7e8/#关闭自动提交-一个事务执行多条SQL" class="header_2">关闭自动提交 一个事务执行多条SQL</a>&nbsp;<br><a href="/ReadingNotes/2e30f7e8/#后续章节对事务的介绍" class="header_2">后续章节对事务的介绍</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="4-3-事务"><a href="#4-3-事务" class="headerlink" title="4.3 事务"></a>4.3 事务</h1><p>事务(<code>transaction</code>)由查询询和(或)更新语句的<code>序列组成</code>。<strong><code>SQL</code>标准规定当一条<code>SOL</code>语句被执行,就隐式地开始了一个事务</strong>。</p><h2 id="结束事务"><a href="#结束事务" class="headerlink" title="结束事务"></a>结束事务</h2><p>下列<code>SQL</code>语句之一会结束一个事务:</p><ul><li><code>Commit work</code>:提交当前事务,也就是将该事务所做的更新在数据库中持久保存。在事务被提交后,一个新的事务自动开始。</li><li><code>Rollback work</code>:回滚当前事务,即撤销该事务中所有<code>SoL</code>语句对数据库的更新。这样,数据库就恢复到执行该事务第一条语句之前的状态。</li></ul><p>关键词<code>work</code>在两条语句中都是可选的<br>当在事务执行过程中检测到错误时,事务回滚是有用的。在某种意义上,事务提交就像对编辑文档的变化存盘,而回滚就像<strong>不保存变化退出编辑</strong>。<strong>一旦某事务执行了<code>commit work,</code>它的影响就不能用<code>rollback work</code>来撤销了</strong>。<br>数据库系统保证在发生诸如某条<code>SQL</code>语句错误、断电、系统崩溃这些故障的情况下,<strong>如果一个事务还没有完成<code>commit work</code>,其影响将被回滚</strong>。<br>在断电和系统崩溃的情况下,<strong>回滚会在系统重启后执行</strong>。</p><h2 id="系统出现不一致例子"><a href="#系统出现不一致例子" class="headerlink" title="系统出现不一致例子"></a>系统出现不一致例子</h2><h3 id="银行例子"><a href="#银行例子" class="headerlink" title="银行例子"></a>银行例子</h3><p>例如,考虑一个银行应用,我们需要从一个银行账户上把钱转到同一家银行的另一个账户。为了这样做,我们需要更新两个账户的余额,把需要转移的资金额从一个账户划走,并把它加到另一个账户上。如果在从第一个账户上划走资金以后,但在把这笔资金加入第二个账户之前发生了系统崩溃,那么银行账户就会不一致。如果在第一个账户划走资金之前先往第二个账户存款,并且在存款之后马上发生系统崩溃,那么也会出现类似的问题。</p><h3 id="大学应用例子"><a href="#大学应用例子" class="headerlink" title="大学应用例子"></a>大学应用例子</h3><p>作为另一个例子,考虑我们正在使用的大学应用的例子。我们假设<code>student</code>关系中每个元组在<code>tot_cred</code>属性上的取值需要保持在最新状态,只要学生成功修完一门课程,该属性值就要更新。为了这样做只要<code>takes</code>关系被更新为记录一位学生成功修完一门课程的信息(通过赋予适当的成绩),相应的<code>student</code>元组也必须更新。如果执行这两个更新的任务在执行完一个更新后,但在第二个更新前崩溃了,数据库中的数据就是不一致的。</p><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>一个事务</p><ul><li><strong>或者在完成所有步骤后提交其行为</strong>,</li><li><strong>或者在不能成功完成其所有动作的情况下回滚其所有动作</strong>,</li></ul><p>通过这种方式数据库提供了对事务具有<strong>原子性</strong>(<code>atomic</code>)的抽象,原子性也就是不可分割性,</p><ul><li>要么事务的所有影响被反映到数据库中,</li><li>要么任何影响都没有(在回滚之后)。</li></ul><p>如果把事务的概念应用到上述应用中,那些更新语句就会作为单个事务执行。在事务执行其某条语句时出错会导致事务早先执行的语句的影响被撒销,从而不会让数据库处于部分更新状态。</p><h2 id="不是commit或Rollback的命令出错时是提交还是回滚得看具体的数据库实现"><a href="#不是commit或Rollback的命令出错时是提交还是回滚得看具体的数据库实现" class="headerlink" title="不是commit或Rollback的命令出错时是提交还是回滚得看具体的数据库实现"></a>不是commit或Rollback的命令出错时是提交还是回滚得看具体的数据库实现</h2><p>如果程序没有执行<code>Commit</code>或<code>Rollback</code>两条命令中的任何一条而终止了,<strong>那么更新要么被提交要么被回滚</strong>。<code>SQL</code>标准并没有指出究竟执行哪一种,如何选择依赖于具体实现。</p><h2 id="默认一条SQL语句一个事务"><a href="#默认一条SQL语句一个事务" class="headerlink" title="默认一条SQL语句一个事务"></a>默认一条<code>SQL</code>语句一个事务</h2><p>在很多<code>SQL</code>实现中,<strong>默认方式下每个<code>SQL</code>语句<code>自成一个事务</code>,且一执行完就提交</strong>。</p><h2 id="关闭自动提交-一个事务执行多条SQL"><a href="#关闭自动提交-一个事务执行多条SQL" class="headerlink" title="关闭自动提交 一个事务执行多条SQL"></a>关闭自动提交 一个事务执行多条SQL</h2><p>如果一个事务要执行多条<code>SQL</code>语句,就必须关闭单独<code>SQL</code>语句的自动提交。如何关闭自动提交也依赖于特定的<code>SQL</code>实现,尽管在诸如<code>JDBC</code>或<code>ODBC</code>那样的应用编程接口中存在标准化方式来完成这项工作。我们将在<code>5.1.1</code>和<code>5.1.2</code>节分别学习<code>JDBC</code>和<code>ODBC</code>。<br>一个较好的选择是,作为<code>SQL:1999</code>标准的一部分(但目前只有一些<code>SQL</code>实现支持),允许多条<code>SQL</code>语句包含在关键字<code>begin atomic … end</code>之间。所有在关键字之间的语句构成了一个单一事务。</p><h2 id="后续章节对事务的介绍"><a href="#后续章节对事务的介绍" class="headerlink" title="后续章节对事务的介绍"></a>后续章节对事务的介绍</h2><ul><li>我们将在第<code>14</code>章学习事务的更多特性;</li><li>第<code>15</code>章和第<code>16</code>章介绍在单个数据库中实现事务的相关问题,</li><li>而在第<code>19</code>章介绍跨多个数据库上实现事务的相关问题,这是为了处理不同银行的账户之间转账的问题,不同银行有不同的数据库。</li></ul><!--SSTStop-->]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第4章 中级SQL </category>
          
          <category> 4.3 事务 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.2.4 视图更新</title>
      <link href="/ReadingNotes//d8d00e0a/"/>
      <url>/ReadingNotes//d8d00e0a/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/d8d00e0a/#4-2-4-视图更新" class="header_1">4.2.4 视图更新</a>&nbsp;<br><a href="/ReadingNotes/d8d00e0a/#向视图插入数据" class="header_2">向视图插入数据</a>&nbsp;<br><a href="/ReadingNotes/d8d00e0a/#更新一个表上的的视图的情况" class="header_3">更新一个表上的的视图的情况</a>&nbsp;<br><a href="/ReadingNotes/d8d00e0a/#更新多个表上的视图的情况" class="header_3">更新多个表上的视图的情况</a>&nbsp;<br><a href="/ReadingNotes/d8d00e0a/#一般不允许对视图关系进行修改" class="header_2">一般不允许对视图关系进行修改</a>&nbsp;<br><a href="/ReadingNotes/d8d00e0a/#可更新的视图要满足的条件" class="header_2">可更新的视图要满足的条件</a>&nbsp;<br><a href="/ReadingNotes/d8d00e0a/#实例-可更新的视图" class="header_3">实例 可更新的视图</a>&nbsp;<br><a href="/ReadingNotes/d8d00e0a/#可更新的视图存在的问题" class="header_3">可更新的视图存在的问题</a>&nbsp;<br><a href="/ReadingNotes/d8d00e0a/#拒绝向视图插入一条不满足视图的-where-子句条件的元组" class="header_3">拒绝向视图插入一条不满足视图的`where`子句条件的元组</a>&nbsp;<br><a href="/ReadingNotes/d8d00e0a/#SQL-1999对视图更新的规则" class="header_3">SQL:1999对视图更新的规则</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="4-2-4-视图更新"><a href="#4-2-4-视图更新" class="headerlink" title="4.2.4 视图更新"></a>4.2.4 视图更新</h1><p>尽管对查询而言,视图是一个有用的工具,但如果我们用它们来表达<code>更新</code>、<code>插入</code>或<code>删除</code>,它们可能带来严重的问题。困难在于,<strong>用视图表达的数据库修改必须被翻译为对数据库逻辑模型中实际关系的修改</strong>。</p><h2 id="向视图插入数据"><a href="#向视图插入数据" class="headerlink" title="向视图插入数据"></a>向视图插入数据</h2><h3 id="更新一个表上的的视图的情况"><a href="#更新一个表上的的视图的情况" class="headerlink" title="更新一个表上的的视图的情况"></a>更新一个表上的的视图的情况</h3><p>假设我们此前所见的视图<code>faculty</code>被提供给一个职员。既然我们允许视图名出现在任何关系名可以出现的地方,该职员可以这样写出:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> faculty</span><br><span class="line">    <span class="keyword">values</span>(<span class="string">'30765'</span>,<span class="string">'Green'</span>,<span class="string">'Music'</span>);</span><br></pre></td></tr></table></figure><br>这个插入必须表示为对<code>instructor</code>关系的插入,因为<code>instructor</code>是数据库系统用于构造视图<code>faculty</code>的实际关系。然而,为了把一个元组插入到<code>instructor</code>中,我们必须给出<code>salary</code>的值。存在两种合理的解决方法来处理该插入:</p><ol><li>拒绝插入,并向用户返回一个错误信息。</li><li>向<code>instructor</code>关系插入元组<code>(&#39;30765&#39;,&#39;Green&#39;, &#39;Music&#39;,null)</code></li></ol><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into faculty</span><br><span class="line">    values('<span class="number">30765</span>','Green','Music');</span><br><span class="line">Query OK, <span class="number">1</span> row affected (<span class="number">0</span>.<span class="number">03</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from instructor;</span><br><span class="line">+-------+------------+------------+----------+</span><br><span class="line">| ID    | name       | dept_name  | salary   |</span><br><span class="line">+-------+------------+------------+----------+</span><br><span class="line">| <span class="number">10101</span> | Srinivasan | <span class="built_in">Comp</span>. Sci. | <span class="number">65000</span>.<span class="number">00</span> |</span><br><span class="line">| <span class="number">12121</span> | Wu         | Finance    | <span class="number">90000</span>.<span class="number">00</span> |</span><br><span class="line">| <span class="number">15151</span> | Mozart     | Music      | <span class="number">40000</span>.<span class="number">00</span> |</span><br><span class="line">| <span class="number">22222</span> | Einstein   | Physics    | <span class="number">95000</span>.<span class="number">00</span> |</span><br><span class="line">| <span class="number">30765</span> | Green      | Music      | NULL     |</span><br><span class="line">| <span class="number">32343</span> | El Said    | History    | <span class="number">60000</span>.<span class="number">00</span> |</span><br><span class="line">| <span class="number">33456</span> | Gold       | Physics    | <span class="number">87000</span>.<span class="number">00</span> |</span><br><span class="line">| <span class="number">45565</span> | Katz       | <span class="built_in">Comp</span>. Sci. | <span class="number">75000</span>.<span class="number">00</span> |</span><br><span class="line">| <span class="number">58583</span> | Califieri  | History    | <span class="number">62000</span>.<span class="number">00</span> |</span><br><span class="line">| <span class="number">76543</span> | Singh      | Finance    | <span class="number">80000</span>.<span class="number">00</span> |</span><br><span class="line">| <span class="number">76766</span> | Crick      | Biology    | <span class="number">72000</span>.<span class="number">00</span> |</span><br><span class="line">| <span class="number">83821</span> | Brandt     | <span class="built_in">Comp</span>. Sci. | <span class="number">92000</span>.<span class="number">00</span> |</span><br><span class="line">| <span class="number">98345</span> | Kim        | Elec. Eng. | <span class="number">80000</span>.<span class="number">00</span> |</span><br><span class="line">+-------+------------+------------+----------+</span><br><span class="line"><span class="number">13</span> rows <span class="keyword">in</span> <span class="built_in">set</span> (<span class="number">0</span>.<span class="number">04</span> sec)</span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| <span class="number">30765</span> | Green      | Music      | NULL     |</span><br></pre></td></tr></table></figure><h3 id="更新多个表上的视图的情况"><a href="#更新多个表上的视图的情况" class="headerlink" title="更新多个表上的视图的情况"></a>更新多个表上的视图的情况</h3><p>通过视图修改数据库的另一类问题发生在这样的视图上:<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create view instructor_info</span><br><span class="line">as</span><br><span class="line">select ID, name,building</span><br><span class="line">    from instructor,department</span><br><span class="line">    where instructor.dept_name=department.dept_name;</span><br></pre></td></tr></table></figure><br>这个视图列出了大学里每个教师的<code>ID</code>、<code>name</code>和<code>建筑名</code>。<br>考虑如下通过该视图的插入:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> instructor_info</span><br><span class="line">    <span class="keyword">values</span>(<span class="string">'69987'</span>,<span class="string">'White'</span>,<span class="string">'Taylor'</span>);</span><br></pre></td></tr></table></figure><br>假设没有标识为<code>69987</code>的教师,也没有位于<code>Taylor</code>大楼的系。那么向<code>instructor</code>和<code>department</code>关系中插入元组的唯一可能的方法是:</p><ul><li>向<code>instructor</code>中插入元组<code>(&#39;69987&#39;,&#39;White&#39;,null,null)</code></li><li>并向<code>department</code>中插入元组<code>(&#39;null&#39;,&#39;Taylor&#39;,null)</code>。</li></ul><p>但是这个更新并没有产生出所需的结果,因为视图关系<code>instructor_info</code>中仍然不包含元组<code>(&#39;69987&#39;,&#39;White&#39;,&#39;Taylor&#39;)</code>,<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into instructor_info</span><br><span class="line">    values('<span class="number">69987</span>','White','Taylor');</span><br><span class="line"><span class="number">1394</span> - Can <span class="keyword">not</span> insert into join view 'university.instructor_info' without fields list</span><br></pre></td></tr></table></figure><br>因此,通过利用空值来更新 <code>instructor</code>和<code>department</code>关系以得到对<code>instructor_info</code>所需的更新是不可行的。</p><h2 id="一般不允许对视图关系进行修改"><a href="#一般不允许对视图关系进行修改" class="headerlink" title="一般不允许对视图关系进行修改"></a>一般不允许对视图关系进行修改</h2><p>由于如上所述的种种问题,<strong>除了一些有限的情况之外,一般不允许对视图关系进行修改</strong>。<br>不同的数据库系统指定了不同的条件以允许更新视图关系;请参考数据库系统手册以获得详细信息。通过视图进行数据库修改的通用问题已经成为重要的研究课题,文献注解中引用了一些这方面的研究。</p><h2 id="可更新的视图要满足的条件"><a href="#可更新的视图要满足的条件" class="headerlink" title="可更新的视图要满足的条件"></a>可更新的视图要满足的条件</h2><p>一般说来,<strong>如果定义视图的<code>查询</code>对下列条件<code>都</code>能满足</strong>我们称<code>SQL</code>视图是可更新的(<code>updatable</code>)(即视图上可以执行<code>插入</code>、<code>更新</code>或<code>删除</code></p><ol><li><code>from</code>子句中只有一个数据库关系。</li><li><code>select</code>子句中只包含关系的属性名,不包含任何<code>表达式</code>、<code>聚集</code>或<code>distinct</code>声明。</li><li>任何<strong>没有出现在<code>select</code>子句中的属性</strong>可以取空值;即这些属性上没有<code>not null</code>约束,也不构成主码的部分。</li><li>查询中不含有<code>group by</code>或<code>having</code>子句。</li></ol><h3 id="实例-可更新的视图"><a href="#实例-可更新的视图" class="headerlink" title="实例 可更新的视图"></a>实例 可更新的视图</h3><p>在这些限制下,下面的视图上允许执行<code>update</code>、 <code>insert</code>和<code>delete</code>操作:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> history_instructors</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> dept_name =<span class="string">'History'</span>;</span><br></pre></td></tr></table></figure></p><h3 id="可更新的视图存在的问题"><a href="#可更新的视图存在的问题" class="headerlink" title="可更新的视图存在的问题"></a>可更新的视图存在的问题</h3><p>即便是在可更新的情况下,下面这些问题仍然存在。假设一个用户尝试向视图<code>history_instructors</code>中插入元组<code>(&#39;25566&#39;,&#39;Brown&#39;,&#39;Biology&#39;,100000)</code>:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> history_instructors</span><br><span class="line">    <span class="keyword">values</span> (<span class="string">'25566'</span>,<span class="string">'Brown'</span>,<span class="string">'Biology'</span>,<span class="number">100000</span>);</span><br></pre></td></tr></table></figure><br>这个元组可以被插入到<code>instructor</code>关系中,但是<strong>由于它不满足视图所要求的选择条件</strong>,它不会出现在视图<code>history_instructors</code>中。<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into history_instructors</span><br><span class="line">    values ('<span class="number">25566</span>','Brown','Biology',<span class="number">100000</span>);</span><br><span class="line">Query OK, <span class="number">1</span> row affected (<span class="number">0</span>.<span class="number">01</span> sec)</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from history_instructors;</span><br><span class="line">+-------+-----------+-----------+----------+</span><br><span class="line">| ID    | name      | dept_name | salary   |</span><br><span class="line">+-------+-----------+-----------+----------+</span><br><span class="line">| <span class="number">32343</span> | El Said   | History   | <span class="number">60000</span>.<span class="number">00</span> |</span><br><span class="line">| <span class="number">58583</span> | Califieri | History   | <span class="number">62000</span>.<span class="number">00</span> |</span><br><span class="line">+-------+-----------+-----------+----------+</span><br><span class="line"><span class="number">2</span> rows <span class="keyword">in</span> <span class="built_in">set</span> (<span class="number">0</span>.<span class="number">03</span> sec)</span><br></pre></td></tr></table></figure></p><h3 id="拒绝向视图插入一条不满足视图的where子句条件的元组"><a href="#拒绝向视图插入一条不满足视图的where子句条件的元组" class="headerlink" title="拒绝向视图插入一条不满足视图的where子句条件的元组"></a>拒绝向视图插入一条不满足视图的<code>where</code>子句条件的元组</h3><p>在默认情况下,<code>SQL</code>允许执行上述更新。但是,可以<strong>通过在视图定义的末尾包含<code>with check option</code>子句</strong>的方式来定义视图。<br>这样,如果向视图中<code>插入</code>(<code>insert</code>)一条不满足视图的<code>where</code>子句条件的元组,数据库系统将<code>拒绝</code>该<code>插入</code>操作。<br>类似地,如果<code>更新</code>的新值不满足<code>where</code>子句的条件,<code>更新</code>(<code>update</code>)也会被拒绝。</p><h3 id="SQL-1999对视图更新的规则"><a href="#SQL-1999对视图更新的规则" class="headerlink" title="SQL:1999对视图更新的规则"></a>SQL:1999对视图更新的规则</h3><p><code>SQL:1999</code>对于何时可以在视图上执行插入、更新和删除有更复杂的规则集,该规则集允许通过类更大视图进行更新,但是这些规则过于复杂,我们就不在这里讨论了<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第4章 中级SQL </category>
          
          <category> 4.2 视图 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.2.3 物化视图</title>
      <link href="/ReadingNotes//7bb06130/"/>
      <url>/ReadingNotes//7bb06130/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/7bb06130/#4-2-3-物化视图" class="header_1">4.2.3 物化视图</a>&nbsp;<br><a href="/ReadingNotes/7bb06130/#物化视图" class="header_2">物化视图</a>&nbsp;<br><a href="/ReadingNotes/7bb06130/#物化视图的内容也必须更新" class="header_2">物化视图的内容也必须更新</a>&nbsp;<br><a href="/ReadingNotes/7bb06130/#物化视图维护" class="header_2">物化视图维护</a>&nbsp;<br><a href="/ReadingNotes/7bb06130/#视图维护的时机" class="header_2">视图维护的时机</a>&nbsp;<br><a href="/ReadingNotes/7bb06130/#物化视图的优点" class="header_2">物化视图的优点</a>&nbsp;<br><a href="/ReadingNotes/7bb06130/#物化视图由使用的数据库系统实现" class="header_2">物化视图由使用的数据库系统实现</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="4-2-3-物化视图"><a href="#4-2-3-物化视图" class="headerlink" title="4.2.3 物化视图"></a>4.2.3 物化视图</h1><h2 id="物化视图"><a href="#物化视图" class="headerlink" title="物化视图"></a>物化视图</h2><p>特定数据库系统允许存储视图关系,但是它们保证:<strong>如果用于定义视图的实际关系改变,视图也跟着修改</strong>。这样的视图被称为<strong>物化视图</strong>(<code>materialized view</code>)。</p><h2 id="物化视图的内容也必须更新"><a href="#物化视图的内容也必须更新" class="headerlink" title="物化视图的内容也必须更新"></a>物化视图的内容也必须更新</h2><p>例如,考察视图<code>departments_total_salary</code>。如果上述视图是物化的,它的结果就会存放在数据库中然而,如果一个<code>instructor</code>元组被插入到<code>instructor</code>关系中,或者从<code>instructor</code>关系中删除,定义视图的查询结果就会变化,其结果是<strong>物化视图的内容也必须更新</strong>。类似地,如果一位教师的工资被更新,那么<code>departments_total_salary</code>中对应于该教师所在系的元组必须更新。</p><h2 id="物化视图维护"><a href="#物化视图维护" class="headerlink" title="物化视图维护"></a>物化视图维护</h2><p><strong>保持物化视图一直在最新状态的过程</strong>称为<strong>物化视图维护</strong>(<code>materialized view maintenance</code>),或者通常简称<strong>视图维护</strong>( <code>view maintenance</code>),这将在<code>13.5</code>节进行介绍。</p><h2 id="视图维护的时机"><a href="#视图维护的时机" class="headerlink" title="视图维护的时机"></a>视图维护的时机</h2><ul><li>当<strong>构成视图定义的任何关系被更新时</strong>,可以马上进行视图维护。</li><li>然而某些数据库系统<strong>在视图被访问时</strong>才执行视图维护。</li><li>还有一些系统仅<strong>采用周期性的物化视图更新方式</strong>,在这种情况下,当物化视图被使用时,其中的内容可能是陈旧的,或者说过时的。如果应用需要最新数据的话,这种方式是不适用的。</li></ul><p>某些数据库系统允许数据库管理员来控制在每个物化视图上需要采取上述的哪种方式。</p><h2 id="物化视图的优点"><a href="#物化视图的优点" class="headerlink" title="物化视图的优点"></a>物化视图的优点</h2><ul><li><strong>频繁使用视图的应用</strong>将会从视图的物化中获益。</li><li>那些<strong>需要快速响应基于大关系上聚集计算的特定查询</strong>也会从创建与查询相对应的物化视图中受益良多。在这种情况下,聚集结果很可能比定义视图的大关系要小得多,其结果是利用物化视图来回答査询就很快,它避免了读取大的底层关系。</li></ul><p>当然,物化视图查询所带来的好处还需要与存储代价和增加的更新开销相权衡。</p><h2 id="物化视图由使用的数据库系统实现"><a href="#物化视图由使用的数据库系统实现" class="headerlink" title="物化视图由使用的数据库系统实现"></a>物化视图由使用的数据库系统实现</h2><p><code>SQL</code>没有定义指定物化视图的标准方式,但是很多数据库系统提供了各自的<code>SQL</code>扩展来实现这项任务。<br>一些数据库系统在底层关系变化时,总是把物化视图保持在最新状态;<br>也有另外一些系统允许物化视图过时,但周期性地重新计算物化视图。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第4章 中级SQL </category>
          
          <category> 4.2 视图 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.2.2 SQL查询中使用视图</title>
      <link href="/ReadingNotes//4f9aad4e/"/>
      <url>/ReadingNotes//4f9aad4e/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/4f9aad4e/#4-2-2-SQL查询中使用视图" class="header_1">4.2.2 SQL查询中使用视图</a>&nbsp;<br><a href="/ReadingNotes/4f9aad4e/#视图和关系的用法一样" class="header_2">视图和关系的用法一样</a>&nbsp;<br><a href="/ReadingNotes/4f9aad4e/#定义视图时指定视图的属性名" class="header_2">定义视图时指定视图的属性名</a>&nbsp;<br><a href="/ReadingNotes/4f9aad4e/#视图关系的结果通过计算产生" class="header_2">视图关系的结果通过计算产生</a>&nbsp;<br><a href="/ReadingNotes/4f9aad4e/#一个视图可能被用到定义另一个视图的表达式中" class="header_2">一个视图可能被用到定义另一个视图的表达式中</a>&nbsp;<br><a href="/ReadingNotes/4f9aad4e/#等价视图" class="header_3">等价视图</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="4-2-2-SQL查询中使用视图"><a href="#4-2-2-SQL查询中使用视图" class="headerlink" title="4.2.2 SQL查询中使用视图"></a>4.2.2 SQL查询中使用视图</h1><h2 id="视图和关系的用法一样"><a href="#视图和关系的用法一样" class="headerlink" title="视图和关系的用法一样"></a>视图和关系的用法一样</h2><p>一旦定义了一个视图,我们就可以用视图名指代该视图生成的虚关系。<br>使用视图<code>physics_fall_2009</code>,我们可以用下面的查询<strong>找到所有于<code>2009</code>年秋季学期在<code>Watson</code>大楼开设的<code>Physics</code>课程</strong>:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> course_id</span><br><span class="line">    <span class="keyword">from</span> physics_fall_2009</span><br><span class="line">    <span class="keyword">where</span> building = <span class="string">'Watson'</span>;</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select course_id</span><br><span class="line">    from physics_fall_2009</span><br><span class="line">    where building = 'Watson';</span><br><span class="line">+-----------+</span><br><span class="line">| course_id |</span><br><span class="line">+-----------+</span><br><span class="line">| PHY-<span class="number">101</span>   |</span><br><span class="line">+-----------+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> <span class="built_in">set</span> (<span class="number">0</span>.<span class="number">03</span> sec)</span><br></pre></td></tr></table></figure><br>在查询中,<strong>视图名可以出现在关系名可以出现的任何地方</strong>。</p><h2 id="定义视图时指定视图的属性名"><a href="#定义视图时指定视图的属性名" class="headerlink" title="定义视图时指定视图的属性名"></a>定义视图时指定视图的属性名</h2><p>视图的属性名可以按下述方式显式指定:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> </span><br><span class="line">    departments_total_salary(dept_name, total_salary)</span><br><span class="line">    <span class="keyword">as</span></span><br><span class="line">    <span class="keyword">select</span> dept_name, <span class="keyword">sum</span>(salary)</span><br><span class="line">    <span class="keyword">from</span> instructor</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> dept_name;</span><br></pre></td></tr></table></figure><br>上述视图给出了每个系中所有教师的工资总和。因为表达式<code>sum(salary)</code>没有名称,<strong>其属性名<code>total_salary</code>是在视图定义中显式指定的</strong>。</p><h2 id="视图关系的结果通过计算产生"><a href="#视图关系的结果通过计算产生" class="headerlink" title="视图关系的结果通过计算产生"></a>视图关系的结果通过计算产生</h2><p>直觉上,在任何给定时刻,视图关系中的元组集是该时刻视图定义中的查询表达式的计算结果因此,如果一个视图关系被计算并存储,一旦用于定义该视图的关系被修改,视图就会过期。为了避免这一点,视图通常这样来实现:<strong>当我们定义一个视图时,数据库系统存储视图的定义本身,而不存储定义该视图的查询表达式的执行结果</strong>。一旦视图关系出现在查询中,它就被已存储的查询表达式代替。因此,<strong>无论我们何时执行这个查询,视图关系都被重新计算</strong>。</p><h2 id="一个视图可能被用到定义另一个视图的表达式中"><a href="#一个视图可能被用到定义另一个视图的表达式中" class="headerlink" title="一个视图可能被用到定义另一个视图的表达式中"></a>一个视图可能被用到定义另一个视图的表达式中</h2><p>例如,我们可以如下定义视图<code>physics_fall_2009_watson</code>,它列出了<strong>于<code>2009</code>年秋季学期在<code>Watson</code>大楼开设的所有<code>Physics</code>课程的标识和房间号</strong>:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> physics_fall_2009_watson</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> course_id,room_number</span><br><span class="line"><span class="keyword">from</span> physics_fall_2009</span><br><span class="line"><span class="keyword">where</span> building =<span class="string">'Watson'</span>;</span><br></pre></td></tr></table></figure><br>其中<code>physics_fall_2009</code>本身是一个视图关系.</p><h3 id="等价视图"><a href="#等价视图" class="headerlink" title="等价视图"></a>等价视图</h3><p>这个<code>physics_fall_2009_watson</code>视图等价于:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> physics_fall_2009_watson2</span><br><span class="line"><span class="keyword">as</span>(</span><br><span class="line">    <span class="keyword">select</span> course_id,room_number</span><br><span class="line">    <span class="keyword">from</span>(</span><br><span class="line">        <span class="keyword">select</span> course.course_id,building,room_number</span><br><span class="line">            <span class="keyword">from</span> course,<span class="keyword">section</span></span><br><span class="line">            <span class="keyword">where</span> course.course_id=section.course_id</span><br><span class="line">                <span class="keyword">and</span> course.dept_name = <span class="string">'Physics'</span></span><br><span class="line">                <span class="keyword">and</span> section.semester=<span class="string">'Fall'</span></span><br><span class="line">                <span class="keyword">and</span> section.year =<span class="number">2009</span></span><br><span class="line">    ) <span class="keyword">as</span> T <span class="keyword">where</span> building = <span class="string">'Watson'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from physics_fall_2009_watson2;</span><br><span class="line">+-----------+-------------+</span><br><span class="line">| course_id | room_number |</span><br><span class="line">+-----------+-------------+</span><br><span class="line">| PHY-<span class="number">101</span>   | <span class="number">100</span>         |</span><br><span class="line">+-----------+-------------+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> <span class="built_in">set</span> (<span class="number">0</span>.<span class="number">03</span> sec)</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from physics_fall_2009_watson;</span><br><span class="line">+-----------+-------------+</span><br><span class="line">| course_id | room_number |</span><br><span class="line">+-----------+-------------+</span><br><span class="line">| PHY-<span class="number">101</span>   | <span class="number">100</span>         |</span><br><span class="line">+-----------+-------------+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> <span class="built_in">set</span> (<span class="number">0</span>.<span class="number">03</span> sec)</span><br></pre></td></tr></table></figure><br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第4章 中级SQL </category>
          
          <category> 4.2 视图 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.2.1 视图定义</title>
      <link href="/ReadingNotes//bd569939/"/>
      <url>/ReadingNotes//bd569939/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/bd569939/#4-2-1-视图定义" class="header_1">4.2.1 视图定义</a>&nbsp;<br><a href="/ReadingNotes/bd569939/#创建视图的格式" class="header_2">创建视图的格式</a>&nbsp;<br><a href="/ReadingNotes/bd569939/#实例" class="header_2">实例</a>&nbsp;<br><a href="/ReadingNotes/bd569939/#视图关系是在需要的时候才被创建的" class="header_2">视图关系是在需要的时候才被创建的</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="4-2-1-视图定义"><a href="#4-2-1-视图定义" class="headerlink" title="4.2.1 视图定义"></a>4.2.1 视图定义</h1><p>我们在<code>SQL</code>中用<code>create view</code>命令定义视图。为了定义视图,我们必须给视图一个名称,并且必须提供计算视图的查询。 </p><h2 id="创建视图的格式"><a href="#创建视图的格式" class="headerlink" title="创建视图的格式"></a>创建视图的格式</h2><p><code>create view</code>命令的格式为:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> v <span class="keyword">as</span>&lt;<span class="keyword">query</span> expression&gt;;</span><br></pre></td></tr></table></figure><br>其中</p><ul><li><code>&lt;query expression&gt;</code>可以是任何合法的查询表达式,</li><li><code>v</code>表示视图名</li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>重新考虑需要访问<code>instructor</code>关系中除<code>salary</code>之外的所有数据的职员。这样的职员不应该授予访问<code>instructor</code>关系的权限(我们将在后面<code>4.6</code>节介绍如何进行授权)。相反,可以把视图关系<code>faculty</code>提供给职员,此视图的定义如下:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> faculty <span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">ID</span>, <span class="keyword">name</span>, dept_name</span><br><span class="line"><span class="keyword">from</span> instructor;</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create view faculty as</span><br><span class="line">select ID, name, dept_name</span><br><span class="line">from instructor;</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0</span>.<span class="number">01</span> sec)</span><br></pre></td></tr></table></figure></p><h2 id="视图关系是在需要的时候才被创建的"><a href="#视图关系是在需要的时候才被创建的" class="headerlink" title="视图关系是在需要的时候才被创建的"></a>视图关系是在需要的时候才被创建的</h2><p>正如前面已经解释过的,<strong>视图关系</strong>在概念上<strong>包含查询结果中的元组</strong>,但并不进行预计算和存储。相反,数据库系统存储与视图关系相关联的查询表达式。<br><strong>当视图关系被访问时,视图关系中的元组是通过计算查询结果而被创建出来的</strong>。从而,<strong>视图关系是在需要的时候才被创建的</strong>。</p><p>为了创建一个视图,<strong>列出<code>Physics</code>系在<code>2009</code>年秋季学期所开设的所有课程段,以及每个课程段在哪栋建筑的哪个房间授课的信息</strong>,我们可以写出:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> physics_fall_2009 <span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> course.course_id, sec_id, building, room_number</span><br><span class="line"><span class="keyword">from</span> course,<span class="keyword">section</span></span><br><span class="line"><span class="keyword">where</span> course.course_id=section.course_id</span><br><span class="line">    <span class="keyword">and</span> course.dept_name = <span class="string">'Physics'</span></span><br><span class="line">    <span class="keyword">and</span> section.semester = <span class="string">'Fall'</span></span><br><span class="line">    <span class="keyword">and</span> section.year =<span class="number">2009</span>;</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create view physics_fall_2009 as</span><br><span class="line">select course.course_id, sec_id, building, room_number</span><br><span class="line">from course,section</span><br><span class="line">where course.course_id=section.course_id</span><br><span class="line">    and course.dept_name = 'Physics'</span><br><span class="line">    and section.semester = 'Fall'</span><br><span class="line">    and section.year =<span class="number">2009</span>;</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0</span>.<span class="number">02</span> sec)</span><br></pre></td></tr></table></figure><br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第4章 中级SQL </category>
          
          <category> 4.2 视图 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.2 视图</title>
      <link href="/ReadingNotes//21939206/"/>
      <url>/ReadingNotes//21939206/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/21939206/#4-2-视图" class="header_1">4.2 视图</a>&nbsp;<br><a href="/ReadingNotes/21939206/#虚关系" class="header_2">虚关系</a>&nbsp;<br><a href="/ReadingNotes/21939206/#什么是视图" class="header_2">什么是视图</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="4-2-视图"><a href="#4-2-视图" class="headerlink" title="4.2 视图"></a>4.2 视图</h1><p>在上面的所有例子中,我们一直都在<code>逻辑模型</code>层操作,即我们假定了<strong>给定的集合中的关系都是实际存储在数据库中的</strong>。<br><strong>让所有用户都看到整个逻辑模型是不合适的</strong>。出于安全考虑,可能需要向用户隐藏特定的数据。考虑一个职员需要知道<code>教师的标识</code>、<code>姓名</code>和<code>所在系名</code>,但是没有权限看到教师的工资值。此人应该看到的关系由如下<code>SQL</code>语句所描述:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">ID</span>,<span class="keyword">name</span>,dept_name</span><br><span class="line"><span class="keyword">from</span> instructor;</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select ID,name,dept_name</span><br><span class="line">from instructor;</span><br><span class="line">+-------+------------+------------+</span><br><span class="line">| ID    | name       | dept_name  |</span><br><span class="line">+-------+------------+------------+</span><br><span class="line">| <span class="number">10101</span> | Srinivasan | <span class="built_in">Comp</span>. Sci. |</span><br><span class="line">| <span class="number">12121</span> | Wu         | Finance    |</span><br><span class="line">| <span class="number">15151</span> | Mozart     | Music      |</span><br><span class="line">| <span class="number">22222</span> | Einstein   | Physics    |</span><br><span class="line">| <span class="number">32343</span> | El Said    | History    |</span><br><span class="line">| <span class="number">33456</span> | Gold       | Physics    |</span><br><span class="line">| <span class="number">45565</span> | Katz       | <span class="built_in">Comp</span>. Sci. |</span><br><span class="line">| <span class="number">58583</span> | Califieri  | History    |</span><br><span class="line">| <span class="number">76543</span> | Singh      | Finance    |</span><br><span class="line">| <span class="number">76766</span> | Crick      | Biology    |</span><br><span class="line">| <span class="number">83821</span> | Brandt     | <span class="built_in">Comp</span>. Sci. |</span><br><span class="line">| <span class="number">98345</span> | Kim        | Elec. Eng. |</span><br><span class="line">+-------+------------+------------+</span><br><span class="line"><span class="number">12</span> rows <span class="keyword">in</span> <span class="built_in">set</span> (<span class="number">0</span>.<span class="number">04</span> sec)</span><br></pre></td></tr></table></figure><br>除了安全考虑,我们还可能希望创建一个比逻辑模型更符合特定用户直觉的个人化的关系集合。我们可能希望有一个关于<code>Physics</code>系在<code>2009</code>年秋季学期所开设的所有课程段的列表,其中包括每个课程段在哪栋建筑的哪个房间授课的信息。为了得到这样的列表,我们需要创建的关系是:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> course.course_id, sec_id, building, room_number</span><br><span class="line"><span class="keyword">from</span> course,<span class="keyword">section</span></span><br><span class="line"><span class="keyword">where</span> course.course_id=section.course_id</span><br><span class="line">    <span class="keyword">and</span> course.dept_name =<span class="string">'Physics'</span></span><br><span class="line">    <span class="keyword">and</span> section.semester = <span class="string">'Fall'</span></span><br><span class="line">    <span class="keyword">and</span> section.year =<span class="number">2009</span>;</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select course.course_id, sec_id, building, room_number</span><br><span class="line">from course,section</span><br><span class="line">where course.course_id=section.course_id</span><br><span class="line">    and course.dept_name ='Physics'</span><br><span class="line">    and section.semester = 'Fall'</span><br><span class="line">    and section.year =<span class="number">2009</span>;</span><br><span class="line">+-----------+--------+----------+-------------+</span><br><span class="line">| course_id | sec_id | building | room_number |</span><br><span class="line">+-----------+--------+----------+-------------+</span><br><span class="line">| PHY-<span class="number">101</span>   | <span class="number">1</span>      | Watson   | <span class="number">100</span>         |</span><br><span class="line">+-----------+--------+----------+-------------+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> <span class="built_in">set</span> (<span class="number">0</span>.<span class="number">04</span> sec)</span><br></pre></td></tr></table></figure><br>我们可以计算出上述查询的结果并存储下来,然后把存储好关系提供给用户。<br>但如果这样做的话,一旦<code>instructor</code>、 <code>course</code>或<code>section</code>关系中的底层数据发生变化,那么所存储的查询结果就不再与在这些关系上重新执行查询的结果匹配。一般说来,对像上例那样的查询结果进行计算并存储不是一种好的方式(尽管也存在某些例外情况,我们会在后面讨论)。</p><h2 id="虚关系"><a href="#虚关系" class="headerlink" title="虚关系"></a>虚关系</h2><p>相反,<code>SQL</code>允许通过查询来定义”虚关系”,它在概念上包含查询的结果。<br><strong>虚关系并不预先计算并存储,而是在使用虚关系的时候才通过执行查询被计算出来</strong>。</p><h2 id="什么是视图"><a href="#什么是视图" class="headerlink" title="什么是视图"></a>什么是视图</h2><p>任何像这种<strong>不是逻辑模型的一部分,但作为虚关系对用户可见的关系称为视图(<code>view</code>)</strong>。<br>在任何给定的实际关系集合上能够支持大量视图。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第4章 中级SQL </category>
          
          <category> 4.2 视图 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.1.3 连接类型和条件</title>
      <link href="/ReadingNotes//bb8cb4f2/"/>
      <url>/ReadingNotes//bb8cb4f2/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/bb8cb4f2/#4-1-3-连接类型和条件" class="header_1">4.1.3 连接类型和条件</a>&nbsp;<br><a href="/ReadingNotes/bb8cb4f2/#默认是内连接" class="header_2">默认是内连接</a>&nbsp;<br><a href="/ReadingNotes/bb8cb4f2/#连接类型和连接条件" class="header_2">连接类型和连接条件</a>&nbsp;<br><a href="/ReadingNotes/bb8cb4f2/#连接类型" class="header_3">连接类型</a>&nbsp;<br><a href="/ReadingNotes/bb8cb4f2/#连接条件" class="header_3">连接条件</a>&nbsp;<br><a href="/ReadingNotes/bb8cb4f2/#任意的连接形式都可以和任意的连接条件进行组合" class="header_3">任意的连接形式都可以和任意的连接条件进行组合</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="4-1-3-连接类型和条件"><a href="#4-1-3-连接类型和条件" class="headerlink" title="4.1.3 连接类型和条件"></a>4.1.3 连接类型和条件</h1><p>为了把<strong>常规连接</strong>和<strong>外连接区</strong>分开来,<code>SQL</code>中把常规连接称作<strong>内连接</strong>。连接子句就可以用<code>inner join</code>来说明使用的是常规连接。</p><h2 id="默认是内连接"><a href="#默认是内连接" class="headerlink" title="默认是内连接"></a>默认是内连接</h2><p>然而关键词<code>inner</code>是可选的,当<code>join</code>子句中没有使用<code>outer</code>前缀,默认的连接类型是<code>inner join</code>。从而:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> student <span class="keyword">join</span> takes <span class="keyword">using</span>(<span class="keyword">ID</span>);</span><br></pre></td></tr></table></figure><br>等价于:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> student <span class="keyword">inner</span> <span class="keyword">join</span> takes <span class="keyword">using</span>(<span class="keyword">ID</span>);</span><br></pre></td></tr></table></figure><br>类似地,<code>natural join</code>等价于<code>natural inner join</code>。</p><h2 id="连接类型和连接条件"><a href="#连接类型和连接条件" class="headerlink" title="连接类型和连接条件"></a>连接类型和连接条件</h2><h3 id="连接类型"><a href="#连接类型" class="headerlink" title="连接类型"></a>连接类型</h3><ol><li><code>inner join</code></li><li><code>left outer join</code></li><li><code>right outer join</code></li><li><code>full outer ioin</code></li></ol><h3 id="连接条件"><a href="#连接条件" class="headerlink" title="连接条件"></a>连接条件</h3><ol><li><code>natural</code></li><li><code>on&lt;predicate&gt;</code></li><li><code>using(A1,A2…An)</code><h3 id="任意的连接形式都可以和任意的连接条件进行组合"><a href="#任意的连接形式都可以和任意的连接条件进行组合" class="headerlink" title="任意的连接形式都可以和任意的连接条件进行组合"></a>任意的连接形式都可以和任意的连接条件进行组合</h3>任意的连接形式(包括内连接、左外连接、右外连接或全外连接)可以和任意的连接条件(包括自然连接、 <code>using</code>条件连接或<code>on</code>条件连接)进行组合。<!--SSTStop--></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第4章 中级SQL </category>
          
          <category> 4.1 连接表达式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.1.2 外连接</title>
      <link href="/ReadingNotes//ca319795/"/>
      <url>/ReadingNotes//ca319795/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/ca319795/#4-1-2-外连接" class="header_1">4.1.2 外连接</a>&nbsp;<br><a href="/ReadingNotes/ca319795/#外连接不会丢失元组" class="header_2">外连接不会丢失元组</a>&nbsp;<br><a href="/ReadingNotes/ca319795/#内连接定义" class="header_2">内连接定义</a>&nbsp;<br><a href="/ReadingNotes/ca319795/#外连接定义" class="header_2">外连接定义</a>&nbsp;<br><a href="/ReadingNotes/ca319795/#外连接分类" class="header_2">外连接分类</a>&nbsp;<br><a href="/ReadingNotes/ca319795/#左外连接运算过程" class="header_2">左外连接运算过程</a>&nbsp;<br><a href="/ReadingNotes/ca319795/#实例" class="header_3">实例</a>&nbsp;<br><a href="/ReadingNotes/ca319795/#左外连接结果" class="header_4">左外连接结果</a>&nbsp;<br><a href="/ReadingNotes/ca319795/#内连接结果" class="header_3">内连接结果</a>&nbsp;<br><a href="/ReadingNotes/ca319795/#找出所有一门课程也没有选修的学生" class="header_3">找出所有一门课程也没有选修的学生</a>&nbsp;<br><a href="/ReadingNotes/ca319795/#右外连接" class="header_2">右外连接</a>&nbsp;<br><a href="/ReadingNotes/ca319795/#实例" class="header_3">实例</a>&nbsp;<br><a href="/ReadingNotes/ca319795/#全外连接" class="header_2">全外连接</a>&nbsp;<br><a href="/ReadingNotes/ca319795/#实例" class="header_3">实例</a>&nbsp;<br><a href="/ReadingNotes/ca319795/#MySQL8-0不支持全外连接" class="header_3">MySQL8.0不支持全外连接</a>&nbsp;<br><a href="/ReadingNotes/ca319795/#MySQL中实现全外连接" class="header_3">MySQL中实现全外连接</a>&nbsp;<br><a href="/ReadingNotes/ca319795/#通过union元素" class="header_4">通过union元素</a>&nbsp;<br><a href="/ReadingNotes/ca319795/#左外连接结果" class="header_3">左外连接结果</a>&nbsp;<br><a href="/ReadingNotes/ca319795/#右外连接结果" class="header_3">右外连接结果</a>&nbsp;<br><a href="/ReadingNotes/ca319795/#全外连接结果" class="header_3">全外连接结果</a>&nbsp;<br><a href="/ReadingNotes/ca319795/#要显示给出属性的顺序" class="header_4">要显示给出属性的顺序</a>&nbsp;<br><a href="/ReadingNotes/ca319795/#错误的写法" class="header_4">错误的写法</a>&nbsp;<br><a href="/ReadingNotes/ca319795/#on子句和外连接一起使用" class="header_2">on子句和外连接一起使用</a>&nbsp;<br><a href="/ReadingNotes/ca319795/#外连接中on子句和where子句" class="header_2">外连接中on子句和where子句</a>&nbsp;<br><a href="/ReadingNotes/ca319795/#外连接补空值的条件" class="header_3">外连接补空值的条件</a>&nbsp;<br><a href="/ReadingNotes/ca319795/#外连接中on子句和where子句的不同" class="header_3">外连接中on子句和where子句的不同</a>&nbsp;<br><a href="/ReadingNotes/ca319795/#小结" class="header_2">小结</a>&nbsp;<br><a href="/ReadingNotes/ca319795/#使用的表" class="header_1">使用的表</a>&nbsp;<br><a href="/ReadingNotes/ca319795/#student关系内容" class="header_2">student关系内容</a>&nbsp;<br><a href="/ReadingNotes/ca319795/#takes关系内容" class="header_2">takes关系内容</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="4-1-2-外连接"><a href="#4-1-2-外连接" class="headerlink" title="4.1.2 外连接"></a>4.1.2 外连接</h1><p>假设我们要显示一个所有学生的列表,显示他们的<code>ID</code>、<code>name</code>、 <code>dept_name</code>和<code>tot_cred,</code>以及他们所选修的课程。下面的查询<code>好像</code>检索出了所需的信息:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> student <span class="keyword">natural</span> <span class="keyword">join</span> takes;</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select *</span><br><span class="line">from student natural join takes;</span><br><span class="line">+-------+----------+------------+----------+-----------+--------+----------+------+-------+</span><br><span class="line">| ID    | name     | dept_name  | tot_cred | course_id | sec_id | semester | year | grade |</span><br><span class="line">+-------+----------+------------+----------+-----------+--------+----------+------+-------+</span><br><span class="line">| <span class="number">00128</span> | Zhang    | <span class="built_in">Comp</span>. Sci. | <span class="number">102</span>      | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">00128</span> | Zhang    | <span class="built_in">Comp</span>. Sci. | <span class="number">102</span>      | CS-<span class="number">347</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A-    |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | C     |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | CS-<span class="number">315</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | A     |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | CS-<span class="number">347</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">19991</span> | Brandt   | History    | <span class="number">80</span>       | HIS-<span class="number">351</span>   | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">23121</span> | Chavez   | Finance    | <span class="number">110</span>      | FIN-<span class="number">201</span>   | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | C+    |</span><br><span class="line">| <span class="number">44553</span> | Peltier  | Physics    | <span class="number">56</span>       | PHY-<span class="number">101</span>   | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | B-    |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | F     |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       | CS-<span class="number">101</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B+    |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       | CS-<span class="number">319</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">54321</span> | Williams | <span class="built_in">Comp</span>. Sci. | <span class="number">54</span>       | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A-    |</span><br><span class="line">| <span class="number">54321</span> | Williams | <span class="built_in">Comp</span>. Sci. | <span class="number">54</span>       | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | B+    |</span><br><span class="line">| <span class="number">55739</span> | Sanchez  | Music      | <span class="number">38</span>       | MU-<span class="number">199</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | A-    |</span><br><span class="line">| <span class="number">76543</span> | Brown    | <span class="built_in">Comp</span>. Sci. | <span class="number">58</span>       | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">76543</span> | Brown    | <span class="built_in">Comp</span>. Sci. | <span class="number">58</span>       | CS-<span class="number">319</span>    | <span class="number">2</span>      | Spring   | <span class="number">2010</span> | A     |</span><br><span class="line">| <span class="number">76653</span> | Aoi      | Elec. Eng. | <span class="number">60</span>       | EE-<span class="number">181</span>    | <span class="number">1</span>      | Spring   | <span class="number">2009</span> | C     |</span><br><span class="line">| <span class="number">98765</span> | Bourikas | Elec. Eng. | <span class="number">98</span>       | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | C-    |</span><br><span class="line">| <span class="number">98765</span> | Bourikas | Elec. Eng. | <span class="number">98</span>       | CS-<span class="number">315</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">98988</span> | Tanaka   | Biology    | <span class="number">120</span>      | BIO-<span class="number">101</span>   | <span class="number">1</span>      | Summer   | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">98988</span> | Tanaka   | Biology    | <span class="number">120</span>      | BIO-<span class="number">301</span>   | <span class="number">1</span>      | Summer   | <span class="number">2010</span> | NULL  |</span><br><span class="line">+-------+----------+------------+----------+-----------+--------+----------+------+-------+</span><br><span class="line"><span class="number">22</span> rows <span class="keyword">in</span> <span class="built_in">set</span> (<span class="number">0</span>.<span class="number">08</span> sec)</span><br></pre></td></tr></table></figure><br>遗憾的是,上述查询与想要的结果是不同的。假设有一些学生,他们没有选修任何课程。那么这些学生在<code>student</code>关系中所对应的元组与<code>takes</code>关系中的任何元组配对,都不会满足自然连接的条件,从而这些学生的数据就不会出现在结果中。这样我们就<strong>看不到没有选修任何课程的学生的任何信息</strong>。例如,<br><a href="#使用的表">在student关系和takes关系中</a>,<code>ID</code>为<code>70557</code>的学生<code>Snow</code>没有选修任何课程。<code>Snow</code>出现在<code>student</code>关系中,但是<code>Snow</code>的<code>ID</code>号没有出现在<code>takes</code>的I列中。从而<code>Snow</code>不会出现在自然连接的结果中。</p><h2 id="外连接不会丢失元组"><a href="#外连接不会丢失元组" class="headerlink" title="外连接不会丢失元组"></a>外连接不会丢失元组</h2><p>更为一般地,在参与连接的任何一个或两个关系中的某些元组可能会以这种方式”<strong>丢失</strong>“。外连接( <code>outer join</code>)运算与我们已经学过的连接运算类似,但<strong>通过在结果中创建包含空值元组的方式,保留了那些在连接中丢失的元组</strong>。<br>例如,为了保证在我们前例中的名为<code>Snow</code>的学生出现在结果中,可以在连接结果中加入一个元组,它</p><ul><li>在来自<code>student</code>关系的所有属性上的值被设置为学生<code>Snow</code>的相应值,</li><li>在所有余下的来自<code>takes</code>关系属性上的值被设为<code>null,</code>这些属性是<code>course id</code>、<code>sed</code>、 <code>semester</code>和<code>year</code></li></ul><h2 id="内连接定义"><a href="#内连接定义" class="headerlink" title="内连接定义"></a>内连接定义</h2><p><strong><code>不保留未匹配元组</code>的连接运算</strong>被称作<strong>内连接</strong>运算(<code>inner join</code>)。</p><h2 id="外连接定义"><a href="#外连接定义" class="headerlink" title="外连接定义"></a>外连接定义</h2><p><strong>保留未匹配元组的连接运算</strong>被称作<strong>外连接</strong>运算(<code>outer join</code>)。</p><h2 id="外连接分类"><a href="#外连接分类" class="headerlink" title="外连接分类"></a>外连接分类</h2><p>实际上有三种形式的外连接:</p><ul><li><strong>左外连接</strong>(<code>left outer join</code>)<strong>只保留</strong>出现在左外连接运算<strong>之前(左边)的关系中的元组</strong>。</li><li><strong>右外连接</strong>(<code>right outer join</code>)<strong>只保留</strong>出现在右外连接运算之后<strong>(右边)的关系中的元组</strong>。</li><li><strong>全外连接</strong>(<code>full outer join</code>)保留出现在两个关系中的元组。</li></ul><h2 id="左外连接运算过程"><a href="#左外连接运算过程" class="headerlink" title="左外连接运算过程"></a>左外连接运算过程</h2><p>我们现在详细解释每种形式的外连接是怎样操作的。我们可以按照如下方式计算<strong>左外连接运算</strong></p><ul><li>首先,像前面那样计算出内连接的结果;</li><li>然后,对于在内连接的<strong>左侧关系中</strong>任意一个与右侧关系中任何元组都不匹配<strong>的元组<code>t</code></strong>,向连接结果中加入一个元组<code>r</code>,<code>r</code>的构造如下:<ul><li>元组r从<strong>左侧关系</strong>得到的属性被赋为元组t中的值。</li><li>元组r的其他属性被赋为<strong>空值</strong>。</li></ul></li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line">    <span class="keyword">from</span> student <span class="keyword">natural</span> <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> takes;</span><br></pre></td></tr></table></figure><p>与内连接的结果不同,此结果中包含了学生<code>Snow(ID 70557)</code>,但是在<code>Snow</code>对应的元组中,在<strong>那些只出现在<code>takes</code>关系模式中的属性上<code>取空值</code></strong>。</p><h4 id="左外连接结果"><a href="#左外连接结果" class="headerlink" title="左外连接结果"></a>左外连接结果</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select *</span><br><span class="line">    from student natural left outer join takes;</span><br><span class="line">+-------+----------+------------+----------+-----------+--------+----------+------+-------+</span><br><span class="line">| ID    | name     | dept_name  | tot_cred | course_id | sec_id | semester | year | grade |</span><br><span class="line">+-------+----------+------------+----------+-----------+--------+----------+------+-------+</span><br><span class="line">| <span class="number">00128</span> | Zhang    | <span class="built_in">Comp</span>. Sci. | <span class="number">102</span>      | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">00128</span> | Zhang    | <span class="built_in">Comp</span>. Sci. | <span class="number">102</span>      | CS-<span class="number">347</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A-    |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | C     |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | CS-<span class="number">315</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | A     |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | CS-<span class="number">347</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">19991</span> | Brandt   | History    | <span class="number">80</span>       | HIS-<span class="number">351</span>   | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">23121</span> | Chavez   | Finance    | <span class="number">110</span>      | FIN-<span class="number">201</span>   | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | C+    |</span><br><span class="line">| <span class="number">44553</span> | Peltier  | Physics    | <span class="number">56</span>       | PHY-<span class="number">101</span>   | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | B-    |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | F     |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       | CS-<span class="number">101</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B+    |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       | CS-<span class="number">319</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">54321</span> | Williams | <span class="built_in">Comp</span>. Sci. | <span class="number">54</span>       | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A-    |</span><br><span class="line">| <span class="number">54321</span> | Williams | <span class="built_in">Comp</span>. Sci. | <span class="number">54</span>       | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | B+    |</span><br><span class="line">| <span class="number">55739</span> | Sanchez  | Music      | <span class="number">38</span>       | MU-<span class="number">199</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | A-    |</span><br><span class="line">| <span class="number">70557</span> | Snow     | Physics    | <span class="number">0</span>        | NULL      | NULL   | NULL     | NULL | NULL  |</span><br><span class="line">| <span class="number">76543</span> | Brown    | <span class="built_in">Comp</span>. Sci. | <span class="number">58</span>       | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">76543</span> | Brown    | <span class="built_in">Comp</span>. Sci. | <span class="number">58</span>       | CS-<span class="number">319</span>    | <span class="number">2</span>      | Spring   | <span class="number">2010</span> | A     |</span><br><span class="line">| <span class="number">76653</span> | Aoi      | Elec. Eng. | <span class="number">60</span>       | EE-<span class="number">181</span>    | <span class="number">1</span>      | Spring   | <span class="number">2009</span> | C     |</span><br><span class="line">| <span class="number">98765</span> | Bourikas | Elec. Eng. | <span class="number">98</span>       | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | C-    |</span><br><span class="line">| <span class="number">98765</span> | Bourikas | Elec. Eng. | <span class="number">98</span>       | CS-<span class="number">315</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">98988</span> | Tanaka   | Biology    | <span class="number">120</span>      | BIO-<span class="number">101</span>   | <span class="number">1</span>      | Summer   | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">98988</span> | Tanaka   | Biology    | <span class="number">120</span>      | BIO-<span class="number">301</span>   | <span class="number">1</span>      | Summer   | <span class="number">2010</span> | NULL  |</span><br><span class="line">+-------+----------+------------+----------+-----------+--------+----------+------+-------+</span><br><span class="line"><span class="number">23</span> rows <span class="keyword">in</span> <span class="built_in">set</span> (<span class="number">0</span>.<span class="number">07</span> sec)</span><br></pre></td></tr></table></figure><h3 id="内连接结果"><a href="#内连接结果" class="headerlink" title="内连接结果"></a>内连接结果</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select *</span><br><span class="line">    from student natural join takes;</span><br><span class="line">+-------+----------+------------+----------+-----------+--------+----------+------+-------+</span><br><span class="line">| ID    | name     | dept_name  | tot_cred | course_id | sec_id | semester | year | grade |</span><br><span class="line">+-------+----------+------------+----------+-----------+--------+----------+------+-------+</span><br><span class="line">| <span class="number">00128</span> | Zhang    | <span class="built_in">Comp</span>. Sci. | <span class="number">102</span>      | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">00128</span> | Zhang    | <span class="built_in">Comp</span>. Sci. | <span class="number">102</span>      | CS-<span class="number">347</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A-    |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | C     |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | CS-<span class="number">315</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | A     |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | CS-<span class="number">347</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">19991</span> | Brandt   | History    | <span class="number">80</span>       | HIS-<span class="number">351</span>   | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">23121</span> | Chavez   | Finance    | <span class="number">110</span>      | FIN-<span class="number">201</span>   | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | C+    |</span><br><span class="line">| <span class="number">44553</span> | Peltier  | Physics    | <span class="number">56</span>       | PHY-<span class="number">101</span>   | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | B-    |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | F     |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       | CS-<span class="number">101</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B+    |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       | CS-<span class="number">319</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">54321</span> | Williams | <span class="built_in">Comp</span>. Sci. | <span class="number">54</span>       | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A-    |</span><br><span class="line">| <span class="number">54321</span> | Williams | <span class="built_in">Comp</span>. Sci. | <span class="number">54</span>       | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | B+    |</span><br><span class="line">| <span class="number">55739</span> | Sanchez  | Music      | <span class="number">38</span>       | MU-<span class="number">199</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | A-    |</span><br><span class="line">| <span class="number">76543</span> | Brown    | <span class="built_in">Comp</span>. Sci. | <span class="number">58</span>       | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">76543</span> | Brown    | <span class="built_in">Comp</span>. Sci. | <span class="number">58</span>       | CS-<span class="number">319</span>    | <span class="number">2</span>      | Spring   | <span class="number">2010</span> | A     |</span><br><span class="line">| <span class="number">76653</span> | Aoi      | Elec. Eng. | <span class="number">60</span>       | EE-<span class="number">181</span>    | <span class="number">1</span>      | Spring   | <span class="number">2009</span> | C     |</span><br><span class="line">| <span class="number">98765</span> | Bourikas | Elec. Eng. | <span class="number">98</span>       | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | C-    |</span><br><span class="line">| <span class="number">98765</span> | Bourikas | Elec. Eng. | <span class="number">98</span>       | CS-<span class="number">315</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">98988</span> | Tanaka   | Biology    | <span class="number">120</span>      | BIO-<span class="number">101</span>   | <span class="number">1</span>      | Summer   | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">98988</span> | Tanaka   | Biology    | <span class="number">120</span>      | BIO-<span class="number">301</span>   | <span class="number">1</span>      | Summer   | <span class="number">2010</span> | NULL  |</span><br><span class="line">+-------+----------+------------+----------+-----------+--------+----------+------+-------+</span><br><span class="line"><span class="number">22</span> rows <span class="keyword">in</span> <span class="built_in">set</span> (<span class="number">0</span>.<span class="number">07</span> sec)</span><br></pre></td></tr></table></figure><p>外连接比内连接多了一行:<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| <span class="number">70557</span> | Snow     | Physics    | <span class="number">0</span>        | NULL      | NULL   | NULL     | NULL | NULL  |</span><br></pre></td></tr></table></figure></p><h3 id="找出所有一门课程也没有选修的学生"><a href="#找出所有一门课程也没有选修的学生" class="headerlink" title="找出所有一门课程也没有选修的学生"></a>找出所有一门课程也没有选修的学生</h3><p>作为使用<code>外连接运算</code>的另一个例子,我们可以写出查询”<strong>找出所有一门课程也没有选修的学生</strong>“:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">ID</span></span><br><span class="line">    <span class="keyword">from</span> student <span class="keyword">natural</span> <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> takes</span><br><span class="line">    <span class="keyword">where</span> course_id <span class="keyword">is</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select ID</span><br><span class="line">    from student natural left outer join takes</span><br><span class="line">    where course_id is null;</span><br><span class="line">+-------+</span><br><span class="line">| ID    |</span><br><span class="line">+-------+</span><br><span class="line">| <span class="number">70557</span> |</span><br><span class="line">+-------+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> <span class="built_in">set</span> (<span class="number">0</span>.<span class="number">03</span> sec)</span><br></pre></td></tr></table></figure></p><h2 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h2><p><strong>右外连接和左外连接是对称的</strong>。<br>来自<strong>右侧关系中</strong>不匹配左侧关系任何元组<strong>的元组被补上空值并加入到右外连接的结果中</strong>。</p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>如果我们使用右外连接来重写前面的查询,并<strong>交换列出关系的次序</strong>,如下所示:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line">    <span class="keyword">from</span> takes <span class="keyword">natural</span> <span class="keyword">right</span> <span class="keyword">outer</span> <span class="keyword">join</span> student;</span><br></pre></td></tr></table></figure><br><strong>我们得到的结果是一样的</strong>,只不过结果中属性出现的顺序不同<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select *</span><br><span class="line">    from takes natural right outer join student;</span><br><span class="line">+-------+----------+------------+----------+-----------+--------+----------+------+-------+</span><br><span class="line">| ID    | name     | dept_name  | tot_cred | course_id | sec_id | semester | year | grade |</span><br><span class="line">+-------+----------+------------+----------+-----------+--------+----------+------+-------+</span><br><span class="line">| <span class="number">00128</span> | Zhang    | <span class="built_in">Comp</span>. Sci. | <span class="number">102</span>      | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">00128</span> | Zhang    | <span class="built_in">Comp</span>. Sci. | <span class="number">102</span>      | CS-<span class="number">347</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A-    |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | C     |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | CS-<span class="number">315</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | A     |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | CS-<span class="number">347</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">19991</span> | Brandt   | History    | <span class="number">80</span>       | HIS-<span class="number">351</span>   | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">23121</span> | Chavez   | Finance    | <span class="number">110</span>      | FIN-<span class="number">201</span>   | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | C+    |</span><br><span class="line">| <span class="number">44553</span> | Peltier  | Physics    | <span class="number">56</span>       | PHY-<span class="number">101</span>   | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | B-    |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | F     |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       | CS-<span class="number">101</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B+    |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       | CS-<span class="number">319</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">54321</span> | Williams | <span class="built_in">Comp</span>. Sci. | <span class="number">54</span>       | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A-    |</span><br><span class="line">| <span class="number">54321</span> | Williams | <span class="built_in">Comp</span>. Sci. | <span class="number">54</span>       | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | B+    |</span><br><span class="line">| <span class="number">55739</span> | Sanchez  | Music      | <span class="number">38</span>       | MU-<span class="number">199</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | A-    |</span><br><span class="line">| <span class="number">70557</span> | Snow     | Physics    | <span class="number">0</span>        | NULL      | NULL   | NULL     | NULL | NULL  |</span><br><span class="line">| <span class="number">76543</span> | Brown    | <span class="built_in">Comp</span>. Sci. | <span class="number">58</span>       | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">76543</span> | Brown    | <span class="built_in">Comp</span>. Sci. | <span class="number">58</span>       | CS-<span class="number">319</span>    | <span class="number">2</span>      | Spring   | <span class="number">2010</span> | A     |</span><br><span class="line">| <span class="number">76653</span> | Aoi      | Elec. Eng. | <span class="number">60</span>       | EE-<span class="number">181</span>    | <span class="number">1</span>      | Spring   | <span class="number">2009</span> | C     |</span><br><span class="line">| <span class="number">98765</span> | Bourikas | Elec. Eng. | <span class="number">98</span>       | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | C-    |</span><br><span class="line">| <span class="number">98765</span> | Bourikas | Elec. Eng. | <span class="number">98</span>       | CS-<span class="number">315</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">98988</span> | Tanaka   | Biology    | <span class="number">120</span>      | BIO-<span class="number">101</span>   | <span class="number">1</span>      | Summer   | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">98988</span> | Tanaka   | Biology    | <span class="number">120</span>      | BIO-<span class="number">301</span>   | <span class="number">1</span>      | Summer   | <span class="number">2010</span> | NULL  |</span><br><span class="line">+-------+----------+------------+----------+-----------+--------+----------+------+-------+</span><br><span class="line"><span class="number">23</span> rows <span class="keyword">in</span> <span class="built_in">set</span> (<span class="number">0</span>.<span class="number">07</span> sec)</span><br></pre></td></tr></table></figure><br>经过我的测试<code>MySQL8.0</code>中这里的左外连接的结果和右外连接的结果一样.并且属性出现的顺序也一样:<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select *</span><br><span class="line">    from student natural left outer join takes;</span><br><span class="line">+-------+----------+------------+----------+-----------+--------+----------+------+-------+</span><br><span class="line">| ID    | name     | dept_name  | tot_cred | course_id | sec_id | semester | year | grade |</span><br><span class="line">+-------+----------+------------+----------+-----------+--------+----------+------+-------+</span><br><span class="line">| <span class="number">00128</span> | Zhang    | <span class="built_in">Comp</span>. Sci. | <span class="number">102</span>      | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">00128</span> | Zhang    | <span class="built_in">Comp</span>. Sci. | <span class="number">102</span>      | CS-<span class="number">347</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A-    |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | C     |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | CS-<span class="number">315</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | A     |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | CS-<span class="number">347</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">19991</span> | Brandt   | History    | <span class="number">80</span>       | HIS-<span class="number">351</span>   | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">23121</span> | Chavez   | Finance    | <span class="number">110</span>      | FIN-<span class="number">201</span>   | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | C+    |</span><br><span class="line">| <span class="number">44553</span> | Peltier  | Physics    | <span class="number">56</span>       | PHY-<span class="number">101</span>   | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | B-    |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | F     |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       | CS-<span class="number">101</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B+    |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       | CS-<span class="number">319</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">54321</span> | Williams | <span class="built_in">Comp</span>. Sci. | <span class="number">54</span>       | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A-    |</span><br><span class="line">| <span class="number">54321</span> | Williams | <span class="built_in">Comp</span>. Sci. | <span class="number">54</span>       | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | B+    |</span><br><span class="line">| <span class="number">55739</span> | Sanchez  | Music      | <span class="number">38</span>       | MU-<span class="number">199</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | A-    |</span><br><span class="line">| <span class="number">70557</span> | Snow     | Physics    | <span class="number">0</span>        | NULL      | NULL   | NULL     | NULL | NULL  |</span><br><span class="line">| <span class="number">76543</span> | Brown    | <span class="built_in">Comp</span>. Sci. | <span class="number">58</span>       | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">76543</span> | Brown    | <span class="built_in">Comp</span>. Sci. | <span class="number">58</span>       | CS-<span class="number">319</span>    | <span class="number">2</span>      | Spring   | <span class="number">2010</span> | A     |</span><br><span class="line">| <span class="number">76653</span> | Aoi      | Elec. Eng. | <span class="number">60</span>       | EE-<span class="number">181</span>    | <span class="number">1</span>      | Spring   | <span class="number">2009</span> | C     |</span><br><span class="line">| <span class="number">98765</span> | Bourikas | Elec. Eng. | <span class="number">98</span>       | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | C-    |</span><br><span class="line">| <span class="number">98765</span> | Bourikas | Elec. Eng. | <span class="number">98</span>       | CS-<span class="number">315</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">98988</span> | Tanaka   | Biology    | <span class="number">120</span>      | BIO-<span class="number">101</span>   | <span class="number">1</span>      | Summer   | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">98988</span> | Tanaka   | Biology    | <span class="number">120</span>      | BIO-<span class="number">301</span>   | <span class="number">1</span>      | Summer   | <span class="number">2010</span> | NULL  |</span><br><span class="line">+-------+----------+------------+----------+-----------+--------+----------+------+-------+</span><br><span class="line"><span class="number">23</span> rows <span class="keyword">in</span> <span class="built_in">set</span> (<span class="number">0</span>.<span class="number">06</span> sec)</span><br></pre></td></tr></table></figure></p><h2 id="全外连接"><a href="#全外连接" class="headerlink" title="全外连接"></a>全外连接</h2><p>全外连接是左外连接与右外连接类型的组合。在内连接结果计算出来之后:</p><ul><li>左侧关系中不匹配右侧关系任何元组的元组被添上空值并加到结果中.</li><li>右侧关系中不匹配左侧关系任何元组的元组也被添上空值并加到结果中。</li></ul><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>作为使用全外连接的例子,考虑查询:”<strong>显示Comp. Sci. 系所有学生以及他们在2009年春季选修的所有课程段的列表,<code>2009</code>年春季开设的所有课程段都必须显示,即使没有<code>Comp. Sci.</code>系的学生选修这些课程段</strong>“。此查询可写为:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span>(</span><br><span class="line">    <span class="keyword">select</span> *</span><br><span class="line">    <span class="keyword">from</span> student</span><br><span class="line">    <span class="keyword">where</span> dept_name =<span class="string">'Comp. Sci. '</span></span><br><span class="line">) <span class="keyword">as</span> S <span class="keyword">natural</span> <span class="keyword">full</span> <span class="keyword">outer</span> <span class="keyword">join</span>(</span><br><span class="line">    <span class="keyword">select</span> *</span><br><span class="line">    <span class="keyword">from</span> takes</span><br><span class="line">    <span class="keyword">where</span> semester=<span class="string">'Spring'</span> <span class="keyword">and</span> <span class="keyword">year</span> =<span class="number">2009</span></span><br><span class="line">) <span class="keyword">as</span> T;</span><br></pre></td></tr></table></figure></p><h3 id="MySQL8-0不支持全外连接"><a href="#MySQL8-0不支持全外连接" class="headerlink" title="MySQL8.0不支持全外连接"></a>MySQL8.0不支持全外连接</h3><p>经过我的测试最新版的<code>MySQL8.0</code><strong>不支持全外连接</strong><code>natural full outer join</code>;<br><code>on</code>子句可以和外连接一起使用。下述查询与我们见过的第一个使用”<code>student natural left outer join takes</code>“的查询是相同的,只不过属性<code>ID</code>在结果中出现两次。</p><h3 id="MySQL中实现全外连接"><a href="#MySQL中实现全外连接" class="headerlink" title="MySQL中实现全外连接"></a>MySQL中实现全外连接</h3><h4 id="通过union元素"><a href="#通过union元素" class="headerlink" title="通过union元素"></a>通过union元素</h4><p><code>MySQL</code>支持并运算(<code>union</code>),所以可以通过<strong><code>左外连接</code>和<code>右外连接</code>的并运算</strong>得到<code>全外连接</code>.<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> S1.*,T1.course_id,T1.sec_id,T1.semester,T1.year,grade</span><br><span class="line"><span class="keyword">from</span>(</span><br><span class="line">    <span class="keyword">select</span> *</span><br><span class="line">    <span class="keyword">from</span> student</span><br><span class="line">    <span class="keyword">where</span> dept_name =<span class="string">'Comp. Sci. '</span></span><br><span class="line">) <span class="keyword">as</span> S1</span><br><span class="line"><span class="keyword">natural</span> <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> *</span><br><span class="line">        <span class="keyword">from</span> takes</span><br><span class="line">        <span class="keyword">where</span> semester=<span class="string">'Spring'</span> <span class="keyword">and</span> <span class="keyword">year</span> =<span class="number">2009</span></span><br><span class="line">) <span class="keyword">as</span> T1</span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> S2.*,T2.course_id,T2.sec_id,T2.semester,T2.year,grade</span><br><span class="line"><span class="keyword">from</span>(</span><br><span class="line">    <span class="keyword">select</span> *</span><br><span class="line">    <span class="keyword">from</span> student</span><br><span class="line">    <span class="keyword">where</span> dept_name =<span class="string">'Comp. Sci. '</span></span><br><span class="line">) <span class="keyword">as</span> S2</span><br><span class="line"><span class="keyword">natural</span> <span class="keyword">right</span> <span class="keyword">outer</span> <span class="keyword">join</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> *</span><br><span class="line">        <span class="keyword">from</span> takes</span><br><span class="line">        <span class="keyword">where</span> semester=<span class="string">'Spring'</span> <span class="keyword">and</span> <span class="keyword">year</span> =<span class="number">2009</span></span><br><span class="line">) <span class="keyword">as</span> T2;</span><br></pre></td></tr></table></figure></p><h3 id="左外连接结果-1"><a href="#左外连接结果-1" class="headerlink" title="左外连接结果"></a>左外连接结果</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;  select S1.*,T1.course_id,T1.sec_id,T1.semester,T1.year,grade</span><br><span class="line">from(</span><br><span class="line">    select *</span><br><span class="line">    from student</span><br><span class="line">    where dept_name ='<span class="built_in">Comp</span>. Sci. '</span><br><span class="line">) as S1</span><br><span class="line">natural left outer join</span><br><span class="line">(</span><br><span class="line">    select *</span><br><span class="line">        from takes</span><br><span class="line">        where semester='Spring' and year =<span class="number">2009</span></span><br><span class="line">) as T1;</span><br><span class="line">+-------+----------+------------+----------+-----------+--------+----------+------+-------+</span><br><span class="line">| ID    | name     | dept_name  | tot_cred | course_id | sec_id | semester | year | grade |</span><br><span class="line">+-------+----------+------------+----------+-----------+--------+----------+------+-------+</span><br><span class="line">| <span class="number">00128</span> | Zhang    | <span class="built_in">Comp</span>. Sci. | <span class="number">102</span>      | NULL      | NULL   | NULL     | NULL | NULL  |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">54321</span> | Williams | <span class="built_in">Comp</span>. Sci. | <span class="number">54</span>       | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | B+    |</span><br><span class="line">| <span class="number">76543</span> | Brown    | <span class="built_in">Comp</span>. Sci. | <span class="number">58</span>       | NULL      | NULL   | NULL     | NULL | NULL  |</span><br><span class="line">+-------+----------+------------+----------+-----------+--------+----------+------+-------+</span><br><span class="line"><span class="number">4</span> rows <span class="keyword">in</span> <span class="built_in">set</span> (<span class="number">0</span>.<span class="number">04</span> sec)</span><br></pre></td></tr></table></figure><h3 id="右外连接结果"><a href="#右外连接结果" class="headerlink" title="右外连接结果"></a>右外连接结果</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select S2.*,T2.course_id,T2.sec_id,T2.semester,T2.year,grade</span><br><span class="line">from(</span><br><span class="line">    select *</span><br><span class="line">    from student</span><br><span class="line">    where dept_name ='<span class="built_in">Comp</span>. Sci. '</span><br><span class="line">) as S2</span><br><span class="line">natural right outer join</span><br><span class="line">(</span><br><span class="line">    select *</span><br><span class="line">        from takes</span><br><span class="line">        where semester='Spring' and year =<span class="number">2009</span></span><br><span class="line">) as T2;</span><br><span class="line">+-------+----------+------------+----------+-----------+--------+----------+------+-------+</span><br><span class="line">| ID    | name     | dept_name  | tot_cred | course_id | sec_id | semester | year | grade |</span><br><span class="line">+-------+----------+------------+----------+-----------+--------+----------+------+-------+</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">54321</span> | Williams | <span class="built_in">Comp</span>. Sci. | <span class="number">54</span>       | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | B+    |</span><br><span class="line">| NULL  | NULL     | NULL       | NULL     | EE-<span class="number">181</span>    | <span class="number">1</span>      | Spring   | <span class="number">2009</span> | C     |</span><br><span class="line">+-------+----------+------------+----------+-----------+--------+----------+------+-------+</span><br><span class="line"><span class="number">3</span> rows <span class="keyword">in</span> <span class="built_in">set</span> (<span class="number">0</span>.<span class="number">04</span> sec)</span><br></pre></td></tr></table></figure><h3 id="全外连接结果"><a href="#全外连接结果" class="headerlink" title="全外连接结果"></a>全外连接结果</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select S1.*,T1.course_id,T1.sec_id,T1.semester,T1.year,grade</span><br><span class="line">from(</span><br><span class="line">    select *</span><br><span class="line">    from student</span><br><span class="line">    where dept_name ='<span class="built_in">Comp</span>. Sci. '</span><br><span class="line">) as S1</span><br><span class="line">natural left outer join</span><br><span class="line">(</span><br><span class="line">    select *</span><br><span class="line">        from takes</span><br><span class="line">        where semester='Spring' and year =<span class="number">2009</span></span><br><span class="line">) as T1</span><br><span class="line">union</span><br><span class="line">select S2.*,T2.course_id,T2.sec_id,T2.semester,T2.year,grade</span><br><span class="line">from(</span><br><span class="line">    select *</span><br><span class="line">    from student</span><br><span class="line">    where dept_name ='<span class="built_in">Comp</span>. Sci. '</span><br><span class="line">) as S2</span><br><span class="line">natural right outer join</span><br><span class="line">(</span><br><span class="line">    select *</span><br><span class="line">        from takes</span><br><span class="line">        where semester='Spring' and year =<span class="number">2009</span></span><br><span class="line">) as T2;</span><br><span class="line">+-------+----------+------------+----------+-----------+--------+----------+------+-------+</span><br><span class="line">| ID    | name     | dept_name  | tot_cred | course_id | sec_id | semester | year | grade |</span><br><span class="line">+-------+----------+------------+----------+-----------+--------+----------+------+-------+</span><br><span class="line">| <span class="number">00128</span> | Zhang    | <span class="built_in">Comp</span>. Sci. | <span class="number">102</span>      | NULL      | NULL   | NULL     | NULL | NULL  |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">54321</span> | Williams | <span class="built_in">Comp</span>. Sci. | <span class="number">54</span>       | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | B+    |</span><br><span class="line">| <span class="number">76543</span> | Brown    | <span class="built_in">Comp</span>. Sci. | <span class="number">58</span>       | NULL      | NULL   | NULL     | NULL | NULL  |</span><br><span class="line">| NULL  | NULL     | NULL       | NULL     | EE-<span class="number">181</span>    | <span class="number">1</span>      | Spring   | <span class="number">2009</span> | C     |</span><br><span class="line">+-------+----------+------------+----------+-----------+--------+----------+------+-------+</span><br><span class="line"><span class="number">5</span> rows <span class="keyword">in</span> <span class="built_in">set</span> (<span class="number">0</span>.<span class="number">04</span> sec)</span><br></pre></td></tr></table></figure><h4 id="要显示给出属性的顺序"><a href="#要显示给出属性的顺序" class="headerlink" title="要显示给出属性的顺序"></a>要显示给出属性的顺序</h4><p>还需要注意的是左外连接和又外连接的结果集中属性的排列顺序不同,所以不要使用<code>select *</code>,而是在select子句中显示给出两个表的属性的排列顺序.</p><h4 id="错误的写法"><a href="#错误的写法" class="headerlink" title="错误的写法"></a>错误的写法</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select *</span><br><span class="line">from(</span><br><span class="line">    select *</span><br><span class="line">    from student</span><br><span class="line">    where dept_name ='<span class="built_in">Comp</span>. Sci. '</span><br><span class="line">) as S1</span><br><span class="line">natural left outer join</span><br><span class="line">(</span><br><span class="line">    select *</span><br><span class="line">        from takes</span><br><span class="line">        where semester='Spring' and year =<span class="number">2009</span></span><br><span class="line">) as T1</span><br><span class="line">union</span><br><span class="line">select *</span><br><span class="line">from(</span><br><span class="line">    select *</span><br><span class="line">    from student</span><br><span class="line">    where dept_name ='<span class="built_in">Comp</span>. Sci. '</span><br><span class="line">) as S2</span><br><span class="line">natural right outer join</span><br><span class="line">(</span><br><span class="line">    select *</span><br><span class="line">        from takes</span><br><span class="line">        where semester='Spring' and year =<span class="number">2009</span></span><br><span class="line">) as T2;</span><br><span class="line">+-------+----------+------------+----------+-----------+--------+----------+------------+-------+</span><br><span class="line">| ID    | name     | dept_name  | tot_cred | course_id | sec_id | semester | year       | grade |</span><br><span class="line">+-------+----------+------------+----------+-----------+--------+----------+------------+-------+</span><br><span class="line">| <span class="number">00128</span> | Zhang    | <span class="built_in">Comp</span>. Sci. | <span class="number">102</span>      | NULL      | NULL   | NULL     | NULL       | NULL  |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span>       | A     |</span><br><span class="line">| <span class="number">54321</span> | Williams | <span class="built_in">Comp</span>. Sci. | <span class="number">54</span>       | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span>       | B+    |</span><br><span class="line">| <span class="number">76543</span> | Brown    | <span class="built_in">Comp</span>. Sci. | <span class="number">58</span>       | NULL      | NULL   | NULL     | NULL       | NULL  |</span><br><span class="line">| <span class="number">12345</span> | CS-<span class="number">190</span>   | <span class="number">2</span>          | Spring   | <span class="number">2009</span>      | A      | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>    |</span><br><span class="line">| <span class="number">54321</span> | CS-<span class="number">190</span>   | <span class="number">2</span>          | Spring   | <span class="number">2009</span>      | B+     | Williams | <span class="built_in">Comp</span>. Sci. | <span class="number">54</span>    |</span><br><span class="line">| <span class="number">76653</span> | EE-<span class="number">181</span>   | <span class="number">1</span>          | Spring   | <span class="number">2009</span>      | C      | NULL     | NULL       | NULL  |</span><br><span class="line">+-------+----------+------------+----------+-----------+--------+----------+------------+-------+</span><br><span class="line"><span class="number">7</span> rows <span class="keyword">in</span> <span class="built_in">set</span> (<span class="number">0</span>.<span class="number">04</span> sec)</span><br></pre></td></tr></table></figure><h2 id="on子句和外连接一起使用"><a href="#on子句和外连接一起使用" class="headerlink" title="on子句和外连接一起使用"></a>on子句和外连接一起使用</h2><p><code>on</code>子句可以和外连接一起使用。下述查询与我们见过的第一个使用”<code>student natural left outer join takes</code>“的查询是相同的,只不过属性<code>ID</code>在结果中出现两次。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> student <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> takes </span><br><span class="line"><span class="keyword">on</span> student.ID= takes.ID;</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select *</span><br><span class="line">from student left outer join takes </span><br><span class="line">on student.ID= takes.ID;</span><br><span class="line">+-------+----------+------------+----------+-------+-----------+--------+----------+------+-------+</span><br><span class="line">| ID    | name     | dept_name  | tot_cred | ID    | course_id | sec_id | semester | year | grade |</span><br><span class="line">+-------+----------+------------+----------+-------+-----------+--------+----------+------+-------+</span><br><span class="line">| <span class="number">00128</span> | Zhang    | <span class="built_in">Comp</span>. Sci. | <span class="number">102</span>      | <span class="number">00128</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">00128</span> | Zhang    | <span class="built_in">Comp</span>. Sci. | <span class="number">102</span>      | <span class="number">00128</span> | CS-<span class="number">347</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A-    |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | <span class="number">12345</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | C     |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | <span class="number">12345</span> | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | <span class="number">12345</span> | CS-<span class="number">315</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | A     |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | <span class="number">12345</span> | CS-<span class="number">347</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">19991</span> | Brandt   | History    | <span class="number">80</span>       | <span class="number">19991</span> | HIS-<span class="number">351</span>   | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">23121</span> | Chavez   | Finance    | <span class="number">110</span>      | <span class="number">23121</span> | FIN-<span class="number">201</span>   | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | C+    |</span><br><span class="line">| <span class="number">44553</span> | Peltier  | Physics    | <span class="number">56</span>       | <span class="number">44553</span> | PHY-<span class="number">101</span>   | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | B-    |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       | <span class="number">45678</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | F     |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       | <span class="number">45678</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B+    |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       | <span class="number">45678</span> | CS-<span class="number">319</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">54321</span> | Williams | <span class="built_in">Comp</span>. Sci. | <span class="number">54</span>       | <span class="number">54321</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A-    |</span><br><span class="line">| <span class="number">54321</span> | Williams | <span class="built_in">Comp</span>. Sci. | <span class="number">54</span>       | <span class="number">54321</span> | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | B+    |</span><br><span class="line">| <span class="number">55739</span> | Sanchez  | Music      | <span class="number">38</span>       | <span class="number">55739</span> | MU-<span class="number">199</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | A-    |</span><br><span class="line">| <span class="number">70557</span> | Snow     | Physics    | <span class="number">0</span>        | NULL  | NULL      | NULL   | NULL     | NULL | NULL  |</span><br><span class="line">| <span class="number">76543</span> | Brown    | <span class="built_in">Comp</span>. Sci. | <span class="number">58</span>       | <span class="number">76543</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">76543</span> | Brown    | <span class="built_in">Comp</span>. Sci. | <span class="number">58</span>       | <span class="number">76543</span> | CS-<span class="number">319</span>    | <span class="number">2</span>      | Spring   | <span class="number">2010</span> | A     |</span><br><span class="line">| <span class="number">76653</span> | Aoi      | Elec. Eng. | <span class="number">60</span>       | <span class="number">76653</span> | EE-<span class="number">181</span>    | <span class="number">1</span>      | Spring   | <span class="number">2009</span> | C     |</span><br><span class="line">| <span class="number">98765</span> | Bourikas | Elec. Eng. | <span class="number">98</span>       | <span class="number">98765</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | C-    |</span><br><span class="line">| <span class="number">98765</span> | Bourikas | Elec. Eng. | <span class="number">98</span>       | <span class="number">98765</span> | CS-<span class="number">315</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">98988</span> | Tanaka   | Biology    | <span class="number">120</span>      | <span class="number">98988</span> | BIO-<span class="number">101</span>   | <span class="number">1</span>      | Summer   | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">98988</span> | Tanaka   | Biology    | <span class="number">120</span>      | <span class="number">98988</span> | BIO-<span class="number">301</span>   | <span class="number">1</span>      | Summer   | <span class="number">2010</span> | NULL  |</span><br><span class="line">+-------+----------+------------+----------+-------+-----------+--------+----------+------+-------+</span><br><span class="line"><span class="number">23</span> rows <span class="keyword">in</span> <span class="built_in">set</span> (<span class="number">0</span>.<span class="number">07</span> sec)</span><br></pre></td></tr></table></figure></p><h2 id="外连接中on子句和where子句"><a href="#外连接中on子句和where子句" class="headerlink" title="外连接中on子句和where子句"></a>外连接中on子句和where子句</h2><h3 id="外连接补空值的条件"><a href="#外连接补空值的条件" class="headerlink" title="外连接补空值的条件"></a>外连接补空值的条件</h3><p><strong>外连接只为那些对相应内连接结果没有贡献的元组补上空值并加入结果</strong>。也就是<code>on</code>子句为<code>false</code>时,外连接才会补上空值.</p><h3 id="外连接中on子句和where子句的不同"><a href="#外连接中on子句和where子句的不同" class="headerlink" title="外连接中on子句和where子句的不同"></a>外连接中on子句和where子句的不同</h3><ul><li><strong><code>on</code>条件是外连接声明的一部分</strong>,</li><li><strong>但<code>where</code>子句却不是</strong>。</li></ul><p>在我们的例子中,<code>ID</code>为<code>70557</code>的学生”<code>Snow</code>“所对应的<code>student</code>元组的情况就说明了这样的差异。假设我们把前述查询中的<code>on</code>子句谓词换成<code>where</code>子句,并使用<code>on</code>条件<code>true</code><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line">    <span class="keyword">from</span> student <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> takes</span><br><span class="line">    <span class="keyword">on</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">where</span> student.ID= takes.ID;</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select *</span><br><span class="line">    from student left outer join takes</span><br><span class="line">    on true</span><br><span class="line">    where student.ID= takes.ID;</span><br><span class="line">+-------+----------+------------+----------+-------+-----------+--------+----------+------+-------+</span><br><span class="line">| ID    | name     | dept_name  | tot_cred | ID    | course_id | sec_id | semester | year | grade |</span><br><span class="line">+-------+----------+------------+----------+-------+-----------+--------+----------+------+-------+</span><br><span class="line">| <span class="number">00128</span> | Zhang    | <span class="built_in">Comp</span>. Sci. | <span class="number">102</span>      | <span class="number">00128</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">00128</span> | Zhang    | <span class="built_in">Comp</span>. Sci. | <span class="number">102</span>      | <span class="number">00128</span> | CS-<span class="number">347</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A-    |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | <span class="number">12345</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | C     |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | <span class="number">12345</span> | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | <span class="number">12345</span> | CS-<span class="number">315</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | A     |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | <span class="number">12345</span> | CS-<span class="number">347</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">19991</span> | Brandt   | History    | <span class="number">80</span>       | <span class="number">19991</span> | HIS-<span class="number">351</span>   | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">23121</span> | Chavez   | Finance    | <span class="number">110</span>      | <span class="number">23121</span> | FIN-<span class="number">201</span>   | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | C+    |</span><br><span class="line">| <span class="number">44553</span> | Peltier  | Physics    | <span class="number">56</span>       | <span class="number">44553</span> | PHY-<span class="number">101</span>   | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | B-    |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       | <span class="number">45678</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | F     |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       | <span class="number">45678</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B+    |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       | <span class="number">45678</span> | CS-<span class="number">319</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">54321</span> | Williams | <span class="built_in">Comp</span>. Sci. | <span class="number">54</span>       | <span class="number">54321</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A-    |</span><br><span class="line">| <span class="number">54321</span> | Williams | <span class="built_in">Comp</span>. Sci. | <span class="number">54</span>       | <span class="number">54321</span> | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | B+    |</span><br><span class="line">| <span class="number">55739</span> | Sanchez  | Music      | <span class="number">38</span>       | <span class="number">55739</span> | MU-<span class="number">199</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | A-    |</span><br><span class="line">| <span class="number">76543</span> | Brown    | <span class="built_in">Comp</span>. Sci. | <span class="number">58</span>       | <span class="number">76543</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">76543</span> | Brown    | <span class="built_in">Comp</span>. Sci. | <span class="number">58</span>       | <span class="number">76543</span> | CS-<span class="number">319</span>    | <span class="number">2</span>      | Spring   | <span class="number">2010</span> | A     |</span><br><span class="line">| <span class="number">76653</span> | Aoi      | Elec. Eng. | <span class="number">60</span>       | <span class="number">76653</span> | EE-<span class="number">181</span>    | <span class="number">1</span>      | Spring   | <span class="number">2009</span> | C     |</span><br><span class="line">| <span class="number">98765</span> | Bourikas | Elec. Eng. | <span class="number">98</span>       | <span class="number">98765</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | C-    |</span><br><span class="line">| <span class="number">98765</span> | Bourikas | Elec. Eng. | <span class="number">98</span>       | <span class="number">98765</span> | CS-<span class="number">315</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">98988</span> | Tanaka   | Biology    | <span class="number">120</span>      | <span class="number">98988</span> | BIO-<span class="number">101</span>   | <span class="number">1</span>      | Summer   | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">98988</span> | Tanaka   | Biology    | <span class="number">120</span>      | <span class="number">98988</span> | BIO-<span class="number">301</span>   | <span class="number">1</span>      | Summer   | <span class="number">2010</span> | NULL  |</span><br><span class="line">+-------+----------+------------+----------+-------+-----------+--------+----------+------+-------+</span><br><span class="line"><span class="number">22</span> rows <span class="keyword">in</span> <span class="built_in">set</span> (<span class="number">0</span>.<span class="number">07</span> sec)</span><br></pre></td></tr></table></figure><br>早先的查询使用带<code>on</code>条件的左外连接,包括元组<code>(70557,Snow, Physics,0,null,null,null,null,null,null)</code>,<br>因为在<code>takes</code>中没有<code>ID=70557</code>的元组。然而在后面的查询中,<strong>每个元组都满足连接条件<code>true</code>,因此外连接不会产生出补上空值的元组</strong>。<br><strong>外连接实际上产生了两个关系的笛卡儿积</strong>。因为在<code>takes</code>中没有<code>ID=70557</code>的元组,每次当外连接中出现<code>name=&quot;Snow&quot;</code>的元组时, <code>student.ID</code>与<code>takes.ID</code>的取值必然是不同的,这样的元组会被<code>where</code>子句谓词排除掉。从而学生<code>Snow</code>不会出现在后面查询的结果中。<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select *</span><br><span class="line">    from student left outer join takes</span><br><span class="line">    on true;</span><br><span class="line">+-------+----------+------------+----------+-------+-----------+--------+----------+------+-------+</span><br><span class="line">| ID    | name     | dept_name  | tot_cred | ID    | course_id | sec_id | semester | year | grade |</span><br><span class="line">+-------+----------+------------+----------+-------+-----------+--------+----------+------+-------+</span><br><span class="line">| <span class="number">00128</span> | Zhang    | <span class="built_in">Comp</span>. Sci. | <span class="number">102</span>      | <span class="number">00128</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | <span class="number">00128</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">19991</span> | Brandt   | History    | <span class="number">80</span>       | <span class="number">00128</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">23121</span> | Chavez   | Finance    | <span class="number">110</span>      | <span class="number">00128</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">44553</span> | Peltier  | Physics    | <span class="number">56</span>       | <span class="number">00128</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       | <span class="number">00128</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">54321</span> | Williams | <span class="built_in">Comp</span>. Sci. | <span class="number">54</span>       | <span class="number">00128</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">55739</span> | Sanchez  | Music      | <span class="number">38</span>       | <span class="number">00128</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">70557</span> | Snow     | Physics    | <span class="number">0</span>        | <span class="number">00128</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">76543</span> | Brown    | <span class="built_in">Comp</span>. Sci. | <span class="number">58</span>       | <span class="number">00128</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">76653</span> | Aoi      | Elec. Eng. | <span class="number">60</span>       | <span class="number">00128</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">98765</span> | Bourikas | Elec. Eng. | <span class="number">98</span>       | <span class="number">00128</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">98988</span> | Tanaka   | Biology    | <span class="number">120</span>      | <span class="number">00128</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">00128</span> | Zhang    | <span class="built_in">Comp</span>. Sci. | <span class="number">102</span>      | <span class="number">00128</span> | CS-<span class="number">347</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A-    |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | <span class="number">00128</span> | CS-<span class="number">347</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A-    |</span><br><span class="line">| <span class="number">19991</span> | Brandt   | History    | <span class="number">80</span>       | <span class="number">00128</span> | CS-<span class="number">347</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A-    |</span><br><span class="line">| <span class="number">23121</span> | Chavez   | Finance    | <span class="number">110</span>      | <span class="number">00128</span> | CS-<span class="number">347</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A-    |</span><br><span class="line">| <span class="number">44553</span> | Peltier  | Physics    | <span class="number">56</span>       | <span class="number">00128</span> | CS-<span class="number">347</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A-    |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       | <span class="number">00128</span> | CS-<span class="number">347</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A-    |</span><br><span class="line">| <span class="number">54321</span> | Williams | <span class="built_in">Comp</span>. Sci. | <span class="number">54</span>       | <span class="number">00128</span> | CS-<span class="number">347</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A-    |</span><br><span class="line">| <span class="number">55739</span> | Sanchez  | Music      | <span class="number">38</span>       | <span class="number">00128</span> | CS-<span class="number">347</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A-    |</span><br><span class="line">| <span class="number">70557</span> | Snow     | Physics    | <span class="number">0</span>        | <span class="number">00128</span> | CS-<span class="number">347</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A-    |</span><br><span class="line">| <span class="number">76543</span> | Brown    | <span class="built_in">Comp</span>. Sci. | <span class="number">58</span>       | <span class="number">00128</span> | CS-<span class="number">347</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A-    |</span><br><span class="line">| <span class="number">76653</span> | Aoi      | Elec. Eng. | <span class="number">60</span>       | <span class="number">00128</span> | CS-<span class="number">347</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A-    |</span><br><span class="line">| <span class="number">98765</span> | Bourikas | Elec. Eng. | <span class="number">98</span>       | <span class="number">00128</span> | CS-<span class="number">347</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A-    |</span><br><span class="line">| <span class="number">98988</span> | Tanaka   | Biology    | <span class="number">120</span>      | <span class="number">00128</span> | CS-<span class="number">347</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A-    |</span><br><span class="line">| <span class="number">00128</span> | Zhang    | <span class="built_in">Comp</span>. Sci. | <span class="number">102</span>      | <span class="number">12345</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | C     |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | <span class="number">12345</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | C     |</span><br><span class="line">| <span class="number">19991</span> | Brandt   | History    | <span class="number">80</span>       | <span class="number">12345</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | C     |</span><br><span class="line">| <span class="number">23121</span> | Chavez   | Finance    | <span class="number">110</span>      | <span class="number">12345</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | C     |</span><br><span class="line">| <span class="number">44553</span> | Peltier  | Physics    | <span class="number">56</span>       | <span class="number">12345</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | C     |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       | <span class="number">12345</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | C     |</span><br><span class="line">| <span class="number">54321</span> | Williams | <span class="built_in">Comp</span>. Sci. | <span class="number">54</span>       | <span class="number">12345</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | C     |</span><br><span class="line">| <span class="number">55739</span> | Sanchez  | Music      | <span class="number">38</span>       | <span class="number">12345</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | C     |</span><br><span class="line">| <span class="number">70557</span> | Snow     | Physics    | <span class="number">0</span>        | <span class="number">12345</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | C     |</span><br><span class="line">| <span class="number">76543</span> | Brown    | <span class="built_in">Comp</span>. Sci. | <span class="number">58</span>       | <span class="number">12345</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | C     |</span><br><span class="line">| <span class="number">76653</span> | Aoi      | Elec. Eng. | <span class="number">60</span>       | <span class="number">12345</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | C     |</span><br><span class="line">| <span class="number">98765</span> | Bourikas | Elec. Eng. | <span class="number">98</span>       | <span class="number">12345</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | C     |</span><br><span class="line">| <span class="number">98988</span> | Tanaka   | Biology    | <span class="number">120</span>      | <span class="number">12345</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | C     |</span><br><span class="line">| <span class="number">00128</span> | Zhang    | <span class="built_in">Comp</span>. Sci. | <span class="number">102</span>      | <span class="number">12345</span> | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | <span class="number">12345</span> | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">19991</span> | Brandt   | History    | <span class="number">80</span>       | <span class="number">12345</span> | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">23121</span> | Chavez   | Finance    | <span class="number">110</span>      | <span class="number">12345</span> | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">44553</span> | Peltier  | Physics    | <span class="number">56</span>       | <span class="number">12345</span> | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       | <span class="number">12345</span> | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">54321</span> | Williams | <span class="built_in">Comp</span>. Sci. | <span class="number">54</span>       | <span class="number">12345</span> | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">55739</span> | Sanchez  | Music      | <span class="number">38</span>       | <span class="number">12345</span> | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">70557</span> | Snow     | Physics    | <span class="number">0</span>        | <span class="number">12345</span> | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">76543</span> | Brown    | <span class="built_in">Comp</span>. Sci. | <span class="number">58</span>       | <span class="number">12345</span> | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">76653</span> | Aoi      | Elec. Eng. | <span class="number">60</span>       | <span class="number">12345</span> | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">98765</span> | Bourikas | Elec. Eng. | <span class="number">98</span>       | <span class="number">12345</span> | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">98988</span> | Tanaka   | Biology    | <span class="number">120</span>      | <span class="number">12345</span> | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">00128</span> | Zhang    | <span class="built_in">Comp</span>. Sci. | <span class="number">102</span>      | <span class="number">12345</span> | CS-<span class="number">315</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | A     |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | <span class="number">12345</span> | CS-<span class="number">315</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | A     |</span><br><span class="line">| <span class="number">19991</span> | Brandt   | History    | <span class="number">80</span>       | <span class="number">12345</span> | CS-<span class="number">315</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | A     |</span><br><span class="line">| <span class="number">23121</span> | Chavez   | Finance    | <span class="number">110</span>      | <span class="number">12345</span> | CS-<span class="number">315</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | A     |</span><br><span class="line">| <span class="number">44553</span> | Peltier  | Physics    | <span class="number">56</span>       | <span class="number">12345</span> | CS-<span class="number">315</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | A     |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       | <span class="number">12345</span> | CS-<span class="number">315</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | A     |</span><br><span class="line">| <span class="number">54321</span> | Williams | <span class="built_in">Comp</span>. Sci. | <span class="number">54</span>       | <span class="number">12345</span> | CS-<span class="number">315</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | A     |</span><br><span class="line">| <span class="number">55739</span> | Sanchez  | Music      | <span class="number">38</span>       | <span class="number">12345</span> | CS-<span class="number">315</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | A     |</span><br><span class="line">| <span class="number">70557</span> | Snow     | Physics    | <span class="number">0</span>        | <span class="number">12345</span> | CS-<span class="number">315</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | A     |</span><br><span class="line">| <span class="number">76543</span> | Brown    | <span class="built_in">Comp</span>. Sci. | <span class="number">58</span>       | <span class="number">12345</span> | CS-<span class="number">315</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | A     |</span><br><span class="line">| <span class="number">76653</span> | Aoi      | Elec. Eng. | <span class="number">60</span>       | <span class="number">12345</span> | CS-<span class="number">315</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | A     |</span><br><span class="line">| <span class="number">98765</span> | Bourikas | Elec. Eng. | <span class="number">98</span>       | <span class="number">12345</span> | CS-<span class="number">315</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | A     |</span><br><span class="line">| <span class="number">98988</span> | Tanaka   | Biology    | <span class="number">120</span>      | <span class="number">12345</span> | CS-<span class="number">315</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | A     |</span><br><span class="line">| <span class="number">00128</span> | Zhang    | <span class="built_in">Comp</span>. Sci. | <span class="number">102</span>      | <span class="number">12345</span> | CS-<span class="number">347</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | <span class="number">12345</span> | CS-<span class="number">347</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">19991</span> | Brandt   | History    | <span class="number">80</span>       | <span class="number">12345</span> | CS-<span class="number">347</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">23121</span> | Chavez   | Finance    | <span class="number">110</span>      | <span class="number">12345</span> | CS-<span class="number">347</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">44553</span> | Peltier  | Physics    | <span class="number">56</span>       | <span class="number">12345</span> | CS-<span class="number">347</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       | <span class="number">12345</span> | CS-<span class="number">347</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">54321</span> | Williams | <span class="built_in">Comp</span>. Sci. | <span class="number">54</span>       | <span class="number">12345</span> | CS-<span class="number">347</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">55739</span> | Sanchez  | Music      | <span class="number">38</span>       | <span class="number">12345</span> | CS-<span class="number">347</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">70557</span> | Snow     | Physics    | <span class="number">0</span>        | <span class="number">12345</span> | CS-<span class="number">347</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">76543</span> | Brown    | <span class="built_in">Comp</span>. Sci. | <span class="number">58</span>       | <span class="number">12345</span> | CS-<span class="number">347</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">76653</span> | Aoi      | Elec. Eng. | <span class="number">60</span>       | <span class="number">12345</span> | CS-<span class="number">347</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">98765</span> | Bourikas | Elec. Eng. | <span class="number">98</span>       | <span class="number">12345</span> | CS-<span class="number">347</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">98988</span> | Tanaka   | Biology    | <span class="number">120</span>      | <span class="number">12345</span> | CS-<span class="number">347</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">00128</span> | Zhang    | <span class="built_in">Comp</span>. Sci. | <span class="number">102</span>      | <span class="number">19991</span> | HIS-<span class="number">351</span>   | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | <span class="number">19991</span> | HIS-<span class="number">351</span>   | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">19991</span> | Brandt   | History    | <span class="number">80</span>       | <span class="number">19991</span> | HIS-<span class="number">351</span>   | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">23121</span> | Chavez   | Finance    | <span class="number">110</span>      | <span class="number">19991</span> | HIS-<span class="number">351</span>   | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">44553</span> | Peltier  | Physics    | <span class="number">56</span>       | <span class="number">19991</span> | HIS-<span class="number">351</span>   | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       | <span class="number">19991</span> | HIS-<span class="number">351</span>   | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">54321</span> | Williams | <span class="built_in">Comp</span>. Sci. | <span class="number">54</span>       | <span class="number">19991</span> | HIS-<span class="number">351</span>   | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">55739</span> | Sanchez  | Music      | <span class="number">38</span>       | <span class="number">19991</span> | HIS-<span class="number">351</span>   | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">70557</span> | Snow     | Physics    | <span class="number">0</span>        | <span class="number">19991</span> | HIS-<span class="number">351</span>   | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">76543</span> | Brown    | <span class="built_in">Comp</span>. Sci. | <span class="number">58</span>       | <span class="number">19991</span> | HIS-<span class="number">351</span>   | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">76653</span> | Aoi      | Elec. Eng. | <span class="number">60</span>       | <span class="number">19991</span> | HIS-<span class="number">351</span>   | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">98765</span> | Bourikas | Elec. Eng. | <span class="number">98</span>       | <span class="number">19991</span> | HIS-<span class="number">351</span>   | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">98988</span> | Tanaka   | Biology    | <span class="number">120</span>      | <span class="number">19991</span> | HIS-<span class="number">351</span>   | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">00128</span> | Zhang    | <span class="built_in">Comp</span>. Sci. | <span class="number">102</span>      | <span class="number">23121</span> | FIN-<span class="number">201</span>   | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | C+    |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | <span class="number">23121</span> | FIN-<span class="number">201</span>   | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | C+    |</span><br><span class="line">| <span class="number">19991</span> | Brandt   | History    | <span class="number">80</span>       | <span class="number">23121</span> | FIN-<span class="number">201</span>   | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | C+    |</span><br><span class="line">| <span class="number">23121</span> | Chavez   | Finance    | <span class="number">110</span>      | <span class="number">23121</span> | FIN-<span class="number">201</span>   | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | C+    |</span><br><span class="line">| <span class="number">44553</span> | Peltier  | Physics    | <span class="number">56</span>       | <span class="number">23121</span> | FIN-<span class="number">201</span>   | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | C+    |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       | <span class="number">23121</span> | FIN-<span class="number">201</span>   | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | C+    |</span><br><span class="line">| <span class="number">54321</span> | Williams | <span class="built_in">Comp</span>. Sci. | <span class="number">54</span>       | <span class="number">23121</span> | FIN-<span class="number">201</span>   | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | C+    |</span><br><span class="line">| <span class="number">55739</span> | Sanchez  | Music      | <span class="number">38</span>       | <span class="number">23121</span> | FIN-<span class="number">201</span>   | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | C+    |</span><br><span class="line">| <span class="number">70557</span> | Snow     | Physics    | <span class="number">0</span>        | <span class="number">23121</span> | FIN-<span class="number">201</span>   | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | C+    |</span><br><span class="line">| <span class="number">76543</span> | Brown    | <span class="built_in">Comp</span>. Sci. | <span class="number">58</span>       | <span class="number">23121</span> | FIN-<span class="number">201</span>   | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | C+    |</span><br><span class="line">| <span class="number">76653</span> | Aoi      | Elec. Eng. | <span class="number">60</span>       | <span class="number">23121</span> | FIN-<span class="number">201</span>   | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | C+    |</span><br><span class="line">| <span class="number">98765</span> | Bourikas | Elec. Eng. | <span class="number">98</span>       | <span class="number">23121</span> | FIN-<span class="number">201</span>   | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | C+    |</span><br><span class="line">| <span class="number">98988</span> | Tanaka   | Biology    | <span class="number">120</span>      | <span class="number">23121</span> | FIN-<span class="number">201</span>   | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | C+    |</span><br><span class="line">| <span class="number">00128</span> | Zhang    | <span class="built_in">Comp</span>. Sci. | <span class="number">102</span>      | <span class="number">44553</span> | PHY-<span class="number">101</span>   | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | B-    |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | <span class="number">44553</span> | PHY-<span class="number">101</span>   | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | B-    |</span><br><span class="line">| <span class="number">19991</span> | Brandt   | History    | <span class="number">80</span>       | <span class="number">44553</span> | PHY-<span class="number">101</span>   | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | B-    |</span><br><span class="line">| <span class="number">23121</span> | Chavez   | Finance    | <span class="number">110</span>      | <span class="number">44553</span> | PHY-<span class="number">101</span>   | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | B-    |</span><br><span class="line">| <span class="number">44553</span> | Peltier  | Physics    | <span class="number">56</span>       | <span class="number">44553</span> | PHY-<span class="number">101</span>   | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | B-    |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       | <span class="number">44553</span> | PHY-<span class="number">101</span>   | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | B-    |</span><br><span class="line">| <span class="number">54321</span> | Williams | <span class="built_in">Comp</span>. Sci. | <span class="number">54</span>       | <span class="number">44553</span> | PHY-<span class="number">101</span>   | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | B-    |</span><br><span class="line">| <span class="number">55739</span> | Sanchez  | Music      | <span class="number">38</span>       | <span class="number">44553</span> | PHY-<span class="number">101</span>   | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | B-    |</span><br><span class="line">| <span class="number">70557</span> | Snow     | Physics    | <span class="number">0</span>        | <span class="number">44553</span> | PHY-<span class="number">101</span>   | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | B-    |</span><br><span class="line">| <span class="number">76543</span> | Brown    | <span class="built_in">Comp</span>. Sci. | <span class="number">58</span>       | <span class="number">44553</span> | PHY-<span class="number">101</span>   | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | B-    |</span><br><span class="line">| <span class="number">76653</span> | Aoi      | Elec. Eng. | <span class="number">60</span>       | <span class="number">44553</span> | PHY-<span class="number">101</span>   | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | B-    |</span><br><span class="line">| <span class="number">98765</span> | Bourikas | Elec. Eng. | <span class="number">98</span>       | <span class="number">44553</span> | PHY-<span class="number">101</span>   | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | B-    |</span><br><span class="line">| <span class="number">98988</span> | Tanaka   | Biology    | <span class="number">120</span>      | <span class="number">44553</span> | PHY-<span class="number">101</span>   | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | B-    |</span><br><span class="line">| <span class="number">00128</span> | Zhang    | <span class="built_in">Comp</span>. Sci. | <span class="number">102</span>      | <span class="number">45678</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | F     |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | <span class="number">45678</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | F     |</span><br><span class="line">| <span class="number">19991</span> | Brandt   | History    | <span class="number">80</span>       | <span class="number">45678</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | F     |</span><br><span class="line">| <span class="number">23121</span> | Chavez   | Finance    | <span class="number">110</span>      | <span class="number">45678</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | F     |</span><br><span class="line">| <span class="number">44553</span> | Peltier  | Physics    | <span class="number">56</span>       | <span class="number">45678</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | F     |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       | <span class="number">45678</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | F     |</span><br><span class="line">| <span class="number">54321</span> | Williams | <span class="built_in">Comp</span>. Sci. | <span class="number">54</span>       | <span class="number">45678</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | F     |</span><br><span class="line">| <span class="number">55739</span> | Sanchez  | Music      | <span class="number">38</span>       | <span class="number">45678</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | F     |</span><br><span class="line">| <span class="number">70557</span> | Snow     | Physics    | <span class="number">0</span>        | <span class="number">45678</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | F     |</span><br><span class="line">| <span class="number">76543</span> | Brown    | <span class="built_in">Comp</span>. Sci. | <span class="number">58</span>       | <span class="number">45678</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | F     |</span><br><span class="line">| <span class="number">76653</span> | Aoi      | Elec. Eng. | <span class="number">60</span>       | <span class="number">45678</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | F     |</span><br><span class="line">| <span class="number">98765</span> | Bourikas | Elec. Eng. | <span class="number">98</span>       | <span class="number">45678</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | F     |</span><br><span class="line">| <span class="number">98988</span> | Tanaka   | Biology    | <span class="number">120</span>      | <span class="number">45678</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | F     |</span><br><span class="line">| <span class="number">00128</span> | Zhang    | <span class="built_in">Comp</span>. Sci. | <span class="number">102</span>      | <span class="number">45678</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B+    |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | <span class="number">45678</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B+    |</span><br><span class="line">| <span class="number">19991</span> | Brandt   | History    | <span class="number">80</span>       | <span class="number">45678</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B+    |</span><br><span class="line">| <span class="number">23121</span> | Chavez   | Finance    | <span class="number">110</span>      | <span class="number">45678</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B+    |</span><br><span class="line">| <span class="number">44553</span> | Peltier  | Physics    | <span class="number">56</span>       | <span class="number">45678</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B+    |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       | <span class="number">45678</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B+    |</span><br><span class="line">| <span class="number">54321</span> | Williams | <span class="built_in">Comp</span>. Sci. | <span class="number">54</span>       | <span class="number">45678</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B+    |</span><br><span class="line">| <span class="number">55739</span> | Sanchez  | Music      | <span class="number">38</span>       | <span class="number">45678</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B+    |</span><br><span class="line">| <span class="number">70557</span> | Snow     | Physics    | <span class="number">0</span>        | <span class="number">45678</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B+    |</span><br><span class="line">| <span class="number">76543</span> | Brown    | <span class="built_in">Comp</span>. Sci. | <span class="number">58</span>       | <span class="number">45678</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B+    |</span><br><span class="line">| <span class="number">76653</span> | Aoi      | Elec. Eng. | <span class="number">60</span>       | <span class="number">45678</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B+    |</span><br><span class="line">| <span class="number">98765</span> | Bourikas | Elec. Eng. | <span class="number">98</span>       | <span class="number">45678</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B+    |</span><br><span class="line">| <span class="number">98988</span> | Tanaka   | Biology    | <span class="number">120</span>      | <span class="number">45678</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B+    |</span><br><span class="line">| <span class="number">00128</span> | Zhang    | <span class="built_in">Comp</span>. Sci. | <span class="number">102</span>      | <span class="number">45678</span> | CS-<span class="number">319</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | <span class="number">45678</span> | CS-<span class="number">319</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">19991</span> | Brandt   | History    | <span class="number">80</span>       | <span class="number">45678</span> | CS-<span class="number">319</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">23121</span> | Chavez   | Finance    | <span class="number">110</span>      | <span class="number">45678</span> | CS-<span class="number">319</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">44553</span> | Peltier  | Physics    | <span class="number">56</span>       | <span class="number">45678</span> | CS-<span class="number">319</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       | <span class="number">45678</span> | CS-<span class="number">319</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">54321</span> | Williams | <span class="built_in">Comp</span>. Sci. | <span class="number">54</span>       | <span class="number">45678</span> | CS-<span class="number">319</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">55739</span> | Sanchez  | Music      | <span class="number">38</span>       | <span class="number">45678</span> | CS-<span class="number">319</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">70557</span> | Snow     | Physics    | <span class="number">0</span>        | <span class="number">45678</span> | CS-<span class="number">319</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">76543</span> | Brown    | <span class="built_in">Comp</span>. Sci. | <span class="number">58</span>       | <span class="number">45678</span> | CS-<span class="number">319</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">76653</span> | Aoi      | Elec. Eng. | <span class="number">60</span>       | <span class="number">45678</span> | CS-<span class="number">319</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">98765</span> | Bourikas | Elec. Eng. | <span class="number">98</span>       | <span class="number">45678</span> | CS-<span class="number">319</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">98988</span> | Tanaka   | Biology    | <span class="number">120</span>      | <span class="number">45678</span> | CS-<span class="number">319</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">00128</span> | Zhang    | <span class="built_in">Comp</span>. Sci. | <span class="number">102</span>      | <span class="number">54321</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A-    |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | <span class="number">54321</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A-    |</span><br><span class="line">| <span class="number">19991</span> | Brandt   | History    | <span class="number">80</span>       | <span class="number">54321</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A-    |</span><br><span class="line">| <span class="number">23121</span> | Chavez   | Finance    | <span class="number">110</span>      | <span class="number">54321</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A-    |</span><br><span class="line">| <span class="number">44553</span> | Peltier  | Physics    | <span class="number">56</span>       | <span class="number">54321</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A-    |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       | <span class="number">54321</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A-    |</span><br><span class="line">| <span class="number">54321</span> | Williams | <span class="built_in">Comp</span>. Sci. | <span class="number">54</span>       | <span class="number">54321</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A-    |</span><br><span class="line">| <span class="number">55739</span> | Sanchez  | Music      | <span class="number">38</span>       | <span class="number">54321</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A-    |</span><br><span class="line">| <span class="number">70557</span> | Snow     | Physics    | <span class="number">0</span>        | <span class="number">54321</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A-    |</span><br><span class="line">| <span class="number">76543</span> | Brown    | <span class="built_in">Comp</span>. Sci. | <span class="number">58</span>       | <span class="number">54321</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A-    |</span><br><span class="line">| <span class="number">76653</span> | Aoi      | Elec. Eng. | <span class="number">60</span>       | <span class="number">54321</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A-    |</span><br><span class="line">| <span class="number">98765</span> | Bourikas | Elec. Eng. | <span class="number">98</span>       | <span class="number">54321</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A-    |</span><br><span class="line">| <span class="number">98988</span> | Tanaka   | Biology    | <span class="number">120</span>      | <span class="number">54321</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A-    |</span><br><span class="line">| <span class="number">00128</span> | Zhang    | <span class="built_in">Comp</span>. Sci. | <span class="number">102</span>      | <span class="number">54321</span> | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | B+    |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | <span class="number">54321</span> | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | B+    |</span><br><span class="line">| <span class="number">19991</span> | Brandt   | History    | <span class="number">80</span>       | <span class="number">54321</span> | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | B+    |</span><br><span class="line">| <span class="number">23121</span> | Chavez   | Finance    | <span class="number">110</span>      | <span class="number">54321</span> | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | B+    |</span><br><span class="line">| <span class="number">44553</span> | Peltier  | Physics    | <span class="number">56</span>       | <span class="number">54321</span> | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | B+    |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       | <span class="number">54321</span> | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | B+    |</span><br><span class="line">| <span class="number">54321</span> | Williams | <span class="built_in">Comp</span>. Sci. | <span class="number">54</span>       | <span class="number">54321</span> | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | B+    |</span><br><span class="line">| <span class="number">55739</span> | Sanchez  | Music      | <span class="number">38</span>       | <span class="number">54321</span> | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | B+    |</span><br><span class="line">| <span class="number">70557</span> | Snow     | Physics    | <span class="number">0</span>        | <span class="number">54321</span> | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | B+    |</span><br><span class="line">| <span class="number">76543</span> | Brown    | <span class="built_in">Comp</span>. Sci. | <span class="number">58</span>       | <span class="number">54321</span> | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | B+    |</span><br><span class="line">| <span class="number">76653</span> | Aoi      | Elec. Eng. | <span class="number">60</span>       | <span class="number">54321</span> | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | B+    |</span><br><span class="line">| <span class="number">98765</span> | Bourikas | Elec. Eng. | <span class="number">98</span>       | <span class="number">54321</span> | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | B+    |</span><br><span class="line">| <span class="number">98988</span> | Tanaka   | Biology    | <span class="number">120</span>      | <span class="number">54321</span> | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | B+    |</span><br><span class="line">| <span class="number">00128</span> | Zhang    | <span class="built_in">Comp</span>. Sci. | <span class="number">102</span>      | <span class="number">55739</span> | MU-<span class="number">199</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | A-    |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | <span class="number">55739</span> | MU-<span class="number">199</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | A-    |</span><br><span class="line">| <span class="number">19991</span> | Brandt   | History    | <span class="number">80</span>       | <span class="number">55739</span> | MU-<span class="number">199</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | A-    |</span><br><span class="line">| <span class="number">23121</span> | Chavez   | Finance    | <span class="number">110</span>      | <span class="number">55739</span> | MU-<span class="number">199</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | A-    |</span><br><span class="line">| <span class="number">44553</span> | Peltier  | Physics    | <span class="number">56</span>       | <span class="number">55739</span> | MU-<span class="number">199</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | A-    |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       | <span class="number">55739</span> | MU-<span class="number">199</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | A-    |</span><br><span class="line">| <span class="number">54321</span> | Williams | <span class="built_in">Comp</span>. Sci. | <span class="number">54</span>       | <span class="number">55739</span> | MU-<span class="number">199</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | A-    |</span><br><span class="line">| <span class="number">55739</span> | Sanchez  | Music      | <span class="number">38</span>       | <span class="number">55739</span> | MU-<span class="number">199</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | A-    |</span><br><span class="line">| <span class="number">70557</span> | Snow     | Physics    | <span class="number">0</span>        | <span class="number">55739</span> | MU-<span class="number">199</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | A-    |</span><br><span class="line">| <span class="number">76543</span> | Brown    | <span class="built_in">Comp</span>. Sci. | <span class="number">58</span>       | <span class="number">55739</span> | MU-<span class="number">199</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | A-    |</span><br><span class="line">| <span class="number">76653</span> | Aoi      | Elec. Eng. | <span class="number">60</span>       | <span class="number">55739</span> | MU-<span class="number">199</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | A-    |</span><br><span class="line">| <span class="number">98765</span> | Bourikas | Elec. Eng. | <span class="number">98</span>       | <span class="number">55739</span> | MU-<span class="number">199</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | A-    |</span><br><span class="line">| <span class="number">98988</span> | Tanaka   | Biology    | <span class="number">120</span>      | <span class="number">55739</span> | MU-<span class="number">199</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | A-    |</span><br><span class="line">| <span class="number">00128</span> | Zhang    | <span class="built_in">Comp</span>. Sci. | <span class="number">102</span>      | <span class="number">76543</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | <span class="number">76543</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">19991</span> | Brandt   | History    | <span class="number">80</span>       | <span class="number">76543</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">23121</span> | Chavez   | Finance    | <span class="number">110</span>      | <span class="number">76543</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">44553</span> | Peltier  | Physics    | <span class="number">56</span>       | <span class="number">76543</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       | <span class="number">76543</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">54321</span> | Williams | <span class="built_in">Comp</span>. Sci. | <span class="number">54</span>       | <span class="number">76543</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">55739</span> | Sanchez  | Music      | <span class="number">38</span>       | <span class="number">76543</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">70557</span> | Snow     | Physics    | <span class="number">0</span>        | <span class="number">76543</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">76543</span> | Brown    | <span class="built_in">Comp</span>. Sci. | <span class="number">58</span>       | <span class="number">76543</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">76653</span> | Aoi      | Elec. Eng. | <span class="number">60</span>       | <span class="number">76543</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">98765</span> | Bourikas | Elec. Eng. | <span class="number">98</span>       | <span class="number">76543</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">98988</span> | Tanaka   | Biology    | <span class="number">120</span>      | <span class="number">76543</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">00128</span> | Zhang    | <span class="built_in">Comp</span>. Sci. | <span class="number">102</span>      | <span class="number">76543</span> | CS-<span class="number">319</span>    | <span class="number">2</span>      | Spring   | <span class="number">2010</span> | A     |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | <span class="number">76543</span> | CS-<span class="number">319</span>    | <span class="number">2</span>      | Spring   | <span class="number">2010</span> | A     |</span><br><span class="line">| <span class="number">19991</span> | Brandt   | History    | <span class="number">80</span>       | <span class="number">76543</span> | CS-<span class="number">319</span>    | <span class="number">2</span>      | Spring   | <span class="number">2010</span> | A     |</span><br><span class="line">| <span class="number">23121</span> | Chavez   | Finance    | <span class="number">110</span>      | <span class="number">76543</span> | CS-<span class="number">319</span>    | <span class="number">2</span>      | Spring   | <span class="number">2010</span> | A     |</span><br><span class="line">| <span class="number">44553</span> | Peltier  | Physics    | <span class="number">56</span>       | <span class="number">76543</span> | CS-<span class="number">319</span>    | <span class="number">2</span>      | Spring   | <span class="number">2010</span> | A     |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       | <span class="number">76543</span> | CS-<span class="number">319</span>    | <span class="number">2</span>      | Spring   | <span class="number">2010</span> | A     |</span><br><span class="line">| <span class="number">54321</span> | Williams | <span class="built_in">Comp</span>. Sci. | <span class="number">54</span>       | <span class="number">76543</span> | CS-<span class="number">319</span>    | <span class="number">2</span>      | Spring   | <span class="number">2010</span> | A     |</span><br><span class="line">| <span class="number">55739</span> | Sanchez  | Music      | <span class="number">38</span>       | <span class="number">76543</span> | CS-<span class="number">319</span>    | <span class="number">2</span>      | Spring   | <span class="number">2010</span> | A     |</span><br><span class="line">| <span class="number">70557</span> | Snow     | Physics    | <span class="number">0</span>        | <span class="number">76543</span> | CS-<span class="number">319</span>    | <span class="number">2</span>      | Spring   | <span class="number">2010</span> | A     |</span><br><span class="line">| <span class="number">76543</span> | Brown    | <span class="built_in">Comp</span>. Sci. | <span class="number">58</span>       | <span class="number">76543</span> | CS-<span class="number">319</span>    | <span class="number">2</span>      | Spring   | <span class="number">2010</span> | A     |</span><br><span class="line">| <span class="number">76653</span> | Aoi      | Elec. Eng. | <span class="number">60</span>       | <span class="number">76543</span> | CS-<span class="number">319</span>    | <span class="number">2</span>      | Spring   | <span class="number">2010</span> | A     |</span><br><span class="line">| <span class="number">98765</span> | Bourikas | Elec. Eng. | <span class="number">98</span>       | <span class="number">76543</span> | CS-<span class="number">319</span>    | <span class="number">2</span>      | Spring   | <span class="number">2010</span> | A     |</span><br><span class="line">| <span class="number">98988</span> | Tanaka   | Biology    | <span class="number">120</span>      | <span class="number">76543</span> | CS-<span class="number">319</span>    | <span class="number">2</span>      | Spring   | <span class="number">2010</span> | A     |</span><br><span class="line">| <span class="number">00128</span> | Zhang    | <span class="built_in">Comp</span>. Sci. | <span class="number">102</span>      | <span class="number">76653</span> | EE-<span class="number">181</span>    | <span class="number">1</span>      | Spring   | <span class="number">2009</span> | C     |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | <span class="number">76653</span> | EE-<span class="number">181</span>    | <span class="number">1</span>      | Spring   | <span class="number">2009</span> | C     |</span><br><span class="line">| <span class="number">19991</span> | Brandt   | History    | <span class="number">80</span>       | <span class="number">76653</span> | EE-<span class="number">181</span>    | <span class="number">1</span>      | Spring   | <span class="number">2009</span> | C     |</span><br><span class="line">| <span class="number">23121</span> | Chavez   | Finance    | <span class="number">110</span>      | <span class="number">76653</span> | EE-<span class="number">181</span>    | <span class="number">1</span>      | Spring   | <span class="number">2009</span> | C     |</span><br><span class="line">| <span class="number">44553</span> | Peltier  | Physics    | <span class="number">56</span>       | <span class="number">76653</span> | EE-<span class="number">181</span>    | <span class="number">1</span>      | Spring   | <span class="number">2009</span> | C     |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       | <span class="number">76653</span> | EE-<span class="number">181</span>    | <span class="number">1</span>      | Spring   | <span class="number">2009</span> | C     |</span><br><span class="line">| <span class="number">54321</span> | Williams | <span class="built_in">Comp</span>. Sci. | <span class="number">54</span>       | <span class="number">76653</span> | EE-<span class="number">181</span>    | <span class="number">1</span>      | Spring   | <span class="number">2009</span> | C     |</span><br><span class="line">| <span class="number">55739</span> | Sanchez  | Music      | <span class="number">38</span>       | <span class="number">76653</span> | EE-<span class="number">181</span>    | <span class="number">1</span>      | Spring   | <span class="number">2009</span> | C     |</span><br><span class="line">| <span class="number">70557</span> | Snow     | Physics    | <span class="number">0</span>        | <span class="number">76653</span> | EE-<span class="number">181</span>    | <span class="number">1</span>      | Spring   | <span class="number">2009</span> | C     |</span><br><span class="line">| <span class="number">76543</span> | Brown    | <span class="built_in">Comp</span>. Sci. | <span class="number">58</span>       | <span class="number">76653</span> | EE-<span class="number">181</span>    | <span class="number">1</span>      | Spring   | <span class="number">2009</span> | C     |</span><br><span class="line">| <span class="number">76653</span> | Aoi      | Elec. Eng. | <span class="number">60</span>       | <span class="number">76653</span> | EE-<span class="number">181</span>    | <span class="number">1</span>      | Spring   | <span class="number">2009</span> | C     |</span><br><span class="line">| <span class="number">98765</span> | Bourikas | Elec. Eng. | <span class="number">98</span>       | <span class="number">76653</span> | EE-<span class="number">181</span>    | <span class="number">1</span>      | Spring   | <span class="number">2009</span> | C     |</span><br><span class="line">| <span class="number">98988</span> | Tanaka   | Biology    | <span class="number">120</span>      | <span class="number">76653</span> | EE-<span class="number">181</span>    | <span class="number">1</span>      | Spring   | <span class="number">2009</span> | C     |</span><br><span class="line">| <span class="number">00128</span> | Zhang    | <span class="built_in">Comp</span>. Sci. | <span class="number">102</span>      | <span class="number">98765</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | C-    |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | <span class="number">98765</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | C-    |</span><br><span class="line">| <span class="number">19991</span> | Brandt   | History    | <span class="number">80</span>       | <span class="number">98765</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | C-    |</span><br><span class="line">| <span class="number">23121</span> | Chavez   | Finance    | <span class="number">110</span>      | <span class="number">98765</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | C-    |</span><br><span class="line">| <span class="number">44553</span> | Peltier  | Physics    | <span class="number">56</span>       | <span class="number">98765</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | C-    |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       | <span class="number">98765</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | C-    |</span><br><span class="line">| <span class="number">54321</span> | Williams | <span class="built_in">Comp</span>. Sci. | <span class="number">54</span>       | <span class="number">98765</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | C-    |</span><br><span class="line">| <span class="number">55739</span> | Sanchez  | Music      | <span class="number">38</span>       | <span class="number">98765</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | C-    |</span><br><span class="line">| <span class="number">70557</span> | Snow     | Physics    | <span class="number">0</span>        | <span class="number">98765</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | C-    |</span><br><span class="line">| <span class="number">76543</span> | Brown    | <span class="built_in">Comp</span>. Sci. | <span class="number">58</span>       | <span class="number">98765</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | C-    |</span><br><span class="line">| <span class="number">76653</span> | Aoi      | Elec. Eng. | <span class="number">60</span>       | <span class="number">98765</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | C-    |</span><br><span class="line">| <span class="number">98765</span> | Bourikas | Elec. Eng. | <span class="number">98</span>       | <span class="number">98765</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | C-    |</span><br><span class="line">| <span class="number">98988</span> | Tanaka   | Biology    | <span class="number">120</span>      | <span class="number">98765</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | C-    |</span><br><span class="line">| <span class="number">00128</span> | Zhang    | <span class="built_in">Comp</span>. Sci. | <span class="number">102</span>      | <span class="number">98765</span> | CS-<span class="number">315</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | <span class="number">98765</span> | CS-<span class="number">315</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">19991</span> | Brandt   | History    | <span class="number">80</span>       | <span class="number">98765</span> | CS-<span class="number">315</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">23121</span> | Chavez   | Finance    | <span class="number">110</span>      | <span class="number">98765</span> | CS-<span class="number">315</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">44553</span> | Peltier  | Physics    | <span class="number">56</span>       | <span class="number">98765</span> | CS-<span class="number">315</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       | <span class="number">98765</span> | CS-<span class="number">315</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">54321</span> | Williams | <span class="built_in">Comp</span>. Sci. | <span class="number">54</span>       | <span class="number">98765</span> | CS-<span class="number">315</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">55739</span> | Sanchez  | Music      | <span class="number">38</span>       | <span class="number">98765</span> | CS-<span class="number">315</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">70557</span> | Snow     | Physics    | <span class="number">0</span>        | <span class="number">98765</span> | CS-<span class="number">315</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">76543</span> | Brown    | <span class="built_in">Comp</span>. Sci. | <span class="number">58</span>       | <span class="number">98765</span> | CS-<span class="number">315</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">76653</span> | Aoi      | Elec. Eng. | <span class="number">60</span>       | <span class="number">98765</span> | CS-<span class="number">315</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">98765</span> | Bourikas | Elec. Eng. | <span class="number">98</span>       | <span class="number">98765</span> | CS-<span class="number">315</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">98988</span> | Tanaka   | Biology    | <span class="number">120</span>      | <span class="number">98765</span> | CS-<span class="number">315</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">00128</span> | Zhang    | <span class="built_in">Comp</span>. Sci. | <span class="number">102</span>      | <span class="number">98988</span> | BIO-<span class="number">101</span>   | <span class="number">1</span>      | Summer   | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | <span class="number">98988</span> | BIO-<span class="number">101</span>   | <span class="number">1</span>      | Summer   | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">19991</span> | Brandt   | History    | <span class="number">80</span>       | <span class="number">98988</span> | BIO-<span class="number">101</span>   | <span class="number">1</span>      | Summer   | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">23121</span> | Chavez   | Finance    | <span class="number">110</span>      | <span class="number">98988</span> | BIO-<span class="number">101</span>   | <span class="number">1</span>      | Summer   | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">44553</span> | Peltier  | Physics    | <span class="number">56</span>       | <span class="number">98988</span> | BIO-<span class="number">101</span>   | <span class="number">1</span>      | Summer   | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       | <span class="number">98988</span> | BIO-<span class="number">101</span>   | <span class="number">1</span>      | Summer   | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">54321</span> | Williams | <span class="built_in">Comp</span>. Sci. | <span class="number">54</span>       | <span class="number">98988</span> | BIO-<span class="number">101</span>   | <span class="number">1</span>      | Summer   | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">55739</span> | Sanchez  | Music      | <span class="number">38</span>       | <span class="number">98988</span> | BIO-<span class="number">101</span>   | <span class="number">1</span>      | Summer   | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">70557</span> | Snow     | Physics    | <span class="number">0</span>        | <span class="number">98988</span> | BIO-<span class="number">101</span>   | <span class="number">1</span>      | Summer   | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">76543</span> | Brown    | <span class="built_in">Comp</span>. Sci. | <span class="number">58</span>       | <span class="number">98988</span> | BIO-<span class="number">101</span>   | <span class="number">1</span>      | Summer   | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">76653</span> | Aoi      | Elec. Eng. | <span class="number">60</span>       | <span class="number">98988</span> | BIO-<span class="number">101</span>   | <span class="number">1</span>      | Summer   | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">98765</span> | Bourikas | Elec. Eng. | <span class="number">98</span>       | <span class="number">98988</span> | BIO-<span class="number">101</span>   | <span class="number">1</span>      | Summer   | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">98988</span> | Tanaka   | Biology    | <span class="number">120</span>      | <span class="number">98988</span> | BIO-<span class="number">101</span>   | <span class="number">1</span>      | Summer   | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">00128</span> | Zhang    | <span class="built_in">Comp</span>. Sci. | <span class="number">102</span>      | <span class="number">98988</span> | BIO-<span class="number">301</span>   | <span class="number">1</span>      | Summer   | <span class="number">2010</span> | NULL  |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | <span class="number">98988</span> | BIO-<span class="number">301</span>   | <span class="number">1</span>      | Summer   | <span class="number">2010</span> | NULL  |</span><br><span class="line">| <span class="number">19991</span> | Brandt   | History    | <span class="number">80</span>       | <span class="number">98988</span> | BIO-<span class="number">301</span>   | <span class="number">1</span>      | Summer   | <span class="number">2010</span> | NULL  |</span><br><span class="line">| <span class="number">23121</span> | Chavez   | Finance    | <span class="number">110</span>      | <span class="number">98988</span> | BIO-<span class="number">301</span>   | <span class="number">1</span>      | Summer   | <span class="number">2010</span> | NULL  |</span><br><span class="line">| <span class="number">44553</span> | Peltier  | Physics    | <span class="number">56</span>       | <span class="number">98988</span> | BIO-<span class="number">301</span>   | <span class="number">1</span>      | Summer   | <span class="number">2010</span> | NULL  |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       | <span class="number">98988</span> | BIO-<span class="number">301</span>   | <span class="number">1</span>      | Summer   | <span class="number">2010</span> | NULL  |</span><br><span class="line">| <span class="number">54321</span> | Williams | <span class="built_in">Comp</span>. Sci. | <span class="number">54</span>       | <span class="number">98988</span> | BIO-<span class="number">301</span>   | <span class="number">1</span>      | Summer   | <span class="number">2010</span> | NULL  |</span><br><span class="line">| <span class="number">55739</span> | Sanchez  | Music      | <span class="number">38</span>       | <span class="number">98988</span> | BIO-<span class="number">301</span>   | <span class="number">1</span>      | Summer   | <span class="number">2010</span> | NULL  |</span><br><span class="line">| <span class="number">70557</span> | Snow     | Physics    | <span class="number">0</span>        | <span class="number">98988</span> | BIO-<span class="number">301</span>   | <span class="number">1</span>      | Summer   | <span class="number">2010</span> | NULL  |</span><br><span class="line">| <span class="number">76543</span> | Brown    | <span class="built_in">Comp</span>. Sci. | <span class="number">58</span>       | <span class="number">98988</span> | BIO-<span class="number">301</span>   | <span class="number">1</span>      | Summer   | <span class="number">2010</span> | NULL  |</span><br><span class="line">| <span class="number">76653</span> | Aoi      | Elec. Eng. | <span class="number">60</span>       | <span class="number">98988</span> | BIO-<span class="number">301</span>   | <span class="number">1</span>      | Summer   | <span class="number">2010</span> | NULL  |</span><br><span class="line">| <span class="number">98765</span> | Bourikas | Elec. Eng. | <span class="number">98</span>       | <span class="number">98988</span> | BIO-<span class="number">301</span>   | <span class="number">1</span>      | Summer   | <span class="number">2010</span> | NULL  |</span><br><span class="line">| <span class="number">98988</span> | Tanaka   | Biology    | <span class="number">120</span>      | <span class="number">98988</span> | BIO-<span class="number">301</span>   | <span class="number">1</span>      | Summer   | <span class="number">2010</span> | NULL  |</span><br><span class="line">+-------+----------+------------+----------+-------+-----------+--------+----------+------+-------+</span><br><span class="line"><span class="number">286</span> rows <span class="keyword">in</span> <span class="built_in">set</span> (<span class="number">0</span>.<span class="number">37</span> sec)</span><br></pre></td></tr></table></figure></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>左外连接保留左边的元组,右边补<code>null</code></li><li>右外连接保留右边的元组,左边补<code>null</code></li><li>交换两个表的顺序后,左外连接可以转成右外连接,右外连接可以可以转成左外连接.</li><li>不满足外连接的条件时补<code>null</code></li></ul><!--SSTStop--><blockquote><h1 id="使用的表"><a href="#使用的表" class="headerlink" title="使用的表"></a>使用的表</h1><p>本节的例子涉及<code>student</code>和<code>takes</code>两个关系,如下所示:</p><h2 id="student关系内容"><a href="#student关系内容" class="headerlink" title="student关系内容"></a>student关系内容</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from student;</span><br><span class="line">+-------+----------+------------+----------+</span><br><span class="line">| ID    | name     | dept_ame  | tot_cred |</span><br><span class="line">+-------+----------+--------n----+----------+</span><br><span class="line">| <span class="number">00128</span> | Zhang    | <span class="built_in">Comp</span>. Sci. | <span class="number">102</span>      |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       |</span><br><span class="line">| <span class="number">19991</span> | Brandt   | History    | <span class="number">80</span>       |</span><br><span class="line">| <span class="number">23121</span> | Chavez   | Finance    | <span class="number">110</span>      |</span><br><span class="line">| <span class="number">44553</span> | Peltier  | Physics    | <span class="number">56</span>       |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       |</span><br><span class="line">| <span class="number">54321</span> | Williams | <span class="built_in">Comp</span>. Sci. | <span class="number">54</span>       |</span><br><span class="line">| <span class="number">55739</span> | Sanchez  | Music      | <span class="number">38</span>       |</span><br><span class="line">| <span class="number">70557</span> | Snow     | Physics    | <span class="number">0</span>        |</span><br><span class="line">| <span class="number">76543</span> | Brown    | <span class="built_in">Comp</span>. Sci. | <span class="number">58</span>       |</span><br><span class="line">| <span class="number">76653</span> | Aoi      | Elec. Eng. | <span class="number">60</span>       |</span><br><span class="line">| <span class="number">98765</span> | Bourikas | Elec. Eng. | <span class="number">98</span>       |</span><br><span class="line">| <span class="number">98988</span> | Tanaka   | Biology    | <span class="number">120</span>      |</span><br><span class="line">+-------+----------+------------+----------+</span><br><span class="line"><span class="number">13</span> rows <span class="keyword">in</span> <span class="built_in">set</span> (<span class="number">0</span>.<span class="number">03</span> sec)</span><br></pre></td></tr></table></figure><h2 id="takes关系内容"><a href="#takes关系内容" class="headerlink" title="takes关系内容"></a>takes关系内容</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from takes;</span><br><span class="line">+-------+-----------+--------+----------+------+-------+</span><br><span class="line">| ID    | course_id | sec_id | semester | year | grade |</span><br><span class="line">+-------+-----------+--------+----------+------+-------+</span><br><span class="line">| <span class="number">00128</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">00128</span> | CS-<span class="number">347</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A-    |</span><br><span class="line">| <span class="number">12345</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | C     |</span><br><span class="line">| <span class="number">12345</span> | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">12345</span> | CS-<span class="number">315</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | A     |</span><br><span class="line">| <span class="number">12345</span> | CS-<span class="number">347</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">19991</span> | HIS-<span class="number">351</span>   | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">23121</span> | FIN-<span class="number">201</span>   | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | C+    |</span><br><span class="line">| <span class="number">44553</span> | PHY-<span class="number">101</span>   | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | B-    |</span><br><span class="line">| <span class="number">45678</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | F     |</span><br><span class="line">| <span class="number">45678</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B+    |</span><br><span class="line">| <span class="number">45678</span> | CS-<span class="number">319</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">54321</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A-    |</span><br><span class="line">| <span class="number">54321</span> | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | B+    |</span><br><span class="line">| <span class="number">55739</span> | MU-<span class="number">199</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | A-    |</span><br><span class="line">| <span class="number">76543</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">76543</span> | CS-<span class="number">319</span>    | <span class="number">2</span>      | Spring   | <span class="number">2010</span> | A     |</span><br><span class="line">| <span class="number">76653</span> | EE-<span class="number">181</span>    | <span class="number">1</span>      | Spring   | <span class="number">2009</span> | C     |</span><br><span class="line">| <span class="number">98765</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | C-    |</span><br><span class="line">| <span class="number">98765</span> | CS-<span class="number">315</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">98988</span> | BIO-<span class="number">101</span>   | <span class="number">1</span>      | Summer   | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">98988</span> | BIO-<span class="number">301</span>   | <span class="number">1</span>      | Summer   | <span class="number">2010</span> | NULL  |</span><br><span class="line">+-------+-----------+--------+----------+------+-------+</span><br><span class="line"><span class="number">22</span> rows <span class="keyword">in</span> <span class="built_in">set</span> (<span class="number">0</span>.<span class="number">06</span> sec)</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第4章 中级SQL </category>
          
          <category> 4.1 连接表达式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.1 连接表达式 4.1.1 连接条件</title>
      <link href="/ReadingNotes//d4b47bf9/"/>
      <url>/ReadingNotes//d4b47bf9/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/d4b47bf9/#4-1-连接表达式" class="header_1">4.1 连接表达式</a>&nbsp;<br><a href="/ReadingNotes/d4b47bf9/#student关系内容" class="header_2">student关系内容</a>&nbsp;<br><a href="/ReadingNotes/d4b47bf9/#takes关系内容" class="header_2">takes关系内容</a>&nbsp;<br><a href="/ReadingNotes/d4b47bf9/#4-1-1-连接条件" class="header_1">4.1.1 连接条件</a>&nbsp;<br><a href="/ReadingNotes/d4b47bf9/#on条件" class="header_2">on条件</a>&nbsp;<br><a href="/ReadingNotes/d4b47bf9/#on条件和自然连接的区别" class="header_2">on条件和自然连接的区别</a>&nbsp;<br><a href="/ReadingNotes/d4b47bf9/#on条件改成where" class="header_2">on条件改成where</a>&nbsp;<br><a href="/ReadingNotes/d4b47bf9/#on条件只显示一次重复的属性-不使用-select-*" class="header_2">on条件只显示一次重复的属性 不使用`select *`</a>&nbsp;<br><a href="/ReadingNotes/d4b47bf9/#on条件比自然连接功能更强" class="header_2">on条件比自然连接功能更强</a>&nbsp;<br><a href="/ReadingNotes/d4b47bf9/#on条件可以使用where替代" class="header_2">on条件可以使用where替代</a>&nbsp;<br><a href="/ReadingNotes/d4b47bf9/#on条件的优点" class="header_2">on条件的优点</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="4-1-连接表达式"><a href="#4-1-连接表达式" class="headerlink" title="4.1 连接表达式"></a>4.1 连接表达式</h1><p>在3.3.3节我们介绍了<code>自然连接</code>运算。<code>SQL</code>提供了连接运算的其他形式,包括能够指定显式的<strong>连接谓词</strong>(<code>join predicate</code>),能够在结果中包含被自然连接排除在外的元组。本节我们将讨论这些连接的形式。<br>本节的例子涉及<code>student</code>和<code>takes</code>两个关系,如下所示:</p><h2 id="student关系内容"><a href="#student关系内容" class="headerlink" title="student关系内容"></a>student关系内容</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from student;</span><br><span class="line">+-------+----------+------------+----------+</span><br><span class="line">| ID    | name     | dept_name  | tot_cred |</span><br><span class="line">+-------+----------+------------+----------+</span><br><span class="line">| <span class="number">00128</span> | Zhang    | <span class="built_in">Comp</span>. Sci. | <span class="number">102</span>      |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       |</span><br><span class="line">| <span class="number">19991</span> | Brandt   | History    | <span class="number">80</span>       |</span><br><span class="line">| <span class="number">23121</span> | Chavez   | Finance    | <span class="number">110</span>      |</span><br><span class="line">| <span class="number">44553</span> | Peltier  | Physics    | <span class="number">56</span>       |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       |</span><br><span class="line">| <span class="number">54321</span> | Williams | <span class="built_in">Comp</span>. Sci. | <span class="number">54</span>       |</span><br><span class="line">| <span class="number">55739</span> | Sanchez  | Music      | <span class="number">38</span>       |</span><br><span class="line">| <span class="number">70557</span> | Snow     | Physics    | <span class="number">0</span>        |</span><br><span class="line">| <span class="number">76543</span> | Brown    | <span class="built_in">Comp</span>. Sci. | <span class="number">58</span>       |</span><br><span class="line">| <span class="number">76653</span> | Aoi      | Elec. Eng. | <span class="number">60</span>       |</span><br><span class="line">| <span class="number">98765</span> | Bourikas | Elec. Eng. | <span class="number">98</span>       |</span><br><span class="line">| <span class="number">98988</span> | Tanaka   | Biology    | <span class="number">120</span>      |</span><br><span class="line">+-------+----------+------------+----------+</span><br><span class="line"><span class="number">13</span> rows <span class="keyword">in</span> <span class="built_in">set</span> (<span class="number">0</span>.<span class="number">03</span> sec)</span><br></pre></td></tr></table></figure><h2 id="takes关系内容"><a href="#takes关系内容" class="headerlink" title="takes关系内容"></a>takes关系内容</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from takes;</span><br><span class="line">+-------+-----------+--------+----------+------+-------+</span><br><span class="line">| ID    | course_id | sec_id | semester | year | grade |</span><br><span class="line">+-------+-----------+--------+----------+------+-------+</span><br><span class="line">| <span class="number">00128</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">00128</span> | CS-<span class="number">347</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A-    |</span><br><span class="line">| <span class="number">12345</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | C     |</span><br><span class="line">| <span class="number">12345</span> | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">12345</span> | CS-<span class="number">315</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | A     |</span><br><span class="line">| <span class="number">12345</span> | CS-<span class="number">347</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">19991</span> | HIS-<span class="number">351</span>   | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">23121</span> | FIN-<span class="number">201</span>   | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | C+    |</span><br><span class="line">| <span class="number">44553</span> | PHY-<span class="number">101</span>   | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | B-    |</span><br><span class="line">| <span class="number">45678</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | F     |</span><br><span class="line">| <span class="number">45678</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B+    |</span><br><span class="line">| <span class="number">45678</span> | CS-<span class="number">319</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">54321</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A-    |</span><br><span class="line">| <span class="number">54321</span> | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | B+    |</span><br><span class="line">| <span class="number">55739</span> | MU-<span class="number">199</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | A-    |</span><br><span class="line">| <span class="number">76543</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">76543</span> | CS-<span class="number">319</span>    | <span class="number">2</span>      | Spring   | <span class="number">2010</span> | A     |</span><br><span class="line">| <span class="number">76653</span> | EE-<span class="number">181</span>    | <span class="number">1</span>      | Spring   | <span class="number">2009</span> | C     |</span><br><span class="line">| <span class="number">98765</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | C-    |</span><br><span class="line">| <span class="number">98765</span> | CS-<span class="number">315</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">98988</span> | BIO-<span class="number">101</span>   | <span class="number">1</span>      | Summer   | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">98988</span> | BIO-<span class="number">301</span>   | <span class="number">1</span>      | Summer   | <span class="number">2010</span> | NULL  |</span><br><span class="line">+-------+-----------+--------+----------+------+-------+</span><br><span class="line"><span class="number">22</span> rows <span class="keyword">in</span> <span class="built_in">set</span> (<span class="number">0</span>.<span class="number">06</span> sec)</span><br></pre></td></tr></table></figure><p>注意到对于ID为98988的学生,他在2010夏季选修的<code>BIO-301</code>课程的1号课程段的<code>grade</code>属性为空值。该空值表示这门课程的成绩还没有得到。</p><h1 id="4-1-1-连接条件"><a href="#4-1-1-连接条件" class="headerlink" title="4.1.1 连接条件"></a>4.1.1 连接条件</h1><p>在3.3.3节我们介绍了如何表达<strong>自然连接</strong>,并且介绍了<code>join…using</code>子句,它是一种自然连接的形式,只需要<strong>在指定属性上的取值匹配</strong>。<br><code>SQL</code>支持另外一种形式的连接,其中可以<strong>指定任意的连接条件</strong>。</p><h2 id="on条件"><a href="#on条件" class="headerlink" title="on条件"></a>on条件</h2><p>on条件允许在参与连接的关系上设置通用的谓词。该谓词的写法与<code>where</code>子句谓词类似,只不过使用的是关键词<code>on</code>而不是<code>where</code>。与<code>using</code>条件样,<strong><code>on</code>条件出现在连接表达式的末尾</strong>。<br>考虑下面的查询,它具有包含on条件的连接表达式:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line">    <span class="keyword">from</span> student</span><br><span class="line">    <span class="keyword">join</span> takes <span class="keyword">on</span> student.ID=takes.ID;</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select *</span><br><span class="line">    from student</span><br><span class="line">    join takes on student.ID=takes.ID;</span><br><span class="line">+-------+----------+------------+----------+-------+-----------+--------+----------+------+-------+</span><br><span class="line">| ID    | name     | dept_name  | tot_cred | ID    | course_id | sec_id | semester | year | grade |</span><br><span class="line">+-------+----------+------------+----------+-------+-----------+--------+----------+------+-------+</span><br><span class="line">| <span class="number">00128</span> | Zhang    | <span class="built_in">Comp</span>. Sci. | <span class="number">102</span>      | <span class="number">00128</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">00128</span> | Zhang    | <span class="built_in">Comp</span>. Sci. | <span class="number">102</span>      | <span class="number">00128</span> | CS-<span class="number">347</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A-    |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | <span class="number">12345</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | C     |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | <span class="number">12345</span> | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | <span class="number">12345</span> | CS-<span class="number">315</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | A     |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | <span class="number">12345</span> | CS-<span class="number">347</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">19991</span> | Brandt   | History    | <span class="number">80</span>       | <span class="number">19991</span> | HIS-<span class="number">351</span>   | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">23121</span> | Chavez   | Finance    | <span class="number">110</span>      | <span class="number">23121</span> | FIN-<span class="number">201</span>   | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | C+    |</span><br><span class="line">| <span class="number">44553</span> | Peltier  | Physics    | <span class="number">56</span>       | <span class="number">44553</span> | PHY-<span class="number">101</span>   | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | B-    |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       | <span class="number">45678</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | F     |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       | <span class="number">45678</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B+    |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       | <span class="number">45678</span> | CS-<span class="number">319</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">54321</span> | Williams | <span class="built_in">Comp</span>. Sci. | <span class="number">54</span>       | <span class="number">54321</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A-    |</span><br><span class="line">| <span class="number">54321</span> | Williams | <span class="built_in">Comp</span>. Sci. | <span class="number">54</span>       | <span class="number">54321</span> | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | B+    |</span><br><span class="line">| <span class="number">55739</span> | Sanchez  | Music      | <span class="number">38</span>       | <span class="number">55739</span> | MU-<span class="number">199</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | A-    |</span><br><span class="line">| <span class="number">76543</span> | Brown    | <span class="built_in">Comp</span>. Sci. | <span class="number">58</span>       | <span class="number">76543</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">76543</span> | Brown    | <span class="built_in">Comp</span>. Sci. | <span class="number">58</span>       | <span class="number">76543</span> | CS-<span class="number">319</span>    | <span class="number">2</span>      | Spring   | <span class="number">2010</span> | A     |</span><br><span class="line">| <span class="number">76653</span> | Aoi      | Elec. Eng. | <span class="number">60</span>       | <span class="number">76653</span> | EE-<span class="number">181</span>    | <span class="number">1</span>      | Spring   | <span class="number">2009</span> | C     |</span><br><span class="line">| <span class="number">98765</span> | Bourikas | Elec. Eng. | <span class="number">98</span>       | <span class="number">98765</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | C-    |</span><br><span class="line">| <span class="number">98765</span> | Bourikas | Elec. Eng. | <span class="number">98</span>       | <span class="number">98765</span> | CS-<span class="number">315</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">98988</span> | Tanaka   | Biology    | <span class="number">120</span>      | <span class="number">98988</span> | BIO-<span class="number">101</span>   | <span class="number">1</span>      | Summer   | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">98988</span> | Tanaka   | Biology    | <span class="number">120</span>      | <span class="number">98988</span> | BIO-<span class="number">301</span>   | <span class="number">1</span>      | Summer   | <span class="number">2010</span> | NULL  |</span><br><span class="line">+-------+----------+------------+----------+-------+-----------+--------+----------+------+-------+</span><br><span class="line"><span class="number">22</span> rows <span class="keyword">in</span> <span class="built_in">set</span> (<span class="number">0</span>.<span class="number">08</span> sec)</span><br></pre></td></tr></table></figure><br>上述<code>on</code>条件表明:如果一个来自<code>student</code>的元组和一个来自<code>takes</code>的元组在<code>ID</code>上的取值相同,那么它们是匹配的。</p><h2 id="on条件和自然连接的区别"><a href="#on条件和自然连接的区别" class="headerlink" title="on条件和自然连接的区别"></a>on条件和自然连接的区别</h2><p>在上例中的连接表达式与连接表达式<code>student natural join takes</code>几乎是一样的,因为自然连接运算也需要<code>studen</code>元组和<code>takes</code>元组是匹配的。<br>这两者之间的一个区别在于:在上述连接查询结果中,<code>ID</code>属性出现两次,一次是<code>student</code>中的,另一次是<code>takes</code>中的,即便它们的<code>ID</code>属性值是相同的。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line">    <span class="keyword">from</span> student <span class="keyword">natural</span> <span class="keyword">join</span> takes;</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select *</span><br><span class="line">    from student natural join takes;</span><br><span class="line">+-------+----------+------------+----------+-----------+--------+----------+------+-------+</span><br><span class="line">| ID    | name     | dept_name  | tot_cred | course_id | sec_id | semester | year | grade |</span><br><span class="line">+-------+----------+------------+----------+-----------+--------+----------+------+-------+</span><br><span class="line">| <span class="number">00128</span> | Zhang    | <span class="built_in">Comp</span>. Sci. | <span class="number">102</span>      | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">00128</span> | Zhang    | <span class="built_in">Comp</span>. Sci. | <span class="number">102</span>      | CS-<span class="number">347</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A-    |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | C     |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | CS-<span class="number">315</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | A     |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | CS-<span class="number">347</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">19991</span> | Brandt   | History    | <span class="number">80</span>       | HIS-<span class="number">351</span>   | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">23121</span> | Chavez   | Finance    | <span class="number">110</span>      | FIN-<span class="number">201</span>   | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | C+    |</span><br><span class="line">| <span class="number">44553</span> | Peltier  | Physics    | <span class="number">56</span>       | PHY-<span class="number">101</span>   | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | B-    |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | F     |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       | CS-<span class="number">101</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B+    |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       | CS-<span class="number">319</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">54321</span> | Williams | <span class="built_in">Comp</span>. Sci. | <span class="number">54</span>       | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A-    |</span><br><span class="line">| <span class="number">54321</span> | Williams | <span class="built_in">Comp</span>. Sci. | <span class="number">54</span>       | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | B+    |</span><br><span class="line">| <span class="number">55739</span> | Sanchez  | Music      | <span class="number">38</span>       | MU-<span class="number">199</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | A-    |</span><br><span class="line">| <span class="number">76543</span> | Brown    | <span class="built_in">Comp</span>. Sci. | <span class="number">58</span>       | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">76543</span> | Brown    | <span class="built_in">Comp</span>. Sci. | <span class="number">58</span>       | CS-<span class="number">319</span>    | <span class="number">2</span>      | Spring   | <span class="number">2010</span> | A     |</span><br><span class="line">| <span class="number">76653</span> | Aoi      | Elec. Eng. | <span class="number">60</span>       | EE-<span class="number">181</span>    | <span class="number">1</span>      | Spring   | <span class="number">2009</span> | C     |</span><br><span class="line">| <span class="number">98765</span> | Bourikas | Elec. Eng. | <span class="number">98</span>       | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | C-    |</span><br><span class="line">| <span class="number">98765</span> | Bourikas | Elec. Eng. | <span class="number">98</span>       | CS-<span class="number">315</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">98988</span> | Tanaka   | Biology    | <span class="number">120</span>      | BIO-<span class="number">101</span>   | <span class="number">1</span>      | Summer   | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">98988</span> | Tanaka   | Biology    | <span class="number">120</span>      | BIO-<span class="number">301</span>   | <span class="number">1</span>      | Summer   | <span class="number">2010</span> | NULL  |</span><br><span class="line">+-------+----------+------------+----------+-----------+--------+----------+------+-------+</span><br><span class="line"><span class="number">22</span> rows <span class="keyword">in</span> <span class="built_in">set</span> (<span class="number">0</span>.<span class="number">07</span> sec)</span><br></pre></td></tr></table></figure></p><h2 id="on条件改成where"><a href="#on条件改成where" class="headerlink" title="on条件改成where"></a>on条件改成where</h2><p>实际上,上述查询与以下查询产生的结果是完全相同的。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line">    <span class="keyword">from</span> student,takes</span><br><span class="line">    <span class="keyword">where</span> student.ID=takes.ID;</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select *</span><br><span class="line">    from student,takes</span><br><span class="line">    where student.ID=takes.ID;</span><br><span class="line">+-------+----------+------------+----------+-------+-----------+--------+----------+------+-------+</span><br><span class="line">| ID    | name     | dept_name  | tot_cred | ID    | course_id | sec_id | semester | year | grade |</span><br><span class="line">+-------+----------+------------+----------+-------+-----------+--------+----------+------+-------+</span><br><span class="line">| <span class="number">00128</span> | Zhang    | <span class="built_in">Comp</span>. Sci. | <span class="number">102</span>      | <span class="number">00128</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">00128</span> | Zhang    | <span class="built_in">Comp</span>. Sci. | <span class="number">102</span>      | <span class="number">00128</span> | CS-<span class="number">347</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A-    |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | <span class="number">12345</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | C     |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | <span class="number">12345</span> | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | <span class="number">12345</span> | CS-<span class="number">315</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | A     |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | <span class="number">12345</span> | CS-<span class="number">347</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">19991</span> | Brandt   | History    | <span class="number">80</span>       | <span class="number">19991</span> | HIS-<span class="number">351</span>   | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">23121</span> | Chavez   | Finance    | <span class="number">110</span>      | <span class="number">23121</span> | FIN-<span class="number">201</span>   | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | C+    |</span><br><span class="line">| <span class="number">44553</span> | Peltier  | Physics    | <span class="number">56</span>       | <span class="number">44553</span> | PHY-<span class="number">101</span>   | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | B-    |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       | <span class="number">45678</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | F     |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       | <span class="number">45678</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B+    |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       | <span class="number">45678</span> | CS-<span class="number">319</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">54321</span> | Williams | <span class="built_in">Comp</span>. Sci. | <span class="number">54</span>       | <span class="number">54321</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A-    |</span><br><span class="line">| <span class="number">54321</span> | Williams | <span class="built_in">Comp</span>. Sci. | <span class="number">54</span>       | <span class="number">54321</span> | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | B+    |</span><br><span class="line">| <span class="number">55739</span> | Sanchez  | Music      | <span class="number">38</span>       | <span class="number">55739</span> | MU-<span class="number">199</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | A-    |</span><br><span class="line">| <span class="number">76543</span> | Brown    | <span class="built_in">Comp</span>. Sci. | <span class="number">58</span>       | <span class="number">76543</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">76543</span> | Brown    | <span class="built_in">Comp</span>. Sci. | <span class="number">58</span>       | <span class="number">76543</span> | CS-<span class="number">319</span>    | <span class="number">2</span>      | Spring   | <span class="number">2010</span> | A     |</span><br><span class="line">| <span class="number">76653</span> | Aoi      | Elec. Eng. | <span class="number">60</span>       | <span class="number">76653</span> | EE-<span class="number">181</span>    | <span class="number">1</span>      | Spring   | <span class="number">2009</span> | C     |</span><br><span class="line">| <span class="number">98765</span> | Bourikas | Elec. Eng. | <span class="number">98</span>       | <span class="number">98765</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | C-    |</span><br><span class="line">| <span class="number">98765</span> | Bourikas | Elec. Eng. | <span class="number">98</span>       | <span class="number">98765</span> | CS-<span class="number">315</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">98988</span> | Tanaka   | Biology    | <span class="number">120</span>      | <span class="number">98988</span> | BIO-<span class="number">101</span>   | <span class="number">1</span>      | Summer   | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">98988</span> | Tanaka   | Biology    | <span class="number">120</span>      | <span class="number">98988</span> | BIO-<span class="number">301</span>   | <span class="number">1</span>      | Summer   | <span class="number">2010</span> | NULL  |</span><br><span class="line">+-------+----------+------------+----------+-------+-----------+--------+----------+------+-------+</span><br><span class="line"><span class="number">22</span> rows <span class="keyword">in</span> <span class="built_in">set</span> (<span class="number">0</span>.<span class="number">07</span> sec)</span><br></pre></td></tr></table></figure></p><h2 id="on条件只显示一次重复的属性-不使用select"><a href="#on条件只显示一次重复的属性-不使用select" class="headerlink" title="on条件只显示一次重复的属性 不使用select *"></a>on条件只显示一次重复的属性 不使用<code>select *</code></h2><p>正如我们此前所见,关系名用来区分属性名D,这样ID的两次出现被分别表示为<code>student.ID</code>和<code>takes.ID</code>。<br>只显示一次ID值的查询版本如下:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> student.ID <span class="keyword">as</span> <span class="keyword">ID</span>, <span class="keyword">name</span>, dept_name, tot_cred,course_id, sec_id, semester, <span class="keyword">year</span>, grade</span><br><span class="line">    <span class="keyword">from</span> student</span><br><span class="line">    <span class="keyword">join</span> takes <span class="keyword">on</span> student.ID= takes.ID;</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select student.ID as ID, name, dept_name, tot_cred,course_id, sec_id, semester, year, grade</span><br><span class="line">    from student</span><br><span class="line">    join takes on student.ID= takes.ID;</span><br><span class="line">+-------+----------+------------+----------+-----------+--------+----------+------+-------+</span><br><span class="line">| ID    | name     | dept_name  | tot_cred | course_id | sec_id | semester | year | grade |</span><br><span class="line">+-------+----------+------------+----------+-----------+--------+----------+------+-------+</span><br><span class="line">| <span class="number">00128</span> | Zhang    | <span class="built_in">Comp</span>. Sci. | <span class="number">102</span>      | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">00128</span> | Zhang    | <span class="built_in">Comp</span>. Sci. | <span class="number">102</span>      | CS-<span class="number">347</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A-    |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | C     |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | CS-<span class="number">315</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | A     |</span><br><span class="line">| <span class="number">12345</span> | Shankar  | <span class="built_in">Comp</span>. Sci. | <span class="number">32</span>       | CS-<span class="number">347</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">19991</span> | Brandt   | History    | <span class="number">80</span>       | HIS-<span class="number">351</span>   | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">23121</span> | Chavez   | Finance    | <span class="number">110</span>      | FIN-<span class="number">201</span>   | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | C+    |</span><br><span class="line">| <span class="number">44553</span> | Peltier  | Physics    | <span class="number">56</span>       | PHY-<span class="number">101</span>   | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | B-    |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | F     |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       | CS-<span class="number">101</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B+    |</span><br><span class="line">| <span class="number">45678</span> | Levy     | Physics    | <span class="number">46</span>       | CS-<span class="number">319</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">54321</span> | Williams | <span class="built_in">Comp</span>. Sci. | <span class="number">54</span>       | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A-    |</span><br><span class="line">| <span class="number">54321</span> | Williams | <span class="built_in">Comp</span>. Sci. | <span class="number">54</span>       | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> | B+    |</span><br><span class="line">| <span class="number">55739</span> | Sanchez  | Music      | <span class="number">38</span>       | MU-<span class="number">199</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | A-    |</span><br><span class="line">| <span class="number">76543</span> | Brown    | <span class="built_in">Comp</span>. Sci. | <span class="number">58</span>       | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">76543</span> | Brown    | <span class="built_in">Comp</span>. Sci. | <span class="number">58</span>       | CS-<span class="number">319</span>    | <span class="number">2</span>      | Spring   | <span class="number">2010</span> | A     |</span><br><span class="line">| <span class="number">76653</span> | Aoi      | Elec. Eng. | <span class="number">60</span>       | EE-<span class="number">181</span>    | <span class="number">1</span>      | Spring   | <span class="number">2009</span> | C     |</span><br><span class="line">| <span class="number">98765</span> | Bourikas | Elec. Eng. | <span class="number">98</span>       | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> | C-    |</span><br><span class="line">| <span class="number">98765</span> | Bourikas | Elec. Eng. | <span class="number">98</span>       | CS-<span class="number">315</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> | B     |</span><br><span class="line">| <span class="number">98988</span> | Tanaka   | Biology    | <span class="number">120</span>      | BIO-<span class="number">101</span>   | <span class="number">1</span>      | Summer   | <span class="number">2009</span> | A     |</span><br><span class="line">| <span class="number">98988</span> | Tanaka   | Biology    | <span class="number">120</span>      | BIO-<span class="number">301</span>   | <span class="number">1</span>      | Summer   | <span class="number">2010</span> | NULL  |</span><br><span class="line">+-------+----------+------------+----------+-----------+--------+----------+------+-------+</span><br><span class="line"><span class="number">22</span> rows <span class="keyword">in</span> <span class="built_in">set</span> (<span class="number">0</span>.<span class="number">07</span> sec)</span><br></pre></td></tr></table></figure></p><h2 id="on条件比自然连接功能更强"><a href="#on条件比自然连接功能更强" class="headerlink" title="on条件比自然连接功能更强"></a>on条件比自然连接功能更强</h2><p><code>on</code>条件可以表示任何<code>SQL</code>谓词,从而<strong>使用<code>on</code>条件的连接表达式就可以表示比自然连接更为丰富的连接条件</strong>。</p><h2 id="on条件可以使用where替代"><a href="#on条件可以使用where替代" class="headerlink" title="on条件可以使用where替代"></a>on条件可以使用where替代</h2><p>然而,正如上例所示,使用带<code>on</code>条件的连接表达式的查询可以用不带<code>on</code>条件的等价表达式来替换,只要把<code>on</code>子句中的谓词移到<code>where</code>子句中即可。这样看来,<code>on</code>条件似乎是一个冗余的<code>SQL</code>特征</p><h2 id="on条件的优点"><a href="#on条件的优点" class="headerlink" title="on条件的优点"></a>on条件的优点</h2><p>但是,引入<code>on</code>条件有两个优点。</p><ul><li>首先,对于我们马上要介绍的,被称作<code>外连接</code>的这类连接来说,<code>on</code>条件的表现与<code>where</code>条件是不同的。</li><li>其次,如果在<code>on</code>子句中指定连接条件,并在<code>where</code>子句中出现其余的条件,这样的<code>SQL</code>查询通常更容易让人读懂。</li></ul><!--SSTStop-->]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第4章 中级SQL </category>
          
          <category> 4.1 连接表达式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第4章 中级SQL</title>
      <link href="/ReadingNotes//ee98ec8f/"/>
      <url>/ReadingNotes//ee98ec8f/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/ee98ec8f/#第4章-中级SQL" class="header_1">第4章 中级SQL</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="第4章-中级SQL"><a href="#第4章-中级SQL" class="headerlink" title="第4章 中级SQL"></a>第4章 中级SQL</h1><p>本章我们继续学习<code>SQL</code>。我们考虑具有更复杂形式的<code>SQL</code>查询、视图定义、事务、完整性约束、关于<code>SQL</code>数据定义的更详细介绍以及授权。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第4章 中级SQL </category>
          
          <category> 4.0 本章概述 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.10 总结</title>
      <link href="/ReadingNotes//81b3e3dc/"/>
      <url>/ReadingNotes//81b3e3dc/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/81b3e3dc/#3-10-总结" class="header_1">3.10 总结</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="3-10-总结"><a href="#3-10-总结" class="headerlink" title="3.10 总结"></a>3.10 总结</h1><ul><li><code>SQL</code>是最有影响力的商用市场化的关系查询语言。<code>SQL</code>语言包括几个部分:<ul><li>数据定义语言(<code>DDL</code>),它提供了<code>定义关系</code>模式、<code>删除关系</code>以及<code>修改关系</code>模式的命令。</li><li>数据操纵语言(<code>DML</code>),它包括<code>查询语言</code>,以及往数据库中<code>插入</code>元组、从数据库中<code>删除</code>元组和<code>修改</code>数据库中元组的命令。</li></ul></li><li><code>SQL</code>的数据定义语言用于创建具有特定模式的关系。除了声明关系属性的名称和类型之外,<code>SQL</code>还允许声明完整性约束,例如主码约束和外码约束。</li><li><code>SQL</code>提供多种用于查询数据库的语言结构,其中包括<code>select</code>、<code>from</code>和<code>where</code>子句。<code>SQL</code>支持<code>自然连接</code>操作。</li><li><code>SQL</code>支持关系上的基本<strong>集合运算</strong>,包括<code>并</code>、<code>交</code>和<code>差</code>运算,它们分别对应于数学集合论中的U、∩和-运算。</li><li><code>SQL</code>通过在通用真值<code>true</code>和<code>false</code>外增加真值<code>&quot;unknown&quot;</code>,来处理对包含空值的关系的查询。</li><li><code>SQL</code>支持聚集,可以把关系进行分组,在每个分组上单独运用聚集。<code>SQL</code>还支持在分组上的集合运算。</li><li><code>SQL</code>支持在外层查询的<code>where</code>和<code>from</code>子句中嵌套<strong>子查询</strong>。它还在一个表达式返回的单个值所允许出现的任何地方支持<strong>标量子查询</strong>。</li><li><code>SQL</code>提供了用于更新、插入、删除信息的结构。<!--SSTStop--></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第3章 SQL </category>
          
          <category> 3.10 总结 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.9.3 更新</title>
      <link href="/ReadingNotes//636c1eda/"/>
      <url>/ReadingNotes//636c1eda/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/636c1eda/#3-9-3-更新" class="header_1">3.9.3 更新</a>&nbsp;<br><a href="/ReadingNotes/636c1eda/#SQL更新-所有教师的工资将增长5%" class="header_2">SQL更新 所有教师的工资将增长5%</a>&nbsp;<br><a href="/ReadingNotes/636c1eda/#SQL更新-只给那些工资低于70000美元的教师涨工资" class="header_2">SQL更新 只给那些工资低于70000美元的教师涨工资</a>&nbsp;<br><a href="/ReadingNotes/636c1eda/#update的where子句可以嵌套查询语句" class="header_2">update的where子句可以嵌套查询语句</a>&nbsp;<br><a href="/ReadingNotes/636c1eda/#SQL更新-对工资低于平均数的教师涨5%的工资" class="header_3">SQL更新 对工资低于平均数的教师涨5%的工资</a>&nbsp;<br><a href="/ReadingNotes/636c1eda/#给工资超过100000美元的教师涨3%的工资-其余教师涨5%" class="header_3">给工资超过100000美元的教师涨3%的工资,其余教师涨5%</a>&nbsp;<br><a href="/ReadingNotes/636c1eda/#update语句的顺序十分重要" class="header_2">update语句的顺序十分重要</a>&nbsp;<br><a href="/ReadingNotes/636c1eda/#case结构" class="header_2">case结构</a>&nbsp;<br><a href="/ReadingNotes/636c1eda/#case语句的格式" class="header_3">case语句的格式</a>&nbsp;<br><a href="/ReadingNotes/636c1eda/#case语句可以出现的地方" class="header_3">case语句可以出现的地方</a>&nbsp;<br><a href="/ReadingNotes/636c1eda/#使用标量子查询" class="header_2">使用标量子查询</a>&nbsp;<br><a href="/ReadingNotes/636c1eda/#使用标量子查询和case" class="header_2">使用标量子查询和case</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="3-9-3-更新"><a href="#3-9-3-更新" class="headerlink" title="3.9.3 更新"></a>3.9.3 更新</h1><p>有些情况下,我们可能希望在不改变整个元组的情况下改变其部分属性的值。为达到这一目的,可以使用<code>update</code>语句。与使用<code>insert</code>、 <code>delete</code>类似,待更新的元组可以用查询语句找到</p><h2 id="SQL更新-所有教师的工资将增长5"><a href="#SQL更新-所有教师的工资将增长5" class="headerlink" title="SQL更新 所有教师的工资将增长5%"></a>SQL更新 所有教师的工资将增长5%</h2><p>假设要进行年度工资增长,所有教师的工资将增长5%。我们写出:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> instructor</span><br><span class="line">    <span class="keyword">set</span> salary=salary * <span class="number">1.05</span>;</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update instructor</span><br><span class="line">    <span class="built_in">set</span> salary=salary * <span class="number">1</span>.<span class="number">05</span>;</span><br><span class="line">Query OK, <span class="number">12</span> rows affected (<span class="number">0</span>.<span class="number">01</span> sec)</span><br><span class="line">Rows matched: <span class="number">12</span>  Changed: <span class="number">12</span>  Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure><br>上面的更新语句将在 <code>instructor</code>关系的每个元组上执行一次。</p><h2 id="SQL更新-只给那些工资低于70000美元的教师涨工资"><a href="#SQL更新-只给那些工资低于70000美元的教师涨工资" class="headerlink" title="SQL更新 只给那些工资低于70000美元的教师涨工资"></a>SQL更新 只给那些工资低于70000美元的教师涨工资</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> instructor</span><br><span class="line">    <span class="keyword">set</span> salary=salary*<span class="number">1.05</span></span><br><span class="line">    <span class="keyword">where</span> salary&gt;<span class="number">70000</span>;</span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update instructor</span><br><span class="line">    <span class="built_in">set</span> salary=salary*<span class="number">1</span>.<span class="number">05</span></span><br><span class="line">    where salary&gt;<span class="number">70000</span>;</span><br><span class="line">Query OK, <span class="number">8</span> rows affected (<span class="number">0</span>.<span class="number">01</span> sec)</span><br><span class="line">Rows matched: <span class="number">8</span>  Changed: <span class="number">8</span>  Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="update的where子句可以嵌套查询语句"><a href="#update的where子句可以嵌套查询语句" class="headerlink" title="update的where子句可以嵌套查询语句"></a>update的where子句可以嵌套查询语句</h2><p>总之, <code>update</code>语句的<code>where</code>子句可以包含<code>select</code>语句的<code>where</code>子句中的任何合法结构(包括嵌套的<code>select</code>)。<br>和<code>insert</code>、 <code>delete</code>类似, <code>update</code>语句中嵌套的<code>set</code>可以引用待更新的关系。同样,<code>SQL</code>首先检查关系中的所有元组,看它们是否应该被更新,然后才执行更新。</p><h3 id="SQL更新-对工资低于平均数的教师涨5-的工资"><a href="#SQL更新-对工资低于平均数的教师涨5-的工资" class="headerlink" title="SQL更新 对工资低于平均数的教师涨5%的工资"></a>SQL更新 对工资低于平均数的教师涨5%的工资</h3><p>例如,请求”<strong>对工资低于平均数的教师涨5%的工资</strong>“可以写为如下形式:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> instructor</span><br><span class="line">    <span class="keyword">set</span> salary=salary*<span class="number">1.05</span></span><br><span class="line">    <span class="keyword">where</span> salary &lt;(</span><br><span class="line">        <span class="keyword">select</span> avg_salary <span class="keyword">from</span>(</span><br><span class="line">            <span class="keyword">select</span> <span class="keyword">avg</span>(salary) <span class="keyword">as</span> avg_salary <span class="keyword">from</span> instructor</span><br><span class="line">        ) <span class="keyword">as</span> Avgs</span><br><span class="line">);</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update instructor</span><br><span class="line">    <span class="built_in">set</span> salary=salary*<span class="number">1</span>.<span class="number">05</span></span><br><span class="line">    where salary &lt;(</span><br><span class="line">        select avg_salary from(</span><br><span class="line">            select avg(salary) as avg_salary from instructor</span><br><span class="line">        ) as Avgs</span><br><span class="line">);</span><br><span class="line">Query OK, <span class="number">5</span> rows affected (<span class="number">0</span>.<span class="number">01</span> sec)</span><br><span class="line">Rows matched: <span class="number">5</span>  Changed: <span class="number">5</span>  Warnings: <span class="number">1</span></span><br></pre></td></tr></table></figure></p><h3 id="给工资超过100000美元的教师涨3-的工资-其余教师涨5"><a href="#给工资超过100000美元的教师涨3-的工资-其余教师涨5" class="headerlink" title="给工资超过100000美元的教师涨3%的工资,其余教师涨5%"></a>给工资超过100000美元的教师涨3%的工资,其余教师涨5%</h3><p>我们可以写两条<code>update</code>语句:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> instructor</span><br><span class="line">    <span class="keyword">set</span> salary=salary*<span class="number">1.03</span></span><br><span class="line">    <span class="keyword">where</span> salary &gt;<span class="number">100000</span>;</span><br><span class="line"><span class="keyword">update</span> instructor</span><br><span class="line">    <span class="keyword">set</span> salary=salary*<span class="number">1.05</span></span><br><span class="line">    <span class="keyword">where</span> salary&lt;<span class="number">100000</span>;</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update instructor</span><br><span class="line">    <span class="built_in">set</span> salary=salary*<span class="number">1</span>.<span class="number">03</span></span><br><span class="line">    where salary &gt;<span class="number">100000</span>;</span><br><span class="line">update instructor</span><br><span class="line">    <span class="built_in">set</span> salary=salary*<span class="number">1</span>.<span class="number">05</span></span><br><span class="line">    where salary&lt;<span class="number">100000</span>;</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0</span>.<span class="number">00</span> sec)</span><br><span class="line">Rows matched: <span class="number">0</span>  Changed: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">12</span> rows affected (<span class="number">0</span>.<span class="number">01</span> sec)</span><br><span class="line">Rows matched: <span class="number">12</span>  Changed: <span class="number">12</span>  Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure></p><h2 id="update语句的顺序十分重要"><a href="#update语句的顺序十分重要" class="headerlink" title="update语句的顺序十分重要"></a>update语句的顺序十分重要</h2><p>注意上面这两条<code>update</code>语句的<strong>顺序十分重要</strong>。<br>假如我们改变这两条语句的顺序,工资略少于100000美元的教师将增长8%的工资。</p><h2 id="case结构"><a href="#case结构" class="headerlink" title="case结构"></a>case结构</h2><p><code>SQL</code>提供<code>case</code>结构,我们可以利用它在一条<code>update</code>语句中执行前面的两种更新,避免更新次序引发的问题:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> instructor</span><br><span class="line"><span class="keyword">set</span> salary=<span class="keyword">case</span></span><br><span class="line">    <span class="keyword">when</span> salary &lt; <span class="number">100000</span> <span class="keyword">then</span> salary*<span class="number">1.05</span></span><br><span class="line">    <span class="keyword">else</span> salary*<span class="number">1.03</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update instructor</span><br><span class="line"><span class="built_in">set</span> salary=case</span><br><span class="line">    when salary &lt; <span class="number">100000</span> then salary*<span class="number">1</span>.<span class="number">05</span></span><br><span class="line">    <span class="keyword">else</span> salary*<span class="number">1</span>.<span class="number">03</span></span><br><span class="line">end;</span><br><span class="line">Query OK, <span class="number">12</span> rows affected (<span class="number">0</span>.<span class="number">01</span> sec)</span><br><span class="line">Rows matched: <span class="number">12</span>  Changed: <span class="number">12</span>  Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure></p><h3 id="case语句的格式"><a href="#case语句的格式" class="headerlink" title="case语句的格式"></a>case语句的格式</h3><p><code>case</code>语句的一般格式如下:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">case</span><br><span class="line">    when pred_1, then result_1</span><br><span class="line">    when pred_2, then result_2</span><br><span class="line">    ...</span><br><span class="line">    when pred_n, then result_n</span><br><span class="line">    else result0</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><ul><li>如果第一个满足的是谓词<code>pred_i</code>,则返回结果<code>result_i</code>.</li><li>如果没有一个谓词可以满足,则返回<code>result0</code></li></ul><h3 id="case语句可以出现的地方"><a href="#case语句可以出现的地方" class="headerlink" title="case语句可以出现的地方"></a>case语句可以出现的地方</h3><p><strong><code>case</code>语句可以用在任何应该出现<code>值</code>的地方</strong>。</p><h2 id="使用标量子查询"><a href="#使用标量子查询" class="headerlink" title="使用标量子查询"></a>使用标量子查询</h2><p>标量子查询在<code>SQL</code>更新语句中也非常有用,它们可以用在<code>set</code>子句中。<br>考虑这样一种更新:我们把每个<code>student</code>元组的<code>tot_cred</code>属性值设为该生<strong>成功学完的课程学分的总和</strong>。我们假设如果一个学生在某门课程上的成绩既不是”<code>F</code>“,也不是空,那么他成功学完了这门课程。<br>我们需要使用<code>set</code>子句中的子查询来写出这种更新,如下所示:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> student S</span><br><span class="line">    <span class="keyword">set</span> tot_cred =(</span><br><span class="line">        <span class="keyword">select</span> <span class="keyword">sum</span>(credits)</span><br><span class="line">            <span class="keyword">from</span> takes <span class="keyword">natural</span> <span class="keyword">join</span> course</span><br><span class="line">            <span class="keyword">where</span> S.ID=takes.ID <span class="keyword">and</span> takes.grade &lt;&gt; <span class="string">'F'</span> <span class="keyword">and</span> takes.grade <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update student S</span><br><span class="line">    <span class="built_in">set</span> tot_cred =(</span><br><span class="line">        select sum(credits)</span><br><span class="line">            from takes natural join course</span><br><span class="line">            where S.ID=takes.ID and takes.grade &lt;&gt; 'F' and takes.grade is <span class="keyword">not</span> null</span><br><span class="line">);</span><br><span class="line">Query OK, <span class="number">13</span> rows affected (<span class="number">0</span>.<span class="number">02</span> sec)</span><br><span class="line">Rows matched: <span class="number">13</span>  Changed: <span class="number">13</span>  Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure></p><h2 id="使用标量子查询和case"><a href="#使用标量子查询和case" class="headerlink" title="使用标量子查询和case"></a>使用标量子查询和case</h2><p>注意子查询使用了来自<code>update</code>语句中的相关变量S。如果一个学生没有成功学完任何课程,上述更新语句将把其<code>tot_cred</code>属性值设为空。<br>如果想把这样的属性值设为0的话,我们可以使用另一条<code>update</code>语句来把空值替换为0。<br>不过更好的方案是把上述子查询中的”<code>select sun(credits)</code>“子句替换为如下使用<code>case</code>表达式的<code>select</code>子句:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">case</span></span><br><span class="line">    <span class="keyword">when</span> <span class="keyword">sum</span>(credits ) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">then</span> <span class="keyword">sum</span>(credits)</span><br><span class="line">    <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><br>也就是改为如下形式:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> student S</span><br><span class="line">    <span class="keyword">set</span> tot_cred =(</span><br><span class="line">            <span class="keyword">select</span> <span class="keyword">case</span></span><br><span class="line">                    <span class="keyword">when</span> <span class="keyword">sum</span>(credits ) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">then</span> <span class="keyword">sum</span>(credits)</span><br><span class="line">                    <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">from</span> takes <span class="keyword">natural</span> <span class="keyword">join</span> course</span><br><span class="line">            <span class="keyword">where</span> S.ID=takes.ID <span class="keyword">and</span> takes.grade &lt;&gt; <span class="string">'F'</span> <span class="keyword">and</span> takes.grade <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第3章 SQL </category>
          
          <category> 3.9 数据库的修改 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.9.2 插入</title>
      <link href="/ReadingNotes//b18bc4c4/"/>
      <url>/ReadingNotes//b18bc4c4/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/b18bc4c4/#3-9-2-插入" class="header_1">3.9.2 插入</a>&nbsp;<br><a href="/ReadingNotes/b18bc4c4/#按表中定义的顺序插入元组" class="header_2">按表中定义的顺序插入元组</a>&nbsp;<br><a href="/ReadingNotes/b18bc4c4/#按指定顺序插入元组" class="header_2">按指定顺序插入元组</a>&nbsp;<br><a href="/ReadingNotes/b18bc4c4/#在查询结果的基础上插入" class="header_2">在查询结果的基础上插入</a>&nbsp;<br><a href="/ReadingNotes/b18bc4c4/#要保证select先执行完毕" class="header_2">要保证select先执行完毕</a>&nbsp;<br><a href="/ReadingNotes/b18bc4c4/#没有给出值的属性会被设置为null" class="header_2">没有给出值的属性会被设置为null</a>&nbsp;<br><a href="/ReadingNotes/b18bc4c4/#从格式化文本文件插入元组" class="header_2">从格式化文本文件插入元组</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="3-9-2-插入"><a href="#3-9-2-插入" class="headerlink" title="3.9.2 插入"></a>3.9.2 插入</h1><p>要往关系中插入数据,我们可以指定待插入的元组,或者写一条查询语句来生成待插入的元组集合。显然,待插入元组的属性值必须在相应属性的域中。同样,待插入元组的分量数也必须是正确的。</p><h2 id="按表中定义的顺序插入元组"><a href="#按表中定义的顺序插入元组" class="headerlink" title="按表中定义的顺序插入元组"></a>按表中定义的顺序插入元组</h2><p>最简单的<code>insert</code>语句是单个元组的插入请求。假设我们想要插入的信息是<strong><code>Computer Science</code>系开设的名为<code>&quot;Database Systems&quot;</code>的课程<code>CS-437</code>,它有4个学分</strong>。我们可写成:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> course</span><br><span class="line">    <span class="keyword">values</span>(<span class="string">'CS-437'</span>, <span class="string">'Database Systems'</span>, <span class="string">'Comp. Sci. '</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into course</span><br><span class="line">    values('CS-<span class="number">437</span>', 'Database Systems', '<span class="built_in">Comp</span>. Sci. ',<span class="number">4</span>);</span><br><span class="line">Query OK, <span class="number">1</span> row affected (<span class="number">0</span>.<span class="number">02</span> sec)</span><br></pre></td></tr></table></figure><br>在此例中,元组属性值的排列顺序和关系模式中属性排列的顺序一致。</p><h2 id="按指定顺序插入元组"><a href="#按指定顺序插入元组" class="headerlink" title="按指定顺序插入元组"></a>按指定顺序插入元组</h2><p>考虑到用户可能不记得关系属性的排列顺序,<code>SQL</code>允许在<code>insert</code>语句中指定属性。例如,以下<code>SQL insert</code>语句与前述语句的功能相同。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> course(course_id, title, dept_name, credits)</span><br><span class="line">    <span class="keyword">values</span>(<span class="string">'CS-437'</span>, <span class="string">'Database Systems'</span>,<span class="string">'Comp. Sci. '</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into course(course_id, <span class="built_in">title</span>, dept_name, credits)</span><br><span class="line">    values('CS-<span class="number">437</span>', 'Database Systems','<span class="built_in">Comp</span>. Sci. ', <span class="number">4</span>);</span><br><span class="line">Query OK, <span class="number">1</span> row affected (<span class="number">0</span>.<span class="number">01</span> sec)</span><br></pre></td></tr></table></figure><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> course(title, course_id, credits, dept_name)</span><br><span class="line">    <span class="keyword">values</span>(<span class="string">'Database Systems'</span>, <span class="string">'CS-437'</span>, <span class="number">4</span>,<span class="string">'Comp. Sci. '</span>);</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into course(<span class="built_in">title</span>, course_id, credits, dept_name)</span><br><span class="line">    values('Database Systems', 'CS-<span class="number">437</span>', <span class="number">4</span>,'<span class="built_in">Comp</span>. Sci. ');</span><br><span class="line">Query OK, <span class="number">1</span> row affected (<span class="number">0</span>.<span class="number">01</span> sec)</span><br></pre></td></tr></table></figure></p><h2 id="在查询结果的基础上插入"><a href="#在查询结果的基础上插入" class="headerlink" title="在查询结果的基础上插入"></a>在查询结果的基础上插入</h2><p>更通常的情况是,<strong>我们可能想在查询结果的基础上插入元组</strong>。假设我们想让<code>Music</code>系每个修满144学分的学生成为<code>Music</code>系的教师,其工资为18000美元。我们可写作:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> instructor</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">ID</span>, <span class="keyword">name</span>, dept_name, <span class="number">18000</span></span><br><span class="line">        <span class="keyword">from</span> student</span><br><span class="line">        <span class="keyword">where</span> dept_name =<span class="string">'Music'</span> <span class="keyword">and</span> tot_cred&gt;<span class="number">144</span>;</span><br></pre></td></tr></table></figure><br>和本节前面的例子不同的是,我们没有指定一个元组,而是用<code>select</code>选出一个元组集合。<strong><code>SQL</code>先执行这条<code>select</code>语句,求出将要插入到<code>instructor</code>关系中的元组集合</strong>。每个元组都有<code>ID</code>、<code>dept_name(Music)</code>和工资(18000美元)。</p><h2 id="要保证select先执行完毕"><a href="#要保证select先执行完毕" class="headerlink" title="要保证select先执行完毕"></a>要保证select先执行完毕</h2><p>在执行插入之前先执行完<code>select</code>语句是非常重要的。<br>如果在执行<code>select</code>语句的同时执行插入动作如果在<code>student</code>上没有主码约束的话,像:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student</span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> student;</span><br></pre></td></tr></table></figure><br>这样的请求就可能会插入无数元组。如果没有主码约束,上述请求会重新插入<code>student</code>中的第一个元组,产生该元组的第二份拷贝。由于这个副本现在是<code>student</code>中的一部分, <code>select</code>语句可能找到它,于是第三份拷贝被插入到<code>student</code>中。第三份拷贝又可能被<code>select</code>语句发现,于是又插入第四份拷贝,如此等等,无限循环。<br>在执行插入之前先完成<code>select</code>语句的执行可以避免这样的问题。这样,如果在<code>student</code>关系上没有主码约束,那么上述<code>insert</code>语句就只是把<code>student</code>关系中的每个元组都复制一遍。</p><h2 id="没有给出值的属性会被设置为null"><a href="#没有给出值的属性会被设置为null" class="headerlink" title="没有给出值的属性会被设置为null"></a>没有给出值的属性会被设置为null</h2><p>在讨论<code>insert</code>语句时我们只考虑了这样的例子:待插人元组的每个属性都被赋了值。但是有可能<strong>待插入元组中只给出了模式中部分属性的值,那么其余属性将被赋空值,用<code>null</code>表示</strong>。<br>考虑请求:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student</span><br><span class="line">    <span class="keyword">values</span>(<span class="string">'3003'</span>, <span class="string">'Green'</span>,<span class="string">'Finance'</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><br>此请求所插入的元组代表了一个在<code>Finance</code>系、ID为”3003”的学生,但其<code>tot_cred</code>值是未知的。<br>考虑查询:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">ID</span> <span class="keyword">from</span> student</span><br><span class="line">    <span class="keyword">where</span> tot_cred&gt;<span class="number">45</span>;</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into student</span><br><span class="line">    values('<span class="number">3003</span>', 'Green','Finance', null);</span><br><span class="line">Query OK, <span class="number">1</span> row affected (<span class="number">0</span>.<span class="number">02</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select ID from student</span><br><span class="line">    where tot_cred&gt;<span class="number">45</span>;</span><br><span class="line">+-------+</span><br><span class="line">| ID    |</span><br><span class="line">+-------+</span><br><span class="line">| <span class="number">00128</span> |</span><br><span class="line">| <span class="number">19991</span> |</span><br><span class="line">| <span class="number">23121</span> |</span><br><span class="line">| <span class="number">44553</span> |</span><br><span class="line">| <span class="number">45678</span> |</span><br><span class="line">| <span class="number">54321</span> |</span><br><span class="line">| <span class="number">76543</span> |</span><br><span class="line">| <span class="number">76653</span> |</span><br><span class="line">| <span class="number">98765</span> |</span><br><span class="line">| <span class="number">98988</span> |</span><br><span class="line">+-------+</span><br><span class="line"><span class="number">10</span> rows <span class="keyword">in</span> <span class="built_in">set</span> (<span class="number">0</span>.<span class="number">06</span> sec)</span><br></pre></td></tr></table></figure><br>既然”3003”号学生的<code>ot cred</code>值未知,我们不能确定它是否大于45。所以上述查询结果中不会出现”3003”</p><h2 id="从格式化文本文件插入元组"><a href="#从格式化文本文件插入元组" class="headerlink" title="从格式化文本文件插入元组"></a>从格式化文本文件插入元组</h2><p>大部分关系数据库产品有特殊的”<code>bulk loader</code>“工具,它可以向关系中插入一个非常大的元组集合。这些工具允许从<strong>格式化文本文件</strong>中读出数据,且执行速度比同等目的的插入语句序列要快得多。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第3章 SQL </category>
          
          <category> 3.9 数据库的修改 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.9 数据库的修改 3.9.1 删除</title>
      <link href="/ReadingNotes//f3873e33/"/>
      <url>/ReadingNotes//f3873e33/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/f3873e33/#3-9-数据库的修改" class="header_1">3.9 数据库的修改</a>&nbsp;<br><a href="/ReadingNotes/f3873e33/#3-9-1-删除" class="header_1">3.9.1 删除</a>&nbsp;<br><a href="/ReadingNotes/f3873e33/#删除指定元组" class="header_2">删除指定元组</a>&nbsp;<br><a href="/ReadingNotes/f3873e33/#删除所有元组" class="header_2">删除所有元组</a>&nbsp;<br><a href="/ReadingNotes/f3873e33/#一个delete只能删除一个关系" class="header_2">一个delete只能删除一个关系</a>&nbsp;<br><a href="/ReadingNotes/f3873e33/#delete的where子句中可以嵌套查询" class="header_2">delete的where子句中可以嵌套查询</a>&nbsp;<br><a href="/ReadingNotes/f3873e33/#MySQL写法" class="header_3">MySQL写法</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="3-9-数据库的修改"><a href="#3-9-数据库的修改" class="headerlink" title="3.9 数据库的修改"></a>3.9 数据库的修改</h1><p>目前为止我们的注意力集中在对数据库的信息抽取上。现在我们将展示如何用<code>SQL</code>来增加、删除和修改信息。</p><h1 id="3-9-1-删除"><a href="#3-9-1-删除" class="headerlink" title="3.9.1 删除"></a>3.9.1 删除</h1><h2 id="删除指定元组"><a href="#删除指定元组" class="headerlink" title="删除指定元组"></a>删除指定元组</h2><p>删除请求的表达与査询非常类似。我们只能删除整个元组,而不能只删除某些属性上的值。<code>SQL</code>用如下语句表示删除:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> R</span><br><span class="line"><span class="keyword">where</span> P;</span><br></pre></td></tr></table></figure><br>其中P代表一个谓词,<code>R</code>代表一个关系。 delete语句首先从关系R中找出所有使P(t)为真的元组<code>t</code>,然后把它们从<code>R</code>中删除。</p><h2 id="删除所有元组"><a href="#删除所有元组" class="headerlink" title="删除所有元组"></a>删除所有元组</h2><p>如果省略<code>where</code>子句,则<code>R</code>中所有元组将被删除。</p><h2 id="一个delete只能删除一个关系"><a href="#一个delete只能删除一个关系" class="headerlink" title="一个delete只能删除一个关系"></a>一个delete只能删除一个关系</h2><p>注意<code>delete</code>命令只能作用于一个关系。如果我们想从多个关系中删除元组,必须在每个关系上使用一条<code>delete</code>命令。<br><code>where</code>子句中的谓词可以和<code>select</code>命令的<code>where</code>子句中的谓词一样复杂。在另一种极端情况下, <code>where</code>子句可以为空,请求:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> instructor;</span><br></pre></td></tr></table></figure><br>将删除<code>instructor</code>关系中的所有元组。 <code>instructor</code>关系本身仍然存在,知识它变成空的关系而已了.<br>下面是<code>SQL</code>删除请求的一些例子:<br>从<code>instructor</code>关系中删除与<code>Finance</code>系教师相关的所有元组。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> dept_name =<span class="string">'Finance'</span>;</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; delete from instructor</span><br><span class="line">where dept_name ='Finance';</span><br><span class="line">Query OK, <span class="number">2</span> rows affected</span><br></pre></td></tr></table></figure><br>删除所有工资在13000美元到15000美元之间的教师。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> salary <span class="keyword">between</span> <span class="number">13000</span> <span class="keyword">and</span> <span class="number">15000</span>;</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; delete from instructor</span><br><span class="line">where salary between <span class="number">13000</span> and <span class="number">15000</span>;</span><br><span class="line">Query OK, <span class="number">0</span> rows affected</span><br></pre></td></tr></table></figure><br>从<code>instructor</code>关系中删除所有在位于 <code>Watson</code>大楼的系工作的教师元组。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> dept_name <span class="keyword">in</span>(</span><br><span class="line">    <span class="keyword">select</span> dept_name</span><br><span class="line">    <span class="keyword">from</span> department</span><br><span class="line">    <span class="keyword">where</span> building =<span class="string">'Watson'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; delete from instructor</span><br><span class="line">where dept_name <span class="keyword">in</span>(</span><br><span class="line">    select dept_name</span><br><span class="line">    from department</span><br><span class="line">    where building ='Watson'</span><br><span class="line">);</span><br><span class="line">Query OK, <span class="number">3</span> rows affected</span><br></pre></td></tr></table></figure><br>此<code>delete</code>请求首先找出所有位于<code>Watson</code>大楼的系,然后将属于这些系的<code>instructor</code>元组全部删除。</p><h2 id="delete的where子句中可以嵌套查询"><a href="#delete的where子句中可以嵌套查询" class="headerlink" title="delete的where子句中可以嵌套查询"></a>delete的where子句中可以嵌套查询</h2><p>注意,虽然我们一次只能从一个关系中删除元组,但是通过在<code>delete</code>的<code>where</code>子句中嵌套<code>select-from-where</code>,我们可以引用任意数目的关系。 <code>delete</code>请求可以包含嵌套的<code>select</code>,该<code>select</code>引用待删除元组的关系。<br>例如,假设我们想<strong>删除工资低于大学平均工资的教师记录</strong>,可以写出如下语句<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> salary &lt; (</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">avg</span>(salary) <span class="keyword">from</span> instructor</span><br><span class="line">);</span><br></pre></td></tr></table></figure><br>该<code>delete</code>语句首先测试<code>instructor</code>关系中的每一个元组,检查其工资是否小于大学教师的平均工资。然后删除所有符合条件的元组,即所有低于平均工资的教师。在执行任何删除之前先进行所有元组的测试是至关重要的,因为若有些元组在其余元组未被测试前先被删除,则平均工资将会改变,这样<code>delete</code>的最后结果将依赖于元组被处理的顺序</p><h3 id="MySQL写法"><a href="#MySQL写法" class="headerlink" title="MySQL写法"></a>MySQL写法</h3><p>上面的代码在<code>MySQL</code>里测试会报错:<code>You can&#39;t specify target table &#39;instructor&#39; for update in FROM clause</code><br>因为在<code>MYSQL</code>里，不能先<code>select</code>一个表的记录，在按此条件进行更新和删除同一个表的记录，<br>解决办法是，<strong>将<code>select</code>得到的结果，再通过中间表<code>select</code>一遍</strong>，这样就规避了错误，<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> salary &lt; (</span><br><span class="line">    <span class="keyword">select</span> avg_salary <span class="keyword">from</span> (</span><br><span class="line">        <span class="keyword">select</span> <span class="keyword">avg</span>(salary) <span class="keyword">as</span> avg_salary <span class="keyword">from</span> instructor</span><br><span class="line">    ) I</span><br><span class="line">);</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; delete from instructor</span><br><span class="line">where salary &lt; (</span><br><span class="line">    select avg_salary from (</span><br><span class="line">        select avg(salary) as avg_salary from instructor</span><br><span class="line">    ) I</span><br><span class="line">);</span><br><span class="line">Query OK, <span class="number">5</span> rows affected</span><br></pre></td></tr></table></figure><br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第3章 SQL </category>
          
          <category> 3.9 数据库的修改 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.8.7 标量子查询</title>
      <link href="/ReadingNotes//43ada1c3/"/>
      <url>/ReadingNotes//43ada1c3/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/43ada1c3/#3-8-7-标量子查询" class="header_1">3.8.7 标量子查询</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="3-8-7-标量子查询"><a href="#3-8-7-标量子查询" class="headerlink" title="3.8.7 标量子查询"></a>3.8.7 标量子查询</h1><p><code>SQL</code>允许子查询出现在返回单个值的表达式能够出现的任何地方,只要该子查询只返回包含单个属性的单个元组;这样的子查询称为<strong>标量子查询</strong>(<code>scalar subquery)</code>。<br>例如,一个子查询可以用到下面例子的<code>select</code>子句中,这个例子<strong>列出所有的系以及它们拥有的教师数</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> dept_name,(</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">count</span>(*)<span class="keyword">from</span> instructor</span><br><span class="line">    <span class="keyword">where</span> department.dept_name=instructor.dept_name</span><br><span class="line">) <span class="keyword">as</span> num_instructors</span><br><span class="line"><span class="keyword">from</span> department;</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select dept_name,(</span><br><span class="line">    select count(*)from instructor</span><br><span class="line">    where department.dept_name=instructor.dept_name</span><br><span class="line">) as num_instructors</span><br><span class="line">from department;</span><br><span class="line">+------------+-----------------+</span><br><span class="line">| dept_name  | num_instructors |</span><br><span class="line">+------------+-----------------+</span><br><span class="line">| Biology    |               <span class="number">1</span> |</span><br><span class="line">| <span class="built_in">Comp</span>. Sci. |               <span class="number">3</span> |</span><br><span class="line">| Elec. Eng. |               <span class="number">1</span> |</span><br><span class="line">| Finance    |               <span class="number">2</span> |</span><br><span class="line">| History    |               <span class="number">2</span> |</span><br><span class="line">| Music      |               <span class="number">1</span> |</span><br><span class="line">| Physics    |               <span class="number">2</span> |</span><br><span class="line">+------------+-----------------+</span><br><span class="line"><span class="number">7</span> rows <span class="keyword">in</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure><br>上面例子中的<strong>子查询保证只返回单个值</strong>,因为它使用了不带<code>group by</code>的<code>count(*)</code>聚集函数。此例也说明了对<strong>相关变量</strong>的使用,即使用在外层查询的<code>from</code>子句中关系的属性,例如上例中的<code>department.dept_name;</code></p><p>标量子查询可以出现在<code>select</code>、 <code>where</code>和<code>having</code>子句中。也可以不使用聚集函数来定义标量子查询。在编译时并非总能判断一个子査询返回的结果中是否有多个元组,如果在子査询被执行后其结果中有不止一个元组,则产生一个运行时错误。<br>注意从技术上讲标量子查询的结果类型仍然是关系,尽管其中只包含单个元组。然而,当在表达式中使用标量子查询时,它出现的位置是单个值出现的地方,<code>SQL</code>就从该关系中包含单属性的单元组中取出相应的值,并返回该值。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第3章 SQL </category>
          
          <category> 3.8 嵌套子查询 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.8.6 with子句</title>
      <link href="/ReadingNotes//4fa458b7/"/>
      <url>/ReadingNotes//4fa458b7/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/4fa458b7/#3-8-6-with子句" class="header_1">3.8.6 with子句</a>&nbsp;<br><a href="/ReadingNotes/4fa458b7/#SQL查询-找出具有最大预算值的系" class="header_2">SQL查询 找出具有最大预算值的系</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="3-8-6-with子句"><a href="#3-8-6-with子句" class="headerlink" title="3.8.6 with子句"></a>3.8.6 with子句</h1><p><code>with</code>子句提供<strong>定义临时关系</strong>的方法,这个定义只对包含<code>with</code>子句的查询有效。<br><!--SSTStop--></p><h2 id="SQL查询-找出具有最大预算值的系"><a href="#SQL查询-找出具有最大预算值的系" class="headerlink" title="SQL查询 找出具有最大预算值的系"></a>SQL查询 找出具有最大预算值的系</h2><p>考虑下面的查询,它找出具有最大预算值的系。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> max_budget(<span class="keyword">value</span>) <span class="keyword">as</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">max</span>(budget)</span><br><span class="line">    <span class="keyword">from</span> department</span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> budget</span><br><span class="line"><span class="keyword">from</span> department, max_budget</span><br><span class="line"><span class="keyword">where</span> department.budget=max_budget.value;</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; with max_budget(value) as (</span><br><span class="line">    select max(budget)</span><br><span class="line">    from department</span><br><span class="line">)</span><br><span class="line">select budget</span><br><span class="line">from department, max_budget</span><br><span class="line">where department.budget=max_budget.value;</span><br><span class="line">+--------+</span><br><span class="line">| budget |</span><br><span class="line">+--------+</span><br><span class="line">| <span class="number">120000</span> |</span><br><span class="line">+--------+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure><br>我们也能用<code>from</code>子句或<code>where</code>子句中的嵌套子查询书写上述查询。但是,用嵌套子查询会使得查询语句晦涩难懂。<code>with</code>子句使査询在逻辑上更加清晰,它还允许在一个查询内的多个地方使用视图定义。<br>例如,假设我们要<strong>查出所有工资总额大于所有系平均工资总额的系</strong>,我们可以利用如下<code>with</code>子句写出查询:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> dept_total(dept_name,<span class="keyword">value</span>) <span class="keyword">as</span> (</span><br><span class="line">    <span class="keyword">select</span> dept_name, <span class="keyword">sum</span>(salary)</span><br><span class="line">    <span class="keyword">from</span> instructor</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> dept_name</span><br><span class="line">),</span><br><span class="line">dept_total_avg(<span class="keyword">value</span>) <span class="keyword">as</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">avg</span>(<span class="keyword">value</span>) <span class="keyword">from</span> dept_total</span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> dept_name</span><br><span class="line"><span class="keyword">from</span> dept_total,dept_total_avg</span><br><span class="line"><span class="keyword">where</span> dept_total.value&gt;=dept_total_avg.value;</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; with dept_total(dept_name,value) as (</span><br><span class="line">    select dept_name, sum(salary)</span><br><span class="line">    from instructor</span><br><span class="line">    group by dept_name</span><br><span class="line">),</span><br><span class="line">dept_total_avg(value) as (</span><br><span class="line">    select avg(value) from dept_total</span><br><span class="line">)</span><br><span class="line">select dept_name</span><br><span class="line">from dept_total,dept_total_avg</span><br><span class="line">where dept_total.value&gt;=dept_total_avg.value;</span><br><span class="line">+------------+</span><br><span class="line">| dept_name  |</span><br><span class="line">+------------+</span><br><span class="line">| <span class="built_in">Comp</span>. Sci. |</span><br><span class="line">| Finance    |</span><br><span class="line">| Physics    |</span><br><span class="line">+------------+</span><br><span class="line"><span class="number">3</span> rows <span class="keyword">in</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure><br>我们当然也可以不用<code>with</code>子句来建立等价的查询,但是那样会复杂很多,而且也不易看懂.</p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第3章 SQL </category>
          
          <category> 3.8 嵌套子查询 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.8.5 from子句中的子查询</title>
      <link href="/ReadingNotes//1c1e5c0b/"/>
      <url>/ReadingNotes//1c1e5c0b/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/1c1e5c0b/#3-8-5-from子句中的子查询" class="header_1">3.8.5 from子句中的子查询</a>&nbsp;<br><a href="/ReadingNotes/1c1e5c0b/#SQL查询-找出系平均工资超过42000美元的那些系中教师的平均工资" class="header_2">SQL查询 找出系平均工资超过42000美元的那些系中教师的平均工资</a>&nbsp;<br><a href="/ReadingNotes/1c1e5c0b/#重命名from子查询的结果关系" class="header_2">重命名from子查询的结果关系</a>&nbsp;<br><a href="/ReadingNotes/1c1e5c0b/#数据库实现对from子查询的支持" class="header_2">数据库实现对from子查询的支持</a>&nbsp;<br><a href="/ReadingNotes/1c1e5c0b/#MySQL必须给from自己的子查询取别名" class="header_3">MySQL必须给from自己的子查询取别名</a>&nbsp;<br><a href="/ReadingNotes/1c1e5c0b/#SQL查询-找出在所有系中工资总额最大的系" class="header_2">SQL查询 找出在所有系中工资总额最大的系</a>&nbsp;<br><a href="/ReadingNotes/1c1e5c0b/#子查询访问外层查询的相关变量-lateral关键词" class="header_2">子查询访问外层查询的相关变量 lateral关键词</a>&nbsp;<br><a href="/ReadingNotes/1c1e5c0b/#数据库实现支持" class="header_2">数据库实现支持</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="3-8-5-from子句中的子查询"><a href="#3-8-5-from子句中的子查询" class="headerlink" title="3.8.5 from子句中的子查询"></a>3.8.5 from子句中的子查询</h1><p><code>SQL</code>允许在<code>from</code>子句中使用子查询表达式。因为任何<code>select-from-where</code>表达式返回的结果都是<code>关系</code>,所以<code>子查询</code>可以被插入到另一个<code>select-from- where</code>中任何<strong>关系可以出现的位置</strong>。</p><h2 id="SQL查询-找出系平均工资超过42000美元的那些系中教师的平均工资"><a href="#SQL查询-找出系平均工资超过42000美元的那些系中教师的平均工资" class="headerlink" title="SQL查询 找出系平均工资超过42000美元的那些系中教师的平均工资"></a>SQL查询 找出系平均工资超过42000美元的那些系中教师的平均工资</h2><p>考虑査询”<strong>找出系平均工资超过42000美元的那些系中教师的平均工资</strong>“。在3.7节我们使用了<code>having</code>子句来书写此查询。现在我们可以不用<code>having</code>子句来重写这个查询,而是通过如下这种在<code>from</code>子句中使用子查询的方式:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> dept_name,avg_salary</span><br><span class="line"><span class="keyword">from</span> ( <span class="keyword">select</span> dept_name, <span class="keyword">avg</span>(salary) <span class="keyword">as</span> avg_salary</span><br><span class="line">    <span class="keyword">from</span> instructor </span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> dept_name</span><br><span class="line">) <span class="keyword">as</span> I</span><br><span class="line"><span class="keyword">where</span> avg_salary&gt;<span class="number">42000</span>;</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select dept_name,avg_salary</span><br><span class="line">from ( select dept_name, avg(salary) as avg_salary</span><br><span class="line">    from instructor </span><br><span class="line">    group by dept_name</span><br><span class="line">) as I</span><br><span class="line">where avg_salary&gt;<span class="number">42000</span>;</span><br><span class="line">+------------+--------------+</span><br><span class="line">| dept_name  | avg_salary   |</span><br><span class="line">+------------+--------------+</span><br><span class="line">| Biology    | <span class="number">72000</span>        |</span><br><span class="line">| <span class="built_in">Comp</span>. Sci. | <span class="number">77333</span>.<span class="number">333333</span> |</span><br><span class="line">| Elec. Eng. | <span class="number">80000</span>        |</span><br><span class="line">| Finance    | <span class="number">85000</span>        |</span><br><span class="line">| History    | <span class="number">61000</span>        |</span><br><span class="line">| Physics    | <span class="number">91000</span>        |</span><br><span class="line">+------------+--------------+</span><br><span class="line"><span class="number">6</span> rows <span class="keyword">in</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure><br>子查询:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">( <span class="keyword">select</span> dept_name, <span class="keyword">avg</span>(salary) <span class="keyword">as</span> avg_salary</span><br><span class="line">    <span class="keyword">from</span> instructor </span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> dept_name</span><br><span class="line">) <span class="keyword">as</span> I</span><br></pre></td></tr></table></figure><br>产生的关系包含所有系的名字和相应的教师平均工资。子查询的结果属性可以在外层查询中使用.</p><p>注意我们不需要使用<code>having</code>子句,因为<code>from</code>子句中的子查询计算出了每个系的平均工资,早先在<code>having</code>子句中使用的谓词现在出现在外层查询的<code>where</code>子句中。</p><h2 id="重命名from子查询的结果关系"><a href="#重命名from子查询的结果关系" class="headerlink" title="重命名from子查询的结果关系"></a>重命名from子查询的结果关系</h2><p>我们可以用<strong><code>as</code>子句重命名子查询的结果关系</strong>,也可以<strong>使用as子句重命名子查询的属性</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> dept_name,avg_salary</span><br><span class="line"><span class="keyword">from</span>( <span class="keyword">select</span> dept_name, <span class="keyword">avg</span>(salary) <span class="keyword">as</span> avg_salary</span><br><span class="line">    <span class="keyword">from</span> instructor </span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> dept_name</span><br><span class="line">) <span class="keyword">as</span> dept_avg</span><br><span class="line"><span class="keyword">where</span> avg_salary &gt; <span class="number">42000</span>;</span><br></pre></td></tr></table></figure></p><h2 id="数据库实现对from子查询的支持"><a href="#数据库实现对from子查询的支持" class="headerlink" title="数据库实现对from子查询的支持"></a>数据库实现对from子查询的支持</h2><p>很多(但并非全部)<code>SQL</code>实现都支持在<code>from</code>子句中嵌套子查询。<br>请注意,<strong>某些<code>SQL</code>实现要求对每一个<code>from</code>子查询结果关系都给一个名字,即使该名字从不被引用</strong>;(<code>MySQL</code>)</p><h3 id="MySQL必须给from自己的子查询取别名"><a href="#MySQL必须给from自己的子查询取别名" class="headerlink" title="MySQL必须给from自己的子查询取别名"></a>MySQL必须给from自己的子查询取别名</h3><p>经过我的测试<strong><code>MySQL</code>必须对<code>from</code>子查询的结果关系取别名</strong>,不给子查询取别名会报错:<code>Every derived table must have its own alias</code>：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select dept_name,avg_salary</span><br><span class="line">from( select dept_name, avg(salary) as avg_salary</span><br><span class="line">    from instructor </span><br><span class="line">    group by dept_name</span><br><span class="line">)</span><br><span class="line">where avg_salary &gt; <span class="number">42000</span>;</span><br><span class="line"><span class="number">1248</span> - Every derived table must have its own alias</span><br></pre></td></tr></table></figure></p><h2 id="SQL查询-找出在所有系中工资总额最大的系"><a href="#SQL查询-找出在所有系中工资总额最大的系" class="headerlink" title="SQL查询 找出在所有系中工资总额最大的系"></a>SQL查询 找出在所有系中工资总额最大的系</h2><p>作为另一个例子,假设我们想要<strong>找出在所有系中工资总额最大的系</strong>。在此<code>having</code>子句是无能为力的,但我们可以用<code>from</code>子句中的子查询轻易地写出如下查询<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">max</span>(tot_salary)</span><br><span class="line"><span class="keyword">from</span>(</span><br><span class="line">    <span class="keyword">select</span> dept_name, <span class="keyword">sum</span>(salary) <span class="keyword">as</span> tot_salary</span><br><span class="line">        <span class="keyword">from</span> instructor</span><br><span class="line">        <span class="keyword">group</span> <span class="keyword">by</span> dept_name</span><br><span class="line">)<span class="keyword">as</span> dept_total;</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">select max(tot_salary)</span><br><span class="line">from(</span><br><span class="line">    select dept_name, sum(salary) as tot_salary</span><br><span class="line">        from instructor</span><br><span class="line">        group by dept_name</span><br><span class="line">)as dept_total;</span><br><span class="line">+-----------------+</span><br><span class="line">| max(tot_salary) |</span><br><span class="line">+-----------------+</span><br><span class="line">| <span class="number">232000</span>.<span class="number">00</span>       |</span><br><span class="line">+-----------------+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure><br>我们注意到在<code>from</code>子句嵌套的子查询中不能使用来自<code>from</code>子句其他关系的<strong>相关变量</strong>。</p><h2 id="子查询访问外层查询的相关变量-lateral关键词"><a href="#子查询访问外层查询的相关变量-lateral关键词" class="headerlink" title="子查询访问外层查询的相关变量 lateral关键词"></a>子查询访问外层查询的相关变量 lateral关键词</h2><p>然而<code>SQL2003</code>允许<code>from</code>子句中的子查询用关键词<code>lateral</code>作为前缀,以便访问<code>from</code>子句中在它前面的表或子查询中的属性。<br>例如,如果我们想<strong>打印每位教师的姓名,以及他们的工资和所在系的平均工资</strong>,可书写查询如下:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, salary, avg_salary</span><br><span class="line"><span class="keyword">from</span> instructor I1,<span class="keyword">lateral</span>(</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">avg</span>(salary) <span class="keyword">as</span> avg_salary</span><br><span class="line">    <span class="keyword">from</span> instructor I2</span><br><span class="line">    <span class="keyword">where</span> I1.dept_name=I2.dept_name</span><br><span class="line">);</span><br></pre></td></tr></table></figure><br>没有<code>lateral</code>子句的话,子查询就不能访问来自外层查询的相关变量<code>I1</code>。</p><h2 id="数据库实现支持"><a href="#数据库实现支持" class="headerlink" title="数据库实现支持"></a>数据库实现支持</h2><p>目前只有少数<code>SQL</code>实现支持<code>lateral</code>子句,比如<code>IBM DB2</code><br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第3章 SQL </category>
          
          <category> 3.8 嵌套子查询 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.8.4 重复元组存在性测试</title>
      <link href="/ReadingNotes//79c746d6/"/>
      <url>/ReadingNotes//79c746d6/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/79c746d6/#3-8-4-重复元组存在性测试" class="header_1">3.8.4 重复元组存在性测试</a>&nbsp;<br><a href="/ReadingNotes/79c746d6/#unique" class="header_2">unique</a>&nbsp;<br><a href="/ReadingNotes/79c746d6/#unique结果为真的情况" class="header_3">unique结果为真的情况</a>&nbsp;<br><a href="/ReadingNotes/79c746d6/#unique结果为假的情况" class="header_3">unique结果为假的情况</a>&nbsp;<br><a href="/ReadingNotes/79c746d6/#注意空值" class="header_3">注意空值</a>&nbsp;<br><a href="/ReadingNotes/79c746d6/#-SQL-查询-找出所有在2009年最多开设一次的课程" class="header_2">`SQL`查询 找出所有在2009年最多开设一次的课程</a>&nbsp;<br><a href="/ReadingNotes/79c746d6/#-MySQL-好像不支持-unique-结构" class="header_2">`MySQL`好像不支持`unique`结构</a>&nbsp;<br><a href="/ReadingNotes/79c746d6/#not-unique" class="header_2">not unique</a>&nbsp;<br><a href="/ReadingNotes/79c746d6/#-MySQL-也不支持-not-unique" class="header_2">`MySQL`也不支持`not unique`</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="3-8-4-重复元组存在性测试"><a href="#3-8-4-重复元组存在性测试" class="headerlink" title="3.8.4 重复元组存在性测试"></a>3.8.4 重复元组存在性测试</h1><h2 id="unique"><a href="#unique" class="headerlink" title="unique"></a>unique</h2><p><code>SQL</code>提供一个<code>unique</code>结构用于测试在一个子查询的结果中是否存在重复元组。</p><h3 id="unique结果为真的情况"><a href="#unique结果为真的情况" class="headerlink" title="unique结果为真的情况"></a>unique结果为真的情况</h3><p><strong>如果作为参数的子查询结果中没有重复的元组, <code>unique</code>结构将返回<code>true</code>值</strong>。</p><h3 id="unique结果为假的情况"><a href="#unique结果为假的情况" class="headerlink" title="unique结果为假的情况"></a>unique结果为假的情况</h3><p>当且仅当在关系中存在着两个元组t1和t2,且t1=t2时<code>unique</code>测试结果为假</p><h3 id="注意空值"><a href="#注意空值" class="headerlink" title="注意空值"></a>注意空值</h3><p>由于在t1或t2的某个域为空时,判断t1=t2为假,所以尽管一个元组有多个副本,只要该元组有一个属性为空, <code>unique</code>测试就有可能为真。</p><h2 id="SQL查询-找出所有在2009年最多开设一次的课程"><a href="#SQL查询-找出所有在2009年最多开设一次的课程" class="headerlink" title="SQL查询 找出所有在2009年最多开设一次的课程"></a><code>SQL</code>查询 找出所有在2009年最多开设一次的课程</h2><p>我们可以用<code>unique</code>结构书写查询”找出所有在2009年最多开设一次的课程”,如下所示:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> T.course_id</span><br><span class="line"><span class="keyword">from</span> course <span class="keyword">as</span> T</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">unique</span>(</span><br><span class="line">    <span class="keyword">select</span> R.course_id</span><br><span class="line">    <span class="keyword">from</span> <span class="keyword">section</span> <span class="keyword">as</span> R</span><br><span class="line">    <span class="keyword">where</span> T.course_id=R.course_id <span class="keyword">and</span> R.year=<span class="number">2009</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><br>注意如果某门课程不在2009年开设,那么子查询会返回一个空的结果, <code>unique</code>谓词在空集上计算出真值。</p><h2 id="MySQL好像不支持unique结构"><a href="#MySQL好像不支持unique结构" class="headerlink" title="MySQL好像不支持unique结构"></a><code>MySQL</code>好像不支持<code>unique</code>结构</h2><p>在不使用<code>unique</code>结构的情况下,上述查询的一种等价表达方式是<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> T.course_id</span><br><span class="line"><span class="keyword">from</span> course <span class="keyword">as</span> T</span><br><span class="line"><span class="keyword">where</span> <span class="number">1</span> &gt;=(</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">count</span>(R.course_id)</span><br><span class="line">        <span class="keyword">from</span> <span class="keyword">section</span> <span class="keyword">as</span> R</span><br><span class="line">        <span class="keyword">where</span> T.course_id =R.course_id <span class="keyword">and</span> R.year=<span class="number">2009</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select T.course_id</span><br><span class="line">from course as T</span><br><span class="line">where <span class="number">1</span> &gt;=(</span><br><span class="line">    select count(R.course_id)</span><br><span class="line">        from section as R</span><br><span class="line">        where T.course_id =R.course_id and R.year=<span class="number">2009</span></span><br><span class="line">);</span><br><span class="line">+-----------+</span><br><span class="line">| course_id |</span><br><span class="line">+-----------+</span><br><span class="line">| BIO-<span class="number">101</span>   |</span><br><span class="line">| BIO-<span class="number">301</span>   |</span><br><span class="line">| BIO-<span class="number">399</span>   |</span><br><span class="line">| CS-<span class="number">101</span>    |</span><br><span class="line">| CS-<span class="number">315</span>    |</span><br><span class="line">| CS-<span class="number">319</span>    |</span><br><span class="line">| CS-<span class="number">347</span>    |</span><br><span class="line">| EE-<span class="number">181</span>    |</span><br><span class="line">| FIN-<span class="number">201</span>   |</span><br><span class="line">| HIS-<span class="number">351</span>   |</span><br><span class="line">| MU-<span class="number">199</span>    |</span><br><span class="line">| PHY-<span class="number">101</span>   |</span><br><span class="line">+-----------+</span><br><span class="line"><span class="number">12</span> rows <span class="keyword">in</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure></p><h2 id="not-unique"><a href="#not-unique" class="headerlink" title="not unique"></a>not unique</h2><p>我们可以用<code>not unique</code>结构测试在一个子查询结果中是否存在重复元组。为了说明这一结构,考虑查询”找出所有在2009年最少开设两次的课程”,如下所示:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> T.course_id</span><br><span class="line"><span class="keyword">from</span> course <span class="keyword">as</span> T</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">unique</span>(</span><br><span class="line">    <span class="keyword">select</span> R&gt;course_id</span><br><span class="line">        <span class="keyword">from</span> <span class="keyword">section</span> <span class="keyword">as</span> R</span><br><span class="line">        <span class="keyword">where</span> T.course_id= R.course_id <span class="keyword">and</span> R.year=<span class="number">2009</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><h2 id="MySQL也不支持not-unique"><a href="#MySQL也不支持not-unique" class="headerlink" title="MySQL也不支持not unique"></a><code>MySQL</code>也不支持<code>not unique</code></h2><!--SSTStop-->]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第3章 SQL </category>
          
          <category> 3.8 嵌套子查询 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.8.3 空关系测试</title>
      <link href="/ReadingNotes//b1a8955d/"/>
      <url>/ReadingNotes//b1a8955d/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/b1a8955d/#3-8-3-空关系测试" class="header_1">3.8.3 空关系测试</a>&nbsp;<br><a href="/ReadingNotes/b1a8955d/#exists" class="header_2">exists</a>&nbsp;<br><a href="/ReadingNotes/b1a8955d/#相关子查询" class="header_2">相关子查询</a>&nbsp;<br><a href="/ReadingNotes/b1a8955d/#子查询只能使用自己定义的相关名称-或者外层查询定义的相关名称" class="header_2">子查询只能使用自己定义的相关名称,或者外层查询定义的相关名称</a>&nbsp;<br><a href="/ReadingNotes/b1a8955d/#内外层相关名称重名时-内层相关名称有效" class="header_2">内外层相关名称重名时,内层相关名称有效</a>&nbsp;<br><a href="/ReadingNotes/b1a8955d/#not-exists" class="header_2">not exists</a>&nbsp;<br><a href="/ReadingNotes/b1a8955d/#关系A是否包含关系B-not-exists-B-except-A" class="header_3">关系A是否包含关系B not exists( B except A)</a>&nbsp;<br><a href="/ReadingNotes/b1a8955d/#-SQL-查询-找出选修了Biology系开设的所有课程的学生" class="header_3">`SQL`查询 找出选修了Biology系开设的所有课程的学生</a>&nbsp;<br><a href="/ReadingNotes/b1a8955d/#找出Biology系开设的所有课程集合" class="header_4">找出Biology系开设的所有课程集合</a>&nbsp;<br><a href="/ReadingNotes/b1a8955d/#找出-S-ID-选修的所有课程" class="header_4">找出`S.ID`选修的所有课程</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="3-8-3-空关系测试"><a href="#3-8-3-空关系测试" class="headerlink" title="3.8.3 空关系测试"></a>3.8.3 空关系测试</h1><p><code>SQL</code>还有一个特性可<strong>测试一个子查询的结果中是否存在元组</strong>。 </p><h2 id="exists"><a href="#exists" class="headerlink" title="exists"></a>exists</h2><p><strong><code>exists</code>结构在作为参数的子查询非空时返回<code>true</code>值</strong>。使用<code>exists</code>结构,我们还能用另外一种方法书写査询”<strong>找出在2009年秋季学期和2010年春季学期同时开课的所有课程</strong>“<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> course_id</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">section</span> <span class="keyword">as</span> S</span><br><span class="line"><span class="keyword">where</span> semester=<span class="string">'Fall'</span> <span class="keyword">and</span> <span class="keyword">year</span>=<span class="number">2009</span> <span class="keyword">and</span> <span class="keyword">exists</span>(</span><br><span class="line">    <span class="keyword">select</span> *</span><br><span class="line">    <span class="keyword">from</span> <span class="keyword">section</span> <span class="keyword">as</span> T</span><br><span class="line">    <span class="keyword">where</span> semester =<span class="string">'Spring'</span> <span class="keyword">and</span> <span class="keyword">year</span>=<span class="number">2010</span> <span class="keyword">and</span> S.course_id= T.course_id</span><br><span class="line">);</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select course_id</span><br><span class="line">from section as S</span><br><span class="line">where semester='Fall' and year=<span class="number">2009</span> and exists(</span><br><span class="line">    select *</span><br><span class="line">    from section as T</span><br><span class="line">    where semester ='Spring' and year=<span class="number">2010</span> and S.course_id= T.course_id</span><br><span class="line">);</span><br><span class="line">+-----------+</span><br><span class="line">| course_id |</span><br><span class="line">+-----------+</span><br><span class="line">| CS-<span class="number">101</span>    |</span><br><span class="line">+-----------+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure><br>上述査询还说明了<code>SQL</code>的一个特性,<strong>来自外层查询的一个相关名称(上述查询中的S)可以用在<code>where</code>子句的子查询中</strong>。</p><h2 id="相关子查询"><a href="#相关子查询" class="headerlink" title="相关子查询"></a>相关子查询</h2><p><strong>使用了来自外层查询相关名称的子查询被称作相关子查询</strong>(<code>correlated subquery</code>)。</p><h2 id="子查询只能使用自己定义的相关名称-或者外层查询定义的相关名称"><a href="#子查询只能使用自己定义的相关名称-或者外层查询定义的相关名称" class="headerlink" title="子查询只能使用自己定义的相关名称,或者外层查询定义的相关名称"></a>子查询只能使用自己定义的相关名称,或者外层查询定义的相关名称</h2><p>在包含了子查询的查询中,在相关名称上可以应用<code>作用域规则</code>。根据此规则,在一个子查询中只能使用此子查询本身定义的,或者在包含这个子查询的任何外部查询中定义的相关名称。</p><h2 id="内外层相关名称重名时-内层相关名称有效"><a href="#内外层相关名称重名时-内层相关名称有效" class="headerlink" title="内外层相关名称重名时,内层相关名称有效"></a>内外层相关名称重名时,内层相关名称有效</h2><p>如果一个相关名称既在子查询中定义,又在包含该子查询的查询中定义,则子查询中的定义有效。这条规则类似于编程语言中通用的<strong>变量作用域规则</strong>(重名局部变量覆盖成员变量.)。</p><h2 id="not-exists"><a href="#not-exists" class="headerlink" title="not exists"></a>not exists</h2><p>我们可以用<code>not exists</code>结构测试子查询结果集中是否不存在元组。</p><h3 id="关系A是否包含关系B-not-exists-B-except-A"><a href="#关系A是否包含关系B-not-exists-B-except-A" class="headerlink" title="关系A是否包含关系B not exists( B except A)"></a>关系A是否包含关系B not exists( B except A)</h3><p>我们可以使用<code>not exists</code>结构模拟集合<strong>包含</strong>(即超集)操作:我们可将”<strong>关系A包含关系B</strong>“写成” <code>not exists( B except A)</code>“。(尽管<code>contains</code>运算符并不是当前<code>SQL</code>标准的一部分,但这一运算符曾出现在某些早期的关系系统中。)</p><h3 id="SQL查询-找出选修了Biology系开设的所有课程的学生"><a href="#SQL查询-找出选修了Biology系开设的所有课程的学生" class="headerlink" title="SQL查询 找出选修了Biology系开设的所有课程的学生"></a><code>SQL</code>查询 找出选修了Biology系开设的所有课程的学生</h3><p>为了说明<code>not exists</code>操作符,考虑查询”<strong>找出选修了<code>Biology</code>系开设的所有课程的学生</strong>“。使用<code>except</code>结构我们可以书写此查询如下:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> S.ID,S.name</span><br><span class="line"><span class="keyword">from</span> student <span class="keyword">as</span> S</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span>((</span><br><span class="line">    <span class="keyword">select</span> course_id</span><br><span class="line">    <span class="keyword">from</span> course</span><br><span class="line">    <span class="keyword">where</span> dept_name =<span class="string">'Biology'</span></span><br><span class="line">) <span class="keyword">except</span> (</span><br><span class="line">    <span class="keyword">select</span> T.course_ID</span><br><span class="line">    <span class="keyword">from</span> takes <span class="keyword">as</span> T</span><br><span class="line">    <span class="keyword">where</span> S.ID= T.ID</span><br><span class="line">));</span><br></pre></td></tr></table></figure></p><h4 id="找出Biology系开设的所有课程集合"><a href="#找出Biology系开设的所有课程集合" class="headerlink" title="找出Biology系开设的所有课程集合"></a>找出Biology系开设的所有课程集合</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> course_id</span><br><span class="line"><span class="keyword">from</span> course</span><br><span class="line"><span class="keyword">where</span> dept_name =<span class="string">'Biology'</span></span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select course_id</span><br><span class="line">from course</span><br><span class="line">where dept_name ='Biology';</span><br><span class="line">+-----------+</span><br><span class="line">| course_id |</span><br><span class="line">+-----------+</span><br><span class="line">| BIO-<span class="number">101</span>   |</span><br><span class="line">| BIO-<span class="number">301</span>   |</span><br><span class="line">| BIO-<span class="number">399</span>   |</span><br><span class="line">+-----------+</span><br><span class="line"><span class="number">3</span> rows <span class="keyword">in</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure><h4 id="找出S-ID选修的所有课程"><a href="#找出S-ID选修的所有课程" class="headerlink" title="找出S.ID选修的所有课程"></a>找出<code>S.ID</code>选修的所有课程</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> T.course_ID</span><br><span class="line">    <span class="keyword">from</span> takes <span class="keyword">as</span> T</span><br><span class="line">    <span class="keyword">where</span> S.ID= T.ID</span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select S.ID ,T.course_ID</span><br><span class="line">from takes as T,student as S</span><br><span class="line">where S.ID= T.ID;</span><br><span class="line">+-------+-----------+</span><br><span class="line">| ID    | course_ID |</span><br><span class="line">+-------+-----------+</span><br><span class="line">| <span class="number">98988</span> | BIO-<span class="number">101</span>   |</span><br><span class="line">| <span class="number">98988</span> | BIO-<span class="number">301</span>   |</span><br><span class="line">| <span class="number">00128</span> | CS-<span class="number">101</span>    |</span><br><span class="line">| <span class="number">00128</span> | CS-<span class="number">347</span>    |</span><br><span class="line">| <span class="number">12345</span> | CS-<span class="number">101</span>    |</span><br><span class="line">| <span class="number">12345</span> | CS-<span class="number">190</span>    |</span><br><span class="line">| <span class="number">12345</span> | CS-<span class="number">315</span>    |</span><br><span class="line">| <span class="number">12345</span> | CS-<span class="number">347</span>    |</span><br><span class="line">| <span class="number">54321</span> | CS-<span class="number">101</span>    |</span><br><span class="line">| <span class="number">54321</span> | CS-<span class="number">190</span>    |</span><br><span class="line">| <span class="number">76543</span> | CS-<span class="number">101</span>    |</span><br><span class="line">| <span class="number">76543</span> | CS-<span class="number">319</span>    |</span><br><span class="line">| <span class="number">76653</span> | EE-<span class="number">181</span>    |</span><br><span class="line">| <span class="number">98765</span> | CS-<span class="number">101</span>    |</span><br><span class="line">| <span class="number">98765</span> | CS-<span class="number">315</span>    |</span><br><span class="line">| <span class="number">23121</span> | FIN-<span class="number">201</span>   |</span><br><span class="line">| <span class="number">19991</span> | HIS-<span class="number">351</span>   |</span><br><span class="line">| <span class="number">55739</span> | MU-<span class="number">199</span>    |</span><br><span class="line">| <span class="number">44553</span> | PHY-<span class="number">101</span>   |</span><br><span class="line">| <span class="number">45678</span> | CS-<span class="number">101</span>    |</span><br><span class="line">| <span class="number">45678</span> | CS-<span class="number">101</span>    |</span><br><span class="line">| <span class="number">45678</span> | CS-<span class="number">319</span>    |</span><br><span class="line">+-------+-----------+</span><br><span class="line"><span class="number">22</span> rows <span class="keyword">in</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure><p>这样,外层<code>select</code>对每个学生测试其选修的所有课程集合是否<strong>包含</strong><code>Biology</code>系开设的所有课程集合。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第3章 SQL </category>
          
          <category> 3.8 嵌套子查询 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.8.2 集合的比较</title>
      <link href="/ReadingNotes//7e81718d/"/>
      <url>/ReadingNotes//7e81718d/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/7e81718d/#3-8-2-集合的比较" class="header_1">3.8.2 集合的比较</a>&nbsp;<br><a href="/ReadingNotes/7e81718d/#SQL查询-找出满足下面条件的所有-教师-的-姓名-他们的-工资-至少比-Biology-系某一个教师的工资要高" class="header_2">SQL查询 找出满足下面条件的所有`教师`的`姓名`,他们的`工资`至少比`Biology`系某一个教师的工资要高</a>&nbsp;<br><a href="/ReadingNotes/7e81718d/#写法1" class="header_3">写法1</a>&nbsp;<br><a href="/ReadingNotes/7e81718d/#写法2" class="header_3">写法2</a>&nbsp;<br><a href="/ReadingNotes/7e81718d/#子查询-产生-Biology-系所有教师的所有工资值的集合" class="header_3">子查询 产生`Biology`系所有教师的所有工资值的集合</a>&nbsp;<br><a href="/ReadingNotes/7e81718d/#至少大于其中一个->some" class="header_3">至少大于其中一个`>some`</a>&nbsp;<br><a href="/ReadingNotes/7e81718d/#some详解" class="header_2">some详解</a>&nbsp;<br><a href="/ReadingNotes/7e81718d/#其他运算符和some组合的情况" class="header_3">其他运算符和some组合的情况</a>&nbsp;<br><a href="/ReadingNotes/7e81718d/#-=some-等价于in" class="header_3">`=some`等价于in</a>&nbsp;<br><a href="/ReadingNotes/7e81718d/#-<>some-不等价与-not-in" class="header_3">`<>some`不等价与`not in`</a>&nbsp;<br><a href="/ReadingNotes/7e81718d/#SQL查询-找出-工资值-比-Biology-系每个教师的工资-都高-的所有教师的-姓名" class="header_2">SQL查询 找出`工资值`比`Biology`系每个教师的工资`都高`的所有教师的`姓名`</a>&nbsp;<br><a href="/ReadingNotes/7e81718d/#all详解" class="header_2">all详解</a>&nbsp;<br><a href="/ReadingNotes/7e81718d/#-<>all-等价于-not-in" class="header_3">`<>all`等价于`not in`</a>&nbsp;<br><a href="/ReadingNotes/7e81718d/#-=all-不等价与in" class="header_3">`=all`不等价与in</a>&nbsp;<br><a href="/ReadingNotes/7e81718d/#SQL查询-找出平均工资最高的系" class="header_2">SQL查询 找出平均工资最高的系</a>&nbsp;<br><a href="/ReadingNotes/7e81718d/#any" class="header_2">any</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="3-8-2-集合的比较"><a href="#3-8-2-集合的比较" class="headerlink" title="3.8.2 集合的比较"></a>3.8.2 集合的比较</h1><h2 id="SQL查询-找出满足下面条件的所有教师的姓名-他们的工资至少比Biology系某一个教师的工资要高"><a href="#SQL查询-找出满足下面条件的所有教师的姓名-他们的工资至少比Biology系某一个教师的工资要高" class="headerlink" title="SQL查询 找出满足下面条件的所有教师的姓名,他们的工资至少比Biology系某一个教师的工资要高"></a>SQL查询 找出满足下面条件的所有<code>教师</code>的<code>姓名</code>,他们的<code>工资</code>至少比<code>Biology</code>系某一个教师的工资要高</h2><p>作为一个说明<code>嵌套子查询</code>能够对集合进行比较的例子,考虑查询”<strong>找出满足下面条件的所有<code>教师</code>的<code>姓名</code>,他们的<code>工资</code>至少比<code>Biology</code>系某一个教师的工资要高</strong>“。</p><h3 id="写法1"><a href="#写法1" class="headerlink" title="写法1"></a>写法1</h3><p>在3.4.1节,我们将此查询写作:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> T.name</span><br><span class="line"><span class="keyword">from</span> instructor <span class="keyword">as</span> T,instructor <span class="keyword">as</span> s</span><br><span class="line"><span class="keyword">where</span> T.salary &gt;S.salary <span class="keyword">and</span> S.dept_name = <span class="string">'Biology'</span>;</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select distinct T.name</span><br><span class="line">from instructor as T,instructor as s</span><br><span class="line">where T.salary &gt;S.salary and S.dept_name = 'Biology';</span><br><span class="line">+----------+</span><br><span class="line">| name     |</span><br><span class="line">+----------+</span><br><span class="line">| Wu       |</span><br><span class="line">| Einstein |</span><br><span class="line">| Gold     |</span><br><span class="line">| Katz     |</span><br><span class="line">| Singh    |</span><br><span class="line">| Brandt   |</span><br><span class="line">| Kim      |</span><br><span class="line">+----------+</span><br><span class="line"><span class="number">7</span> rows <span class="keyword">in</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure></p><h3 id="写法2"><a href="#写法2" class="headerlink" title="写法2"></a>写法2</h3><h3 id="子查询-产生Biology系所有教师的所有工资值的集合"><a href="#子查询-产生Biology系所有教师的所有工资值的集合" class="headerlink" title="子查询 产生Biology系所有教师的所有工资值的集合"></a>子查询 产生<code>Biology</code>系所有教师的所有工资值的集合</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(</span><br><span class="line"><span class="keyword">select</span> salary</span><br><span class="line">    <span class="keyword">from</span> instructor</span><br><span class="line">    <span class="keyword">where</span> dept_name =<span class="string">'Biology'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>产生<code>Biology</code>系所有教师的所有工资值的集合。</p><h3 id="至少大于其中一个-gt-some"><a href="#至少大于其中一个-gt-some" class="headerlink" title="至少大于其中一个&gt;some"></a>至少大于其中一个<code>&gt;some</code></h3><p>短语”<strong>至少比某一个要大</strong>“在<code>SQL</code>中用<code>&gt;some</code>表示。<code>&gt;some</code>短语允许我们用一种更贴近此查询的文字表达的形式重写上面的查询:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span></span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> salary &gt; <span class="keyword">some</span>(</span><br><span class="line">    <span class="keyword">select</span> salary</span><br><span class="line">        <span class="keyword">from</span> instructor</span><br><span class="line">        <span class="keyword">where</span> dept_name=<span class="string">'Biology'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select name</span><br><span class="line">from instructor</span><br><span class="line">where salary &gt; some(</span><br><span class="line">    select salary</span><br><span class="line">        from instructor</span><br><span class="line">        where dept_name='Biology'</span><br><span class="line">);</span><br><span class="line">+----------+</span><br><span class="line">| name     |</span><br><span class="line">+----------+</span><br><span class="line">| Wu       |</span><br><span class="line">| Einstein |</span><br><span class="line">| Gold     |</span><br><span class="line">| Katz     |</span><br><span class="line">| Singh    |</span><br><span class="line">| Brandt   |</span><br><span class="line">| Kim      |</span><br><span class="line">+----------+</span><br><span class="line"><span class="number">7</span> rows <span class="keyword">in</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure><br>当元组的<code>salary</code>值至少比<code>Biology</code>系教师的所有工资值集合中某一成员高时,外层<code>select</code>的<code>where</code>子句中<code>&gt;some</code>的比较为真。</p><h2 id="some详解"><a href="#some详解" class="headerlink" title="some详解"></a>some详解</h2><h3 id="其他运算符和some组合的情况"><a href="#其他运算符和some组合的情况" class="headerlink" title="其他运算符和some组合的情况"></a>其他运算符和some组合的情况</h3><ul><li><strong>至少<code>小于</code>其中一个</strong>(<code>&lt;some</code>),</li><li><strong>至少<code>小于等于</code>其中一个</strong>(<code>&lt;=some</code>),</li><li><strong>至少<code>大于等于</code>其中一个</strong>(<code>&gt;=some</code>),</li><li><strong>至少<code>等于</code>其中一个</strong>(<code>=some</code>)</li><li><strong>至少<code>不等于</code>其中一个</strong>(<code>&lt;&gt;some</code>),<code>SQL</code>中<code>&lt;&gt;</code>符号是<code>不等于</code>的意思</li></ul><h3 id="some等价于in"><a href="#some等价于in" class="headerlink" title="=some等价于in"></a><code>=some</code>等价于in</h3><p>因为<code>=some</code>的意思是<strong>至少等于其中一个</strong>,而<code>in</code>关键字,也是<strong>至少等于其中一个</strong>的意思,所以<code>=some</code>等价于<code>in</code>。</p><h3 id="lt-gt-some不等价与not-in"><a href="#lt-gt-some不等价与not-in" class="headerlink" title="&lt;&gt;some不等价与not in"></a><code>&lt;&gt;some</code>不等价与<code>not in</code></h3><ul><li><code>&lt;&gt;some</code>的意思是<strong>至少不等于其中任意一个</strong>,</li><li><code>not in</code>的意思是<strong>都不等于其中任意一个</strong>.</li></ul><p>可见<code>not in</code>要求比<code>&lt;&gt;some</code>要严格,所以<code>&lt;&gt;some</code>不等价于<code>not in</code>。</p><h2 id="SQL查询-找出工资值比Biology系每个教师的工资都高的所有教师的姓名"><a href="#SQL查询-找出工资值比Biology系每个教师的工资都高的所有教师的姓名" class="headerlink" title="SQL查询 找出工资值比Biology系每个教师的工资都高的所有教师的姓名"></a>SQL查询 找出<code>工资值</code>比<code>Biology</code>系每个教师的工资<code>都高</code>的所有教师的<code>姓名</code></h2><p>结构<code>&gt;all</code>对应于词组”<strong>比所有的都大</strong>“。使用该结构,我们写出査询如下:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span></span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> salary &gt;<span class="keyword">all</span>(</span><br><span class="line">    <span class="keyword">select</span> salary</span><br><span class="line">        <span class="keyword">from</span> instructor</span><br><span class="line">            <span class="keyword">where</span> dept_name =<span class="string">'Biology'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select name</span><br><span class="line">from instructor</span><br><span class="line">where salary &gt;all(</span><br><span class="line">    select salary</span><br><span class="line">        from instructor</span><br><span class="line">            where dept_name ='Biology'</span><br><span class="line">);</span><br><span class="line">+----------+</span><br><span class="line">| name     |</span><br><span class="line">+----------+</span><br><span class="line">| Wu       |</span><br><span class="line">| Einstein |</span><br><span class="line">| Gold     |</span><br><span class="line">| Katz     |</span><br><span class="line">| Singh    |</span><br><span class="line">| Brandt   |</span><br><span class="line">| Kim      |</span><br><span class="line">+----------+</span><br><span class="line"><span class="number">7</span> rows <span class="keyword">in</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure></p><h2 id="all详解"><a href="#all详解" class="headerlink" title="all详解"></a>all详解</h2><ul><li>大于其中所有的<code>&lt;all</code>,</li><li>小于等于其中所有的<code>&lt;=all</code>,</li><li>大于等于其中所有的<code>&gt;=all</code>,</li><li>等于其中所有的<code>=all</code>,</li><li>不等于其中所有的<code>&lt;&gt;al</code>,</li></ul><h3 id="lt-gt-all等价于not-in"><a href="#lt-gt-all等价于not-in" class="headerlink" title="&lt;&gt;all等价于not in"></a><code>&lt;&gt;all</code>等价于<code>not in</code></h3><p><code>&lt;&gt;all</code>的意思是不等于其中所有的,和<code>not in</code>的意思是一样的,两者等价。</p><h3 id="all不等价与in"><a href="#all不等价与in" class="headerlink" title="=all不等价与in"></a><code>=all</code>不等价与in</h3><ul><li><code>=all</code>的意思是等于其中所有的,</li><li><code>in</code>的意思是等于其中一个</li></ul><p><code>=all</code>比in要求要严格,<code>=all</code>不等价于in</p><h2 id="SQL查询-找出平均工资最高的系"><a href="#SQL查询-找出平均工资最高的系" class="headerlink" title="SQL查询 找出平均工资最高的系"></a>SQL查询 找出平均工资最高的系</h2><p>作为集合比较的另一个例子,考虑查询”<strong>找出平均工资最高的系</strong>“。<strong>我们首先写一个查询来<code>找出每个系的平均工资</code></strong>,<strong>然后把它作为子查询嵌套在一个更大的查询中</strong>,<strong>以找出那些平均工资大于等于所有系平均工资的系</strong>。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> dept_name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> dept_name</span><br><span class="line"><span class="keyword">having</span> <span class="keyword">avg</span>(salary) &gt;= <span class="keyword">all</span>(</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">avg</span>(salary)</span><br><span class="line">        <span class="keyword">from</span> instructor</span><br><span class="line">        <span class="keyword">group</span> <span class="keyword">by</span> dept_name</span><br><span class="line">);</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select dept_name,avg(salary)</span><br><span class="line">from instructor</span><br><span class="line">group by dept_name;</span><br><span class="line">+------------+--------------+</span><br><span class="line">| dept_name  | avg(salary)  |</span><br><span class="line">+------------+--------------+</span><br><span class="line">| Biology    | <span class="number">72000</span>        |</span><br><span class="line">| <span class="built_in">Comp</span>. Sci. | <span class="number">77333</span>.<span class="number">333333</span> |</span><br><span class="line">| Elec. Eng. | <span class="number">80000</span>        |</span><br><span class="line">| Finance    | <span class="number">85000</span>        |</span><br><span class="line">| History    | <span class="number">61000</span>        |</span><br><span class="line">| Music      | <span class="number">40000</span>        |</span><br><span class="line">| Physics    | <span class="number">91000</span>        |</span><br><span class="line">+------------+--------------+</span><br><span class="line"><span class="number">7</span> rows <span class="keyword">in</span> <span class="built_in">set</span></span><br><span class="line"></span><br><span class="line">mysql&gt; select dept_name</span><br><span class="line">from instructor</span><br><span class="line">group by dept_name</span><br><span class="line">having avg(salary) &gt;= all(</span><br><span class="line">    select avg(salary)</span><br><span class="line">        from instructor</span><br><span class="line">        group by dept_name</span><br><span class="line">);</span><br><span class="line">+-----------+</span><br><span class="line">| dept_name |</span><br><span class="line">+-----------+</span><br><span class="line">| Physics   |</span><br><span class="line">+-----------+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure></p><h2 id="any"><a href="#any" class="headerlink" title="any"></a>any</h2><p>在<code>SQL</code>中关键词<code>any</code>同义于<code>some</code>。早期<code>SQL</code>版本中仅允许使用<code>any</code>,后来的版本为了避免和英语中<code>any</code>一词在语言上的混淆,又添加了另一个可选择的关键词<code>some</code>。</p><ul><li><code>any</code>是任意一个</li><li><code>some</code>是一些,也就是至少一个</li></ul><!--SSTStop--><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select name</span><br><span class="line">from instructor</span><br><span class="line">where salary &gt; any(</span><br><span class="line">    select salary</span><br><span class="line">        from instructor</span><br><span class="line">        where dept_name='Biology'</span><br><span class="line">);</span><br><span class="line">+----------+</span><br><span class="line">| name     |</span><br><span class="line">+----------+</span><br><span class="line">| Wu       |</span><br><span class="line">| Einstein |</span><br><span class="line">| Gold     |</span><br><span class="line">| Katz     |</span><br><span class="line">| Singh    |</span><br><span class="line">| Brandt   |</span><br><span class="line">| Kim      |</span><br><span class="line">+----------+</span><br><span class="line"><span class="number">7</span> rows <span class="keyword">in</span> <span class="built_in">set</span></span><br><span class="line"></span><br><span class="line">mysql&gt; select name</span><br><span class="line">from instructor</span><br><span class="line">where salary &gt; some(</span><br><span class="line">    select salary</span><br><span class="line">        from instructor</span><br><span class="line">        where dept_name='Biology'</span><br><span class="line">);</span><br><span class="line">+----------+</span><br><span class="line">| name     |</span><br><span class="line">+----------+</span><br><span class="line">| Wu       |</span><br><span class="line">| Einstein |</span><br><span class="line">| Gold     |</span><br><span class="line">| Katz     |</span><br><span class="line">| Singh    |</span><br><span class="line">| Brandt   |</span><br><span class="line">| Kim      |</span><br><span class="line">+----------+</span><br><span class="line"><span class="number">7</span> rows <span class="keyword">in</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第3章 SQL </category>
          
          <category> 3.8 嵌套子查询 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何下载数据库系统教程第6版 大学模式源码</title>
      <link href="/ReadingNotes//a3223bac/"/>
      <url>/ReadingNotes//a3223bac/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/a3223bac/#如何下载数据库系统教程第6版-大学模式源码" class="header_1">如何下载数据库系统教程第6版 大学模式源码</a>&nbsp;<br><a href="/ReadingNotes/a3223bac/#大学数据库模式源码" class="header_2">大学数据库模式源码</a>&nbsp;<br><a href="/ReadingNotes/a3223bac/#PPT" class="header_2">PPT</a>&nbsp;<br><a href="/ReadingNotes/a3223bac/#练习题答案" class="header_2">练习题答案</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="如何下载数据库系统教程第6版-大学模式源码"><a href="#如何下载数据库系统教程第6版-大学模式源码" class="headerlink" title="如何下载数据库系统教程第6版 大学模式源码"></a>如何下载数据库系统教程第6版 大学模式源码</h1><p><a href="http://www.db-book.com" target="_blank" rel="noopener">http://www.db-book.com</a></p><h2 id="大学数据库模式源码"><a href="#大学数据库模式源码" class="headerlink" title="大学数据库模式源码"></a>大学数据库模式源码</h2><p><a href="https://www.db-book.com/db6/lab-dir/sample_tables-dir/index.html" target="_blank" rel="noopener">https://www.db-book.com/db6/lab-dir/sample_tables-dir/index.html</a></p><h2 id="PPT"><a href="#PPT" class="headerlink" title="PPT"></a>PPT</h2><p>书中的一些代码还PPT里面.<br><a href="https://www.db-book.com/db6/slide-dir/index.html" target="_blank" rel="noopener">https://www.db-book.com/db6/slide-dir/index.html</a></p><h2 id="练习题答案"><a href="#练习题答案" class="headerlink" title="练习题答案"></a>练习题答案</h2><p><a href="https://www.db-book.com/db6/practice-exer-dir/index.html" target="_blank" rel="noopener">https://www.db-book.com/db6/practice-exer-dir/index.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 前言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.8 嵌套子查询 3.8.1 集合成员资格</title>
      <link href="/ReadingNotes//ebc49635/"/>
      <url>/ReadingNotes//ebc49635/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/ebc49635/#3-8-嵌套子查询" class="header_1">3.8 嵌套子查询</a>&nbsp;<br><a href="/ReadingNotes/ebc49635/#可以在where子句中嵌套子查询" class="header_2">可以在where子句中嵌套子查询</a>&nbsp;<br><a href="/ReadingNotes/ebc49635/#可以在from子句中嵌套子查询" class="header_2">可以在from子句中嵌套子查询</a>&nbsp;<br><a href="/ReadingNotes/ebc49635/#标量子查询" class="header_2">标量子查询</a>&nbsp;<br><a href="/ReadingNotes/ebc49635/#3-8-1-集合成员资格" class="header_1">3.8.1 集合成员资格</a>&nbsp;<br><a href="/ReadingNotes/ebc49635/#测试元组是否是集合的成员-in" class="header_2">测试元组是否是集合的成员 in</a>&nbsp;<br><a href="/ReadingNotes/ebc49635/#测试元组是否不是集合的成员-not-in" class="header_2">测试元组是否不是集合的成员 not in</a>&nbsp;<br><a href="/ReadingNotes/ebc49635/#in示例-找出在2009年秋季和2010年春季学期同时开课的所有课程" class="header_2">in示例 找出在2009年秋季和2010年春季学期同时开课的所有课程</a>&nbsp;<br><a href="/ReadingNotes/ebc49635/#先写出子查询" class="header_3">先写出子查询</a>&nbsp;<br><a href="/ReadingNotes/ebc49635/#完整查询" class="header_3">完整查询</a>&nbsp;<br><a href="/ReadingNotes/ebc49635/#not-in示例-找出所有在2009年秋季学期开课-但不在2010年春季学期开课的课程" class="header_2">not in示例 找出所有在2009年秋季学期开课,但不在2010年春季学期开课的课程</a>&nbsp;<br><a href="/ReadingNotes/ebc49635/#in和not-in用于枚举集合" class="header_2">in和not in用于枚举集合</a>&nbsp;<br><a href="/ReadingNotes/ebc49635/#测试多个成员资格" class="header_2">测试多个成员资格</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="3-8-嵌套子查询"><a href="#3-8-嵌套子查询" class="headerlink" title="3.8 嵌套子查询"></a>3.8 嵌套子查询</h1><p><code>SQL</code>提供嵌套子查询机制。子查询是嵌套在另一个查询中的<code>select-from-where</code>表达式。</p><h2 id="可以在where子句中嵌套子查询"><a href="#可以在where子句中嵌套子查询" class="headerlink" title="可以在where子句中嵌套子查询"></a>可以在where子句中嵌套子查询</h2><p>子查询嵌套在<code>where</code>子句中,通常用于对集合的成员资格、集合的比较以及集合的基数进行检查。<br>从3.8.1到3.8.4节我们学习在<code>where</code>子句中嵌套子查询的用法。</p><h2 id="可以在from子句中嵌套子查询"><a href="#可以在from子句中嵌套子查询" class="headerlink" title="可以在from子句中嵌套子查询"></a>可以在from子句中嵌套子查询</h2><p>在3.8.5节我们学习在<code>from</code>子句中嵌套的子查询。</p><h2 id="标量子查询"><a href="#标量子查询" class="headerlink" title="标量子查询"></a>标量子查询</h2><p>在3.8.7节我们将看到一类被称作<code>标量子查询</code>的子查询,标量子查询可以出现在一个表达式所返回的单个值可以出现的任何地方的。</p><h1 id="3-8-1-集合成员资格"><a href="#3-8-1-集合成员资格" class="headerlink" title="3.8.1 集合成员资格"></a>3.8.1 集合成员资格</h1><p><code>SQL</code>允许测试元组在关系中的成员资格。</p><h2 id="测试元组是否是集合的成员-in"><a href="#测试元组是否是集合的成员-in" class="headerlink" title="测试元组是否是集合的成员 in"></a>测试元组是否是集合的成员 in</h2><p>连接词<code>in</code>测试元组是否是集合中的成员,这里的集合是指是由<code>select</code>子句产生的一组值。</p><h2 id="测试元组是否不是集合的成员-not-in"><a href="#测试元组是否不是集合的成员-not-in" class="headerlink" title="测试元组是否不是集合的成员 not in"></a>测试元组是否不是集合的成员 not in</h2><p>连接词<code>not in</code>则测试元组是否不是集合中的成员。</p><h2 id="in示例-找出在2009年秋季和2010年春季学期同时开课的所有课程"><a href="#in示例-找出在2009年秋季和2010年春季学期同时开课的所有课程" class="headerlink" title="in示例 找出在2009年秋季和2010年春季学期同时开课的所有课程"></a>in示例 找出在2009年秋季和2010年春季学期同时开课的所有课程</h2><p>作为示例,考虑査询”找出在2009年秋季和2010年春季学期同时开课的所有课程”。先前,我们通过对两个集合进行<code>交运算</code>来书写该査询,这两个集合分别是:<strong>2009年秋季开课的课程集合</strong>与<strong>2010年春季开课的课程集合</strong>。<br>现在我们采用另一种方式,<strong>查找在2009年秋季开课的所有课程,看它们是否也是2010年春季开课的课程集合中的成员</strong>。<br>很明显,这种方式得到的结果与前面相同,但我们可以用<code>SQL</code>中的<code>in</code>连接词书写该查询。</p><h3 id="先写出子查询"><a href="#先写出子查询" class="headerlink" title="先写出子查询"></a>先写出子查询</h3><p>我们从找出2010年春季开课的所有课程开始,写出<code>子查询</code>:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(</span><br><span class="line"><span class="keyword">select</span> course_id</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">section</span></span><br><span class="line"><span class="keyword">where</span> semester=<span class="string">'Spring'</span> <span class="keyword">and</span> <span class="keyword">year</span>=<span class="number">2010</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h3 id="完整查询"><a href="#完整查询" class="headerlink" title="完整查询"></a>完整查询</h3><p>然后我们需要从子查询形成的课程集合中找出那些在2009年秋季开课的课程。为完成此项任务可将子查询嵌入外部查询的<code>where</code>子句中。最后的查询语句是:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> course_id</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">section</span></span><br><span class="line"><span class="keyword">where</span> semester=<span class="string">'Fall'</span> <span class="keyword">and</span> <span class="keyword">year</span>= <span class="number">2009</span> <span class="keyword">and</span> course_id <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> course_id</span><br><span class="line">        <span class="keyword">from</span> <span class="keyword">section</span></span><br><span class="line">        <span class="keyword">where</span> semester=<span class="string">'Spring'</span> <span class="keyword">and</span> <span class="keyword">year</span> = <span class="number">2010</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select distinct course_id</span><br><span class="line">from section</span><br><span class="line">where semester='Fall' and year= <span class="number">2009</span> and course_id <span class="keyword">in</span> (</span><br><span class="line">    select course_id</span><br><span class="line">        from section</span><br><span class="line">        where semester='Spring' and year = <span class="number">2010</span></span><br><span class="line">);</span><br><span class="line">+-----------+</span><br><span class="line">| course_id |</span><br><span class="line">+-----------+</span><br><span class="line">| CS-<span class="number">101</span>    |</span><br><span class="line">+-----------+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure><br>该例说明了在<code>SQL</code>中可以用多种方法书写同一查询。这种灵活性是有好处的,因为它允许用户用最接近自然的方法去思考查询。</p><h2 id="not-in示例-找出所有在2009年秋季学期开课-但不在2010年春季学期开课的课程"><a href="#not-in示例-找出所有在2009年秋季学期开课-但不在2010年春季学期开课的课程" class="headerlink" title="not in示例 找出所有在2009年秋季学期开课,但不在2010年春季学期开课的课程"></a>not in示例 找出所有在2009年秋季学期开课,但不在2010年春季学期开课的课程</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> course_id</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">section</span></span><br><span class="line"><span class="keyword">where</span> semester=<span class="string">'Fall'</span> <span class="keyword">and</span> <span class="keyword">year</span>= <span class="number">2009</span> <span class="keyword">and</span> course_id <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> course_id</span><br><span class="line">        <span class="keyword">from</span> <span class="keyword">section</span></span><br><span class="line">        <span class="keyword">where</span> semester=<span class="string">'Spring'</span> <span class="keyword">and</span> <span class="keyword">year</span> = <span class="number">2010</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select distinct course_id</span><br><span class="line">from section</span><br><span class="line">where semester='Fall' and year= <span class="number">2009</span> and course_id <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line">    select course_id</span><br><span class="line">        from section</span><br><span class="line">        where semester='Spring' and year = <span class="number">2010</span></span><br><span class="line">);</span><br><span class="line">+-----------+</span><br><span class="line">| course_id |</span><br><span class="line">+-----------+</span><br><span class="line">| CS-<span class="number">347</span>    |</span><br><span class="line">| PHY-<span class="number">101</span>   |</span><br><span class="line">+-----------+</span><br><span class="line"><span class="number">2</span> rows <span class="keyword">in</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure><h2 id="in和not-in用于枚举集合"><a href="#in和not-in用于枚举集合" class="headerlink" title="in和not in用于枚举集合"></a>in和not in用于枚举集合</h2><p><code>in</code>和<code>not in</code>操作符也能用于枚举集合。下面的查询找出既不叫<code>&quot;Mozart&quot;</code>,也不叫<code>&quot;Einstein&quot;</code>的教师的姓名<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> <span class="keyword">name</span></span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">'Mozart'</span>,<span class="string">'Einstein'</span>);</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select distinct name</span><br><span class="line">from instructor</span><br><span class="line">where name <span class="keyword">not</span> <span class="keyword">in</span> ('Mozart','Einstein');</span><br><span class="line">+------------+</span><br><span class="line">| name       |</span><br><span class="line">+------------+</span><br><span class="line">| Srinivasan |</span><br><span class="line">| Wu         |</span><br><span class="line">| El Said    |</span><br><span class="line">| Gold       |</span><br><span class="line">| Katz       |</span><br><span class="line">| Califieri  |</span><br><span class="line">| Singh      |</span><br><span class="line">| Crick      |</span><br><span class="line">| Brandt     |</span><br><span class="line">| Kim        |</span><br><span class="line">+------------+</span><br><span class="line"><span class="number">10</span> rows <span class="keyword">in</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure></p><h2 id="测试多个成员资格"><a href="#测试多个成员资格" class="headerlink" title="测试多个成员资格"></a>测试多个成员资格</h2><p>在前面的例子中,我们是在单属性关系中测试成员资格。在<code>SQL</code>中测试任意关系的成员资格也是可以的。<br>例如,我们可以这样来表达查询”<strong>找出(不同的)学生总数,他们选修了ID为10101的教师所讲授的课程段</strong>“<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">ID</span>)</span><br><span class="line"><span class="keyword">from</span> takes</span><br><span class="line"><span class="keyword">where</span> (course_id, sec_id, semester, <span class="keyword">year</span>) <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> course_id, sec_id, semester,<span class="keyword">year</span></span><br><span class="line">        <span class="keyword">from</span> teaches</span><br><span class="line">        <span class="keyword">where</span> teaches.ID=<span class="number">10101</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(distinct ID)</span><br><span class="line">from takes</span><br><span class="line">where (course_id, sec_id, semester, year) <span class="keyword">in</span> (</span><br><span class="line">    select course_id, sec_id, semester,year</span><br><span class="line">        from teaches</span><br><span class="line">        where teaches.ID=<span class="number">10101</span></span><br><span class="line">);</span><br><span class="line">+--------------------+</span><br><span class="line">| count(distinct ID) |</span><br><span class="line">+--------------------+</span><br><span class="line">|                  <span class="number">6</span> |</span><br><span class="line">+--------------------+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure><br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第3章 SQL </category>
          
          <category> 3.8 嵌套子查询 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.7.4 对空值和布尔值的聚集</title>
      <link href="/ReadingNotes//1f7630bd/"/>
      <url>/ReadingNotes//1f7630bd/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/1f7630bd/#3-7-4-对空值和布尔值的聚集" class="header_1">3.7.4 对空值和布尔值的聚集</a>&nbsp;<br><a href="/ReadingNotes/1f7630bd/#sum聚集函数会忽略集合中的某个空值" class="header_2">sum聚集函数会忽略集合中的某个空值</a>&nbsp;<br><a href="/ReadingNotes/1f7630bd/#聚集函数对空值和空集的处理" class="header_1">聚集函数对空值和空集的处理</a>&nbsp;<br><a href="/ReadingNotes/1f7630bd/#输入集合中-带空值-的情况" class="header_2">输入集合中`带空值`的情况</a>&nbsp;<br><a href="/ReadingNotes/1f7630bd/#输入值集合为-空集-的情况" class="header_2">输入值集合为`空集`的情况</a>&nbsp;<br><a href="/ReadingNotes/1f7630bd/#SQL-1999-中引入的boolean类型和some-every聚集函数" class="header_2">SQL:1999 中引入的boolean类型和some every聚集函数</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="3-7-4-对空值和布尔值的聚集"><a href="#3-7-4-对空值和布尔值的聚集" class="headerlink" title="3.7.4 对空值和布尔值的聚集"></a>3.7.4 对空值和布尔值的聚集</h1><p>空值的存在给聚集运算的处理带来了麻烦。例如,假设<code>instructor</code>关系中有些元组在<code>salary</code>上取空值。考虑以下计算所有工资总额的查询:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">sum</span>(salary)</span><br><span class="line"><span class="keyword">from</span> instructor;</span><br></pre></td></tr></table></figure><br>由于一些元组在<code>salary</code>上取空值,上述查询待求和的值中就包含了空值。</p><h2 id="sum聚集函数会忽略集合中的某个空值"><a href="#sum聚集函数会忽略集合中的某个空值" class="headerlink" title="sum聚集函数会忽略集合中的某个空值"></a>sum聚集函数会忽略集合中的某个空值</h2><p><code>SQL</code>标准并不认为总和本身为<code>null</code>,而是认为<strong><code>sum</code>运算符应忽略输入中的<code>null</code>值</strong>。</p><h1 id="聚集函数对空值和空集的处理"><a href="#聚集函数对空值和空集的处理" class="headerlink" title="聚集函数对空值和空集的处理"></a>聚集函数对空值和空集的处理</h1><h2 id="输入集合中带空值的情况"><a href="#输入集合中带空值的情况" class="headerlink" title="输入集合中带空值的情况"></a>输入集合中<code>带空值</code>的情况</h2><ul><li>除了<code>count(*)</code>外所有的聚集函数都<code>忽略</code>输入集合中的空值。</li></ul><h2 id="输入值集合为空集的情况"><a href="#输入值集合为空集的情况" class="headerlink" title="输入值集合为空集的情况"></a>输入值集合为<code>空集</code>的情况</h2><ul><li>规定空集的<code>count</code>运算值为<code>0</code>,</li><li>其他所有聚集运算在输入为空集的情况下返回一个<code>空值</code>。</li></ul><p>在一些更复杂的<code>SQL</code>结构中空值的影响会更难以琢磨。</p><h2 id="SQL-1999-中引入的boolean类型和some-every聚集函数"><a href="#SQL-1999-中引入的boolean类型和some-every聚集函数" class="headerlink" title="SQL:1999 中引入的boolean类型和some every聚集函数"></a>SQL:1999 中引入的boolean类型和some every聚集函数</h2><ul><li>在<code>SQL:1999</code>中引入了布尔数据类型(<code>boolean</code>),它可以取<code>true</code>、 <code>false</code>、 <code>unknown</code>三个值。</li><li><code>some</code>和<code>every</code>这两个聚集函数可用来处理<code>boolean</code>值的集合。<!--SSTStop--></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第3章 SQL </category>
          
          <category> 3.7 聚集函数 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.7.3 having子句</title>
      <link href="/ReadingNotes//65722d5a/"/>
      <url>/ReadingNotes//65722d5a/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/65722d5a/#3-7-3-having子句" class="header_1">3.7.3 having子句</a>&nbsp;<br><a href="/ReadingNotes/65722d5a/#having子句对分组起作用" class="header_2">having子句对分组起作用</a>&nbsp;<br><a href="/ReadingNotes/65722d5a/#SQL查询-找出教师平均工资超过42000美元的系" class="header_2">SQL查询 找出教师平均工资超过42000美元的系</a>&nbsp;<br><a href="/ReadingNotes/65722d5a/#having子句中的没有被聚集的属性必须出现在group-by子句中" class="header_2">having子句中的没有被聚集的属性必须出现在group by子句中</a>&nbsp;<br><a href="/ReadingNotes/65722d5a/#查询子句顺序-先from-再where-然后-group-by-接着having-最后select-聚集" class="header_2">查询子句顺序: 先from 再where 然后 group by 接着having 最后select 聚集</a>&nbsp;<br><a href="/ReadingNotes/65722d5a/#SQL查询-对于在-2009-年讲授的每个-课程段-如果该课程段有至少2名学生选课-找出选修该课程段的所有学生的-总学分-tot_cred-的-平均值" class="header_2">SQL查询 对于在`2009`年讲授的每个`课程段`,如果该课程段有至少2名学生选课,找出选修该课程段的所有学生的`总学分`(`tot_cred)`的`平均值`</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="3-7-3-having子句"><a href="#3-7-3-having子句" class="headerlink" title="3.7.3 having子句"></a>3.7.3 having子句</h1><p>有时候,对分组限定条件比对元组限定条件更有用。例如,我们也许只对<strong>教师平均工资超过42000美元的系</strong>感兴趣。该条件并不针对单个元组,而是针对<code>group by</code>子句构成的分组。为表达这样的查询,我们使用<code>SQL</code>的<code>having</code>子句。</p><h2 id="having子句对分组起作用"><a href="#having子句对分组起作用" class="headerlink" title="having子句对分组起作用"></a>having子句对分组起作用</h2><p><code>having</code>子句中的谓词在形成分组后才起作用,因此可以使用聚集函数。</p><h2 id="SQL查询-找出教师平均工资超过42000美元的系"><a href="#SQL查询-找出教师平均工资超过42000美元的系" class="headerlink" title="SQL查询 找出教师平均工资超过42000美元的系"></a>SQL查询 找出教师平均工资超过42000美元的系</h2><p>我们用<code>SQL</code>表达该查询如下:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> dept_name, <span class="keyword">avg</span>(salary) <span class="keyword">as</span> avg_salary</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> dept_name</span><br><span class="line"><span class="keyword">having</span> <span class="keyword">avg</span>(salary)&gt;<span class="number">42000</span>;</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select dept_name, avg(salary) as avg_salary</span><br><span class="line">from instructor</span><br><span class="line">group by dept_name</span><br><span class="line">having avg(salary)&gt;<span class="number">42000</span>;</span><br><span class="line">+------------+--------------+</span><br><span class="line">| dept_name  | avg_salary   |</span><br><span class="line">+------------+--------------+</span><br><span class="line">| Biology    | <span class="number">72000</span>        |</span><br><span class="line">| <span class="built_in">Comp</span>. Sci. | <span class="number">77333</span>.<span class="number">333333</span> |</span><br><span class="line">| Elec. Eng. | <span class="number">80000</span>        |</span><br><span class="line">| Finance    | <span class="number">85000</span>        |</span><br><span class="line">| History    | <span class="number">61000</span>        |</span><br><span class="line">| Physics    | <span class="number">91000</span>        |</span><br><span class="line">+------------+--------------+</span><br><span class="line"><span class="number">6</span> rows <span class="keyword">in</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure></p><h2 id="having子句中的没有被聚集的属性必须出现在group-by子句中"><a href="#having子句中的没有被聚集的属性必须出现在group-by子句中" class="headerlink" title="having子句中的没有被聚集的属性必须出现在group by子句中"></a>having子句中的没有被聚集的属性必须出现在group by子句中</h2><p>与<code>select</code>子句的情况类似,任何出现在<code>having</code>子句中,但没有被聚集的属性必须出现在<code>group by</code>子句中,否则查询就被当成是错误的。</p><h2 id="查询子句顺序-先from-再where-然后-group-by-接着having-最后select-聚集"><a href="#查询子句顺序-先from-再where-然后-group-by-接着having-最后select-聚集" class="headerlink" title="查询子句顺序: 先from 再where 然后 group by 接着having 最后select 聚集"></a>查询子句顺序: 先from 再where 然后 group by 接着having 最后select 聚集</h2><p>包含<code>聚集</code>、 <code>group by</code>或<code>having</code>子句的查询的含义可通过下述操作序列来定义:</p><ol><li>与不带聚集的查询情况类似,最先根据<code>from</code>子句来计算出一个关系。</li><li>如果出现了<code>where</code>子句, <code>where</code>子句中的谓词将应用到<code>from</code>子句的结果关系上。</li><li>如果出现了<code>group by</code>子句,满足<code>where</code>谓词的元组通过<code>group by</code>子句形成<code>分组</code>。如果没有<code>group by</code>子句,满足<code>where</code>谓词的<code>整个元组集被当作一个分组</code>。</li><li>如果出现了<code>having</code>子句,它将应用到每个分组上;不满足<code>having</code>子句谓词的分组将被抛弃。</li><li><code>select</code>子句利用剩下的分组产生出查询结果中的元组,即在每个分组上应用聚集函数来得到单个结果元组。</li></ol><h2 id="SQL查询-对于在2009年讲授的每个课程段-如果该课程段有至少2名学生选课-找出选修该课程段的所有学生的总学分-tot-cred-的平均值"><a href="#SQL查询-对于在2009年讲授的每个课程段-如果该课程段有至少2名学生选课-找出选修该课程段的所有学生的总学分-tot-cred-的平均值" class="headerlink" title="SQL查询 对于在2009年讲授的每个课程段,如果该课程段有至少2名学生选课,找出选修该课程段的所有学生的总学分(tot_cred)的平均值"></a>SQL查询 对于在<code>2009</code>年讲授的每个<code>课程段</code>,如果该课程段有至少2名学生选课,找出选修该课程段的所有学生的<code>总学分</code>(<code>tot_cred)</code>的<code>平均值</code></h2><p>为了说明在同一个查询中同时使用<code>having</code>子句和<code>where</code>子句的情况,我们考虑查询”<strong>对于在<code>2009</code>年讲授的每个<code>课程段</code>,如果该课程段有至少2名学生选课,找出选修该课程段的所有学生的<code>总学分</code>(<code>tot_cred)</code>的<code>平均值</code></strong>“。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> course_id, semester, <span class="keyword">year</span>, sec_id, <span class="keyword">avg</span>(tot_cred)</span><br><span class="line"><span class="keyword">from</span> takes <span class="keyword">natural</span> <span class="keyword">join</span> student</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">year</span>=<span class="number">2009</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> course_id, semester, <span class="keyword">year</span>, sec_id</span><br><span class="line"><span class="keyword">having</span> <span class="keyword">count</span>(<span class="keyword">ID</span>)&gt;=<span class="number">2</span>;</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select course_id, semester, year, sec_id, avg(tot_cred)</span><br><span class="line">from takes natural join student</span><br><span class="line">where year=<span class="number">2009</span></span><br><span class="line">group by course_id, semester, year, sec_id</span><br><span class="line">having count(ID)&gt;=<span class="number">2</span>;</span><br><span class="line">+-----------+----------+------+--------+---------------+</span><br><span class="line">| course_id | semester | year | sec_id | avg(tot_cred) |</span><br><span class="line">+-----------+----------+------+--------+---------------+</span><br><span class="line">| CS-<span class="number">101</span>    | Fall     | <span class="number">2009</span> | <span class="number">1</span>      | <span class="number">65</span>            |</span><br><span class="line">| CS-<span class="number">190</span>    | Spring   | <span class="number">2009</span> | <span class="number">2</span>      | <span class="number">43</span>            |</span><br><span class="line">| CS-<span class="number">347</span>    | Fall     | <span class="number">2009</span> | <span class="number">1</span>      | <span class="number">67</span>            |</span><br><span class="line">+-----------+----------+------+--------+---------------+</span><br><span class="line"><span class="number">3</span> rows <span class="keyword">in</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure><br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第3章 SQL </category>
          
          <category> 3.7 聚集函数 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.7.2 分组聚集</title>
      <link href="/ReadingNotes//cac2c24a/"/>
      <url>/ReadingNotes//cac2c24a/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/cac2c24a/#3-7-2-分组聚集" class="header_1">3.7.2 分组聚集</a>&nbsp;<br><a href="/ReadingNotes/cac2c24a/#group-by子句分组原则" class="header_2">group by子句分组原则</a>&nbsp;<br><a href="/ReadingNotes/cac2c24a/#实例-使用dept_name属性给instructor关系分组" class="header_3">实例 使用dept_name属性给instructor关系分组</a>&nbsp;<br><a href="/ReadingNotes/cac2c24a/#SQL查询-找出每个系的平均工资" class="header_3">SQL查询 找出每个系的平均工资</a>&nbsp;<br><a href="/ReadingNotes/cac2c24a/#先分组-再查询" class="header_3">先分组 再查询</a>&nbsp;<br><a href="/ReadingNotes/cac2c24a/#省略group-by子句时整个关系作为一个分组" class="header_2">省略group by子句时整个关系作为一个分组</a>&nbsp;<br><a href="/ReadingNotes/cac2c24a/#SQL查询-找出所有教师的平均工资" class="header_3">SQL查询 找出所有教师的平均工资</a>&nbsp;<br><a href="/ReadingNotes/cac2c24a/#SQL查询-找出每个系在2010年春季学期讲授一门课程的教师人数" class="header_2">SQL查询 找出每个系在2010年春季学期讲授一门课程的教师人数</a>&nbsp;<br><a href="/ReadingNotes/cac2c24a/#没有出现在group-by子句中的属性只能出现在select子句的聚集函数-内部" class="header_2">没有出现在group by子句中的属性只能出现在select子句的聚集函数`内部`</a>&nbsp;<br><a href="/ReadingNotes/cac2c24a/#MySQL中没有出现再group-by子句中的属性也可以出现在select子句聚集函数外面" class="header_2">MySQL中没有出现再group by子句中的属性也可以出现在select子句聚集函数外面</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="3-7-2-分组聚集"><a href="#3-7-2-分组聚集" class="headerlink" title="3.7.2 分组聚集"></a>3.7.2 分组聚集</h1><p>有时候我们不仅希望将<code>聚集函数</code>作用在单个元组集上,而且也希望将其作用到一组元组集上;在<code>SQL</code>中可用<code>group by</code>子句实现这个愿望。 <code>group by</code>子句中给出的一个或多个属性是用来构造分组的。</p><h2 id="group-by子句分组原则"><a href="#group-by子句分组原则" class="headerlink" title="group by子句分组原则"></a>group by子句分组原则</h2><p>在<code>group by</code>子句中的<strong><code>所有属性</code>上<code>取值相同</code>的元组</strong>将被分在一个组中。</p><h3 id="实例-使用dept-name属性给instructor关系分组"><a href="#实例-使用dept-name属性给instructor关系分组" class="headerlink" title="实例 使用dept_name属性给instructor关系分组"></a>实例 使用dept_name属性给instructor关系分组</h3><p><code>instructor</code>关系中的元组按照<code>dept_name</code>属性进行分组的情况,如下所示:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> dept_name;</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select *</span><br><span class="line">from instructor</span><br><span class="line">group by dept_name;</span><br><span class="line">+-------+------------+------------+--------+</span><br><span class="line">| ID    | name       | dept_name  | salary |</span><br><span class="line">+-------+------------+------------+--------+</span><br><span class="line">| <span class="number">76766</span> | Crick      | Biology    | <span class="number">72000</span>  |</span><br><span class="line">| <span class="number">10101</span> | Srinivasan | <span class="built_in">Comp</span>. Sci. | <span class="number">65000</span>  |</span><br><span class="line">| <span class="number">98345</span> | Kim        | Elec. Eng. | <span class="number">80000</span>  |</span><br><span class="line">| <span class="number">12121</span> | Wu         | Finance    | <span class="number">90000</span>  |</span><br><span class="line">| <span class="number">32343</span> | El Said    | History    | <span class="number">60000</span>  |</span><br><span class="line">| <span class="number">15151</span> | Mozart     | Music      | <span class="number">40000</span>  |</span><br><span class="line">| <span class="number">22222</span> | Einstein   | Physics    | <span class="number">95000</span>  |</span><br><span class="line">+-------+------------+------------+--------+</span><br><span class="line"><span class="number">7</span> rows <span class="keyword">in</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure></p><h3 id="SQL查询-找出每个系的平均工资"><a href="#SQL查询-找出每个系的平均工资" class="headerlink" title="SQL查询 找出每个系的平均工资"></a>SQL查询 找出每个系的平均工资</h3><p>作为示例,考虑查询”<strong>找出每个系的平均工资</strong>“,该查询书写如下:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> dept_name, <span class="keyword">avg</span>( salary) <span class="keyword">as</span> avg_salary</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> dept_name;</span><br></pre></td></tr></table></figure></p><h3 id="先分组-再查询"><a href="#先分组-再查询" class="headerlink" title="先分组 再查询"></a>先分组 再查询</h3><p><strong>分组是计算查询结果的第一步</strong>。在每个分组上都要进行指定的聚集计算。<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select dept_name, avg( salary) as avg_salary</span><br><span class="line">from instructor</span><br><span class="line">group by dept_name;</span><br><span class="line">+------------+--------------+</span><br><span class="line">| dept_name  | avg_salary   |</span><br><span class="line">+------------+--------------+</span><br><span class="line">| Biology    | <span class="number">72000</span>        |</span><br><span class="line">| <span class="built_in">Comp</span>. Sci. | <span class="number">77333</span>.<span class="number">333333</span> |</span><br><span class="line">| Elec. Eng. | <span class="number">80000</span>        |</span><br><span class="line">| Finance    | <span class="number">85000</span>        |</span><br><span class="line">| History    | <span class="number">61000</span>        |</span><br><span class="line">| Music      | <span class="number">40000</span>        |</span><br><span class="line">| Physics    | <span class="number">91000</span>        |</span><br><span class="line">+------------+--------------+</span><br><span class="line"><span class="number">7</span> rows <span class="keyword">in</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure></p><h2 id="省略group-by子句时整个关系作为一个分组"><a href="#省略group-by子句时整个关系作为一个分组" class="headerlink" title="省略group by子句时整个关系作为一个分组"></a>省略group by子句时整个关系作为一个分组</h2><h3 id="SQL查询-找出所有教师的平均工资"><a href="#SQL查询-找出所有教师的平均工资" class="headerlink" title="SQL查询 找出所有教师的平均工资"></a>SQL查询 找出所有教师的平均工资</h3><p>相反,考虑査询”找出所有教师的平均工资”。我们把此查询写做如下形式:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">avg</span>(salary)</span><br><span class="line"><span class="keyword">from</span> instructor;</span><br></pre></td></tr></table></figure><br>在这里省略了<code>group by</code>子句,因此<strong>整个关系被当作是一个分组</strong>。<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select avg(salary)</span><br><span class="line">from instructor;</span><br><span class="line">+--------------+</span><br><span class="line">| avg(salary)  |</span><br><span class="line">+--------------+</span><br><span class="line">| <span class="number">74833</span>.<span class="number">333333</span> |</span><br><span class="line">+--------------+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure></p><h2 id="SQL查询-找出每个系在2010年春季学期讲授一门课程的教师人数"><a href="#SQL查询-找出每个系在2010年春季学期讲授一门课程的教师人数" class="headerlink" title="SQL查询 找出每个系在2010年春季学期讲授一门课程的教师人数"></a>SQL查询 找出每个系在2010年春季学期讲授一门课程的教师人数</h2><p>作为在元组分组上进行聚集操作的另一个例子,考虑查询”<strong>找出每个系在2010年春季学期讲授一门课程的教师人数</strong>“。有关每位教师在每个学期讲授每个课程段的信息在<code>teaches</code>关系中。但是,这些信息需要与来自<code>instructor</code>关系的信息进行连接,才能够得到每位教师所在的系名。这样,我们把此查询写做如下形式:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> dept_name, <span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">ID</span>) <span class="keyword">as</span> instr_count</span><br><span class="line"><span class="keyword">from</span> instructor <span class="keyword">natural</span> <span class="keyword">join</span> teaches</span><br><span class="line"><span class="keyword">where</span> semester=<span class="string">'Spring'</span> <span class="keyword">and</span> <span class="keyword">year</span> =<span class="number">2010</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> dept_name;</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select dept_name, count(distinct ID) as instr_count</span><br><span class="line">from instructor natural join teaches</span><br><span class="line">where semester='Spring' and year =<span class="number">2010</span></span><br><span class="line">group by dept_name;</span><br><span class="line">+------------+-------------+</span><br><span class="line">| dept_name  | instr_count |</span><br><span class="line">+------------+-------------+</span><br><span class="line">| <span class="built_in">Comp</span>. Sci. |           <span class="number">3</span> |</span><br><span class="line">| Finance    |           <span class="number">1</span> |</span><br><span class="line">| History    |           <span class="number">1</span> |</span><br><span class="line">| Music      |           <span class="number">1</span> |</span><br><span class="line">+------------+-------------+</span><br><span class="line"><span class="number">4</span> rows <span class="keyword">in</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure><br><!--SSTStop--></p><h2 id="没有出现在group-by子句中的属性只能出现在select子句的聚集函数内部"><a href="#没有出现在group-by子句中的属性只能出现在select子句的聚集函数内部" class="headerlink" title="没有出现在group by子句中的属性只能出现在select子句的聚集函数内部"></a>没有出现在group by子句中的属性只能出现在select子句的聚集函数<code>内部</code></h2><p><strong>任何没有出现在<code>group by</code>子句中的属性如果出现在<code>select</code>子句中的话,它只能出现在聚集函数内部,否则这样的查询就是错误的</strong>。<br>例如,下述查询是错误的,<strong>因为<code>ID</code>没有出现在<code>group by</code>子句中,但它出现在了<code>select</code>子句中,但没有出现在聚集函数内部</strong>。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> dept_name,<span class="keyword">ID</span>, <span class="keyword">avg</span>(salary)</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> dept_name;</span><br></pre></td></tr></table></figure><br>在一个特定分组(通过<code>dept_name</code>定义)中的每位教师都有一个不同的I,既然每个分组只输出个元组,那就无法确定选哪个D值作为输出。其结果是,<code>SQL</code>不允许这样的情况出现。</p><h2 id="MySQL中没有出现再group-by子句中的属性也可以出现在select子句聚集函数外面"><a href="#MySQL中没有出现再group-by子句中的属性也可以出现在select子句聚集函数外面" class="headerlink" title="MySQL中没有出现再group by子句中的属性也可以出现在select子句聚集函数外面"></a>MySQL中没有出现再group by子句中的属性也可以出现在select子句聚集函数外面</h2><p>经过我的测试<code>MySQL</code>是可以的:<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select dept_name,ID, avg(salary)</span><br><span class="line">from instructor</span><br><span class="line">group by dept_name;</span><br><span class="line">+------------+-------+--------------+</span><br><span class="line">| dept_name  | ID    | avg(salary)  |</span><br><span class="line">+------------+-------+--------------+</span><br><span class="line">| Biology    | <span class="number">76766</span> | <span class="number">72000</span>        |</span><br><span class="line">| <span class="built_in">Comp</span>. Sci. | <span class="number">10101</span> | <span class="number">77333</span>.<span class="number">333333</span> |</span><br><span class="line">| Elec. Eng. | <span class="number">98345</span> | <span class="number">80000</span>        |</span><br><span class="line">| Finance    | <span class="number">12121</span> | <span class="number">85000</span>        |</span><br><span class="line">| History    | <span class="number">32343</span> | <span class="number">61000</span>        |</span><br><span class="line">| Music      | <span class="number">15151</span> | <span class="number">40000</span>        |</span><br><span class="line">| Physics    | <span class="number">22222</span> | <span class="number">91000</span>        |</span><br><span class="line">+------------+-------+--------------+</span><br><span class="line"><span class="number">7</span> rows <span class="keyword">in</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第3章 SQL </category>
          
          <category> 3.7 聚集函数 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.7 聚集函数 3.7.1 基本聚集</title>
      <link href="/ReadingNotes//cd11efad/"/>
      <url>/ReadingNotes//cd11efad/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/cd11efad/#3-7-聚集函数" class="header_1">3.7 聚集函数</a>&nbsp;<br><a href="/ReadingNotes/cd11efad/#什么是聚集函数" class="header_2">什么是聚集函数</a>&nbsp;<br><a href="/ReadingNotes/cd11efad/#五个固有聚集函数-avg-min-max-sum-count" class="header_2">五个固有聚集函数 `avg min max sum count`</a>&nbsp;<br><a href="/ReadingNotes/cd11efad/#3-7-1-基本聚集" class="header_1">3.7.1 基本聚集</a>&nbsp;<br><a href="/ReadingNotes/cd11efad/#sum实例-找出-Computer-Science-系所以教师的总工资" class="header_2">sum实例 找出`Computer Science`系所以教师的总工资</a>&nbsp;<br><a href="/ReadingNotes/cd11efad/#avg实例-找出-Computer-Science-系教师的平均工资" class="header_2">avg实例 找出`Computer Science`系教师的平均工资</a>&nbsp;<br><a href="/ReadingNotes/cd11efad/#使用as重命名聚集函数的结果" class="header_2">使用as重命名聚集函数的结果</a>&nbsp;<br><a href="/ReadingNotes/cd11efad/#重复值" class="header_2">重复值</a>&nbsp;<br><a href="/ReadingNotes/cd11efad/#计算平均值是注意要保留重复元组" class="header_3">计算平均值是注意要保留重复元组</a>&nbsp;<br><a href="/ReadingNotes/cd11efad/#使用distinct在计算聚集函数之前-删除重复元组" class="header_3">使用distinct在计算聚集函数之前 删除重复元组</a>&nbsp;<br><a href="/ReadingNotes/cd11efad/#计算一个关系中元组的个数count-*" class="header_2">计算一个关系中元组的个数count(*)</a>&nbsp;<br><a href="/ReadingNotes/cd11efad/#没有count-distinct-*" class="header_2">没有count(distinct *)</a>&nbsp;<br><a href="/ReadingNotes/cd11efad/#max和min中可以使用distinct" class="header_2">max和min中可以使用distinct</a>&nbsp;<br><a href="/ReadingNotes/cd11efad/#默认保留重复" class="header_2">默认保留重复</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="3-7-聚集函数"><a href="#3-7-聚集函数" class="headerlink" title="3.7 聚集函数"></a>3.7 聚集函数</h1><h2 id="什么是聚集函数"><a href="#什么是聚集函数" class="headerlink" title="什么是聚集函数"></a>什么是聚集函数</h2><p><code>聚集函数</code>是以值的一个集合(集或多重集)为输入、返回单个值的函数。</p><h2 id="五个固有聚集函数-avg-min-max-sum-count"><a href="#五个固有聚集函数-avg-min-max-sum-count" class="headerlink" title="五个固有聚集函数 avg min max sum count"></a>五个固有聚集函数 <code>avg min max sum count</code></h2><p><code>SQL</code>提供了五个固有聚集函数</p><ul><li>平均值:<code>avg</code></li><li>最小值:<code>min</code></li><li>最大值:<code>max</code>。</li><li>总和:<code>sum</code>。</li><li>计数:<code>count</code>。</li></ul><p>其中<code>sum</code>和<code>avg</code>的输入必须是<code>数字集</code>,<br>其他运算符(<code>min,max,count)</code>还可作用在<code>非数字数据类型</code>的集合上,如字符串。</p><h1 id="3-7-1-基本聚集"><a href="#3-7-1-基本聚集" class="headerlink" title="3.7.1 基本聚集"></a>3.7.1 基本聚集</h1><h2 id="sum实例-找出Computer-Science系所以教师的总工资"><a href="#sum实例-找出Computer-Science系所以教师的总工资" class="headerlink" title="sum实例 找出Computer Science系所以教师的总工资"></a>sum实例 找出<code>Computer Science</code>系所以教师的总工资</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">sum</span>(salary) <span class="keyword">as</span> sum_salary</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> dept_name =<span class="string">'Comp. Sci. '</span>;</span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select sum(salary) as sum_salary</span><br><span class="line">from instructor</span><br><span class="line">where dept_name ='<span class="built_in">Comp</span>. Sci. ';</span><br><span class="line">+------------+</span><br><span class="line">| sum_salary |</span><br><span class="line">+------------+</span><br><span class="line">| <span class="number">232000</span>.<span class="number">00</span>  |</span><br><span class="line">+------------+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure><h2 id="avg实例-找出Computer-Science系教师的平均工资"><a href="#avg实例-找出Computer-Science系教师的平均工资" class="headerlink" title="avg实例 找出Computer Science系教师的平均工资"></a>avg实例 找出<code>Computer Science</code>系教师的平均工资</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">avg</span>(salary)</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> dept_name =<span class="string">'Comp. Sci. '</span>;</span><br></pre></td></tr></table></figure><p>该查询的结果是一个具有<code>单属性</code>的关系,其中只包含一个元组,这个元组的数值对应<code>Computer Science</code>系教师的平均工资。<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select avg(salary)</span><br><span class="line">from instructor</span><br><span class="line">where dept_name ='<span class="built_in">Comp</span>. Sci. ';</span><br><span class="line">+--------------+</span><br><span class="line">| avg(salary)  |</span><br><span class="line">+--------------+</span><br><span class="line">| <span class="number">77333</span>.<span class="number">333333</span> |</span><br><span class="line">+--------------+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure></p><h2 id="使用as重命名聚集函数的结果"><a href="#使用as重命名聚集函数的结果" class="headerlink" title="使用as重命名聚集函数的结果"></a>使用as重命名聚集函数的结果</h2><p>数据库系统可以给结果关系的属性一个任意的名字,该属性是由聚集产生的。然而,我们可以用<code>as</code>子句给属性赋个有意义的名称,如下所示:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">avg</span>(salary) <span class="keyword">as</span> avg_salary</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> dept_name =<span class="string">'Comp. Sci. '</span>;</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select avg(salary) as avg_salary</span><br><span class="line">from instructor</span><br><span class="line">where dept_name ='<span class="built_in">Comp</span>. Sci. ';</span><br><span class="line">+--------------+</span><br><span class="line">| avg_salary   |</span><br><span class="line">+--------------+</span><br><span class="line">| <span class="number">77333</span>.<span class="number">333333</span> |</span><br><span class="line">+--------------+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure><br>在<code>instructor</code>关系中, <code>Computer Science</code>系的工资值是75000美元、65000美元和92000美元,平均工资是<code>232000/3=773333</code>美元。</p><h2 id="重复值"><a href="#重复值" class="headerlink" title="重复值"></a>重复值</h2><h3 id="计算平均值是注意要保留重复元组"><a href="#计算平均值是注意要保留重复元组" class="headerlink" title="计算平均值是注意要保留重复元组"></a>计算平均值是注意要保留重复元组</h3><p><strong>在计算平均值时保留重复元组是很重要的</strong>。假设<code>Computer Science</code>系增加了第四位教师,其工资正好是75000美元。如果去除重复的话,我们会得到错误的答案(232000/4=58000美元),而正确的答案是76750美元。</p><h3 id="使用distinct在计算聚集函数之前-删除重复元组"><a href="#使用distinct在计算聚集函数之前-删除重复元组" class="headerlink" title="使用distinct在计算聚集函数之前 删除重复元组"></a>使用distinct在计算聚集函数之前 删除重复元组</h3><p>有些情况下在计算聚集函数前需先删掉重复元组。如果我们确实想删除重复元组,可在聚集表达式中使用关键词<code>distinct</code>。比方有这样一个查询示例”<strong>找出在<code>2010</code>年<code>春季学期</code>讲授一门课程的<code>教师</code>总数</strong>“,在该例中不论一个教师讲授了几个课程段,他只应被计算一次。所需信息包含在<code>teaches</code>关系中,我们书写该查询如下<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">ID</span>)</span><br><span class="line"><span class="keyword">from</span> teaches</span><br><span class="line"><span class="keyword">where</span> semester =<span class="string">'Spring'</span> <span class="keyword">and</span> <span class="keyword">year</span>=<span class="number">2010</span>;</span><br></pre></td></tr></table></figure></p><h2 id="计算一个关系中元组的个数count"><a href="#计算一个关系中元组的个数count" class="headerlink" title="计算一个关系中元组的个数count(*)"></a>计算一个关系中元组的个数count(*)</h2><p>我们经常使用聚集函数<code>count</code>计算一个关系中元组的个数。<code>SQL</code>中该函数的写法是<code>count(*)</code>。因此,要找出<code>course</code>关系中的元组数,可写成:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*)</span><br><span class="line"><span class="keyword">from</span> course;</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(*)</span><br><span class="line">from course;</span><br><span class="line">+----------+</span><br><span class="line">| count(*) |</span><br><span class="line">+----------+</span><br><span class="line">|       <span class="number">13</span> |</span><br><span class="line">+----------+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure></p><h2 id="没有count-distinct"><a href="#没有count-distinct" class="headerlink" title="没有count(distinct *)"></a>没有count(distinct *)</h2><p><code>SQL</code>不允许在用<code>count(*)</code>时使用<code>distinct</code>。</p><h2 id="max和min中可以使用distinct"><a href="#max和min中可以使用distinct" class="headerlink" title="max和min中可以使用distinct"></a>max和min中可以使用distinct</h2><p>在用<code>max</code>和<code>min</code>时使用<code>distinct</code>是合法的,不过没有必要,因为<code>结果并无差别</code>。</p><h2 id="默认保留重复"><a href="#默认保留重复" class="headerlink" title="默认保留重复"></a>默认保留重复</h2><p>我们可以使用关键词<code>all</code>替代<code>distinct</code>来说明保留重复元组,但是,既然<code>all</code>是默认的,所以没必要显示使用<code>all</code>。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第3章 SQL </category>
          
          <category> 3.7 聚集函数 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.6 空值</title>
      <link href="/ReadingNotes//f4a6669e/"/>
      <url>/ReadingNotes//f4a6669e/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/f4a6669e/#3-6-空值" class="header_1">3.6 空值</a>&nbsp;<br><a href="/ReadingNotes/f4a6669e/#有null的算术表达式结果为null" class="header_2">有null的算术表达式结果为null</a>&nbsp;<br><a href="/ReadingNotes/f4a6669e/#and-or-not元素符与unknown运算的结果" class="header_2">and or not元素符与unknown运算的结果</a>&nbsp;<br><a href="/ReadingNotes/f4a6669e/#谓词is-null和is-not-null" class="header_2">谓词is null和is not null</a>&nbsp;<br><a href="/ReadingNotes/f4a6669e/#SQL查询-找出-instructor-关系中-salary-为空值的所有教师" class="header_3">SQL查询 找出`instructor`关系中`salary`为空值的所有教师</a>&nbsp;<br><a href="/ReadingNotes/f4a6669e/#is-unknown谓词" class="header_2">is unknown谓词</a>&nbsp;<br><a href="/ReadingNotes/f4a6669e/#MySQL不支持is-unknown" class="header_3">MySQL不支持is unknown</a>&nbsp;<br><a href="/ReadingNotes/f4a6669e/#select-distinct中两个null被认为是相等的" class="header_2">select distinct中两个null被认为是相等的</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="3-6-空值"><a href="#3-6-空值" class="headerlink" title="3.6 空值"></a>3.6 空值</h1><p>空值给关系运算带来了特殊的问题,包括<code>算术运算</code>、<code>比较运算</code>和<code>集合运算</code>。</p><h2 id="有null的算术表达式结果为null"><a href="#有null的算术表达式结果为null" class="headerlink" title="有null的算术表达式结果为null"></a>有null的算术表达式结果为null</h2><p>如果算术表达式的任一输人为空,则该算术表达式结果为空<br>如果査询中有一个表达式是<code>R.A+5</code>,并且对于某个特定的元组,<code>R.A</code>为空,那么对此元组来说,该表达式<code>R.A+5</code>的结果也为空。</p><p>涉及空值的<code>比较</code>问题更多。因而<code>SQL</code>将涉及<code>空值</code>的任何比较运算的结果视为<code>unknown</code>(既不是谓词<code>is not</code>,也不是<code>is not null</code>,我们在本节的后面介绍这两个谓词)。这创建了除<code>true</code>和<code>false</code>之外的第三个逻辑值。</p><h2 id="and-or-not元素符与unknown运算的结果"><a href="#and-or-not元素符与unknown运算的结果" class="headerlink" title="and or not元素符与unknown运算的结果"></a>and or not元素符与unknown运算的结果</h2><p>由于在<code>where</code>子句的谓词中可以对比较结果使用诸如<code>and</code>、<code>or</code>和<code>not</code>的布尔运算,所以这些布尔运算的定义也被扩展到可以处理<code>unknown</code>值</p><ul><li><code>and</code>运算符:<code>true and unknown</code>的结果是<code>unknown</code>, <code>false and unknown</code>结果是<code>false</code>, <code>unknoun and unknow</code>的结果是<code>unknown</code>.</li><li><code>or</code>运算符:<code>true or unknown</code>的结果是<code>unknown</code>,<code>false or unknown</code>结果是<code>unknown</code>, <code>unknown or unknown</code>结果是<code>unknown</code>。</li><li><code>not</code>运算符: <code>not unknown</code>的结果是<code>unknown</code>.</li></ul><p>所以,如果<code>R.A</code>为空,那么”<code>1&lt;R.A</code>“和”<code>not(1 &lt; R.A)</code>“结果都是<code>unknown</code>。</p><p>如果<code>where</code>子句谓词对一个元组计算出<code>false</code>或<code>unknown</code>,那么该元组<strong>不能被加入到结果集</strong>中。</p><h2 id="谓词is-null和is-not-null"><a href="#谓词is-null和is-not-null" class="headerlink" title="谓词is null和is not null"></a>谓词is null和is not null</h2><p><code>SQL</code>在谓词中使用特殊的关键词<code>null</code>来表示空值。<br>使用谓词<code>is null</code>可以判断一个元素的值是否为空值,反之,使用谓词<code>is not null</code>可以判断一个元素是否不是空值。</p><h3 id="SQL查询-找出instructor关系中salary为空值的所有教师"><a href="#SQL查询-找出instructor关系中salary为空值的所有教师" class="headerlink" title="SQL查询 找出instructor关系中salary为空值的所有教师"></a>SQL查询 找出<code>instructor</code>关系中<code>salary</code>为空值的所有教师</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span></span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> salary <span class="keyword">is</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select name</span><br><span class="line">from instructor</span><br><span class="line">where salary is null;</span><br><span class="line">Empty <span class="built_in">set</span></span><br><span class="line"></span><br><span class="line">mysql&gt; select name</span><br><span class="line">from instructor</span><br><span class="line">where salary is <span class="keyword">not</span> null;</span><br><span class="line">+------------+</span><br><span class="line">| name       |</span><br><span class="line">+------------+</span><br><span class="line">| Srinivasan |</span><br><span class="line">| Wu         |</span><br><span class="line">| Mozart     |</span><br><span class="line">| Einstein   |</span><br><span class="line">| El Said    |</span><br><span class="line">| Gold       |</span><br><span class="line">| Katz       |</span><br><span class="line">| Califieri  |</span><br><span class="line">| Singh      |</span><br><span class="line">| Crick      |</span><br><span class="line">| Brandt     |</span><br><span class="line">| Kim        |</span><br><span class="line">+------------+</span><br><span class="line"><span class="number">12</span> rows <span class="keyword">in</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure><h2 id="is-unknown谓词"><a href="#is-unknown谓词" class="headerlink" title="is unknown谓词"></a>is unknown谓词</h2><p>某些<code>SQL</code>实现还允许我们使用子句<code>is unknown</code>和<code>is not unknown</code>来测试一个表达式的结果是否为<code>unknown</code>,而不是<code>true</code>或<code>false</code></p><h3 id="MySQL不支持is-unknown"><a href="#MySQL不支持is-unknown" class="headerlink" title="MySQL不支持is unknown"></a>MySQL不支持is unknown</h3><p>经过我的测试<code>MySQL</code>好像不支持<code>is unknown</code>和<code>is not unknown</code>这两个谓词。</p><h2 id="select-distinct中两个null被认为是相等的"><a href="#select-distinct中两个null被认为是相等的" class="headerlink" title="select distinct中两个null被认为是相等的"></a>select distinct中两个null被认为是相等的</h2><p>当一个查询使用<code>select distinct</code>子句时,重复元组将被去除。为了达到这个目的,当比较两个元组对应的属性值时,<strong>如果这两个值都是非空并且值相等,或者都是空,那么它们是相同的</strong>。<br>注意<code>select distinct</code>中对待空值的方式与<code>谓词</code>中对待空值的方式是不同的,在谓词中”<code>null=null</code>“会返回<code>unknown</code>,而不是<code>true</code>。<br>如果元组在所有属性上的取值相等,那么它们就被当作相同元组,即使某些值为空。集合的并、交和差运算也是如此。</p><!--SSTStop-->]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第3章 SQL </category>
          
          <category> 3.6 空值 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.5 集合运算</title>
      <link href="/ReadingNotes//ca9da947/"/>
      <url>/ReadingNotes//ca9da947/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/ca9da947/#3-5-集合运算" class="header_1">3.5 集合运算</a>&nbsp;<br><a href="/ReadingNotes/ca9da947/#-SQL-查询-在2009年秋季学期开设的所有课程的集合" class="header_2">`SQL`查询 在2009年秋季学期开设的所有课程的集合</a>&nbsp;<br><a href="/ReadingNotes/ca9da947/#SQL查询-在2010年春季学期开设的所有课程的集合" class="header_2">SQL查询 在2010年春季学期开设的所有课程的集合</a>&nbsp;<br><a href="/ReadingNotes/ca9da947/#3-5-1-并运算-union" class="header_1">3.5.1 并运算 union</a>&nbsp;<br><a href="/ReadingNotes/ca9da947/#有些-SQL-实现不支持-union-运算" class="header_2">有些`SQL`实现不支持`union`运算</a>&nbsp;<br><a href="/ReadingNotes/ca9da947/#为便于阅读可将两条合并的查询放在括号中" class="header_2">为便于阅读可将两条合并的查询放在括号中</a>&nbsp;<br><a href="/ReadingNotes/ca9da947/#union运算会自动去除重复" class="header_2">union运算会自动去除重复</a>&nbsp;<br><a href="/ReadingNotes/ca9da947/#union-all运算会保留重复" class="header_2">union all运算会保留重复</a>&nbsp;<br><a href="/ReadingNotes/ca9da947/#3-5-2-交运算-intersect" class="header_1">3.5.2 交运算 intersect</a>&nbsp;<br><a href="/ReadingNotes/ca9da947/#-SQL-查询-找出在2009年秋季和2010年春季同时开课的所有课程的集合" class="header_2">`SQL`查询 找出在2009年秋季和2010年春季同时开课的所有课程的集合</a>&nbsp;<br><a href="/ReadingNotes/ca9da947/#保留重复intersect-all" class="header_2">保留重复intersect all</a>&nbsp;<br><a href="/ReadingNotes/ca9da947/#-MySQL-不支持intersect运算" class="header_2">`MySQL`不支持intersect运算</a>&nbsp;<br><a href="/ReadingNotes/ca9da947/#-MySQL-中通过union运算实现交运算" class="header_3">`MySQL`中通过union运算实现交运算</a>&nbsp;<br><a href="/ReadingNotes/ca9da947/#-SQL-查询-找出在2009年秋季所有课程的集合" class="header_3">`SQL`查询 找出在2009年秋季所有课程的集合</a>&nbsp;<br><a href="/ReadingNotes/ca9da947/#-SQL-查询-找出在和2010年春季开课的所有课程的集合" class="header_3">`SQL`查询 找出在和2010年春季开课的所有课程的集合</a>&nbsp;<br><a href="/ReadingNotes/ca9da947/#-SQL-查询-找出在2009年秋季和2010年春季同时开课的所有课程的集合" class="header_3">`SQL`查询 找出在2009年秋季和2010年春季同时开课的所有课程的集合</a>&nbsp;<br><a href="/ReadingNotes/ca9da947/#3-5-3-差运算-except" class="header_1">3.5.3 差运算 except</a>&nbsp;<br><a href="/ReadingNotes/ca9da947/#SQL查询-找出在2009年秋季学期开课但不在2010年春季学期开课的所有课程" class="header_2">SQL查询 找出在2009年秋季学期开课但不在2010年春季学期开课的所有课程</a>&nbsp;<br><a href="/ReadingNotes/ca9da947/#保留重复except-all" class="header_2">保留重复except all</a>&nbsp;<br><a href="/ReadingNotes/ca9da947/#Oracle使用minus代替except" class="header_2">Oracle使用minus代替except</a>&nbsp;<br><a href="/ReadingNotes/ca9da947/#-MySQL-不支持-except-运算符" class="header_2">`MySQL`不支持`except`运算符</a>&nbsp;<br><a href="/ReadingNotes/ca9da947/#-MySQL-中通过-not-in-实现差运算" class="header_3">`MySQL`中通过`not in`实现差运算</a>&nbsp;<br><a href="/ReadingNotes/ca9da947/#参考链接" class="header_1">参考链接</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="3-5-集合运算"><a href="#3-5-集合运算" class="headerlink" title="3.5 集合运算"></a>3.5 集合运算</h1><p><code>SQL</code>作用在关系上的<code>union</code>、 <code>intersect</code>和<code>except</code>运算对应于数学集合论中的并(∪)、交(∩)和差(-)运算。我们现在来构造包含在两个集合上使用<code>union</code>、 <code>intersect</code>和<code>except</code>运算的查询。</p><h2 id="SQL查询-在2009年秋季学期开设的所有课程的集合"><a href="#SQL查询-在2009年秋季学期开设的所有课程的集合" class="headerlink" title="SQL查询 在2009年秋季学期开设的所有课程的集合"></a><code>SQL</code>查询 在2009年秋季学期开设的所有课程的集合</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> course_id</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">section</span></span><br><span class="line"><span class="keyword">where</span> semester =<span class="string">'Fall'</span> <span class="keyword">and</span> <span class="keyword">year</span>=<span class="number">2009</span>;</span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select course_id</span><br><span class="line">from section</span><br><span class="line">where semester ='Fall' and year=<span class="number">2009</span>;</span><br><span class="line">+-----------+</span><br><span class="line">| course_id |</span><br><span class="line">+-----------+</span><br><span class="line">| CS-<span class="number">101</span>    |</span><br><span class="line">| CS-<span class="number">347</span>    |</span><br><span class="line">| PHY-<span class="number">101</span>   |</span><br><span class="line">+-----------+</span><br><span class="line"><span class="number">3</span> rows <span class="keyword">in</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure><h2 id="SQL查询-在2010年春季学期开设的所有课程的集合"><a href="#SQL查询-在2010年春季学期开设的所有课程的集合" class="headerlink" title="SQL查询 在2010年春季学期开设的所有课程的集合"></a>SQL查询 在2010年春季学期开设的所有课程的集合</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> course_id</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">section</span></span><br><span class="line"><span class="keyword">where</span> semester=<span class="string">'Spring'</span> <span class="keyword">and</span> <span class="keyword">year</span>=<span class="number">2010</span>;</span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select course_id</span><br><span class="line">from section</span><br><span class="line">where semester='Spring' and year=<span class="number">2010</span>;</span><br><span class="line">+-----------+</span><br><span class="line">| course_id |</span><br><span class="line">+-----------+</span><br><span class="line">| CS-<span class="number">101</span>    |</span><br><span class="line">| FIN-<span class="number">201</span>   |</span><br><span class="line">| MU-<span class="number">199</span>    |</span><br><span class="line">| HIS-<span class="number">351</span>   |</span><br><span class="line">| CS-<span class="number">319</span>    |</span><br><span class="line">| CS-<span class="number">319</span>    |</span><br><span class="line">| CS-<span class="number">315</span>    |</span><br><span class="line">+-----------+</span><br></pre></td></tr></table></figure><h1 id="3-5-1-并运算-union"><a href="#3-5-1-并运算-union" class="headerlink" title="3.5.1 并运算 union"></a>3.5.1 并运算 union</h1><p>为了找出在200年秋季开课,<code>或者</code>在2010年春季开课或两个学期都开课的所有课程,我们可写查询语句:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> course_id</span><br><span class="line">    <span class="keyword">from</span> <span class="keyword">section</span></span><br><span class="line">    <span class="keyword">where</span> semester =<span class="string">'Fall'</span> <span class="keyword">and</span> <span class="keyword">year</span>=<span class="number">2009</span></span><br><span class="line">)<span class="keyword">union</span>(</span><br><span class="line">    <span class="keyword">select</span> course_id</span><br><span class="line">    <span class="keyword">from</span> <span class="keyword">section</span></span><br><span class="line">    <span class="keyword">where</span> semester=<span class="string">'Spring'</span> <span class="keyword">and</span> <span class="keyword">year</span>=<span class="number">2010</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; (</span><br><span class="line">    select course_id</span><br><span class="line">    from section</span><br><span class="line">    where semester ='Fall' and year=<span class="number">2009</span></span><br><span class="line">)union(</span><br><span class="line">    select course_id</span><br><span class="line">    from section</span><br><span class="line">    where semester='Spring' and year=<span class="number">2010</span></span><br><span class="line">);</span><br><span class="line">+-----------+</span><br><span class="line">| course_id |</span><br><span class="line">+-----------+</span><br><span class="line">| CS-<span class="number">101</span>    |</span><br><span class="line">| CS-<span class="number">347</span>    |</span><br><span class="line">| PHY-<span class="number">101</span>   |</span><br><span class="line">| FIN-<span class="number">201</span>   |</span><br><span class="line">| MU-<span class="number">199</span>    |</span><br><span class="line">| HIS-<span class="number">351</span>   |</span><br><span class="line">| CS-<span class="number">319</span>    |</span><br><span class="line">| CS-<span class="number">315</span>    |</span><br><span class="line">+-----------+</span><br><span class="line"><span class="number">8</span> rows <span class="keyword">in</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure></p><h2 id="有些SQL实现不支持union运算"><a href="#有些SQL实现不支持union运算" class="headerlink" title="有些SQL实现不支持union运算"></a>有些<code>SQL</code>实现不支持<code>union</code>运算</h2><p>尽管这是<code>SQL-92</code>标准的一部分,但某些<code>SQL</code>实现中可能不支持这种语法,经过我的测试<code>MySQL</code>是支持<code>union</code>运算的。</p><h2 id="为便于阅读可将两条合并的查询放在括号中"><a href="#为便于阅读可将两条合并的查询放在括号中" class="headerlink" title="为便于阅读可将两条合并的查询放在括号中"></a>为便于阅读可将两条合并的查询放在括号中</h2><p>上述SQL语句中我们在每条<code>select-from- where</code>语句上使用的<code>括号</code>是为了方便阅读,<code>括号是可省略的</code>,也就是说写成如下形式也是可以的:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> course_id</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">section</span></span><br><span class="line"><span class="keyword">where</span> semester =<span class="string">'Fall'</span> <span class="keyword">and</span> <span class="keyword">year</span>=<span class="number">2009</span></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> course_id</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">section</span></span><br><span class="line"><span class="keyword">where</span> semester=<span class="string">'Spring'</span> <span class="keyword">and</span> <span class="keyword">year</span>=<span class="number">2010</span>;</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select course_id</span><br><span class="line">    from section</span><br><span class="line">    where semester ='Fall' and year=<span class="number">2009</span></span><br><span class="line">union</span><br><span class="line">select course_id</span><br><span class="line">    from section</span><br><span class="line">    where semester='Spring' and year=<span class="number">2010</span>;</span><br><span class="line">+-----------+</span><br><span class="line">| course_id |</span><br><span class="line">+-----------+</span><br><span class="line">| CS-<span class="number">101</span>    |</span><br><span class="line">| CS-<span class="number">347</span>    |</span><br><span class="line">| PHY-<span class="number">101</span>   |</span><br><span class="line">| FIN-<span class="number">201</span>   |</span><br><span class="line">| MU-<span class="number">199</span>    |</span><br><span class="line">| HIS-<span class="number">351</span>   |</span><br><span class="line">| CS-<span class="number">319</span>    |</span><br><span class="line">| CS-<span class="number">315</span>    |</span><br><span class="line">+-----------+</span><br><span class="line"><span class="number">8</span> rows <span class="keyword">in</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure></p><h2 id="union运算会自动去除重复"><a href="#union运算会自动去除重复" class="headerlink" title="union运算会自动去除重复"></a>union运算会自动去除重复</h2><p>与<code>select</code>子句不同, <code>union</code>运算自动去除重复。</p><h2 id="union-all运算会保留重复"><a href="#union-all运算会保留重复" class="headerlink" title="union all运算会保留重复"></a>union all运算会保留重复</h2><p>如果我们想保留所有重复,就必须用<code>union all</code>代替<code>unIon</code>:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> course_id</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">section</span></span><br><span class="line"><span class="keyword">where</span> semester =<span class="string">'Fall'</span> <span class="keyword">and</span> <span class="keyword">year</span>=<span class="number">2009</span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> course_id</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">section</span></span><br><span class="line"><span class="keyword">where</span> semester=<span class="string">'Spring'</span> <span class="keyword">and</span> <span class="keyword">year</span>=<span class="number">2010</span>;</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select course_id</span><br><span class="line">    from section</span><br><span class="line">    where semester ='Fall' and year=<span class="number">2009</span></span><br><span class="line">union all</span><br><span class="line">select course_id</span><br><span class="line">    from section</span><br><span class="line">    where semester='Spring' and year=<span class="number">2010</span>;</span><br><span class="line">+-----------+</span><br><span class="line">| course_id |</span><br><span class="line">+-----------+</span><br><span class="line">| CS-<span class="number">101</span>    |</span><br><span class="line">| CS-<span class="number">347</span>    |</span><br><span class="line">| PHY-<span class="number">101</span>   |</span><br><span class="line">| CS-<span class="number">101</span>    |</span><br><span class="line">| FIN-<span class="number">201</span>   |</span><br><span class="line">| MU-<span class="number">199</span>    |</span><br><span class="line">| HIS-<span class="number">351</span>   |</span><br><span class="line">| CS-<span class="number">319</span>    |</span><br><span class="line">| CS-<span class="number">319</span>    |</span><br><span class="line">| CS-<span class="number">315</span>    |</span><br><span class="line">+-----------+</span><br><span class="line"><span class="number">10</span> rows <span class="keyword">in</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure></p><h1 id="3-5-2-交运算-intersect"><a href="#3-5-2-交运算-intersect" class="headerlink" title="3.5.2 交运算 intersect"></a>3.5.2 交运算 intersect</h1><h2 id="SQL查询-找出在2009年秋季和2010年春季同时开课的所有课程的集合"><a href="#SQL查询-找出在2009年秋季和2010年春季同时开课的所有课程的集合" class="headerlink" title="SQL查询 找出在2009年秋季和2010年春季同时开课的所有课程的集合"></a><code>SQL</code>查询 找出在2009年秋季和2010年春季同时开课的所有课程的集合</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> course_id</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">section</span></span><br><span class="line"><span class="keyword">where</span> semester =<span class="string">'Fall'</span> <span class="keyword">and</span> <span class="keyword">year</span>=<span class="number">2009</span></span><br><span class="line"><span class="keyword">intersect</span></span><br><span class="line"><span class="keyword">select</span> course_id</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">section</span></span><br><span class="line"><span class="keyword">where</span> semester=<span class="string">'Spring'</span> <span class="keyword">and</span> <span class="keyword">year</span>=<span class="number">2010</span>;</span><br></pre></td></tr></table></figure><h2 id="保留重复intersect-all"><a href="#保留重复intersect-all" class="headerlink" title="保留重复intersect all"></a>保留重复intersect all</h2><p><code>intersect</code>运算自动去除重复。如果我们想保留所有重复,就必须用<code>intersect all</code>代替<code>intersect</code>:</p><h2 id="MySQL不支持intersect运算"><a href="#MySQL不支持intersect运算" class="headerlink" title="MySQL不支持intersect运算"></a><code>MySQL</code>不支持intersect运算</h2><p>经过我的测试<code>MySQL</code>好像不支持<code>intersect</code>运算符,所以<code>MySQL</code>中得通过其他方式实现<code>交</code>运算。</p><h3 id="MySQL中通过union运算实现交运算"><a href="#MySQL中通过union运算实现交运算" class="headerlink" title="MySQL中通过union运算实现交运算"></a><code>MySQL</code>中通过union运算实现交运算</h3><p>原理就是求table1与table2不去除重复条目的并集，然后按想要的属性分组，取其中重复条目<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> (</span><br><span class="line">    <span class="keyword">select</span> course_id</span><br><span class="line">        <span class="keyword">from</span> <span class="keyword">section</span></span><br><span class="line">        <span class="keyword">where</span> semester =<span class="string">'Fall'</span> <span class="keyword">and</span> <span class="keyword">year</span>=<span class="number">2009</span></span><br><span class="line">    <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> course_id</span><br><span class="line">        <span class="keyword">from</span> <span class="keyword">section</span></span><br><span class="line">        <span class="keyword">where</span> semester=<span class="string">'Spring'</span> <span class="keyword">and</span> <span class="keyword">year</span>=<span class="number">2010</span></span><br><span class="line">) S </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> course_id <span class="keyword">having</span> <span class="keyword">count</span>(*)&gt;<span class="number">1</span>;</span><br></pre></td></tr></table></figure><br>由于这种方式还有一个条件是<code>table1</code>和<code>table2</code>中各自<code>不能有重复值</code>,不然结果不正确,所以查询的时候需要使用<code>select distinct</code>先取出重复值.</p><h3 id="SQL查询-找出在2009年秋季所有课程的集合"><a href="#SQL查询-找出在2009年秋季所有课程的集合" class="headerlink" title="SQL查询 找出在2009年秋季所有课程的集合"></a><code>SQL</code>查询 找出在2009年秋季所有课程的集合</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> course_id</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">section</span></span><br><span class="line"><span class="keyword">where</span> semester =<span class="string">'Fall'</span> <span class="keyword">and</span> <span class="keyword">year</span>=<span class="number">2009</span>;</span><br></pre></td></tr></table></figure><h3 id="SQL查询-找出在和2010年春季开课的所有课程的集合"><a href="#SQL查询-找出在和2010年春季开课的所有课程的集合" class="headerlink" title="SQL查询 找出在和2010年春季开课的所有课程的集合"></a><code>SQL</code>查询 找出在和2010年春季开课的所有课程的集合</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> course_id</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">section</span></span><br><span class="line"><span class="keyword">where</span> semester=<span class="string">'Spring'</span> <span class="keyword">and</span> <span class="keyword">year</span>=<span class="number">2010</span>;</span><br></pre></td></tr></table></figure><h3 id="SQL查询-找出在2009年秋季和2010年春季同时开课的所有课程的集合-1"><a href="#SQL查询-找出在2009年秋季和2010年春季同时开课的所有课程的集合-1" class="headerlink" title="SQL查询 找出在2009年秋季和2010年春季同时开课的所有课程的集合"></a><code>SQL</code>查询 找出在2009年秋季和2010年春季同时开课的所有课程的集合</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> </span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> course_id</span><br><span class="line">    <span class="keyword">from</span> <span class="keyword">section</span></span><br><span class="line">    <span class="keyword">where</span> semester =<span class="string">'Fall'</span> <span class="keyword">and</span> <span class="keyword">year</span>=<span class="number">2009</span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">distinct</span> course_id</span><br><span class="line">    <span class="keyword">from</span> <span class="keyword">section</span></span><br><span class="line">    <span class="keyword">where</span> semester=<span class="string">'Spring'</span> <span class="keyword">and</span> <span class="keyword">year</span>=<span class="number">2010</span></span><br><span class="line">) S </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> course_id <span class="keyword">having</span> <span class="keyword">count</span>(*)&gt;<span class="number">1</span>;</span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select distinct course_id</span><br><span class="line">from section</span><br><span class="line">where semester ='Fall' and year=<span class="number">2009</span>;</span><br><span class="line">+-----------+</span><br><span class="line">| course_id |</span><br><span class="line">+-----------+</span><br><span class="line">| CS-<span class="number">101</span>    |</span><br><span class="line">| CS-<span class="number">347</span>    |</span><br><span class="line">| PHY-<span class="number">101</span>   |</span><br><span class="line">+-----------+</span><br><span class="line"><span class="number">3</span> rows <span class="keyword">in</span> <span class="built_in">set</span></span><br><span class="line"></span><br><span class="line">mysql&gt; select distinct course_id</span><br><span class="line">from section</span><br><span class="line">where semester='Spring' and year=<span class="number">2010</span>;</span><br><span class="line">+-----------+</span><br><span class="line">| course_id |</span><br><span class="line">+-----------+</span><br><span class="line">| CS-<span class="number">101</span>    |</span><br><span class="line">| CS-<span class="number">315</span>    |</span><br><span class="line">| CS-<span class="number">319</span>    |</span><br><span class="line">| FIN-<span class="number">201</span>   |</span><br><span class="line">| HIS-<span class="number">351</span>   |</span><br><span class="line">| MU-<span class="number">199</span>    |</span><br><span class="line">+-----------+</span><br><span class="line"><span class="number">6</span> rows <span class="keyword">in</span> <span class="built_in">set</span></span><br><span class="line"></span><br><span class="line">mysql&gt; select * from (</span><br><span class="line">    select distinct course_id</span><br><span class="line">        from section</span><br><span class="line">        where semester ='Fall' and year=<span class="number">2009</span></span><br><span class="line">    union all</span><br><span class="line">    select distinct course_id</span><br><span class="line">        from section</span><br><span class="line">        where semester='Spring' and year=<span class="number">2010</span></span><br><span class="line">) S </span><br><span class="line">group by course_id having count(*)&gt;<span class="number">1</span>; </span><br><span class="line">+-----------+</span><br><span class="line">| course_id |</span><br><span class="line">+-----------+</span><br><span class="line">| CS-<span class="number">101</span>    |</span><br><span class="line">+-----------+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure><h1 id="3-5-3-差运算-except"><a href="#3-5-3-差运算-except" class="headerlink" title="3.5.3 差运算 except"></a>3.5.3 差运算 except</h1><h2 id="SQL查询-找出在2009年秋季学期开课但不在2010年春季学期开课的所有课程"><a href="#SQL查询-找出在2009年秋季学期开课但不在2010年春季学期开课的所有课程" class="headerlink" title="SQL查询 找出在2009年秋季学期开课但不在2010年春季学期开课的所有课程"></a>SQL查询 找出在2009年秋季学期开课但不在2010年春季学期开课的所有课程</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> course_id</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">section</span></span><br><span class="line"><span class="keyword">where</span> semester =<span class="string">'Fall'</span> <span class="keyword">and</span> <span class="keyword">year</span>=<span class="number">2009</span></span><br><span class="line"><span class="keyword">except</span></span><br><span class="line"><span class="keyword">select</span> course_id</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">section</span></span><br><span class="line"><span class="keyword">where</span> semester=<span class="string">'Spring'</span> <span class="keyword">and</span> <span class="keyword">year</span>=<span class="number">2010</span>;</span><br></pre></td></tr></table></figure><p><code>except</code>运算从其第一个输入中输出所有不出现在第二个输人中的元组</p><h2 id="保留重复except-all"><a href="#保留重复except-all" class="headerlink" title="保留重复except all"></a>保留重复except all</h2><p><code>except</code>运算在执行集差操作之前自动去除输入中的重复,如果我们想保留所有重复,就必须用<code>except all</code>代替<code>except</code>:</p><h2 id="Oracle使用minus代替except"><a href="#Oracle使用minus代替except" class="headerlink" title="Oracle使用minus代替except"></a>Oracle使用minus代替except</h2><p>某些<code>SQL</code>实现,特别是<code>Oracle</code>,使用关键词<code>minus</code>代替<code>except</code>。</p><h2 id="MySQL不支持except运算符"><a href="#MySQL不支持except运算符" class="headerlink" title="MySQL不支持except运算符"></a><code>MySQL</code>不支持<code>except</code>运算符</h2><h3 id="MySQL中通过not-in实现差运算"><a href="#MySQL中通过not-in实现差运算" class="headerlink" title="MySQL中通过not in实现差运算"></a><code>MySQL</code>中通过<code>not in</code>实现差运算</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select course_id</span><br><span class="line">from section</span><br><span class="line">where semester ='Fall' and year=<span class="number">2009</span>;</span><br><span class="line">+-----------+</span><br><span class="line">| course_id |</span><br><span class="line">+-----------+</span><br><span class="line">| CS-<span class="number">101</span>    |</span><br><span class="line">| CS-<span class="number">347</span>    |</span><br><span class="line">| PHY-<span class="number">101</span>   |</span><br><span class="line">+-----------+</span><br><span class="line"><span class="number">3</span> rows <span class="keyword">in</span> <span class="built_in">set</span></span><br><span class="line"></span><br><span class="line">mysql&gt; select course_id</span><br><span class="line">from section</span><br><span class="line">where semester='Spring' and year=<span class="number">2010</span>;</span><br><span class="line">+-----------+</span><br><span class="line">| course_id |</span><br><span class="line">+-----------+</span><br><span class="line">| CS-<span class="number">101</span>    |</span><br><span class="line">| FIN-<span class="number">201</span>   |</span><br><span class="line">| MU-<span class="number">199</span>    |</span><br><span class="line">| HIS-<span class="number">351</span>   |</span><br><span class="line">| CS-<span class="number">319</span>    |</span><br><span class="line">| CS-<span class="number">319</span>    |</span><br><span class="line">| CS-<span class="number">315</span>    |</span><br><span class="line">+-----------+</span><br><span class="line"><span class="number">7</span> rows <span class="keyword">in</span> <span class="built_in">set</span></span><br><span class="line"></span><br><span class="line">mysql&gt; select course_id</span><br><span class="line">from section</span><br><span class="line">where semester ='Fall' and year=<span class="number">2009</span> and course_id <span class="keyword">not</span> <span class="keyword">in</span>(</span><br><span class="line">    select course_id</span><br><span class="line">        from section</span><br><span class="line">        where semester='Spring' and year=<span class="number">2010</span></span><br><span class="line">);</span><br><span class="line">+-----------+</span><br><span class="line">| course_id |</span><br><span class="line">+-----------+</span><br><span class="line">| CS-<span class="number">347</span>    |</span><br><span class="line">| PHY-<span class="number">101</span>   |</span><br><span class="line">+-----------+</span><br><span class="line"><span class="number">2</span> rows <span class="keyword">in</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure><!--SSTStop--><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/qq_39023116/article/details/79008085" target="_blank" rel="noopener">https://blog.csdn.net/qq_39023116/article/details/79008085</a><br><a href="https://www.w3cschool.cn/mysql/mysql-vge12oye.html" target="_blank" rel="noopener">https://www.w3cschool.cn/mysql/mysql-vge12oye.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第3章 SQL </category>
          
          <category> 3.5 集合运算 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.4.5 where子句谓词</title>
      <link href="/ReadingNotes//242bc9f3/"/>
      <url>/ReadingNotes//242bc9f3/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/242bc9f3/#3-4-5-where子句谓词" class="header_1">3.4.5 where子句谓词</a>&nbsp;<br><a href="/ReadingNotes/242bc9f3/#between-and" class="header_2">between and</a>&nbsp;<br><a href="/ReadingNotes/242bc9f3/#not-between-and" class="header_2">not between and</a>&nbsp;<br><a href="/ReadingNotes/242bc9f3/#-n元组-比较运算符-n元组" class="header_2">(n元组) 比较运算符 (n元组)</a>&nbsp;<br><a href="/ReadingNotes/242bc9f3/#n元组将按字典顺序比较" class="header_3">n元组将按字典顺序比较</a>&nbsp;<br><a href="/ReadingNotes/242bc9f3/#所有属性相等n元组相等" class="header_3">所有属性相等n元组相等</a>&nbsp;<br><a href="/ReadingNotes/242bc9f3/#SQL查询-査找-Biology-系讲授了课程的所有教师的姓名和他们所讲授的课程的课程号" class="header_2">SQL查询 査找`Biology`系讲授了课程的所有教师的姓名和他们所讲授的课程的课程号</a>&nbsp;<br><a href="/ReadingNotes/242bc9f3/#一般形式" class="header_3">一般形式</a>&nbsp;<br><a href="/ReadingNotes/242bc9f3/#n元组比较形式" class="header_3">n元组比较形式</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="3-4-5-where子句谓词"><a href="#3-4-5-where子句谓词" class="headerlink" title="3.4.5 where子句谓词"></a>3.4.5 where子句谓词</h1><h2 id="between-and"><a href="#between-and" class="headerlink" title="between and"></a>between and</h2><p>为了简化<code>where</code>子句,<code>SQL</code>提供<code>between</code>比较运算符来说明<strong>一个值是小于或等于某个值,同时大于或等于另一个值的</strong>。</p><p>如果我们想找出工资在90000美元和100000美元之间的教师的姓名,我们可以使用<code>between</code>比较运算符,如下所示:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span></span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> salary <span class="keyword">between</span> <span class="number">90000</span> <span class="keyword">and</span> <span class="number">100000</span>;</span><br></pre></td></tr></table></figure></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select name</span><br><span class="line">from instructor</span><br><span class="line">where salary between <span class="number">90000</span> and <span class="number">100000</span>;</span><br><span class="line">+----------+</span><br><span class="line">| name     |</span><br><span class="line">+----------+</span><br><span class="line">| Wu       |</span><br><span class="line">| Einstein |</span><br><span class="line">| Brandt   |</span><br><span class="line">+----------+</span><br><span class="line"><span class="number">3</span> rows <span class="keyword">in</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure><p>它可以取代：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span></span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> salary &lt;=<span class="number">100000</span> <span class="keyword">and</span> salary &gt;=<span class="number">90000</span>;</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select name</span><br><span class="line">from instructor</span><br><span class="line">where salary &lt;=<span class="number">100000</span> and salary &gt;=<span class="number">90000</span>;</span><br><span class="line">+----------+</span><br><span class="line">| name     |</span><br><span class="line">+----------+</span><br><span class="line">| Wu       |</span><br><span class="line">| Einstein |</span><br><span class="line">| Brandt   |</span><br><span class="line">+----------+</span><br><span class="line"><span class="number">3</span> rows <span class="keyword">in</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure></p><h2 id="not-between-and"><a href="#not-between-and" class="headerlink" title="not between and"></a>not between and</h2><p>类似地,我们还可以使用<code>not between</code>比较运算符。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span></span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> salary <span class="keyword">not</span> <span class="keyword">between</span> <span class="number">90000</span> <span class="keyword">and</span> <span class="number">100000</span>;</span><br></pre></td></tr></table></figure></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select name</span><br><span class="line">from instructor</span><br><span class="line">where salary <span class="keyword">not</span> between <span class="number">90000</span> and <span class="number">100000</span>;</span><br><span class="line">+------------+</span><br><span class="line">| name       |</span><br><span class="line">+------------+</span><br><span class="line">| Srinivasan |</span><br><span class="line">| Mozart     |</span><br><span class="line">| El Said    |</span><br><span class="line">| Gold       |</span><br><span class="line">| Katz       |</span><br><span class="line">| Califieri  |</span><br><span class="line">| Singh      |</span><br><span class="line">| Crick      |</span><br><span class="line">| Kim        |</span><br><span class="line">+------------+</span><br><span class="line"><span class="number">9</span> rows <span class="keyword">in</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure><p>类似地,我们还可以使用<code>not between</code>比较运算符。</p><h2 id="n元组-比较运算符-n元组"><a href="#n元组-比较运算符-n元组" class="headerlink" title="(n元组) 比较运算符 (n元组)"></a>(n元组) 比较运算符 (n元组)</h2><p>SQL允许我们用记号<code>(V1,V2,…,Vn)</code>来表示一个分量值分别为<code>V1,V2,...,Vn</code>的n维元组。</p><h3 id="n元组将按字典顺序比较"><a href="#n元组将按字典顺序比较" class="headerlink" title="n元组将按字典顺序比较"></a>n元组将按字典顺序比较</h3><p>在元组上可以运用比较运算符时将<strong>按字典顺序进行比较运算</strong><br>例如,<code>(a1,a2)&lt;=(b1,b2)</code>在<code>a1&lt;=b1</code>且<code>a2&lt;=b2</code>时为真。</p><h3 id="所有属性相等n元组相等"><a href="#所有属性相等n元组相等" class="headerlink" title="所有属性相等n元组相等"></a>所有属性相等n元组相等</h3><p>类似地,当两个元组在所有属性上相等时,它们是相等的。</p><h2 id="SQL查询-査找Biology系讲授了课程的所有教师的姓名和他们所讲授的课程的课程号"><a href="#SQL查询-査找Biology系讲授了课程的所有教师的姓名和他们所讲授的课程的课程号" class="headerlink" title="SQL查询 査找Biology系讲授了课程的所有教师的姓名和他们所讲授的课程的课程号"></a>SQL查询 査找<code>Biology</code>系讲授了课程的所有教师的姓名和他们所讲授的课程的课程号</h2><h3 id="一般形式"><a href="#一般形式" class="headerlink" title="一般形式"></a>一般形式</h3><p>为了写出这样的查询,我们可以在前面看到过的两个<code>SQL</code>查询的任意一个的基础上进行修改,在<code>where</code>子句中增加一个额外的条件。我们下面给出修改后的不使用自然连接的<code>SQL</code>查询形式:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,course_id</span><br><span class="line"><span class="keyword">from</span> instructor,teaches</span><br><span class="line"><span class="keyword">where</span> instructor.ID= teaches.ID <span class="keyword">and</span> dept_name = <span class="string">'Biology'</span>;</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select name,course_id</span><br><span class="line">from instructor,teaches</span><br><span class="line">where instructor.ID&#x3D; teaches.ID and dept_name &#x3D; &#39;Biology&#39;;</span><br><span class="line">+-------+-----------+</span><br><span class="line">| name  | course_id |</span><br><span class="line">+-------+-----------+</span><br><span class="line">| Crick | BIO-101   |</span><br><span class="line">| Crick | BIO-301   |</span><br><span class="line">+-------+-----------+</span><br><span class="line">2 rows in set</span><br></pre></td></tr></table></figure></p><h3 id="n元组比较形式"><a href="#n元组比较形式" class="headerlink" title="n元组比较形式"></a>n元组比较形式</h3><p>使用n元组比较可以将上面的一般形式重写为如下形式:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, course_id</span><br><span class="line"><span class="keyword">from</span> instructor,teaches</span><br><span class="line"><span class="keyword">where</span> (instructor.ID, dept_name ) = (teaches.ID, <span class="string">'Biology'</span>);</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select name, course_id</span><br><span class="line">from instructor,teaches</span><br><span class="line">where (instructor.ID, dept_name ) &#x3D; (teaches.ID, &#39;Biology&#39;);</span><br><span class="line">+-------+-----------+</span><br><span class="line">| name  | course_id |</span><br><span class="line">+-------+-----------+</span><br><span class="line">| Crick | BIO-101   |</span><br><span class="line">| Crick | BIO-301   |</span><br><span class="line">+-------+-----------+</span><br><span class="line">2 rows in set</span><br></pre></td></tr></table></figure><!--SSTStop--><blockquote><h1 id="大学数据库模式"><a href="#大学数据库模式" class="headerlink" title="大学数据库模式"></a>大学数据库模式</h1><p>教室:<code>classroom(<u>building</u>,room_number,capacity)</code><br>系:<code>department(<u>dept_name</u>,building,budget)</code><br>课程:<code>course(<u>course_id</u>,title,dept_name,credits)</code><br>授课:<code>teaches(<u>ID,course_id,sec_id,semester,year</u>)</code><br>讲师:<code>instructor(<u>ID</u>,name,dept_name,salary)</code><br><code>section(<u>course_id,sec_id,semester,year</u>,building,room_number,time_slot_id)</code><br>学生:<code>student(<u>ID</u>,name,dept_name,tot_cred)</code><br><code>takes(<u>ID,course_id,sec_id,semester,year</u>,grade)</code><br><code>advisor(<u>s_ID,i_ID</u>)</code><br><code>time_slot(<u>time_slot_id,day,start_time</u>,end_time)</code><br><code>prereq(<u>course_id,prereq_id</u>)</code></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第3章 SQL </category>
          
          <category> 3.4 SQL查询附加的基本运算 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.4.4 排列元组的显示次序</title>
      <link href="/ReadingNotes//b84518cc/"/>
      <url>/ReadingNotes//b84518cc/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/b84518cc/#3-4-4-排列元组的显示次序" class="header_1">3.4.4 排列元组的显示次序</a>&nbsp;<br><a href="/ReadingNotes/b84518cc/#order-by子句" class="header_2">order by子句</a>&nbsp;<br><a href="/ReadingNotes/b84518cc/#SQL查询-列出在-Physics-系的所有教师" class="header_2">SQL查询 列出在`Physics`系的所有教师</a>&nbsp;<br><a href="/ReadingNotes/b84518cc/#desc降序-asc升序" class="header_2">desc降序  asc升序</a>&nbsp;<br><a href="/ReadingNotes/b84518cc/#在多个属性上排序" class="header_2">在多个属性上排序</a>&nbsp;<br><a href="/ReadingNotes/b84518cc/#SQL查询-先按salary降序-若salary相同-则按姓名升序" class="header_3">SQL查询 先按salary降序 若salary相同 则按姓名升序</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="3-4-4-排列元组的显示次序"><a href="#3-4-4-排列元组的显示次序" class="headerlink" title="3.4.4 排列元组的显示次序"></a>3.4.4 排列元组的显示次序</h1><h2 id="order-by子句"><a href="#order-by子句" class="headerlink" title="order by子句"></a>order by子句</h2><p><code>SQL</code>为用户提供了一些对关系中元组显示次序的控制。 <code>order by</code>子句就可以让查询结果中元组按排列顺序显示。</p><h2 id="SQL查询-列出在Physics系的所有教师"><a href="#SQL查询-列出在Physics系的所有教师" class="headerlink" title="SQL查询 列出在Physics系的所有教师"></a>SQL查询 列出在<code>Physics</code>系的所有教师</h2><p>为了按<code>字母顺序</code>列出在<code>Physics</code>系的所有教师,我们可以这样写:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span></span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> dept_name = <span class="string">'Physics'</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span>;</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select name</span><br><span class="line">from instructor</span><br><span class="line">where dept_name = 'Physics'</span><br><span class="line">order by name;</span><br><span class="line">+----------+</span><br><span class="line">| name     |</span><br><span class="line">+----------+</span><br><span class="line">| Einstein |</span><br><span class="line">| Gold     |</span><br><span class="line">+----------+</span><br><span class="line"><span class="number">2</span> rows <span class="keyword">in</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure></p><h2 id="desc降序-asc升序"><a href="#desc降序-asc升序" class="headerlink" title="desc降序  asc升序"></a>desc降序  asc升序</h2><p><code>order by</code>子句默认使用升序。要说明排序顺序,我们可以用<code>desc</code>表示降序,或者用<code>asc</code>表示升序。</p><h2 id="在多个属性上排序"><a href="#在多个属性上排序" class="headerlink" title="在多个属性上排序"></a>在多个属性上排序</h2><p>此外,排序可在多个属性上进行。</p><h3 id="SQL查询-先按salary降序-若salary相同-则按姓名升序"><a href="#SQL查询-先按salary降序-若salary相同-则按姓名升序" class="headerlink" title="SQL查询 先按salary降序 若salary相同 则按姓名升序"></a>SQL查询 先按salary降序 若salary相同 则按姓名升序</h3><p>假设我们希望按<code>salary</code>的降序列出整个<code>instructor</code>关系。如果有几位教师的工资相同,就将它们按姓名升序排列。我们用<code>SQL</code>将该查询表示如下:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span>, <span class="keyword">name</span> <span class="keyword">asc</span>;</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select *</span><br><span class="line">from instructor</span><br><span class="line">order by salary desc, name asc;</span><br><span class="line">+-------+------------+------------+--------+</span><br><span class="line">| ID    | name       | dept_name  | salary |</span><br><span class="line">+-------+------------+------------+--------+</span><br><span class="line">| <span class="number">22222</span> | Einstein   | Physics    | <span class="number">95000</span>  |</span><br><span class="line">| <span class="number">83821</span> | Brandt     | <span class="built_in">Comp</span>. Sci. | <span class="number">92000</span>  |</span><br><span class="line">| <span class="number">12121</span> | Wu         | Finance    | <span class="number">90000</span>  |</span><br><span class="line">| <span class="number">33456</span> | Gold       | Physics    | <span class="number">87000</span>  |</span><br><span class="line">| <span class="number">98345</span> | Kim        | Elec. Eng. | <span class="number">80000</span>  |</span><br><span class="line">| <span class="number">76543</span> | Singh      | Finance    | <span class="number">80000</span>  |</span><br><span class="line">| <span class="number">45565</span> | Katz       | <span class="built_in">Comp</span>. Sci. | <span class="number">75000</span>  |</span><br><span class="line">| <span class="number">76766</span> | Crick      | Biology    | <span class="number">72000</span>  |</span><br><span class="line">| <span class="number">10101</span> | Srinivasan | <span class="built_in">Comp</span>. Sci. | <span class="number">65000</span>  |</span><br><span class="line">| <span class="number">58583</span> | Califieri  | History    | <span class="number">62000</span>  |</span><br><span class="line">| <span class="number">32343</span> | El Said    | History    | <span class="number">60000</span>  |</span><br><span class="line">| <span class="number">15151</span> | Mozart     | Music      | <span class="number">40000</span>  |</span><br><span class="line">+-------+------------+------------+--------+</span><br><span class="line"><span class="number">12</span> rows <span class="keyword">in</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure><br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第3章 SQL </category>
          
          <category> 3.4 SQL查询附加的基本运算 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.4.3 select子句中的属性说明</title>
      <link href="/ReadingNotes//a9bdf70d/"/>
      <url>/ReadingNotes//a9bdf70d/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/a9bdf70d/#3-4-3-select子句中的属性说明" class="header_1">3.4.3 select子句中的属性说明</a>&nbsp;<br><a href="/ReadingNotes/a9bdf70d/#选中from子句结果关系中一个关系的所有属性" class="header_2">选中from子句结果关系中一个关系的所有属性</a>&nbsp;<br><a href="/ReadingNotes/a9bdf70d/#选中from子句结果关系的所有属性" class="header_2">选中from子句结果关系的所有属性</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="3-4-3-select子句中的属性说明"><a href="#3-4-3-select子句中的属性说明" class="headerlink" title="3.4.3 select子句中的属性说明"></a>3.4.3 select子句中的属性说明</h1><h2 id="选中from子句结果关系中一个关系的所有属性"><a href="#选中from子句结果关系中一个关系的所有属性" class="headerlink" title="选中from子句结果关系中一个关系的所有属性"></a>选中from子句结果关系中一个关系的所有属性</h2><p>星号”<code>*</code>“可以用在<code>select</code>子句中表示”所有的属性”,因而,如下查询的<code>select</code>子句中使用<code>instructor.*</code>：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> instructor.*</span><br><span class="line"><span class="keyword">from</span> instructor,teaches</span><br><span class="line"><span class="keyword">where</span> instructor.ID=teaches.ID;</span><br></pre></td></tr></table></figure><br>表示<code>instructor</code>中的所有属性都被选中。<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select instructor.*</span><br><span class="line">from instructor,teaches</span><br><span class="line">where instructor.ID=teaches.ID;</span><br><span class="line">+-------+------------+------------+--------+</span><br><span class="line">| ID    | name       | dept_name  | salary |</span><br><span class="line">+-------+------------+------------+--------+</span><br><span class="line">| <span class="number">76766</span> | Crick      | Biology    | <span class="number">72000</span>  |</span><br><span class="line">| <span class="number">76766</span> | Crick      | Biology    | <span class="number">72000</span>  |</span><br><span class="line">| <span class="number">10101</span> | Srinivasan | <span class="built_in">Comp</span>. Sci. | <span class="number">65000</span>  |</span><br><span class="line">| <span class="number">45565</span> | Katz       | <span class="built_in">Comp</span>. Sci. | <span class="number">75000</span>  |</span><br><span class="line">| <span class="number">83821</span> | Brandt     | <span class="built_in">Comp</span>. Sci. | <span class="number">92000</span>  |</span><br><span class="line">| <span class="number">83821</span> | Brandt     | <span class="built_in">Comp</span>. Sci. | <span class="number">92000</span>  |</span><br><span class="line">| <span class="number">10101</span> | Srinivasan | <span class="built_in">Comp</span>. Sci. | <span class="number">65000</span>  |</span><br><span class="line">| <span class="number">45565</span> | Katz       | <span class="built_in">Comp</span>. Sci. | <span class="number">75000</span>  |</span><br><span class="line">| <span class="number">83821</span> | Brandt     | <span class="built_in">Comp</span>. Sci. | <span class="number">92000</span>  |</span><br><span class="line">| <span class="number">10101</span> | Srinivasan | <span class="built_in">Comp</span>. Sci. | <span class="number">65000</span>  |</span><br><span class="line">| <span class="number">98345</span> | Kim        | Elec. Eng. | <span class="number">80000</span>  |</span><br><span class="line">| <span class="number">12121</span> | Wu         | Finance    | <span class="number">90000</span>  |</span><br><span class="line">| <span class="number">32343</span> | El Said    | History    | <span class="number">60000</span>  |</span><br><span class="line">| <span class="number">15151</span> | Mozart     | Music      | <span class="number">40000</span>  |</span><br><span class="line">| <span class="number">22222</span> | Einstein   | Physics    | <span class="number">95000</span>  |</span><br><span class="line">+-------+------------+------------+--------+</span><br><span class="line"><span class="number">15</span> rows <span class="keyword">in</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure></p><h2 id="选中from子句结果关系的所有属性"><a href="#选中from子句结果关系的所有属性" class="headerlink" title="选中from子句结果关系的所有属性"></a>选中from子句结果关系的所有属性</h2><p>形如<code>select * from ...</code>的<code>select</code>子句表示<code>from</code>子句结果关系的所有属性都被选中,例如:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> instructor,teaches</span><br><span class="line"><span class="keyword">where</span> instructor.ID=teaches.ID;</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select *</span><br><span class="line">from instructor,teaches</span><br><span class="line">where instructor.ID=teaches.ID;</span><br><span class="line">+-------+------------+------------+--------+-------+-----------+--------+----------+------+</span><br><span class="line">| ID    | name       | dept_name  | salary | ID    | course_id | sec_id | semester | year |</span><br><span class="line">+-------+------------+------------+--------+-------+-----------+--------+----------+------+</span><br><span class="line">| <span class="number">76766</span> | Crick      | Biology    | <span class="number">72000</span>  | <span class="number">76766</span> | BIO-<span class="number">101</span>   | <span class="number">1</span>      | Summer   | <span class="number">2009</span> |</span><br><span class="line">| <span class="number">76766</span> | Crick      | Biology    | <span class="number">72000</span>  | <span class="number">76766</span> | BIO-<span class="number">301</span>   | <span class="number">1</span>      | Summer   | <span class="number">2010</span> |</span><br><span class="line">| <span class="number">10101</span> | Srinivasan | <span class="built_in">Comp</span>. Sci. | <span class="number">65000</span>  | <span class="number">10101</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> |</span><br><span class="line">| <span class="number">45565</span> | Katz       | <span class="built_in">Comp</span>. Sci. | <span class="number">75000</span>  | <span class="number">45565</span> | CS-<span class="number">101</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> |</span><br><span class="line">| <span class="number">83821</span> | Brandt     | <span class="built_in">Comp</span>. Sci. | <span class="number">92000</span>  | <span class="number">83821</span> | CS-<span class="number">190</span>    | <span class="number">1</span>      | Spring   | <span class="number">2009</span> |</span><br><span class="line">| <span class="number">83821</span> | Brandt     | <span class="built_in">Comp</span>. Sci. | <span class="number">92000</span>  | <span class="number">83821</span> | CS-<span class="number">190</span>    | <span class="number">2</span>      | Spring   | <span class="number">2009</span> |</span><br><span class="line">| <span class="number">10101</span> | Srinivasan | <span class="built_in">Comp</span>. Sci. | <span class="number">65000</span>  | <span class="number">10101</span> | CS-<span class="number">315</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> |</span><br><span class="line">| <span class="number">45565</span> | Katz       | <span class="built_in">Comp</span>. Sci. | <span class="number">75000</span>  | <span class="number">45565</span> | CS-<span class="number">319</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> |</span><br><span class="line">| <span class="number">83821</span> | Brandt     | <span class="built_in">Comp</span>. Sci. | <span class="number">92000</span>  | <span class="number">83821</span> | CS-<span class="number">319</span>    | <span class="number">2</span>      | Spring   | <span class="number">2010</span> |</span><br><span class="line">| <span class="number">10101</span> | Srinivasan | <span class="built_in">Comp</span>. Sci. | <span class="number">65000</span>  | <span class="number">10101</span> | CS-<span class="number">347</span>    | <span class="number">1</span>      | Fall     | <span class="number">2009</span> |</span><br><span class="line">| <span class="number">98345</span> | Kim        | Elec. Eng. | <span class="number">80000</span>  | <span class="number">98345</span> | EE-<span class="number">181</span>    | <span class="number">1</span>      | Spring   | <span class="number">2009</span> |</span><br><span class="line">| <span class="number">12121</span> | Wu         | Finance    | <span class="number">90000</span>  | <span class="number">12121</span> | FIN-<span class="number">201</span>   | <span class="number">1</span>      | Spring   | <span class="number">2010</span> |</span><br><span class="line">| <span class="number">32343</span> | El Said    | History    | <span class="number">60000</span>  | <span class="number">32343</span> | HIS-<span class="number">351</span>   | <span class="number">1</span>      | Spring   | <span class="number">2010</span> |</span><br><span class="line">| <span class="number">15151</span> | Mozart     | Music      | <span class="number">40000</span>  | <span class="number">15151</span> | MU-<span class="number">199</span>    | <span class="number">1</span>      | Spring   | <span class="number">2010</span> |</span><br><span class="line">| <span class="number">22222</span> | Einstein   | Physics    | <span class="number">95000</span>  | <span class="number">22222</span> | PHY-<span class="number">101</span>   | <span class="number">1</span>      | Fall     | <span class="number">2009</span> |</span><br><span class="line">+-------+------------+------------+--------+-------+-----------+--------+----------+------+</span><br><span class="line"><span class="number">15</span> rows <span class="keyword">in</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure><br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第3章 SQL </category>
          
          <category> 3.4 SQL查询附加的基本运算 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.4.2 字符串运算</title>
      <link href="/ReadingNotes//b946e546/"/>
      <url>/ReadingNotes//b946e546/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/b946e546/#3-4-2-字符串运算" class="header_1">3.4.2 字符串运算</a>&nbsp;<br><a href="/ReadingNotes/b946e546/#字符串放在单引号中" class="header_2">字符串放在单引号中</a>&nbsp;<br><a href="/ReadingNotes/b946e546/#字符串中有单引号时怎么办" class="header_2">字符串中有单引号时怎么办</a>&nbsp;<br><a href="/ReadingNotes/b946e546/#-SQL-标准中字符串大小写敏感" class="header_2">`SQL`标准中字符串大小写敏感</a>&nbsp;<br><a href="/ReadingNotes/b946e546/#-MySQL-匹配字符串时默认不区分大小写" class="header_2">`MySQL`匹配字符串时默认不区分大小写</a>&nbsp;<br><a href="/ReadingNotes/b946e546/#-SQL-字符串函数" class="header_2">`SQL`字符串函数</a>&nbsp;<br><a href="/ReadingNotes/b946e546/#like操作符对字符串进行模式匹配" class="header_2">like操作符对字符串进行模式匹配</a>&nbsp;<br><a href="/ReadingNotes/b946e546/#SQL查询-找出所在建筑名称中包含子串-'Watson'-的所有系名" class="header_2">SQL查询: 找出所在建筑名称中包含子串`'Watson'`的所有系名</a>&nbsp;<br><a href="/ReadingNotes/b946e546/#转义字符" class="header_2">转义字符</a>&nbsp;<br><a href="/ReadingNotes/b946e546/#定义转义字符" class="header_3">定义转义字符</a>&nbsp;<br><a href="/ReadingNotes/b946e546/#搜寻不配配-not-like" class="header_2">搜寻不配配 not like</a>&nbsp;<br><a href="/ReadingNotes/b946e546/#SQL-1999提供的similar-to进行匹配" class="header_2">SQL:1999提供的similar to进行匹配</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="3-4-2-字符串运算"><a href="#3-4-2-字符串运算" class="headerlink" title="3.4.2 字符串运算"></a>3.4.2 字符串运算</h1><h2 id="字符串放在单引号中"><a href="#字符串放在单引号中" class="headerlink" title="字符串放在单引号中"></a>字符串放在单引号中</h2><p><code>SQL</code>使用一对单引号来标示字符串,例如<code>&#39;Computer&#39;</code>。</p><h2 id="字符串中有单引号时怎么办"><a href="#字符串中有单引号时怎么办" class="headerlink" title="字符串中有单引号时怎么办"></a>字符串中有单引号时怎么办</h2><p>如果单引号是字符串的组成部分,就需要放到双引号中,然后单引号要写变成两个单引号,如字符串<code>&quot;it&#39;s right&quot;</code>可表示为<code>&quot;it&#39;&#39;s right&quot;</code>。</p><h2 id="SQL标准中字符串大小写敏感"><a href="#SQL标准中字符串大小写敏感" class="headerlink" title="SQL标准中字符串大小写敏感"></a><code>SQL</code>标准中字符串大小写敏感</h2><p>在<code>SQL</code>标准中,字符串上的相等运算是大小写敏感的</p><h2 id="MySQL匹配字符串时默认不区分大小写"><a href="#MySQL匹配字符串时默认不区分大小写" class="headerlink" title="MySQL匹配字符串时默认不区分大小写"></a><code>MySQL</code>匹配字符串时默认不区分大小写</h2><p>然而一些数据库系统,如<code>MySQL</code>和<code>SQL Server</code>,在匹配字符串时并不区分大小写,然而这种默认方式是可以在数据库级或特定属性级被修改的。</p><h2 id="SQL字符串函数"><a href="#SQL字符串函数" class="headerlink" title="SQL字符串函数"></a><code>SQL</code>字符串函数</h2><p><code>SQL</code>还允许在字符串上有多种函数,例如</p><ul><li>串联(使用”<code>‖</code>“)、</li><li>提取子串、</li><li>计算字符串长度、</li><li>大小写转换(用<code>upper(s)</code>将字符串<code>s</code>转换为大写,或用<code>lower(s)</code>将字符串<code>s</code>转换为小写)、</li><li>去掉字符串后面的空格(使用<code>trim(s)</code>),</li></ul><p>不同数据库系统所提供的字符串函数集是不同的,请参阅你的数据库系统手册来获得它所支持的实际字符串函数的详细信息.</p><h2 id="like操作符对字符串进行模式匹配"><a href="#like操作符对字符串进行模式匹配" class="headerlink" title="like操作符对字符串进行模式匹配"></a>like操作符对字符串进行模式匹配</h2><p>在字符串上可以使用<code>like</code>操作符来实现模式匹配。我们使用两个特殊的字符来描述模式</p><ol><li>百分号(<code>%</code>):匹配任意子串。也就是<strong>0个或者0个以上的字符</strong>.</li><li>下划线(<code>_</code>):匹配任意<strong>一个</strong>字符。</li></ol><p><code>模式</code>是大小写敏感的,也就是说,大写字符与小写字符不匹配,反之亦然。为了说明模式匹配,考虑下列例子:</p><ul><li><code>&#39;Intro%&#39;</code>匹配任何以<code>&quot;lnro&quot;</code>打头的字符串</li><li><code>%Comp%</code>匹配任何包含<code>&quot;Comp&quot;</code>子串的字符串,例如<code>&#39;Intro. to Computer Science&#39;</code>和<code>&#39;Computational Biology&#39;</code></li><li><code>&#39;___&#39;</code>匹配只含三个字符的字符串。</li><li><code>&#39;___%&#39;</code>匹配至少含三个字符的字符串。</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select <span class="built_in">title</span> from course where <span class="built_in">title</span> like 'Intro%';</span><br><span class="line">+----------------------------+</span><br><span class="line">| <span class="built_in">title</span>                      |</span><br><span class="line">+----------------------------+</span><br><span class="line">| Intro. to Biology          |</span><br><span class="line">| Intro. to Computer Science |</span><br><span class="line">| Intro. to Digital Systems  |</span><br><span class="line">+----------------------------+</span><br><span class="line"><span class="number">3</span> rows <span class="keyword">in</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select <span class="built_in">title</span> from course where <span class="built_in">title</span> like "<span class="variable">%Comp%</span>";</span><br><span class="line">+----------------------------+</span><br><span class="line">| <span class="built_in">title</span>                      |</span><br><span class="line">+----------------------------+</span><br><span class="line">| Computational Biology      |</span><br><span class="line">| Intro. to Computer Science |</span><br><span class="line">+----------------------------+</span><br><span class="line"><span class="number">2</span> rows <span class="keyword">in</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure><h2 id="SQL查询-找出所在建筑名称中包含子串-39-Watson-39-的所有系名"><a href="#SQL查询-找出所在建筑名称中包含子串-39-Watson-39-的所有系名" class="headerlink" title="SQL查询: 找出所在建筑名称中包含子串&#39;Watson&#39;的所有系名"></a>SQL查询: 找出所在建筑名称中包含子串<code>&#39;Watson&#39;</code>的所有系名</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> dept_name</span><br><span class="line"><span class="keyword">from</span> department</span><br><span class="line"><span class="keyword">where</span> building <span class="keyword">like</span> <span class="string">'%Watson%'</span>;</span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select dept_name</span><br><span class="line">from department</span><br><span class="line">where building like '<span class="variable">%Watson%</span>';</span><br><span class="line">+-----------+</span><br><span class="line">| dept_name |</span><br><span class="line">+-----------+</span><br><span class="line">| Biology   |</span><br><span class="line">| Physics   |</span><br><span class="line">+-----------+</span><br><span class="line"><span class="number">2</span> rows <span class="keyword">in</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure><h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><p>为使模式中能够包含特殊模式的字符(即<code>%</code>和<code>_</code>),<code>SQL</code>允许定义转义字符。转义字符直接放在特殊字符的前面,表示该特殊字符被当成普通字符。</p><h3 id="定义转义字符"><a href="#定义转义字符" class="headerlink" title="定义转义字符"></a>定义转义字符</h3><p>我们在<code>like</code>比较运算中使用<code>escape</code>关键词来定义转义字符。为了说明这一用法,考虑以下模式,它使用反斜线(<code>\</code>)作为转义字符:</p><ul><li><code>like &#39;ab\%cd%&#39; escape &#39;\&#39;</code>:匹配所有以”<code>ab%cd</code>“开头的字符串。</li><li><code>like &#39;ab\\cd%&#39; escape &#39;\&#39;</code>:匹配所有以”<code>ab\cd</code>“开头的字符串。</li></ul><h2 id="搜寻不配配-not-like"><a href="#搜寻不配配-not-like" class="headerlink" title="搜寻不配配 not like"></a>搜寻不配配 not like</h2><p><code>SQL</code>允许使用<code>not like</code>比较运算符搜寻不匹配项。一些数据库还提供<code>like</code>运算的变体,不区分大小写.</p><h2 id="SQL-1999提供的similar-to进行匹配"><a href="#SQL-1999提供的similar-to进行匹配" class="headerlink" title="SQL:1999提供的similar to进行匹配"></a>SQL:1999提供的similar to进行匹配</h2><p>在<code>SQL:1999</code>中还提供<code>similar to</code>操作,它具备比<code>like</code>运算更强大的模式匹配能力。它的模式定义语法类似于<code>Unix</code>中的正则表达式。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第3章 SQL </category>
          
          <category> 3.4 SQL查询附加的基本运算 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.4 附加的基本运算 3.4.1 更名运算</title>
      <link href="/ReadingNotes//b1cfb0d6/"/>
      <url>/ReadingNotes//b1cfb0d6/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/b1cfb0d6/#3-4-附加的基本运算" class="header_1">3.4 附加的基本运算</a>&nbsp;<br><a href="/ReadingNotes/b1cfb0d6/#3-4-1-更名运算" class="header_1">3.4.1 更名运算</a>&nbsp;<br><a href="/ReadingNotes/b1cfb0d6/#as子句" class="header_2">as子句</a>&nbsp;<br><a href="/ReadingNotes/b1cfb0d6/#重命名属性" class="header_2">重命名属性</a>&nbsp;<br><a href="/ReadingNotes/b1cfb0d6/#重命名关系" class="header_2">重命名关系</a>&nbsp;<br><a href="/ReadingNotes/b1cfb0d6/#将长的关系名换成短的关系名" class="header_3">将长的关系名换成短的关系名</a>&nbsp;<br><a href="/ReadingNotes/b1cfb0d6/#重命名关系以便同一个关系中的元组" class="header_3">重命名关系以便同一个关系中的元组</a>&nbsp;<br><a href="/ReadingNotes/b1cfb0d6/#表别名的其他等效说法" class="header_2">表别名的其他等效说法</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="3-4-附加的基本运算"><a href="#3-4-附加的基本运算" class="headerlink" title="3.4 附加的基本运算"></a>3.4 附加的基本运算</h1><p><code>SQL</code>中还支持几种附加的基本运算。</p><h1 id="3-4-1-更名运算"><a href="#3-4-1-更名运算" class="headerlink" title="3.4.1 更名运算"></a>3.4.1 更名运算</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, course_id</span><br><span class="line"><span class="keyword">from</span> instructor,teaches</span><br><span class="line"><span class="keyword">where</span> instructor.ID = teaches.ID;</span><br></pre></td></tr></table></figure><h2 id="as子句"><a href="#as子句" class="headerlink" title="as子句"></a>as子句</h2><p><code>SQL</code>提供了一个重命名结果关系中属性的方法。即使用如下形式的<code>as</code>子句:<br><code>old-name as new-name</code><br><code>as</code>子句既可出现在<code>select</code>子句中,也可出现在<code>rom</code>子句中</p><h2 id="重命名属性"><a href="#重命名属性" class="headerlink" title="重命名属性"></a>重命名属性</h2><p>例如,如果我们想用名字<code>instructor_name</code>来代替属性名<code>nme</code>,我们可以重写上述查询如下:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">as</span> instructor_name, course_id</span><br><span class="line"><span class="keyword">from</span> instructor, teaches</span><br><span class="line"><span class="keyword">where</span> instructor.ID = teaches.ID;</span><br></pre></td></tr></table></figure></p><h2 id="重命名关系"><a href="#重命名关系" class="headerlink" title="重命名关系"></a>重命名关系</h2><h3 id="将长的关系名换成短的关系名"><a href="#将长的关系名换成短的关系名" class="headerlink" title="将长的关系名换成短的关系名"></a>将长的关系名换成短的关系名</h3><p><code>as</code>子句在重命名关系时特别有用。重命名关系的一个原因是<strong>把一个长的关系名替换成短的</strong>,这样在査询的其他地方使用起来就更为方便。为了说明这一点,我们重写查询”对于大学中所有讲授课程的教师,找出他们的姓名以及所讲述的所有课程标识”:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> T.name,S.course_id</span><br><span class="line"><span class="keyword">from</span> instructor <span class="keyword">as</span> T, teaches <span class="keyword">as</span> S</span><br><span class="line"><span class="keyword">where</span> T.ID =S.ID;</span><br></pre></td></tr></table></figure></p><h3 id="重命名关系以便同一个关系中的元组"><a href="#重命名关系以便同一个关系中的元组" class="headerlink" title="重命名关系以便同一个关系中的元组"></a>重命名关系以便同一个关系中的元组</h3><p>重命名关系的另一个原因是为了<strong>适用于需要比较同一个关系中的元组的情况</strong>。<br>为此我们需要把个关系跟它自身进行<code>笛卡儿积</code>运算,如果不重命名的话,就不可能把一个元组与其他元组区分开来。<br>假设我们希望写出查询:”<strong>找出满足下面条件的所有教师的姓名,他们的工资至少比<code>Biology</code>系某一个教师的工资要高</strong>“,我们可以写出这样的<code>SQL</code>表达式:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> T.name</span><br><span class="line"><span class="keyword">from</span> instructor <span class="keyword">as</span> T,instructor <span class="keyword">as</span> S</span><br><span class="line"><span class="keyword">where</span> T.salary &gt; S.salary <span class="keyword">and</span> S.dept_name =<span class="string">'Biology'</span>;</span><br></pre></td></tr></table></figure><br>在上述查询中,<code>T</code>和<code>S</code>被声明为<code>instructor</code>关系的别名。</p><h2 id="表别名的其他等效说法"><a href="#表别名的其他等效说法" class="headerlink" title="表别名的其他等效说法"></a>表别名的其他等效说法</h2><p>像<code>T</code>和<code>S</code>那样被<code>用来重命名关系的标识符</code>在<code>SQL</code>标准中被称作<strong>相关名称</strong>(<code>correlation name</code>),但通常也被称作<strong>表别名</strong>( <code>table alias</code>),或者<strong>相关变量</strong>( <code>correlation variable</code>),或者<strong>元组变量</strong>(<code>tuple variable</code>)。</p><!--SSTStop-->]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第3章 SQL </category>
          
          <category> 3.4 SQL查询附加的基本运算 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.3.3 自然连接</title>
      <link href="/ReadingNotes//b726cd8c/"/>
      <url>/ReadingNotes//b726cd8c/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/b726cd8c/#3-3-3-自然连接" class="header_1">3.3.3 自然连接</a>&nbsp;<br><a href="/ReadingNotes/b726cd8c/#笛卡儿积" class="header_2">笛卡儿积</a>&nbsp;<br><a href="/ReadingNotes/b726cd8c/#自然连接" class="header_2">自然连接</a>&nbsp;<br><a href="/ReadingNotes/b726cd8c/#SQL查询-对于大学中所有讲授课程的-教师-找出他们的-姓名-以及所讲述的所有-课程标识" class="header_2">SQL查询 对于大学中所有讲授课程的`教师`,找出他们的`姓名`以及所讲述的所有`课程标识`</a>&nbsp;<br><a href="/ReadingNotes/b726cd8c/#之前写法" class="header_3">之前写法</a>&nbsp;<br><a href="/ReadingNotes/b726cd8c/#自然连接写法" class="header_3">自然连接写法</a>&nbsp;<br><a href="/ReadingNotes/b726cd8c/#from后面可以使用多个自然连接" class="header_2">from后面可以使用多个自然连接</a>&nbsp;<br><a href="/ReadingNotes/b726cd8c/#SQL查询-列出-教师-的-名字-以及他们所讲授-课程的名称" class="header_2">SQL查询 列出`教师`的`名字`以及他们所讲授`课程的名称`</a>&nbsp;<br><a href="/ReadingNotes/b726cd8c/#先自然连接-再笛卡儿积" class="header_3">先自然连接 再笛卡儿积</a>&nbsp;<br><a href="/ReadingNotes/b726cd8c/#全部自然连接" class="header_3">全部自然连接</a>&nbsp;<br><a href="/ReadingNotes/b726cd8c/#自然连接和笛卡儿积的区别" class="header_1">自然连接和笛卡儿积的区别</a>&nbsp;<br><a href="/ReadingNotes/b726cd8c/#相同点" class="header_2">相同点</a>&nbsp;<br><a href="/ReadingNotes/b726cd8c/#不同点" class="header_2">不同点</a>&nbsp;<br><a href="/ReadingNotes/b726cd8c/#实例" class="header_2">实例</a>&nbsp;<br><a href="/ReadingNotes/b726cd8c/#笛卡尔积结果" class="header_3">笛卡尔积结果</a>&nbsp;<br><a href="/ReadingNotes/b726cd8c/#自然连接结果" class="header_3">自然连接结果</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="3-3-3-自然连接"><a href="#3-3-3-自然连接" class="headerlink" title="3.3.3 自然连接"></a>3.3.3 自然连接</h1><p>在我们的查询示例中,需要从<code>instructor</code>和<code>teaches</code>表中组合信息,匹配条件是需要<code>instructor.ID</code>等于<code>teaches.ID</code>。这是在两个关系中具有相同名称的所有属性。<br>在最通常的情况下<code>from</code>子句中的匹配条件是在所有匹配名称的<code>属性</code>上<code>相等</code>。</p><p>为了在这种通用情况下简化<code>SQL</code>编程者的工作,<code>SQL</code>支持一种被称作<code>自然连接</code>的运算,下面我们就来讨论这种运算。事实上<code>SQL</code>还支持几种另外的方式使得来自<code>两个</code>或<code>多个关系</code>的信息可以被连接(<code>join</code>)起来。我们已经见过怎样利用<code>笛卡儿积</code>和<code>where</code>子句谓词来连接来自多个关系的信息。连接来自多个关系信息的其他方式在4.1节介绍。</p><h2 id="笛卡儿积"><a href="#笛卡儿积" class="headerlink" title="笛卡儿积"></a>笛卡儿积</h2><p>笛卡儿积将第一个关系的每个元组与第二个关系的所有元组都进行连接;</p><h2 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h2><p>自然连接(<code>natural join)</code>运算作用于两个关系,并产生一个关系作为结果。自然连接只考虑那些在两个关系模式中<code>都出现的属性</code>上<code>取值相同</code>的元组对。<br>因此,回到<code>instructor</code>和<code>teaches</code>关系的例子上,<code>instructor</code>和<code>teaches</code>的自然连接计算中只考虑这样的元组对:来自<code>instructor</code>的元组和来自<code>teaches</code>的元组在共同属性ID上的取值相同<br><!--SSTStop--></p><blockquote><p>授课:<code>teaches(<u>ID,course_id,sec_id,semester,year</u>)</code><br>讲师:<code>instructor(<u>ID</u>,name,dept_name,salary)</code></p></blockquote><!--SSTStart--><h2 id="SQL查询-对于大学中所有讲授课程的教师-找出他们的姓名以及所讲述的所有课程标识"><a href="#SQL查询-对于大学中所有讲授课程的教师-找出他们的姓名以及所讲述的所有课程标识" class="headerlink" title="SQL查询 对于大学中所有讲授课程的教师,找出他们的姓名以及所讲述的所有课程标识"></a>SQL查询 对于大学中所有讲授课程的<code>教师</code>,找出他们的<code>姓名</code>以及所讲述的所有<code>课程标识</code></h2><h3 id="之前写法"><a href="#之前写法" class="headerlink" title="之前写法"></a>之前写法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, course_id</span><br><span class="line"><span class="keyword">from</span> instructor,teaches</span><br><span class="line"><span class="keyword">where</span> instructor.ID= teaches.ID;</span><br></pre></td></tr></table></figure><h3 id="自然连接写法"><a href="#自然连接写法" class="headerlink" title="自然连接写法"></a>自然连接写法</h3><p>该查询可以用<code>SQL</code>的自然连接运算更简洁地写作:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, course_id</span><br><span class="line"><span class="keyword">from</span> instructor <span class="keyword">natural</span> <span class="keyword">join</span> teaches;</span><br></pre></td></tr></table></figure><br><!--SSTStop--></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select name, course_id</span><br><span class="line">from instructor natural join teaches;</span><br><span class="line">+------------+-----------+</span><br><span class="line">| name       | course_id |</span><br><span class="line">+------------+-----------+</span><br><span class="line">| Srinivasan | CS-<span class="number">101</span>    |</span><br><span class="line">| Srinivasan | CS-<span class="number">315</span>    |</span><br><span class="line">| Srinivasan | CS-<span class="number">347</span>    |</span><br><span class="line">| Wu         | FIN-<span class="number">201</span>   |</span><br><span class="line">| Mozart     | MU-<span class="number">199</span>    |</span><br><span class="line">| Einstein   | PHY-<span class="number">101</span>   |</span><br><span class="line">| El Said    | HIS-<span class="number">351</span>   |</span><br><span class="line">| Katz       | CS-<span class="number">101</span>    |</span><br><span class="line">| Katz       | CS-<span class="number">319</span>    |</span><br><span class="line">| Crick      | BIO-<span class="number">101</span>   |</span><br><span class="line">| Crick      | BIO-<span class="number">301</span>   |</span><br><span class="line">| Brandt     | CS-<span class="number">190</span>    |</span><br><span class="line">| Brandt     | CS-<span class="number">190</span>    |</span><br><span class="line">| Brandt     | CS-<span class="number">319</span>    |</span><br><span class="line">| Kim        | EE-<span class="number">181</span>    |</span><br><span class="line">+------------+-----------+</span><br><span class="line"><span class="number">15</span> rows <span class="keyword">in</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure><!--SSTStart--><h2 id="from后面可以使用多个自然连接"><a href="#from后面可以使用多个自然连接" class="headerlink" title="from后面可以使用多个自然连接"></a>from后面可以使用多个自然连接</h2><p>在一个<code>SQL</code>查询的<code>from</code>子句中,可以用<code>自然连接</code>将多个关系结合在一起</p><h2 id="SQL查询-列出教师的名字以及他们所讲授课程的名称"><a href="#SQL查询-列出教师的名字以及他们所讲授课程的名称" class="headerlink" title="SQL查询 列出教师的名字以及他们所讲授课程的名称"></a>SQL查询 列出<code>教师</code>的<code>名字</code>以及他们所讲授<code>课程的名称</code></h2><h3 id="先自然连接-再笛卡儿积"><a href="#先自然连接-再笛卡儿积" class="headerlink" title="先自然连接 再笛卡儿积"></a>先自然连接 再笛卡儿积</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,title</span><br><span class="line"><span class="keyword">from</span> instructor <span class="keyword">natural</span> <span class="keyword">join</span> teaches, course</span><br><span class="line"><span class="keyword">where</span> teaches.course_id= course.course_id;</span><br></pre></td></tr></table></figure><!--SSTStop--><blockquote><p>课程:<code>course(<u>course_id</u>,title,dept_name,credits)</code><br>授课:<code>teaches(<u>ID,course_id,sec_id,semester,year</u>)</code><br>讲师:<code>instructor(<u>ID</u>,name,dept_name,salary)</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;  select name,title</span><br><span class="line">from instructor natural join teaches, course</span><br><span class="line">where teaches.course_id&#x3D; course.course_id;</span><br><span class="line">+------------+----------------------------+</span><br><span class="line">| name       | title                      |</span><br><span class="line">+------------+----------------------------+</span><br><span class="line">| Crick      | Intro. to Biology          |</span><br><span class="line">| Crick      | Genetics                   |</span><br><span class="line">| Srinivasan | Intro. to Computer Science |</span><br><span class="line">| Katz       | Intro. to Computer Science |</span><br><span class="line">| Brandt     | Game Design                |</span><br><span class="line">| Brandt     | Game Design                |</span><br><span class="line">| Srinivasan | Robotics                   |</span><br><span class="line">| Katz       | Image Processing           |</span><br><span class="line">| Brandt     | Image Processing           |</span><br><span class="line">| Srinivasan | Database System Concepts   |</span><br><span class="line">| Kim        | Intro. to Digital Systems  |</span><br><span class="line">| Wu         | Investment Banking         |</span><br><span class="line">| El Said    | World History              |</span><br><span class="line">| Mozart     | Music Video Production     |</span><br><span class="line">| Einstein   | Physical Principles        |</span><br><span class="line">+------------+----------------------------+</span><br><span class="line">15 rows in set</span><br></pre></td></tr></table></figure><p>先计算<code>instructor</code>和<code>teaches</code>的自然连接 再计算该结果和<code>course</code>的笛卡儿积<br><code>where</code>子句从这个结果中提取出这样的元组:来自<code>连接结果</code>的课程标识与来自<code>course</code>关系的课程标识相匹配。<br>注意<code>where</code>子句中的<code>teaches.course_id</code>表示自然连接结果中的<code>course_id</code>域,因为该域最终来自<code>teaches</code>关系。<br><!--SSTStart--></p><h3 id="全部自然连接"><a href="#全部自然连接" class="headerlink" title="全部自然连接"></a>全部自然连接</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,title</span><br><span class="line"><span class="keyword">from</span> instructor <span class="keyword">natural</span> <span class="keyword">join</span> teaches <span class="keyword">natural</span> <span class="keyword">join</span> course;</span><br></pre></td></tr></table></figure><!--SSTStop--><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select name,<span class="built_in">title</span> from  instructor natural join teaches natural join course;</span><br><span class="line">+------------+----------------------------+</span><br><span class="line">| name       | <span class="built_in">title</span>                      |</span><br><span class="line">+------------+----------------------------+</span><br><span class="line">| Crick      | Intro. to Biology          |</span><br><span class="line">| Crick      | Genetics                   |</span><br><span class="line">| Srinivasan | Intro. to Computer Science |</span><br><span class="line">| Katz       | Intro. to Computer Science |</span><br><span class="line">| Brandt     | Game Design                |</span><br><span class="line">| Brandt     | Game Design                |</span><br><span class="line">| Srinivasan | Robotics                   |</span><br><span class="line">| Katz       | Image Processing           |</span><br><span class="line">| Brandt     | Image Processing           |</span><br><span class="line">| Srinivasan | Database System Concepts   |</span><br><span class="line">| Kim        | Intro. to Digital Systems  |</span><br><span class="line">| Wu         | Investment Banking         |</span><br><span class="line">| El Said    | World History              |</span><br><span class="line">| Mozart     | Music Video Production     |</span><br><span class="line">| Einstein   | Physical Principles        |</span><br><span class="line">+------------+----------------------------+</span><br><span class="line"><span class="number">15</span> rows <span class="keyword">in</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure><blockquote><p><code>instructor(<u>ID</u>,name,dept_name,salary)</code><br><code>teaches(<u>ID,course_id,sec_id,semester,year</u>)</code><br>为了说明原因,注意<code>instructor</code>和<code>teaches</code>的自然连接包括属性<code>(ID, name, dept_name, salary, course_id, secid)</code></p></blockquote><!--SSTStart--><h1 id="自然连接和笛卡儿积的区别"><a href="#自然连接和笛卡儿积的区别" class="headerlink" title="自然连接和笛卡儿积的区别"></a>自然连接和笛卡儿积的区别</h1><h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><p>自然连接和笛卡儿积都会合并元组</p><h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><p>笛卡儿积直接合并元组,就是在前一个关系的元组后面追加后面关系的元组即可.</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><code>instructor</code>关系包括(<code>ID,name,dept_name,salary)</code>这4个属性.<br><code>teaches</code>关系包括(<code>ID, course_id,sec_id,semester,year)</code>这5个属性.</p><h3 id="笛卡尔积结果"><a href="#笛卡尔积结果" class="headerlink" title="笛卡尔积结果"></a>笛卡尔积结果</h3><p><code>instructor</code>和<code>teaches</code>的笛卡儿积将有<code>(ID,name,dept_name,salary,ID, course_id,sec_id,semester,year)</code>这9个属性.可以看到笛卡儿积的结果将有两个重复的ID属性.<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from instructor ,teaches;</span><br><span class="line">+-------+------------+------------+--------+-------+-----------+--------+----------+------+</span><br><span class="line">| ID    | name       | dept_name  | salary | ID    | course_id | sec_id | semester | year |</span><br><span class="line">+-------+------------+------------+--------+-------+-----------+--------+----------+------+</span><br></pre></td></tr></table></figure><br>这里笛卡儿积合并的结果为:<br><code>第一个表的属性 第二个表的属性</code></p><h3 id="自然连接结果"><a href="#自然连接结果" class="headerlink" title="自然连接结果"></a>自然连接结果</h3><p><code>instructor</code>关系和<code>teaches</code>关系都有一个公共的属性ID,自然连接合并公共的属性<code>ID</code>,也就是自然连接的结果为:<br><code>(ID,name,dept_name,salary,course_id,sec_id,semester,year)</code>,可以发现自然连接只有8个属性,重复的属性ID只占一列.<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from instructor natural join teaches;</span><br><span class="line">+-------+------------+------------+--------+-----------+--------+----------+------+</span><br><span class="line">| ID    | name       | dept_name  | salary | course_id | sec_id | semester | year |</span><br></pre></td></tr></table></figure><br>这里自然连接合并的结果为:<br><code>公共属性 第一个表的属性 第二个表的属性</code><br><!--SSTStop--></p><blockquote><h1 id="大学数据库模式"><a href="#大学数据库模式" class="headerlink" title="大学数据库模式"></a>大学数据库模式</h1><p>教室:<code>classroom(<u>building</u>,room_number,capacity)</code><br>系:<code>department(<u>dept_name</u>,building,budget)</code><br>课程:<code>course(<u>course_id</u>,title,dept_name,credits)</code><br>授课:<code>teaches(<u>ID,course_id,sec_id,semester,year</u>)</code><br>讲师:<code>instructor(<u>ID</u>,name,dept_name,salary)</code><br><code>section(<u>course_id,sec_id,semester,year</u>,building,room_number,time_slot_id)</code><br>学生:<code>student(<u>ID</u>,name,dept_name,tot_cred)</code><br><code>takes(<u>ID,course_id,sec_id,semester,year</u>,grade)</code><br><code>advisor(<u>s_ID,i_ID</u>)</code><br><code>time_slot(<u>time_slot_id,day,start_time</u>,end_time)</code><br><code>prereq(<u>course_id,prereq_id</u>)</code></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第3章 SQL </category>
          
          <category> 3.3 SQL查询的基本结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.3.2 多关系查询</title>
      <link href="/ReadingNotes//43da05aa/"/>
      <url>/ReadingNotes//43da05aa/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/43da05aa/#3-3-2-多关系查询" class="header_1">3.3.2 多关系查询</a>&nbsp;<br><a href="/ReadingNotes/43da05aa/#找出所有-教师-的-姓名-以及他们-所在系-的-名称-和-系所在建筑的名称" class="header_2">找出所有`教师`的`姓名`,以及他们`所在系`的`名称`和`系所在建筑的名称`</a>&nbsp;<br><a href="/ReadingNotes/43da05aa/#如何查询" class="header_3">如何查询</a>&nbsp;<br><a href="/ReadingNotes/43da05aa/#对应的SQL语句" class="header_3">对应的SQL语句</a>&nbsp;<br><a href="/ReadingNotes/43da05aa/#两个关系中的同名属性要使用关系名作为前缀" class="header_2">两个关系中的同名属性要使用关系名作为前缀</a>&nbsp;<br><a href="/ReadingNotes/43da05aa/#不重名的属性不需要关系名作为前缀" class="header_2">不重名的属性不需要关系名作为前缀</a>&nbsp;<br><a href="/ReadingNotes/43da05aa/#多个关系查询的-SQL-通用形式" class="header_2">多个关系查询的`SQL`通用形式</a>&nbsp;<br><a href="/ReadingNotes/43da05aa/#select-from-where三个子句的作用" class="header_2">select from where三个子句的作用</a>&nbsp;<br><a href="/ReadingNotes/43da05aa/#SQL查询语句格式" class="header_2">SQL查询语句格式</a>&nbsp;<br><a href="/ReadingNotes/43da05aa/#查询运算各子句的执行顺序" class="header_2">查询运算各子句的执行顺序</a>&nbsp;<br><a href="/ReadingNotes/43da05aa/#form子句得到笛卡尔积" class="header_2">form子句得到笛卡尔积</a>&nbsp;<br><a href="/ReadingNotes/43da05aa/#笛卡尔积说明" class="header_3">笛卡尔积说明</a>&nbsp;<br><a href="/ReadingNotes/43da05aa/#where子句限制from子句得到的笛卡尔积" class="header_2">where子句限制from子句得到的笛卡尔积</a>&nbsp;<br><a href="/ReadingNotes/43da05aa/#理解SQL查询的结果应该是什么样的" class="header_2">理解SQL查询的结果应该是什么样的</a>&nbsp;<br><a href="/ReadingNotes/43da05aa/#要设置合适的where" class="header_2">要设置合适的where</a>&nbsp;<br><a href="/ReadingNotes/43da05aa/#大学数据库模式" class="header_1">大学数据库模式</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="3-3-2-多关系查询"><a href="#3-3-2-多关系查询" class="headerlink" title="3.3.2 多关系查询"></a>3.3.2 多关系查询</h1><h2 id="找出所有教师的姓名-以及他们所在系的名称和系所在建筑的名称"><a href="#找出所有教师的姓名-以及他们所在系的名称和系所在建筑的名称" class="headerlink" title="找出所有教师的姓名,以及他们所在系的名称和系所在建筑的名称"></a>找出所有<code>教师</code>的<code>姓名</code>,以及他们<code>所在系</code>的<code>名称</code>和<code>系所在建筑的名称</code></h2><p>考虑<code>instructor</code>关系的模式,我们发现可以从<code>dept_name</code>属性得到<code>系名</code>,但是系所在建筑的名称是在<code>department</code>关系的<code>building</code>属性中给出的。<br><!--SSTStop--></p><blockquote><p>教师模式:<code>instructor(<u>ID</u>,name,dept_name,salary)</code><br>系模式:<code>department(<u>dept_name</u>,building,budget)</code></p></blockquote><!--SSTStart--><p>为了回答上面的查询, <code>instructor</code>关系中的每个元组必须与<code>department</code>关系中的元组匹配,也就是<strong><code>department</code>在<code>dept_name</code>上的取值要<code>等于</code> <code>instructor</code>元组在<code>dept_name</code>上的取值</strong>。</p><h3 id="如何查询"><a href="#如何查询" class="headerlink" title="如何查询"></a>如何查询</h3><p>为了在<code>SQL</code>中回答上述查询,我们<strong>把需要访问的关系都列在<code>from</code>子句中,并在<code>where</code>子句中指定<code>匹配条件</code></strong>。</p><h3 id="对应的SQL语句"><a href="#对应的SQL语句" class="headerlink" title="对应的SQL语句"></a>对应的SQL语句</h3><p>上述查询可用<code>SQL</code>写为:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, instructor.dept_name, building</span><br><span class="line">    <span class="keyword">from</span> instructor, department</span><br><span class="line">    <span class="keyword">where</span> instructor.dept_name = department.dept_name;</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select name, instructor.dept_name, building</span><br><span class="line">from instructor, department</span><br><span class="line">where instructor.dept_name = department.dept_name;</span><br><span class="line">+------------+------------+----------+</span><br><span class="line">| name       | dept_name  | building |</span><br><span class="line">+------------+------------+----------+</span><br><span class="line">| Crick      | Biology    | Watson   |</span><br><span class="line">| Srinivasan | <span class="built_in">Comp</span>. Sci. | Taylor   |</span><br><span class="line">| Katz       | <span class="built_in">Comp</span>. Sci. | Taylor   |</span><br><span class="line">| Brandt     | <span class="built_in">Comp</span>. Sci. | Taylor   |</span><br><span class="line">| Kim        | Elec. Eng. | Taylor   |</span><br><span class="line">| Wu         | Finance    | Painter  |</span><br><span class="line">| Singh      | Finance    | Painter  |</span><br><span class="line">| El Said    | History    | Painter  |</span><br><span class="line">| Califieri  | History    | Painter  |</span><br><span class="line">| Mozart     | Music      | Packard  |</span><br><span class="line">| Einstein   | Physics    | Watson   |</span><br><span class="line">| Gold       | Physics    | Watson   |</span><br><span class="line">+------------+------------+----------+</span><br><span class="line"><span class="number">12</span> rows <span class="keyword">in</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure></p><h2 id="两个关系中的同名属性要使用关系名作为前缀"><a href="#两个关系中的同名属性要使用关系名作为前缀" class="headerlink" title="两个关系中的同名属性要使用关系名作为前缀"></a>两个关系中的同名属性要使用关系名作为前缀</h2><p><code>dept_name</code>属性既出现在<code>instructor</code>关系中,也出现在<code>department</code>中,所以需要使用关系名作为前缀来说明我们使用的是哪个属性<br>例如:<br><code>instructor.dept_name</code><br><code>department.dept_name</code></p><h2 id="不重名的属性不需要关系名作为前缀"><a href="#不重名的属性不需要关系名作为前缀" class="headerlink" title="不重名的属性不需要关系名作为前缀"></a>不重名的属性不需要关系名作为前缀</h2><p>属性<code>name</code>和<code>building</code>只出现在一个关系中,因而不需要把关系名作为前缀。</p><h2 id="多个关系查询的SQL通用形式"><a href="#多个关系查询的SQL通用形式" class="headerlink" title="多个关系查询的SQL通用形式"></a>多个关系查询的<code>SQL</code>通用形式</h2><p>现在我们考虑涉及多个关系的<code>SQL</code>查询的通用形式。</p><h2 id="select-from-where三个子句的作用"><a href="#select-from-where三个子句的作用" class="headerlink" title="select from where三个子句的作用"></a>select from where三个子句的作用</h2><p>一个<code>SQL</code>查询可以包括三种类型的子句:<code>select</code>子句、<code>from</code>子句和<code>where</code>子句。每种子句的作用如下:</p><ul><li><code>select</code>子句用于列出<code>查询结果中所需要的属性</code>。</li><li><code>from</code>子句是一个查询求值中需要访问的<code>关系列表</code>。</li><li><code>where</code>子句是一个<strong>作用在<code>from</code>子句中关系的属性上的谓词</strong></li></ul><h2 id="SQL查询语句格式"><a href="#SQL查询语句格式" class="headerlink" title="SQL查询语句格式"></a>SQL查询语句格式</h2><p>一个典型的<code>SQL</code>查询具有如下形式:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> A1,A2,...An</span><br><span class="line">    <span class="keyword">form</span> R1,R2,...,Rm</span><br><span class="line">    <span class="keyword">where</span> P;</span><br></pre></td></tr></table></figure><br>每个<code>An</code>,代表一个属性,每个<code>Rm</code>代表一个关系。<code>P</code>是一个谓词。如果省略<code>where</code>子句,则谓词<code>P</code>为<code>true</code>。<br>如何</p><h2 id="查询运算各子句的执行顺序"><a href="#查询运算各子句的执行顺序" class="headerlink" title="查询运算各子句的执行顺序"></a>查询运算各子句的执行顺序</h2><p>尽管各子句必须以<code>select</code>、<code>from</code>、 <code>where</code>的次序写出,但理解查询所代表运算的最容易的方式是<code>以运算的顺序</code>来考察各子句:</p><ul><li>首先是<code>from</code>,</li><li>然后是<code>where</code>,</li><li>最后是<code>select</code>。</li></ul><h2 id="form子句得到笛卡尔积"><a href="#form子句得到笛卡尔积" class="headerlink" title="form子句得到笛卡尔积"></a>form子句得到笛卡尔积</h2><p><strong>通过<code>from</code>子句定义了一个在该子句中所列出关系上的<code>笛卡儿积</code></strong>。<br><!--SSTStop--><br>它可以用集合理论来形式化地定义,但最好通过下面的迭代过程来理解,此过程可为<code>from</code>子句的结果关系产生元组。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for each 元组T1 in 关系R1</span><br><span class="line">    for each 元组T2 in 关系R2</span><br><span class="line">        ...</span><br><span class="line">        for each 元组Tn in 关系Rn</span><br><span class="line">            把T1,T2,...,Tn 连接 成单个元组T</span><br><span class="line">            把T加入结果关系中.</span><br></pre></td></tr></table></figure><br>此结果关系具有来自<code>from</code>子句中所有关系的所有属性。由于在关系<code>Ri</code>和<code>Rj</code>中可能出现相同的属性名,此时需要在属性名前加上关系名作为前缀,表示该属性来自于哪个关系。</p><h3 id="笛卡尔积说明"><a href="#笛卡尔积说明" class="headerlink" title="笛卡尔积说明"></a>笛卡尔积说明</h3><blockquote><p><code>instructor(<u>ID</u>,name,dept_name,salary)</code><br><code>teaches(<u>ID,course_id,sec_id,semester,year</u>)</code></p></blockquote><p>关系<code>instructor</code>和<code>teaches</code>的<code>笛卡儿积</code>的关系模式为:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(instructor.ID, instructor.name, instructor.dept_name, instructor.salary teaches.ID, teaches.course_id, teaches.sec_id, teaches.semester, teaches.year)</span><br></pre></td></tr></table></figure><br>有了这个模式,我们可以区分出<code>instructor.ID</code>和<code>teaches.ID</code>。对于那些只出现在单个模式中的属性,我们通常去掉关系名前缀。这种简化并不会造成任何混淆。这样我们可以把关系模式写为<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(instructor.ID, name, dept_name, salary, teaches.ID, course_id, sec_id, semester, year)</span><br></pre></td></tr></table></figure></p><p>通过<code>笛卡儿积</code>把来自<code>instructor</code>和<code>teaches</code>中相互没有关联的元组组合起来。 <code>instructor</code>中的每个元组和<code>teaches</code>中的所有元组都要进行组合。结果可能是一个非常庞大的关系,创建这样的笛卡儿积通常是没有意义的。<br><!--SSTStart--></p><h2 id="where子句限制from子句得到的笛卡尔积"><a href="#where子句限制from子句得到的笛卡尔积" class="headerlink" title="where子句限制from子句得到的笛卡尔积"></a>where子句限制from子句得到的笛卡尔积</h2><p><code>where</code>子句中的谓词用来限制笛卡儿积所建立的组合,只留下那些对所需答案有意义的组合。<br>例如:<br>我们希望把<code>teaches</code>元组只和<strong>具有相同<code>ID</code>值</strong>的<code>instructor</code>元组进行匹配。下面的<code>SQL</code>查询满足这个条件,从这些匹配元组中输出教师名和课程标识。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, course_id</span><br><span class="line"><span class="keyword">from</span> instructor , teaches</span><br><span class="line"><span class="keyword">where</span> instructor.ID= teaches.ID;</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select name, course_id</span><br><span class="line">from instructor , teaches</span><br><span class="line">where instructor.ID= teaches.ID;</span><br><span class="line">+------------+-----------+</span><br><span class="line">| name       | course_id |</span><br><span class="line">+------------+-----------+</span><br><span class="line">| Srinivasan | CS-<span class="number">101</span>    |</span><br><span class="line">| Srinivasan | CS-<span class="number">315</span>    |</span><br><span class="line">| Srinivasan | CS-<span class="number">347</span>    |</span><br><span class="line">| Wu         | FIN-<span class="number">201</span>   |</span><br><span class="line">| Mozart     | MU-<span class="number">199</span>    |</span><br><span class="line">| Einstein   | PHY-<span class="number">101</span>   |</span><br><span class="line">| El Said    | HIS-<span class="number">351</span>   |</span><br><span class="line">| Katz       | CS-<span class="number">101</span>    |</span><br><span class="line">| Katz       | CS-<span class="number">319</span>    |</span><br><span class="line">| Crick      | BIO-<span class="number">101</span>   |</span><br><span class="line">| Crick      | BIO-<span class="number">301</span>   |</span><br><span class="line">| Brandt     | CS-<span class="number">190</span>    |</span><br><span class="line">| Brandt     | CS-<span class="number">190</span>    |</span><br><span class="line">| Brandt     | CS-<span class="number">319</span>    |</span><br><span class="line">| Kim        | EE-<span class="number">181</span>    |</span><br><span class="line">+------------+-----------+</span><br><span class="line"><span class="number">15</span> rows <span class="keyword">in</span> <span class="built_in">set</span></span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><br>注意上述<strong>查询只输出讲授了课程的教师,不会输出那些没有讲授任何课程的教师</strong>,可以使用一种被称作<code>外连接</code>的运算,外连接将在4.1.2节讲述。</p><p>如果我们只希望找出<code>Computer Science</code>系的教师名和课程标识,我们可以在<code>where</code>子句中增加另外的谓词,如下所示:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, course_id </span><br><span class="line"><span class="keyword">from</span> instructor, teaches</span><br><span class="line"><span class="keyword">where</span> instructor.ID= teaches.ID <span class="keyword">and</span> instructor.dept_name = <span class="string">'Comp. Sci.'</span>;</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select name, course_id</span><br><span class="line">from instructor, teaches</span><br><span class="line">where instructor.ID= teaches.ID and instructor.dept_name = '<span class="built_in">Comp</span>. Sci.';</span><br><span class="line">+------------+-----------+</span><br><span class="line">| name       | course_id |</span><br><span class="line">+------------+-----------+</span><br><span class="line">| Srinivasan | CS-<span class="number">101</span>    |</span><br><span class="line">| Srinivasan | CS-<span class="number">315</span>    |</span><br><span class="line">| Srinivasan | CS-<span class="number">347</span>    |</span><br><span class="line">| Katz       | CS-<span class="number">101</span>    |</span><br><span class="line">| Katz       | CS-<span class="number">319</span>    |</span><br><span class="line">| Brandt     | CS-<span class="number">190</span>    |</span><br><span class="line">| Brandt     | CS-<span class="number">190</span>    |</span><br><span class="line">| Brandt     | CS-<span class="number">319</span>    |</span><br><span class="line">+------------+-----------+</span><br><span class="line"><span class="number">8</span> rows <span class="keyword">in</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure></p><h2 id="理解SQL查询的结果应该是什么样的"><a href="#理解SQL查询的结果应该是什么样的" class="headerlink" title="理解SQL查询的结果应该是什么样的"></a>理解SQL查询的结果应该是什么样的</h2><p>通常说来,一个<code>SQL</code>查询的含义可以理解如下:</p><ol><li>为<code>from</code>子句中列出的关系产生<code>笛卡儿积</code>。</li><li>在步骤1的结果上应用<code>where</code>子句中指定的谓词。</li><li>对于步骤2结果中的每个元组,输出<code>select</code>子句中指定的属性(或表达式的结果)。</li></ol><p>上述步骤的顺序有助于<strong>明白一个<code>SQL</code>查询的结果应该是什么样的,</strong>而不是这个结果是怎样被执行的。在<code>SQL</code>的实际实现中不会执行这种形式的查询,它会通过(尽可能)只产生满足<code>where</code>子句谓词的笛卡儿积元素来进行优化执行。我们在后面第12章和第13章学习那样的实现技术。</p><h2 id="要设置合适的where"><a href="#要设置合适的where" class="headerlink" title="要设置合适的where"></a>要设置合适的where</h2><p>当书写查询时,需要小心设置合适的where子句条件。如果在前述SQL查询中省略where子句条件,就会输出<code>笛卡儿积</code>,那是一个巨大的关系<br><!--SSTStop--></p><h1 id="大学数据库模式"><a href="#大学数据库模式" class="headerlink" title="大学数据库模式"></a>大学数据库模式</h1><p><code>classroom(<u>building</u>,room_number,capacity)</code><br><code>department(<u>dept_name</u>,building,budget)</code><br><code>course(<u>course_id</u>,title,dept_name,credits)</code><br><code>instructor(<u>ID</u>,name,dept_name,salary)</code><br><code>section(<u>course_id,sec_id,semester,year</u>,building,room_number,time_slot_id)</code><br><code>teaches(<u>ID,course_id,sec_id,semester,year</u>)</code><br><code>student(<u>ID</u>,name,dept_name,tot_cred)</code><br><code>takes(<u>ID,course_id,sec_id,semester,year</u>,grade)</code><br><code>advisor(<u>s_ID,i_ID</u>)</code><br><code>time_slot(<u>time_slot_id,day,start_time</u>,end_time)</code><br><code>prereq(<u>course_id,prereq_id</u>)</code><br><!--SSTStart--></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第3章 SQL </category>
          
          <category> 3.3 SQL查询的基本结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.3 SQL查询的基本结构 3.3.1 单关系查询</title>
      <link href="/ReadingNotes//b0218f52/"/>
      <url>/ReadingNotes//b0218f52/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/b0218f52/#3-3-SQL查询的基本结构" class="header_1">3.3 SQL查询的基本结构</a>&nbsp;<br><a href="/ReadingNotes/b0218f52/#3-3-1-单关系查询" class="header_1">3.3.1 单关系查询</a>&nbsp;<br><a href="/ReadingNotes/b0218f52/#instructor关系模式定义如下" class="header_2">instructor关系模式定义如下</a>&nbsp;<br><a href="/ReadingNotes/b0218f52/#找出所有教师的名字" class="header_2">找出所有教师的名字</a>&nbsp;<br><a href="/ReadingNotes/b0218f52/#找出所有教师所在的系名" class="header_2">找出所有教师所在的系名</a>&nbsp;<br><a href="/ReadingNotes/b0218f52/#去除查询结果中的重复-select-distinct" class="header_2">去除查询结果中的重复 select distinct</a>&nbsp;<br><a href="/ReadingNotes/b0218f52/#保留查询结果中的重复-select-all" class="header_2">保留查询结果中的重复 select all</a>&nbsp;<br><a href="/ReadingNotes/b0218f52/#算术运算符" class="header_2">算术运算符</a>&nbsp;<br><a href="/ReadingNotes/b0218f52/#算术运算符可用于常数或者元组的属性" class="header_3">算术运算符可用于常数或者元组的属性</a>&nbsp;<br><a href="/ReadingNotes/b0218f52/#特定类型的算术函数" class="header_2">特定类型的算术函数</a>&nbsp;<br><a href="/ReadingNotes/b0218f52/#where子句" class="header_1">where子句</a>&nbsp;<br><a href="/ReadingNotes/b0218f52/#找出所有在Computer-Science系并且工资超过70000美元的教师的姓名" class="header_2">找出所有在Computer Science系并且工资超过70000美元的教师的姓名</a>&nbsp;<br><a href="/ReadingNotes/b0218f52/#逻辑连词" class="header_2">逻辑连词</a>&nbsp;<br><a href="/ReadingNotes/b0218f52/#逻辑连词的运算对象是包含比较运算符的表达式" class="header_3">逻辑连词的运算对象是包含比较运算符的表达式</a>&nbsp;<br><a href="/ReadingNotes/b0218f52/#大学数据库模式" class="header_1">大学数据库模式</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="3-3-SQL查询的基本结构"><a href="#3-3-SQL查询的基本结构" class="headerlink" title="3.3 SQL查询的基本结构"></a>3.3 SQL查询的基本结构</h1><p><code>SQL</code>查询的基本结构由三个子句构成:<code>select</code>、<code>from</code>和<code>where</code>。<br>查询的输入是在<code>from</code>子句中列出的关系,在这些关系上进行<code>where</code>和<code>select</code>子句中指定的运算,然后产生一个关系作为结果。<br>我们通过例子介绍<code>SQL</code>的语法,后面再描述<code>SQL</code>查询的通用结构。</p><h1 id="3-3-1-单关系查询"><a href="#3-3-1-单关系查询" class="headerlink" title="3.3.1 单关系查询"></a>3.3.1 单关系查询</h1><h2 id="instructor关系模式定义如下"><a href="#instructor关系模式定义如下" class="headerlink" title="instructor关系模式定义如下"></a>instructor关系模式定义如下</h2><p><code>instructor(<u>ID</u>,name,dept_name,salary)</code></p><h2 id="找出所有教师的名字"><a href="#找出所有教师的名字" class="headerlink" title="找出所有教师的名字"></a>找出所有教师的名字</h2><p>我们考虑使用<code>大学数据库例子</code>的一个简单查询:<strong>“找出所有教师的名字”</strong>。教师的名字可以在<code>instructor</code>关系中找到,因此我们把<code>instructor</code>关系放到<code>from</code>子句中。教师的名字出现在<code>name</code>属性中,因此我们把<code>name</code>放到<code>select</code>子句中。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> instructor;</span><br></pre></td></tr></table></figure><br>其结果是由属性名为<code>name</code>的单个属性构成的关系。</p><h2 id="找出所有教师所在的系名"><a href="#找出所有教师所在的系名" class="headerlink" title="找出所有教师所在的系名"></a>找出所有教师所在的系名</h2><p>现在考虑另一个查询:”找出所有教师所在的系名”,此查询可写为:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> dept_name <span class="keyword">from</span> instructor;</span><br></pre></td></tr></table></figure><br>因为一个系有多个教师,所以在<code>instructor</code>关系中,一个系的名称可以出现不止一次。<br>在关系模型的形式化数学定义中,关系是一个集合。因此,重复的元组不会出现在关系中。<br>在实践中,去除重复是相当费时的,所以<strong><code>SQL</code>允许在关系以及<code>SQL</code>表达式结果中出现重复</strong>。因此,在上述<code>SQL</code>查询中,每个系名在<code>instructor</code>关系的元组中每出现一次,都会在查询结果中列出一次。</p><h2 id="去除查询结果中的重复-select-distinct"><a href="#去除查询结果中的重复-select-distinct" class="headerlink" title="去除查询结果中的重复 select distinct"></a>去除查询结果中的重复 select distinct</h2><p>有时候我们想要强行删除重复,可<strong>在<code>select</code>后加入<code>distinct</code>关键词</strong>。如果我们想去除重复,可将上述查询重写为:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> dept_name <span class="keyword">from</span> instructor;</span><br></pre></td></tr></table></figure><br>在上述查询的结果中,每个系名最多只出现一次。</p><h2 id="保留查询结果中的重复-select-all"><a href="#保留查询结果中的重复-select-all" class="headerlink" title="保留查询结果中的重复 select all"></a>保留查询结果中的重复 select all</h2><p><code>SQL</code>允许我们使用关键词<code>all</code>来显式指明不去除重复:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">all</span> dept_name <span class="keyword">from</span> instructor;</span><br></pre></td></tr></table></figure><br>不过<code>SQL</code>是默认保留重复元组的,所以<code>all</code>关键词可以省略。</p><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p><code>select</code>子句还可带含有加(<code>+</code>)、减(<code>-</code>)、乘(<code>*</code>)、除(<code>/</code>)运算符的算术表达式。</p><h3 id="算术运算符可用于常数或者元组的属性"><a href="#算术运算符可用于常数或者元组的属性" class="headerlink" title="算术运算符可用于常数或者元组的属性"></a>算术运算符可用于常数或者元组的属性</h3><p>算术运算符的运算对象可以是<code>常数</code>或元组的<code>属性</code>。例如,查询语句:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">ID</span>, <span class="keyword">name</span>, dept_name, salary*<span class="number">1.1</span> <span class="keyword">from</span> instructor;</span><br></pre></td></tr></table></figure><br>将返回一个与<code>instructor</code>一样的关系,只是属性<code>salary</code>的值是原来的<code>1.1</code>倍。这显示了如果我们给每位教师增长10%的工资的结果。注意这并不导致对<code>instructor</code>关系的任何改变。</p><h2 id="特定类型的算术函数"><a href="#特定类型的算术函数" class="headerlink" title="特定类型的算术函数"></a>特定类型的算术函数</h2><p><code>SQL</code>还提供了一些特殊数据类型,如各种形式的<code>日期类型</code>,并允许一些作用于这些类型上的<code>算术函数</code>。我们在4.5.1节进一步讨论这个问题。</p><h1 id="where子句"><a href="#where子句" class="headerlink" title="where子句"></a>where子句</h1><p><code>where</code>子句允许我们只选出那些在<code>from</code>子句的<code>结果关系</code>中满足特定谓词的元组。</p><h2 id="找出所有在Computer-Science系并且工资超过70000美元的教师的姓名"><a href="#找出所有在Computer-Science系并且工资超过70000美元的教师的姓名" class="headerlink" title="找出所有在Computer Science系并且工资超过70000美元的教师的姓名"></a>找出所有在Computer Science系并且工资超过70000美元的教师的姓名</h2><p>考虑查询”找出所有在Computer Science系并且工资超过70000美元的教师的姓名”,该查询用<code>SQL</code>可以写为:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> dept_name =<span class="string">'Comp.Sci'</span> <span class="keyword">and</span> salary &gt;<span class="number">70000</span>;</span><br></pre></td></tr></table></figure></p><h2 id="逻辑连词"><a href="#逻辑连词" class="headerlink" title="逻辑连词"></a>逻辑连词</h2><p><code>SQL</code>允许在<code>where</code>子句中使用逻辑连词<code>and</code>、<code>or</code>和<code>not</code>。</p><h3 id="逻辑连词的运算对象是包含比较运算符的表达式"><a href="#逻辑连词的运算对象是包含比较运算符的表达式" class="headerlink" title="逻辑连词的运算对象是包含比较运算符的表达式"></a>逻辑连词的运算对象是包含比较运算符的表达式</h3><p><strong>逻辑连词`运算对象</strong>可以是<strong>包含比较运算符</strong><code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code>、<code>=</code>和<code>&lt;&gt;</code><strong>的表达式</strong>。<br><code>SQL</code>允许我们使用比较运算符来比较字符串、算术表达式以及特殊类型,如日期类型。<br>在本章的后面,我们将研究<code>where</code>子句谓词的其他特征。<br><!--SSTStop--></p><h1 id="大学数据库模式"><a href="#大学数据库模式" class="headerlink" title="大学数据库模式"></a>大学数据库模式</h1><p><code>classroom(<u>building</u>,room_number,capacity)</code><br><code>department(<u>dept_name</u>,building,budget)</code><br><code>course(<u>course_id</u>,title,dept_name,credits)</code><br><code>instructor(<u>ID</u>,name,dept_name,salary)</code><br><code>section(<u>course_id,sec_id,semester,year</u>,building,room_number,time_slot_id)</code><br><code>teaches(<u>ID,course_id,sec_id,semester,year</u>)</code><br><code>student(<u>ID</u>,name,dept_name,tot_cred)</code><br><code>takes(<u>ID,course_id,sec_id,semester,year</u>,grade)</code><br><code>advisor(<u>s_ID,i_ID</u>)</code><br><code>time_slot(<u>time_slot_id,day,start_time</u>,end_time)</code><br><code>prereq(<u>course_id,prereq_id</u>)</code></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第3章 SQL </category>
          
          <category> 3.3 SQL查询的基本结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.2.2 基本模式定义</title>
      <link href="/ReadingNotes//4ef029b8/"/>
      <url>/ReadingNotes//4ef029b8/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/4ef029b8/#3-2-2-基本模式定义" class="header_1">3.2.2 基本模式定义</a>&nbsp;<br><a href="/ReadingNotes/4ef029b8/#创建关系-create-table" class="header_2">创建关系 create table</a>&nbsp;<br><a href="/ReadingNotes/4ef029b8/#create-table命令格式" class="header_2">create table命令格式</a>&nbsp;<br><a href="/ReadingNotes/4ef029b8/#命令以分号结束" class="header_2">命令以分号结束</a>&nbsp;<br><a href="/ReadingNotes/4ef029b8/#完整性约束" class="header_2">完整性约束</a>&nbsp;<br><a href="/ReadingNotes/4ef029b8/#primary-key" class="header_3">primary key</a>&nbsp;<br><a href="/ReadingNotes/4ef029b8/#foreign-key" class="header_3">foreign key</a>&nbsp;<br><a href="/ReadingNotes/4ef029b8/#not-null" class="header_3">not null</a>&nbsp;<br><a href="/ReadingNotes/4ef029b8/#SQL不允许破坏完整性约束的命令执行" class="header_2">SQL不允许破坏完整性约束的命令执行</a>&nbsp;<br><a href="/ReadingNotes/4ef029b8/#主码不能为空-主码不能重复" class="header_3">主码不能为空 主码不能重复</a>&nbsp;<br><a href="/ReadingNotes/4ef029b8/#外码要在被参照关系中存在" class="header_3">外码要在被参照关系中存在</a>&nbsp;<br><a href="/ReadingNotes/4ef029b8/#插入元组-insert-into" class="header_2">插入元组 insert into</a>&nbsp;<br><a href="/ReadingNotes/4ef029b8/#删除元组-delete-from" class="header_2">删除元组 delete from</a>&nbsp;<br><a href="/ReadingNotes/4ef029b8/#删除关系-drop-table" class="header_2">删除关系 drop table</a>&nbsp;<br><a href="/ReadingNotes/4ef029b8/#drop-table-和delete-from" class="header_2">drop table 和delete from</a>&nbsp;<br><a href="/ReadingNotes/4ef029b8/#alter-table" class="header_2">alter table</a>&nbsp;<br><a href="/ReadingNotes/4ef029b8/#为已有的关系增加属性-alter-table-r-add-A-D" class="header_3">为已有的关系增加属性 alter table r add A D</a>&nbsp;<br><a href="/ReadingNotes/4ef029b8/#从关系中去掉属性-alter-table-r-drop-A" class="header_3">从关系中去掉属性 alter table r drop A</a>&nbsp;<br><a href="/ReadingNotes/4ef029b8/#有些数据库不支持删除属性" class="header_4">有些数据库不支持删除属性</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="3-2-2-基本模式定义"><a href="#3-2-2-基本模式定义" class="headerlink" title="3.2.2 基本模式定义"></a>3.2.2 基本模式定义</h1><h2 id="创建关系-create-table"><a href="#创建关系-create-table" class="headerlink" title="创建关系 create table"></a>创建关系 create table</h2><!--SSTStop--><p>我们用<code>create table</code>命令定义<code>SQL</code>关系。</p><p>下面的命令在数据库中创建了一个<code>department</code>关系。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> department(</span><br><span class="line">    dept_name <span class="built_in">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    building <span class="built_in">varchar</span>(<span class="number">15</span>),</span><br><span class="line">    budget <span class="built_in">numeric</span>(<span class="number">12</span>,<span class="number">2</span>),</span><br><span class="line">    primary <span class="keyword">key</span> (dept_name)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><br>上面创建的关系具有三个属性:</p><ul><li><code>dept_name</code>是最大长度为20的字符串, </li><li><code>building</code>是最大长度为15的字符串, </li><li><code>budget</code>是一个12位的数,其中2位数字在小数点后面。 </li><li><code>create table</code>命令还指明了<code>dept_name</code>属性是<code>department</code>关系的主码。</li></ul><h2 id="create-table命令格式"><a href="#create-table命令格式" class="headerlink" title="create table命令格式"></a>create table命令格式</h2><p><code>create table</code>命令的通用形式是:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> r(</span><br><span class="line">    A_1 D_1,</span><br><span class="line">    A_2 D_2,</span><br><span class="line">    ...</span><br><span class="line">    A_n D_n,</span><br><span class="line">    &lt;完整性约束<span class="number">1</span>&gt;,</span><br><span class="line">    ...</span><br><span class="line">    &lt;完整性约束n&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><br>其中<code>r</code>是关系名,每个<code>A_n</code>是关系<code>r</code>模式中的一个属性名,<code>D_n</code>是属性<code>A_n</code>的域,也就是说<code>D_n</code>约束了属性<code>A_n</code>的类型以及可选的范围,是用于限制所允许的A取值的集合。<br><!--SSTStart--></p><h2 id="命令以分号结束"><a href="#命令以分号结束" class="headerlink" title="命令以分号结束"></a>命令以分号结束</h2><p><code>create table</code>命令后面用分号结束,本章后面的其他<code>SQL</code>语句也是如此,在很多<code>SQL</code>实现中分号是可选的。</p><h2 id="完整性约束"><a href="#完整性约束" class="headerlink" title="完整性约束"></a>完整性约束</h2><p><code>SQL</code>支持许多不同的完整性约束。在本节我们只讨论其中少数几个:</p><h3 id="primary-key"><a href="#primary-key" class="headerlink" title="primary key"></a>primary key</h3><p><code>primary key(A1, A2,...,Am)</code>: <code>primary key</code>声明表示属性<code>A1,A2,…,Am</code>构成关系的主码。主码属性必须非空且唯一。也就是说没有一个元组在主码属性上取空值,关系中也没有两个元组在所有主码属性上取值相同。虽然主码的声明是可选的,但为每个关系指定一个主码通常会更好。</p><h3 id="foreign-key"><a href="#foreign-key" class="headerlink" title="foreign key"></a>foreign key</h3><p><code>foreign key(A1,A2,... An) references 关系S</code>:<br><code>foreign key</code>声明表示关系中任意元组在属性<code>(A1,A2,…,An)</code>上的取值必须对应于<code>关系s</code>中某元组在<code>主码</code>属性上的取值。</p><h3 id="not-null"><a href="#not-null" class="headerlink" title="not null"></a>not null</h3><p><code>not null</code>:一个属性上的<code>not null</code>约束表明在该属性上不允许空值。</p><h2 id="SQL不允许破坏完整性约束的命令执行"><a href="#SQL不允许破坏完整性约束的命令执行" class="headerlink" title="SQL不允许破坏完整性约束的命令执行"></a>SQL不允许破坏完整性约束的命令执行</h2><p><code>SQL</code>禁止破坏完整性约束的任何数据库更新。</p><h3 id="主码不能为空-主码不能重复"><a href="#主码不能为空-主码不能重复" class="headerlink" title="主码不能为空 主码不能重复"></a>主码不能为空 主码不能重复</h3><p>例如,如果关系中一条新插入或新修改的元组在任意一个<code>主码</code>属性上有空值,或者元组在<code>主码属性上的取值</code>与关系中的另一个元组的主码属性值相同,<code>SQL</code>将标记个错误,并阻止更新。</p><h3 id="外码要在被参照关系中存在"><a href="#外码要在被参照关系中存在" class="headerlink" title="外码要在被参照关系中存在"></a>外码要在被参照关系中存在</h3><p>类似地,如果插入的<code>course</code>元组在<code>dept_name</code>上的取值没有出现在<code>department</code>关系中,就会破坏<code>course</code>上的外码约束,<code>SQL</code>会阻止这种插入的发生。</p><h2 id="插入元组-insert-into"><a href="#插入元组-insert-into" class="headerlink" title="插入元组 insert into"></a>插入元组 insert into</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> instructor <span class="keyword">values</span>(<span class="number">10211</span>, <span class="string">"Smith"</span>, <span class="string">"Biology"</span>,<span class="number">66000</span>);</span><br></pre></td></tr></table></figure><h2 id="删除元组-delete-from"><a href="#删除元组-delete-from" class="headerlink" title="删除元组 delete from"></a>删除元组 delete from</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> student;</span><br></pre></td></tr></table></figure><h2 id="删除关系-drop-table"><a href="#删除关系-drop-table" class="headerlink" title="删除关系 drop table"></a>删除关系 drop table</h2><p>如果要从<code>SQL</code>数据库中去掉一个关系,我们使用<code>drop table</code>命令。 <code>drop table</code>命令从数据库中删除关于被去掉关系的所有信息。</p><h2 id="drop-table-和delete-from"><a href="#drop-table-和delete-from" class="headerlink" title="drop table 和delete from"></a>drop table 和delete from</h2><p>命令<code>drop table r;</code>是比<code>delete from r;</code>更强的语句。</p><ul><li><code>delete from r;</code>只是删除<code>r</code>中的所有元组,但会保留关系<code>r</code>。</li><li><code>drop table r;</code>不仅删除<code>r</code>的所有元组,还删除<code>r</code>的模式。此时,除非用<code>create table</code>命令重建关系<code>r</code>,否则无法将元组可以插入到关系<code>r</code>中。</li></ul><h2 id="alter-table"><a href="#alter-table" class="headerlink" title="alter table"></a>alter table</h2><h3 id="为已有的关系增加属性-alter-table-r-add-A-D"><a href="#为已有的关系增加属性-alter-table-r-add-A-D" class="headerlink" title="为已有的关系增加属性 alter table r add A D"></a>为已有的关系增加属性 alter table r add A D</h3><p>使用<code>alter table</code>命令可以给已有关系增加属性。关系中的所有元组在新增加的属性上的取值将被设为<code>null</code>,<br><code>alter table</code>命令的格式为:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> r <span class="keyword">add</span> A D</span><br></pre></td></tr></table></figure><br>其中<code>r</code>是现有关系的名字,<code>A</code>是待添加属性的名字,<code>D</code>是待添加属性的域。</p><h3 id="从关系中去掉属性-alter-table-r-drop-A"><a href="#从关系中去掉属性-alter-table-r-drop-A" class="headerlink" title="从关系中去掉属性 alter table r drop A"></a>从关系中去掉属性 alter table r drop A</h3><p>通过命令<code>alter table r drop A</code>可以从关系中去掉属性。<br>其中<code>r</code>是现有关系的名字,<code>A</code>是关系的一个属性的名字。</p><h4 id="有些数据库不支持删除属性"><a href="#有些数据库不支持删除属性" class="headerlink" title="有些数据库不支持删除属性"></a>有些数据库不支持删除属性</h4><p>很多数据库系统并不支持去掉属性,尽管它们允许去掉整个表。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第3章 SQL </category>
          
          <category> 3.2 SQL数据定义 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.2 SQL数据定义 3.2.1 基本类型</title>
      <link href="/ReadingNotes//f68199a2/"/>
      <url>/ReadingNotes//f68199a2/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/f68199a2/#3-2-SQL-数据定义" class="header_1">3.2 `SQL`数据定义</a>&nbsp;<br><a href="/ReadingNotes/f68199a2/#3-2-1-基本类型" class="header_1">3.2.1 基本类型</a>&nbsp;<br><a href="/ReadingNotes/f68199a2/#空值" class="header_2">空值</a>&nbsp;<br><a href="/ReadingNotes/f68199a2/#-char-和-varchar-的区别" class="header_2">`char`和`varchar`的区别</a>&nbsp;<br><a href="/ReadingNotes/f68199a2/#两个char比较时会自动补空格" class="header_2">两个char比较时会自动补空格</a>&nbsp;<br><a href="/ReadingNotes/f68199a2/#有些数据库系统在-char-和-varchar-比较时会自动加空格-有些不" class="header_2">有些数据库系统在`char`和`varchar`比较时会自动加空格 有些不</a>&nbsp;<br><a href="/ReadingNotes/f68199a2/#建议使用-varchar" class="header_2">建议使用`varchar`</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="3-2-SQL数据定义"><a href="#3-2-SQL数据定义" class="headerlink" title="3.2 SQL数据定义"></a>3.2 <code>SQL</code>数据定义</h1><p>数据库中的关系集合必须由<strong>数据定义语言</strong>(<code>DDL</code>)指定给系统。<code>SQL</code>的<code>DDL</code>不仅能够定义一组关系,还能够定义每个关系的信息,包括:</p><ul><li>每个关系的模式。</li><li>每个属性的取值类型。</li><li>完整性约束。</li><li>每个关系维护的索引集合。</li><li>每个关系的安全性和权限信息。</li><li>每个关系在磁盘上的物理存储结构。</li></ul><h1 id="3-2-1-基本类型"><a href="#3-2-1-基本类型" class="headerlink" title="3.2.1 基本类型"></a>3.2.1 基本类型</h1><p><code>SQL</code>标准支持多种固有类型,包括:</p><div class="table-container"><table><thead><tr><th style="text-align:left">数据类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>char(n)</code></td><td style="text-align:left">固定长度的字符串,用户指定长度<code>n</code>。也可以使用全称<code>character</code></td></tr><tr><td style="text-align:left"><code>varchar(n)</code></td><td style="text-align:left">可变长度的字符串,用户指定最大长度<code>n</code>,等价于全称<code>character varying</code></td></tr><tr><td style="text-align:left"><code>int</code></td><td style="text-align:left"><strong>整数类型</strong>(和机器相关的整数的有限子集),等价于全称<code>integer</code></td></tr><tr><td style="text-align:left"><code>smallint</code></td><td style="text-align:left">小整数类型(和机器相关的整数类型的子集)</td></tr><tr><td style="text-align:left"><code>numeric(p,d)</code></td><td style="text-align:left"><strong>定点数</strong>,精度由用户指定。这个数有<code>p</code>位数字(加上一个符号位),其中<code>d</code>位数字在小数点右边。所以在一个这种类型的字段上, <code>numeric(3,1)</code>可以精确储存<code>44.5</code>,但不能精确存储<code>444.5</code>或<code>0.32</code>这样的数。</td></tr><tr><td style="text-align:left"><code>real,double precision</code></td><td style="text-align:left"><code>浮点数</code>与<code>双精度浮点数</code>,精度与机器相关</td></tr><tr><td style="text-align:left"><code>float(n)</code></td><td style="text-align:left">精度至少为<code>n</code>位的浮点数。</td></tr></tbody></table></div><p>更多类型将在4.5节介绍</p><h2 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h2><p><strong>每种类型</strong>都可能包含一个被称作<code>空值</code>的特殊值。空值表示一个缺失的值,该值可能存在但并不为人所知,或者可能根本不存在。在可能的情况下,我们希望禁止加入空值。</p><h2 id="char和varchar的区别"><a href="#char和varchar的区别" class="headerlink" title="char和varchar的区别"></a><code>char</code>和<code>varchar</code>的区别</h2><p><code>char</code>数据类型存放<strong>固定长度</strong>的字符串。例如,属性A的类型是<code>char(10)</code>。如果我们为此属性存入字符串”<code>XYZ</code>“,那么该字符串后<strong>会追加7个空格</strong>来使其达到10个字符的串长度。<br>反之,如果属性B的类型是<code>varchar(10)</code>,我们在属性B中存入字符串”<code>XYZ</code>“,则<strong>不会增加空格</strong>。</p><h2 id="两个char比较时会自动补空格"><a href="#两个char比较时会自动补空格" class="headerlink" title="两个char比较时会自动补空格"></a>两个char比较时会自动补空格</h2><p>比较两个<code>char</code>类型的值时,如果它们的长度不同,在比较之前会自动在<code>短值</code>后面加上额外的空格以使它们的长度一致</p><h2 id="有些数据库系统在char和varchar比较时会自动加空格-有些不"><a href="#有些数据库系统在char和varchar比较时会自动加空格-有些不" class="headerlink" title="有些数据库系统在char和varchar比较时会自动加空格 有些不"></a>有些数据库系统在<code>char</code>和<code>varchar</code>比较时会自动加空格 有些不</h2><p>当比较一个<code>char</code>类型和一个<code>varchar</code>类型的时候,也许读者会期望在比较之前会自动在<code>varchar</code>类型后面加上额外的空格以使长度一致;<br>然而,这种情况可能发生也可能不发生,这<strong>取决于数据库系统</strong>。其结果是,即便上述属性A和B中存放的是相同的值”<code>XYZ</code>“,<code>A=B</code>的比较也可能返回假。</p><h2 id="建议使用varchar"><a href="#建议使用varchar" class="headerlink" title="建议使用varchar"></a>建议使用<code>varchar</code></h2><p>我们建议始终使用<code>varchar</code>类型而不是<code>char</code>类型来避免这样的问题。</p><!--SSTStop-->]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第3章 SQL </category>
          
          <category> 3.2 SQL数据定义 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.1 SQL查询语言概览</title>
      <link href="/ReadingNotes//9f25830/"/>
      <url>/ReadingNotes//9f25830/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/9f25830/#3-1-SQL-查询语言概览" class="header_1">3.1 `SQL`查询语言概览</a>&nbsp;<br><a href="/ReadingNotes/9f25830/#-SQL-语言组成" class="header_2">`SQL`语言组成</a>&nbsp;<br><a href="/ReadingNotes/9f25830/#第3章中介绍的-SQL" class="header_2">第3章中介绍的`SQL`</a>&nbsp;<br><a href="/ReadingNotes/9f25830/#第4章中介绍的-SQL" class="header_2">第4章中介绍的`SQL`</a>&nbsp;<br><a href="/ReadingNotes/9f25830/#第5章中的-SQL" class="header_2">第5章中的`SQL`</a>&nbsp;<br><a href="/ReadingNotes/9f25830/#不同的-SQL-实现存在差异" class="header_2">不同的`SQL`实现存在差异</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="3-1-SQL查询语言概览"><a href="#3-1-SQL查询语言概览" class="headerlink" title="3.1 SQL查询语言概览"></a>3.1 <code>SQL</code>查询语言概览</h1><h2 id="SQL语言组成"><a href="#SQL语言组成" class="headerlink" title="SQL语言组成"></a><code>SQL</code>语言组成</h2><p><code>SQL</code>语言有以下几个部分:    </p><ul><li>数据定义语言(<code>Data-Definition Language</code>,<code>DDL</code>): <code>SQL DDL</code>提供<code>定义关系模式</code>、<code>删除关系</code>以及<code>修改关系模式</code>的命令。<ul><li>授权(<code>authorization</code>): <code>SQL DDL</code>包括定义对关系和视图的访问权限的命令。</li><li>完整性(<code>integrity</code>): <code>SQL DDL</code>包括定义完整性约束的命令,保存在数据库中的数据必须满足所定义的完整性约束。破坏完整性约束的更新是不允许的。</li><li>视图定义(<code>view definition</code>): <code>SQL DDL</code>包括定义视图的命令。</li></ul></li><li>数据操纵语言(<code>Data-Manipulation Language</code>,<code>DML</code>): <code>SQL DML</code>提供从数据库中<code>查询信息</code>,以及在数据库中<code>插入元组</code>、<code>删除元组</code>、<code>修改元组</code>的能力.</li><li>事务控制(<code>transaction control</code>):<code>SQL</code>包括定义事务的开始和结束的命令。</li><li>嵌入式<code>SQL</code>和动态<code>SQL</code>(<code>embedded SQL and dynamic SQL</code>):嵌入式和动态<code>SQL</code>,定义<code>SQL</code>语句如何嵌入到通用编程语言,如<code>C</code>、<code>C++</code>和<code>Java</code>中。</li></ul><h2 id="第3章中介绍的SQL"><a href="#第3章中介绍的SQL" class="headerlink" title="第3章中介绍的SQL"></a>第3章中介绍的<code>SQL</code></h2><p>本章我们给出对<code>SQL</code>的基本<code>DML</code>和<code>DDL</code>特征的概述。在此描述的特征自<code>SQL-92</code>以来就一直是<code>SQL</code>标准的部分。</p><h2 id="第4章中介绍的SQL"><a href="#第4章中介绍的SQL" class="headerlink" title="第4章中介绍的SQL"></a>第4章中介绍的<code>SQL</code></h2><p>在第4章我们提供对<code>SQL</code>查询语言更详细的介绍,包括:</p><ul><li>各种连接的表达;</li><li>视图;</li><li>事务;</li><li>完整性约束;</li><li>类型系统;</li><li>授权。</li></ul><h2 id="第5章中的SQL"><a href="#第5章中的SQL" class="headerlink" title="第5章中的SQL"></a>第5章中的<code>SQL</code></h2><p>在第5章我们介绍<code>SQL</code>语言更高级的特征,包括:</p><ul><li>允许从编程语言中访问<code>SQL</code>的机制;</li><li>SQL函数和过程;</li><li>触发器;</li><li>递归査询;</li><li>高级聚集特征;</li><li>为数据分析设计的一些特征,它们在<code>SQL:1999</code>中引人,并在<code>SQL</code>的后续版本中使用。</li></ul><p>在后面第22章,我们将概述<code>SQL:1999</code>引人的对<code>SQL</code>的面向对象扩充。</p><h2 id="不同的SQL实现存在差异"><a href="#不同的SQL实现存在差异" class="headerlink" title="不同的SQL实现存在差异"></a>不同的<code>SQL</code>实现存在差异</h2><p>尽管大多数<code>SQL</code>实现支持我们在此描述的标准特征,读者还是应该意识到不同<code>SOL</code>实现之间的差异。大多数<code>SQL</code>实现还支持一些非标准的特征,但不支持一些更高级的特征。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第3章 SQL </category>
          
          <category> 3.1 SQL查询语言概览 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2.7 总结</title>
      <link href="/ReadingNotes//fc18f284/"/>
      <url>/ReadingNotes//fc18f284/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/fc18f284/#2-7-总结" class="header_1">2.7 总结</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="2-7-总结"><a href="#2-7-总结" class="headerlink" title="2.7 总结"></a>2.7 总结</h1><ul><li>关系数据模型(<code>relational data model</code>)建立在表的集合的基础上。数据库系统的用户可以对这些表进行查询,可以<code>插入新元组</code>、<code>删除元组</code>以及<code>更新</code>(修改)元组。表达这些操作的语言有几种。</li><li><strong>关系的模式</strong>(<code>schema</code>)是指它的逻辑设计,而关系的实例(<code>instance</code>)是指它在特定时刻的内容。数据库的模式和实例的定义是类似的。关系的模式包括它的属性,还可能包括属性类型和关系上的约束,比如主码和外码约束。</li><li>关系的<strong>超码</strong>(<code>superkey</code>)是一个或多个属性的<code>集合</code>,这些属性上的取值保证可以唯一识别出关系中的元组。<strong>候选码</strong>是一个最小的超码,也就是说,它是一组构成超码的属性集,但这组属性的任意子集都不是超码。关系的一个候选码被选作<strong>主码</strong>(<code>primary key</code>)。</li><li>在参照关系中的<code>外码</code>(<code>foreign key</code>)是这样的一个属性集合:对于参照关系中的每个元组来说,它在外码属性上的取值肯定等于被参照关系中某个元组在主码上的取值。</li><li><strong>模式图</strong>(<code>schema diagram</code>)是数据库中模式的图形化表示,它显示了数据库中的关系,关系的属性、码和外码。</li><li><strong>关系查询语言</strong>(<code>relational query language</code>)定义了一组运算集,这些运算可作用于表上,并输出表作为结果。这些运算可以组合成表达式,表达所需的查询。</li><li><strong>关系代数</strong>(<code>relational algebra</code>)提供了一组运算,它们以一个或多个关系为输入,返回一个关系作为输出。诸如<code>SQL</code>这样的实际查询语言是基于关系代数的,但增加了一些有用的句法特征。</li></ul><!--SSTStop-->]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第2章 关系模型介绍 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2.6 关系运算</title>
      <link href="/ReadingNotes//af4004c1/"/>
      <url>/ReadingNotes//af4004c1/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/af4004c1/#2-6-关系运算" class="header_1">2.6 关系运算</a>&nbsp;<br><a href="/ReadingNotes/af4004c1/#关系运算可以施加在多个关系上" class="header_2">关系运算可以施加在多个关系上</a>&nbsp;<br><a href="/ReadingNotes/af4004c1/#运算结果总是单个关系" class="header_2">运算结果总是单个关系</a>&nbsp;<br><a href="/ReadingNotes/af4004c1/#可以对关系查询结果再次执行关系运算" class="header_2">可以对关系查询结果再次执行关系运算</a>&nbsp;<br><a href="/ReadingNotes/af4004c1/#常见关系运算" class="header_2">常见关系运算</a>&nbsp;<br><a href="/ReadingNotes/af4004c1/#从单个关系中选择满足特定谓词的元组" class="header_3">从单个关系中选择满足特定谓词的元组</a>&nbsp;<br><a href="/ReadingNotes/af4004c1/#从一个关系中选出特定的属性" class="header_3">从一个关系中选出特定的属性</a>&nbsp;<br><a href="/ReadingNotes/af4004c1/#连接运算" class="header_3">连接运算</a>&nbsp;<br><a href="/ReadingNotes/af4004c1/#自然连接" class="header_4">自然连接</a>&nbsp;<br><a href="/ReadingNotes/af4004c1/#笛卡儿积运算" class="header_4">笛卡儿积运算</a>&nbsp;<br><a href="/ReadingNotes/af4004c1/#可以对关系执行集合运算" class="header_2">可以对关系执行集合运算</a>&nbsp;<br><a href="/ReadingNotes/af4004c1/#在查询结果上施加运算" class="header_2">在查询结果上施加运算</a>&nbsp;<br><a href="/ReadingNotes/af4004c1/#查询结果中可能有重复值" class="header_2">查询结果中可能有重复值</a>&nbsp;<br><a href="/ReadingNotes/af4004c1/#关系代数" class="header_1">关系代数</a>&nbsp;<br><a href="/ReadingNotes/af4004c1/#关系运算概述" class="header_2">关系运算概述</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="2-6-关系运算"><a href="#2-6-关系运算" class="headerlink" title="2.6 关系运算"></a>2.6 关系运算</h1><h2 id="关系运算可以施加在多个关系上"><a href="#关系运算可以施加在多个关系上" class="headerlink" title="关系运算可以施加在多个关系上"></a>关系运算可以施加在多个关系上</h2><p>所有的<code>过程化关系査询语言</code>都提供了一组运算,这些运算要么施加于单个关系上,要么施加于一对关系上。</p><h2 id="运算结果总是单个关系"><a href="#运算结果总是单个关系" class="headerlink" title="运算结果总是单个关系"></a>运算结果总是单个关系</h2><p>这些运算具有一个很好的,并且也是所需的性质:运算结果总是单个的关系。</p><h2 id="可以对关系查询结果再次执行关系运算"><a href="#可以对关系查询结果再次执行关系运算" class="headerlink" title="可以对关系查询结果再次执行关系运算"></a>可以对关系查询结果再次执行关系运算</h2><p>由于关系查询的结果本身也是关系,所以关系运算可施加到查询结果上,正如施加到给定关系集上一样。</p><h2 id="常见关系运算"><a href="#常见关系运算" class="headerlink" title="常见关系运算"></a>常见关系运算</h2><h3 id="从单个关系中选择满足特定谓词的元组"><a href="#从单个关系中选择满足特定谓词的元组" class="headerlink" title="从单个关系中选择满足特定谓词的元组"></a>从单个关系中选择满足特定谓词的元组</h3><p>最常用的关系运算是从单个关系(如<code>instructor</code>)中选出满足一些特定谓词(如<code>salary&gt;85000</code>美元)的特殊元组。其结果是一个<code>新关系</code>,它是原始关系(<code>instructor</code>)的一个子集。</p><h3 id="从一个关系中选出特定的属性"><a href="#从一个关系中选出特定的属性" class="headerlink" title="从一个关系中选出特定的属性"></a>从一个关系中选出特定的属性</h3><p>另一个常用的运算是从一个关系中选出特定的属性(列)。其结果是一个只包含那些被选择属性的新关系。<br>例如,假设我们从<code>instructor</code>关系中只希望列出教师的<code>ID</code>和工资,但不列出<code>name</code>和<code>dept_name</code>的值,那么其结果有<code>ID</code>和<code>salary</code>两个属性。结果中的每个元组都是从<code>instructor</code>关系中的某个元组导出的,不过只具有被选中的属性。</p><h3 id="连接运算"><a href="#连接运算" class="headerlink" title="连接运算"></a>连接运算</h3><p><strong><code>连接运算</code>可以把分别来自两个关系的元组对合并成单个元组</strong>。<br>有几种不同的方式来对关系进行连接</p><p>例如一个连接来自<code>instructor</code>和<code>department</code>表中元组的例子,新元组给出了有关每个教师及其工作所在系的信息。此结果是通过把<code>instructor</code>关系中的每个元组和<code>department</code>关系中对应于教师所在系的元组合并形成的。</p><h4 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h4><p><code>自然连接运行</code>从<code>两个关系</code>中<code>合并</code>那些<code>公共属性的取值都相同</code>元组。</p><h4 id="笛卡儿积运算"><a href="#笛卡儿积运算" class="headerlink" title="笛卡儿积运算"></a>笛卡儿积运算</h4><p><code>笛卡儿积运算</code>合并两个关系中的所有元组,无论它们的属性值是否匹配。</p><h2 id="可以对关系执行集合运算"><a href="#可以对关系执行集合运算" class="headerlink" title="可以对关系执行集合运算"></a>可以对关系执行集合运算</h2><p>因为关系是集合,所以我们可以在关系上施加标准的<code>集合运算</code>。<br><code>集合并运算</code>可以在两个”相似结构”的表上执行集合并操作,(比如一个所有毕业生的表和一个所有大学生的表)。例如,我们可以得到一个系中所有学生的集合。<br>另外的集合运算如<code>集合交运算</code>和<code>集合差运算</code>也都可以被执行。</p><h2 id="在查询结果上施加运算"><a href="#在查询结果上施加运算" class="headerlink" title="在查询结果上施加运算"></a>在查询结果上施加运算</h2><p>我们可以在查询结果上施加运算。例如,如果我们想找出工资超过85000美元的那些教师的<code>ID</code>和<code>salary</code>:</p><ul><li>首先我们从<code>instructor</code>关系中选出<code>salary</code>值大于85000美元的元组,</li><li>然后从结果中选出<code>ID</code>和<code>salary</code>两个属性</li></ul><h2 id="查询结果中可能有重复值"><a href="#查询结果中可能有重复值" class="headerlink" title="查询结果中可能有重复值"></a>查询结果中可能有重复值</h2><p>查询结果中可能会包含重复的元组。<br>一些关系语言严格遵守集合的数学定义(集合中不能有重复),去除了重复。<br>另一些关系语言考虑到去除重复需要大量相关的处理,就保留了重复,这种情况下的关系将不再是纯粹数学意义上的真正关系</p><h1 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h1><p>关系代数定义了在关系上的一组运算,对应于作用在数字上的普通代数运算,如<code>加法</code>、<code>减法</code>或<code>乘法</code>。正如作用在数字上的代数运算以一个或多个数字作为输入,返回一个数字作为输出,<strong>关系代数运算通常以一个或两个关系作为输入,返回一个关系作为输出</strong>。</p><h2 id="关系运算概述"><a href="#关系运算概述" class="headerlink" title="关系运算概述"></a>关系运算概述</h2><p>第6章将详细介绍关系代数,下面我们给出几个运算的概述:</p><div class="table-container"><table><thead><tr><th style="text-align:left">关系运算</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">选择</td><td style="text-align:left">返回输入关系中满足谓词的行</td></tr><tr><td style="text-align:left">投影</td><td style="text-align:left">对输入关系的所有行输出指定的属性。从输出中去除重复元组</td></tr><tr><td style="text-align:left">自然连接</td><td style="text-align:left">从两个输入关系中输出<strong><code>共同属性</code>取值相同</strong>的元组对</td></tr><tr><td style="text-align:left">笛卡儿积</td><td style="text-align:left">从两个输入关系中输出所有的元组对(无论它们在共同属性上的取值是否相同)</td></tr><tr><td style="text-align:left">并</td><td style="text-align:left">输出两个输入关系中元组的并</td></tr></tbody></table></div><!--SSTStop--><p>上面的关系运算符省略,要想详细了解请看书中本节的末尾.</p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第2章 关系模型介绍 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2.5 关系查询语言</title>
      <link href="/ReadingNotes//eba6f17e/"/>
      <url>/ReadingNotes//eba6f17e/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/eba6f17e/#2-5-关系查询语言" class="header_1">2.5 关系查询语言</a>&nbsp;<br><a href="/ReadingNotes/eba6f17e/#查询语言分类" class="header_2">查询语言分类</a>&nbsp;<br><a href="/ReadingNotes/eba6f17e/#关系代数和关系演算" class="header_2">关系代数和关系演算</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="2-5-关系查询语言"><a href="#2-5-关系查询语言" class="headerlink" title="2.5 关系查询语言"></a>2.5 关系查询语言</h1><p>查询语言(<code>query language</code>)是用户<code>用来从数据库中请求获取信息的语言</code>。这些语言通常比标准的程序设计语言层次更高。</p><h2 id="查询语言分类"><a href="#查询语言分类" class="headerlink" title="查询语言分类"></a>查询语言分类</h2><p>查询语言可以分为<code>过程化</code>的和<code>非过程化</code>的。</p><ul><li>在过程化语言(<code>procedural language</code>)中,<strong>用户指导系统对数据库执行一系列操作以计算出所需结果</strong>。</li><li>在非过程化语言(<code>nonprocedural language</code>)中,用户只需描述所需信息,而不用给出获取该信息的具体过程。</li></ul><p><strong>实际使用的查询语言既包含过程化方式的成分,又包含非过程化方式的成分</strong>。我们从第3章到第5章学习被广泛应用的查询语言<code>SQL</code>。</p><h2 id="关系代数和关系演算"><a href="#关系代数和关系演算" class="headerlink" title="关系代数和关系演算"></a>关系代数和关系演算</h2><p>在第6章,我们详细研究<code>关系代数</code>和<code>关系演算</code>的两种形式,即<code>元组关系演算</code>和<code>域关系演算</code>。<br><code>关系代数</code>包括一个运算的集合,这些运算以一个或两个关系为输入,产生一个新的关系作为结果。<br><code>关系演算</code>使用<code>谓词逻辑</code>来定义所需的结果,但不需给出获取结果的特定代数过程。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第2章 关系模型介绍 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2.4 模式图</title>
      <link href="/ReadingNotes//a826e794/"/>
      <url>/ReadingNotes//a826e794/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/a826e794/#2-4-模式图" class="header_1">2.4 模式图</a>&nbsp;<br><a href="/ReadingNotes/a826e794/#模式图符号" class="header_2">模式图符号</a>&nbsp;<br><a href="/ReadingNotes/a826e794/#模式图无法显示完整的参照完整性约束" class="header_2">模式图无法显示完整的参照完整性约束</a>&nbsp;<br><a href="/ReadingNotes/a826e794/#实体-联系图" class="header_2">实体-联系图</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="2-4-模式图"><a href="#2-4-模式图" class="headerlink" title="2.4 模式图"></a>2.4 模式图</h1><p>一个含有主码和外码依赖的数据库模式可以用模式图(<code>schema diagram</code>)来表示，图2-8展示了我们大学组织的模式图。</p><h2 id="模式图符号"><a href="#模式图符号" class="headerlink" title="模式图符号"></a>模式图符号</h2><ul><li>每一个关系用一个矩形来表示,</li><li>关系的名字显示在矩形上方,</li><li>矩形内列出各属性。</li><li>主码属性用下划线标注。</li><li>外码依赖用从参照关系的外码属性到被参照关系的主码属性之间的箭头来表示。</li></ul><p>很多数据库系统提供图形化用户界面设计工具来建立<code>模式图</code>。我们将在第7章详细讨论模式的图形化表示。</p><h2 id="模式图无法显示完整的参照完整性约束"><a href="#模式图无法显示完整的参照完整性约束" class="headerlink" title="模式图无法显示完整的参照完整性约束"></a>模式图无法显示完整的参照完整性约束</h2><p>除外码约束之外,模式图中没有显示表示出参照完整性约束。</p><h2 id="实体-联系图"><a href="#实体-联系图" class="headerlink" title="实体-联系图"></a>实体-联系图</h2><p>在后面第7章,我们将学习<code>实体-联系图</code>。实体-联系图有助于我们表示几种约束,包括通用的参照完整性约束。</p><!--SSTStop-->]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第2章 关系模型介绍 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2.3 码</title>
      <link href="/ReadingNotes//8e7772a1/"/>
      <url>/ReadingNotes//8e7772a1/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/8e7772a1/#2-3-码" class="header_1">2 .3 码</a>&nbsp;<br><a href="/ReadingNotes/8e7772a1/#超码" class="header_2">超码</a>&nbsp;<br><a href="/ReadingNotes/8e7772a1/#候选码" class="header_2">候选码</a>&nbsp;<br><a href="/ReadingNotes/8e7772a1/#候选码不唯一" class="header_3">候选码不唯一</a>&nbsp;<br><a href="/ReadingNotes/8e7772a1/#候选码一定要是最小超码" class="header_3">候选码一定要是最小超码</a>&nbsp;<br><a href="/ReadingNotes/8e7772a1/#主码" class="header_2">主码</a>&nbsp;<br><a href="/ReadingNotes/8e7772a1/#要慎重选择主码" class="header_3">要慎重选择主码</a>&nbsp;<br><a href="/ReadingNotes/8e7772a1/#关系模式中主码的写法" class="header_2">关系模式中主码的写法</a>&nbsp;<br><a href="/ReadingNotes/8e7772a1/#外码" class="header_2">外码</a>&nbsp;<br><a href="/ReadingNotes/8e7772a1/#参照关系" class="header_3">参照关系</a>&nbsp;<br><a href="/ReadingNotes/8e7772a1/#被参照关系" class="header_3">被参照关系</a>&nbsp;<br><a href="/ReadingNotes/8e7772a1/#参照关系中外码的值和被参照关系中主键的值相同" class="header_3">参照关系中外码的值和被参照关系中主键的值相同</a>&nbsp;<br><a href="/ReadingNotes/8e7772a1/#参照完整性约束" class="header_2">参照完整性约束</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="2-3-码"><a href="#2-3-码" class="headerlink" title="2 .3 码"></a>2 .3 码</h1><p>一个元组的属性值必须是能够唯一区分元组的。换句话说,<strong>一个关系中没有两个元组在所有属性上的取值都相同</strong></p><h2 id="超码"><a href="#超码" class="headerlink" title="超码"></a>超码</h2><p><strong>超码(<code>superkey</code>)是一个或多个属性的<code>集合</code>,这些属性的<code>组合</code>可以使我们在一个关系中唯一地标识一个元组。</strong><br>例如, <code>instructor</code>关系的<code>ID</code>属性足以将不同的教师元组区分开来,因此,<code>ID</code>是一个超码。另一方面, <code>instructor</code>的<code>name</code>属性却不是一个超码,因为几个教师可能同名。</p><p>超码中可能包含无关紧要的属性。例如,<code>ID</code>和<code>name</code>的组合是关系<code>instructor</code>的一个超码。如果<code>K</code>是一个超码,那么<code>K</code>的任意超集也是超码。</p><h2 id="候选码"><a href="#候选码" class="headerlink" title="候选码"></a>候选码</h2><p>我们通常只对这样的一些超码感兴趣,它们的任意真子集都不能成为超码。这样的<strong>最小超码称为候选码</strong>(<code>candidate key</code>)。</p><h3 id="候选码不唯一"><a href="#候选码不唯一" class="headerlink" title="候选码不唯一"></a>候选码不唯一</h3><p><strong>几个不同的属性集都可以做候选码的情况是存在的</strong>。假设<code>name</code>和<code>dept_name</code>的组合足以区分<code>instructor</code>关系的各个成员,那么<code>{ID}</code>和<code>{name,dept_ name}</code>都是候选码。</p><h3 id="候选码一定要是最小超码"><a href="#候选码一定要是最小超码" class="headerlink" title="候选码一定要是最小超码"></a>候选码一定要是最小超码</h3><p>虽然属性<code>ID</code>和<code>name</code>一起也能区分<code>instructor</code>元组,但它们的组合<code>{ID,name}</code>不是<code>最小超码</code>,所以组合<code>{ID,name}</code>并不能成为候选码。</p><h2 id="主码"><a href="#主码" class="headerlink" title="主码"></a>主码</h2><p>主码(<code>primary key</code>)就是被数据库设计者选中的用来在一个关系中区分不同元组的<code>候选码</code>。也就是<strong>主码是候选码中的一个</strong></p><p>码(不论是主码、候选码或超码)是整个关系的一种性质,而不是单个元组的性质。关系中的<strong>任意两个不同的元组都不允许同时在码属性上具有相同的值</strong>。码的指定代表了被建模的事物在现实世界中的约束。</p><h3 id="要慎重选择主码"><a href="#要慎重选择主码" class="headerlink" title="要慎重选择主码"></a>要慎重选择主码</h3><p>主码的选择必须慎重。正如我们所注意到的那样,<strong>人名显然是不足以作主码的</strong>,因为可能有多个人重名。<br>在美国,人的社会保障号可以作候选码。而<code>非美国居民</code>可能不具有社会保障号,所以跨国企业必须设置他们自己的唯一标识符。另外也可以使用另一些属性的唯一<code>组合</code>作为码。</p><h2 id="关系模式中主码的写法"><a href="#关系模式中主码的写法" class="headerlink" title="关系模式中主码的写法"></a>关系模式中主码的写法</h2><p>习惯上把一个关系模式的主<code>码属性列在其他属性前面</code>;例如,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">department(&lt;u&gt;dept_name&lt;&#x2F;u&gt;, building, budget)</span><br></pre></td></tr></table></figure><br><code>department</code>关系模式中的<code>dept_name</code>属性最先列出,因为它是主码。主<strong>码属性还加上了<code>下划线</code></strong>。</p><h2 id="外码"><a href="#外码" class="headerlink" title="外码"></a>外码</h2><p>一个关系模式(如<code>r1</code>)可能在它的属性<code>A</code>中包括另一个关系模式(如<code>r2</code>)的主码。这个属性<code>A</code>在<code>r1</code>上称作参照<code>r2</code>的<strong>外码</strong>( <code>foreign key</code>)。</p><h3 id="参照关系"><a href="#参照关系" class="headerlink" title="参照关系"></a>参照关系</h3><p>包含外码的关系<code>r1</code>也称为外码依赖的<code>参照关系</code>(<code>referencing relation</code>),</p><h3 id="被参照关系"><a href="#被参照关系" class="headerlink" title="被参照关系"></a>被参照关系</h3><p><code>r2</code>叫做外码的<code>被参照关系</code>(<code>referenced relation)</code>。</p><h3 id="参照关系中外码的值和被参照关系中主键的值相同"><a href="#参照关系中外码的值和被参照关系中主键的值相同" class="headerlink" title="参照关系中外码的值和被参照关系中主键的值相同"></a>参照关系中外码的值和被参照关系中主键的值相同</h3><p>例如, <code>instructor</code>中的<code>dept_name</code>属性在<code>instructor</code>上是外码,它参照<code>department</code>,因为<code>dept_name</code>是<code>department</code>的主码。<br>在任意的数据库实例中,从<code>instructor</code>关系中任取一个元组<code>t_a</code>,在<code>department</code>关系中必定存在某个元组<code>t_b</code>,使得<code>t_a</code>在外码<code>dept_name</code>属性上的取值与<code>t_b</code>在主码<code>dept_name</code>上的取值相同。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">instructor(ID,name,dept_name,salary)</span><br><span class="line">department(dept_name,building,budget)</span><br><span class="line">teaches(ID,course_id,sec_id,semester,year)</span><br><span class="line">section(course_id,sec_id,semester,year,building,room_number,time_slot_id)</span><br><span class="line">student(ID,name,dept_name,tot_cred)</span><br><span class="line">advisor(s_ id, i_id)</span><br><span class="line">takes(ID,course_id,sec_id,semester,year,grade)</span><br><span class="line">classroom(building,room_number,capacity)</span><br><span class="line">time_slot(time_slot_id,day,start_time,end_time)</span><br></pre></td></tr></table></figure></p><h2 id="参照完整性约束"><a href="#参照完整性约束" class="headerlink" title="参照完整性约束"></a>参照完整性约束</h2><p>参照完整性约束要求在参照关系中任意元组在特定属性上的取值必然等于被参照关系中某个元组在特定属性上的取值。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第2章 关系模型介绍 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2.2 数据库模式</title>
      <link href="/ReadingNotes//67eac50b/"/>
      <url>/ReadingNotes//67eac50b/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/67eac50b/#2-2-数据库模式" class="header_1">2.2 数据库模式</a>&nbsp;<br><a href="/ReadingNotes/67eac50b/#什么是数据库模式-什么是数据库实例" class="header_2">什么是数据库模式 什么是数据库实例</a>&nbsp;<br><a href="/ReadingNotes/67eac50b/#关系和关系模式的类比" class="header_2">关系和关系模式的类比</a>&nbsp;<br><a href="/ReadingNotes/67eac50b/#关系模式-类似-类型" class="header_3">关系模式 类似 类型</a>&nbsp;<br><a href="/ReadingNotes/67eac50b/#关系-类似-变量" class="header_3">关系 类似 变量</a>&nbsp;<br><a href="/ReadingNotes/67eac50b/#关系实例-类似-变量的值" class="header_3">关系实例 类似 变量的值</a>&nbsp;<br><a href="/ReadingNotes/67eac50b/#关系模式例子" class="header_2">关系模式例子</a>&nbsp;<br><a href="/ReadingNotes/67eac50b/#department关系模式定义" class="header_3">department关系模式定义</a>&nbsp;<br><a href="/ReadingNotes/67eac50b/#使用相同属性来联系两个关系中的不同元组" class="header_3">使用相同属性来联系两个关系中的不同元组</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="2-2-数据库模式"><a href="#2-2-数据库模式" class="headerlink" title="2.2 数据库模式"></a>2.2 数据库模式</h1><h2 id="什么是数据库模式-什么是数据库实例"><a href="#什么是数据库模式-什么是数据库实例" class="headerlink" title="什么是数据库模式 什么是数据库实例"></a>什么是数据库模式 什么是数据库实例</h2><p>当我们谈论数据库时,我们必须区分数据库模式(<code>database schema</code>)和数据库实例( <code>database instance</code>).</p><ul><li><code>数据库模式</code>是数据库的<code>逻辑设计</code>,</li><li><code>数据库实例</code>是给定时刻数据库中数据的一个快照。</li></ul><h2 id="关系和关系模式的类比"><a href="#关系和关系模式的类比" class="headerlink" title="关系和关系模式的类比"></a>关系和关系模式的类比</h2><h3 id="关系模式-类似-类型"><a href="#关系模式-类似-类型" class="headerlink" title="关系模式 类似 类型"></a>关系模式 类似 类型</h3><p><code>关系模式</code>(<code>relation schema</code>)的概念对应于程序设计语言中<code>类型定义</code>的概念。</p><h3 id="关系-类似-变量"><a href="#关系-类似-变量" class="headerlink" title="关系 类似 变量"></a>关系 类似 变量</h3><p><code>关系</code>的概念对应于程序设计语言中<code>变量</code>的概念,</p><h3 id="关系实例-类似-变量的值"><a href="#关系实例-类似-变量的值" class="headerlink" title="关系实例 类似 变量的值"></a>关系实例 类似 变量的值</h3><p><code>关系实例</code>的概念对应于程序设计语言中<code>变量的值</code>的概念。给定变量的值可能随时间发生变化;类似地,当关系被更新时,关系实例的内容也随时间发生了变化。相反,<code>关系的模式是不常变化的</code>。</p><h2 id="关系模式例子"><a href="#关系模式例子" class="headerlink" title="关系模式例子"></a>关系模式例子</h2><h3 id="department关系模式定义"><a href="#department关系模式定义" class="headerlink" title="department关系模式定义"></a>department关系模式定义</h3><p><code>department</code>关系的模式是:<br><code>department(dept_name, building, budget)</code></p><h3 id="使用相同属性来联系两个关系中的不同元组"><a href="#使用相同属性来联系两个关系中的不同元组" class="headerlink" title="使用相同属性来联系两个关系中的不同元组"></a>使用相同属性来联系两个关系中的不同元组</h3><p>在关系模式中使用<code>相同属性</code>正是将不同关系的元组联系起来的一种方法。例如,假设我们希望找出在<code>Watson</code>大楼工作的所有教师的相关信息。我们首先在<code>department</code>关系中找出所有位于<code>Watson</code>的系的<code>dept_name</code>,接着,对每一个这样的系,我们在<code>instructor</code>关系中找出与<code>dept_name</code>对应的教师信息。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第2章 关系模型介绍 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2.1 关系数据库的结构</title>
      <link href="/ReadingNotes//57fd0e77/"/>
      <url>/ReadingNotes//57fd0e77/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/57fd0e77/#2-1-关系数据库的结构" class="header_1">2.1 关系数据库的结构</a>&nbsp;<br><a href="/ReadingNotes/57fd0e77/#元组" class="header_2">元组</a>&nbsp;<br><a href="/ReadingNotes/57fd0e77/#n元组" class="header_2">n元组</a>&nbsp;<br><a href="/ReadingNotes/57fd0e77/#等价术语" class="header_2">等价术语</a>&nbsp;<br><a href="/ReadingNotes/57fd0e77/#元组的顺序不重要" class="header_2">元组的顺序不重要</a>&nbsp;<br><a href="/ReadingNotes/57fd0e77/#域" class="header_2">域</a>&nbsp;<br><a href="/ReadingNotes/57fd0e77/#什么是原子的域" class="header_2">什么是原子的域</a>&nbsp;<br><a href="/ReadingNotes/57fd0e77/#是不是原子的域与使用这个域的方式有关" class="header_2">是不是原子的域与使用这个域的方式有关</a>&nbsp;<br><a href="/ReadingNotes/57fd0e77/#尽量避免使用空值" class="header_2">尽量避免使用空值</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="2-1-关系数据库的结构"><a href="#2-1-关系数据库的结构" class="headerlink" title="2.1 关系数据库的结构"></a>2.1 关系数据库的结构</h1><p>关系数据库由<code>表</code>的集合构成,每个表有唯一的名字.<br>一般说来,表中一行代表了一组值之间的一种联系。由于一个表就是这种联系的一个集合,表这个概念和数学上的关系这个概念是密切相关的,这也正是关系数据模型名称的由来。</p><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>在数学术语中,元组只是一组值的序列(或列表)。</p><h2 id="n元组"><a href="#n元组" class="headerlink" title="n元组"></a>n元组</h2><p>在n个值之间的一种联系可以在数学上用关于这些值的一个n元组(n- tuple)来表示,换言之,<strong>n元组就是一个有n个值的元组,它对应于表中的一行</strong></p><h2 id="等价术语"><a href="#等价术语" class="headerlink" title="等价术语"></a>等价术语</h2><p>这样,在关系模型的术语中,<code>关系</code>用来指代<code>表</code>,而<code>元组</code>用来指代<code>行</code>,<code>属性</code>指代的是表中的<code>列</code>。</p><p>我们用<code>关系实例</code>这个术语来表示一个关系的特定实例,也就是所包含的<strong>一组特定的行</strong></p><h2 id="元组的顺序不重要"><a href="#元组的顺序不重要" class="headerlink" title="元组的顺序不重要"></a>元组的顺序不重要</h2><p>由于关系是元组集合,<strong>所以元组在关系中出现的顺序是无关紧要的</strong>,为便于说明,当我们在显示关系时,大多数情况下都按其第一个属性排序。</p><h2 id="域"><a href="#域" class="headerlink" title="域"></a>域</h2><p>对于关系的每个属性,都存在一个允许取值的集合,称为该属性的域( <code>domain)</code>。这样<code>instructor</code>关系的<code>salary</code>属性的域就是所有可能的工资值的集合,而<code>name</code>属性的域是所有可能的教师名字的集合。</p><h2 id="什么是原子的域"><a href="#什么是原子的域" class="headerlink" title="什么是原子的域"></a>什么是原子的域</h2><p><strong>如果域中元素被看作是不可再分的单元,则域是原子的(<code>atomic</code>)</strong>。例如,假设<code>instructor</code>表上有一个属性<code>phone_number</code>,它存放教师的一组联系电话号码。那么<code>phone_umber</code>的域就不是原子的,因为其中的元素是一组电话号,是可以被再分为单个电话号码这样的子成分的。</p><h2 id="是不是原子的域与使用这个域的方式有关"><a href="#是不是原子的域与使用这个域的方式有关" class="headerlink" title="是不是原子的域与使用这个域的方式有关"></a>是不是原子的域与使用这个域的方式有关</h2><p>重要的问题不在于域本身是什么,而在于我们怎样在数据库中使用域中元素。现在假设<code>phone_number</code>属性存放单个电话号码。即便如此,如果我们把电话号码的属性值拆分成国家编号、地区编号以及本地号码,那么我们还是把它作为非原子值来对待。<strong>如果我们把每个电话号码作为不可再分的单元,那么<code>phone_number</code>属性才是原子的域</strong>。<br>在本章,以及第3章~第6章,我们假设所有属性的域都是原子的。在第22章中,我们将讨论对关系数据模型进行扩展以便允许非原子域。</p><h2 id="尽量避免使用空值"><a href="#尽量避免使用空值" class="headerlink" title="尽量避免使用空值"></a>尽量避免使用空值</h2><p>空值(<code>null</code>)是一个特殊的值,表示值未知或不存在。如前所述,如果我们在关系<code>instructor</code>中包括属性<code>phone_number</code>则可能某教师根本没有电话号码,或者电话号码未提供。这时我们就只能使用空值来强调该值未知或不存在。以后我们会看到,<strong>空值给数据库访问和更新带来很多困难,因此应尽量避免使用空值</strong>。我们先假设不存在空值,然后在3.6节中我们将描述空值对不同操作的影响。</p><!--SSTStop-->]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第2章 关系模型介绍 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第2章 关系模型介绍</title>
      <link href="/ReadingNotes//e0037f3e/"/>
      <url>/ReadingNotes//e0037f3e/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/e0037f3e/#第2章-关系模型介绍" class="header_1">第2章 关系模型介绍</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="第2章-关系模型介绍"><a href="#第2章-关系模型介绍" class="headerlink" title="第2章 关系模型介绍"></a>第2章 关系模型介绍</h1><p>和早期的数据模型如网络模型或层次模型相比,关系模型以其简易性简化了编程者的工作,关系模型已经成为当今主要的数据模型。</p><ul><li>本章我们先学习关系模型的基础知识.</li><li>在第6章学习关系数据库理论中与<code>查询相关</code>的部分,</li><li>第7章到第8章我们将考察其中用<code>于关系数据库模式设计</code>的部分,</li><li>在第12章和第13章我们将讨论高效处理查询的理论。</li></ul><!--SSTStop-->]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
          <category> 第2章 关系模型介绍 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第一部分 关系数据库</title>
      <link href="/ReadingNotes//48df7c5e/"/>
      <url>/ReadingNotes//48df7c5e/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/48df7c5e/#第一部分-关系数据库" class="header_1">第一部分 关系数据库</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="第一部分-关系数据库"><a href="#第一部分-关系数据库" class="headerlink" title="第一部分 关系数据库"></a>第一部分 关系数据库</h1><p>据模型是描述数据、数据联系、数据语义以及一致性约束的概念工具的集合。</p><ul><li>第2章将专门介绍关系模型<ul><li>关系模型利用<code>表</code>的集合来表示数据和数据间的联系。</li><li>今天大量的数据库产品都是基于关系模型的,关系模型在逻辑层和视图层描述数据。使用户不必关注数据存储的底层细节。</li><li><code>实体-联系模型</code>是一种更高层的数据模型,被广泛<code>用于数据库设计</code>。</li></ul></li><li>第3章、第4章和第5章讲述<code>SQL</code>语言。</li><li>第3章和第4章介绍SQL及其中等程度的应用知识。第4章还将介绍通过数据库施加完整性约束以及授权机制,用来控制用户发出的哪些访问和更新操作是可以执行的。</li><li>第5章介绍更为深入的主题,包括如何<strong>在编程语言中使用<code>SQL</code></strong>,如何利用<code>SQL</code>进行数据分析。</li><li>第6章介绍三种形式的查询语言:<code>关系代数</code>、<code>元组关系演算</code>和<code>域关系演算</code></li></ul><!--SSTStop-->]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第一部分 关系数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.14 总结</title>
      <link href="/ReadingNotes//5d9554e7/"/>
      <url>/ReadingNotes//5d9554e7/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/5d9554e7/#1-14-总结" class="header_1">1.14 总结</a>&nbsp;<br><a href="/ReadingNotes/5d9554e7/#数据库系统的作用" class="header_2">数据库系统的作用</a>&nbsp;<br><a href="/ReadingNotes/5d9554e7/#数据模型" class="header_2">数据模型</a>&nbsp;<br><a href="/ReadingNotes/5d9554e7/#关系数据模型" class="header_2">关系数据模型</a>&nbsp;<br><a href="/ReadingNotes/5d9554e7/#DML" class="header_2">DML</a>&nbsp;<br><a href="/ReadingNotes/5d9554e7/#DDL" class="header_2">DDL</a>&nbsp;<br><a href="/ReadingNotes/5d9554e7/#数据库系统的组成" class="header_2">数据库系统的组成</a>&nbsp;<br><a href="/ReadingNotes/5d9554e7/#事务管理" class="header_2">事务管理</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="1-14-总结"><a href="#1-14-总结" class="headerlink" title="1.14 总结"></a>1.14 总结</h1><p><strong>数据库管理系统(<code>DBMS</code>)由相互关联的数据集合以及一组用于访问这些数据的程序组成</strong>。<br><code>DBMS</code>的主要目标是为人们提供方便、高效的环境来存储和检索数据。<br>如今数据库系统无所不在,很多人每天直接或间接地与数据库系统打交道。<br>数据库系统设计用来存储大量的信息。数据的管理既包括信息存储结构的定义,也包括提供处理信息的机制。另外数据库系统还必须提供所存储信息的安全性,以处理系统崩溃或者非授权访问企图,如果数据在多个用户之间共享,系统必须避免可能的异常结果。</p><h2 id="数据库系统的作用"><a href="#数据库系统的作用" class="headerlink" title="数据库系统的作用"></a>数据库系统的作用</h2><p>数据库系统的一个主要目的是为用户提供数据的抽象视图,也就是说,系统隐藏数据存储和维护的细节</p><h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>数据库结构的基础是数据模型,数据模型是一个用于描述数据、数据之间的联系、数据语义和数据约束的概念工具的集合</p><h2 id="关系数据模型"><a href="#关系数据模型" class="headerlink" title="关系数据模型"></a>关系数据模型</h2><p>关系数据模型是最广泛使用的将数据存储到数据库中的模型。其他的数据模型有面向对象模型、对象-关系模型和半结构化数据模型。</p><h2 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h2><p><strong>数据操纵语言</strong>(<code>Data-Manipulation Language</code>,<code>DML)</code>是使得用户可以访问和操纵数据的语言。当今广泛使用的是非过程化的<code>DML</code>,它只需要用户指明需要什么数据,而不需指明如何获得这些数据。</p><h2 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h2><p><strong>数据定义语言</strong>(<code>Data-Definition Language</code>,<code>DDL)</code>是说明数据库模式和数据的其他特性的语言。<br>数据库设计主要包括数据库模式的设计。<strong>实体-联系(E-R)数据模型</strong>是广泛用于数据库设计的数据模型,它提供了一种方便的图形化的方式来观察数据、联系和约束。</p><h2 id="数据库系统的组成"><a href="#数据库系统的组成" class="headerlink" title="数据库系统的组成"></a>数据库系统的组成</h2><p>数据库系统由几个子系统构成:</p><ol><li><strong>存储管理器子系统</strong>在数据库中存储的低层数据与应用程序和向系统提交的查询之间提供接口。</li><li><strong>查询处理器子系统</strong>编译和执行<code>DDL</code>和<code>DML</code>语句。</li></ol><h2 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h2><p>事务管理负责保证不管是否有故障发生,数据库都要处于一致的(正确的)状态。事务管理器还保证并发事务的执行互不冲突。</p><p>数据库系统的体系结构受支持其运行的计算机系统的影响很大。数据库系统可以是集中式的,或者客户一服务器方式的,即一个服务器机器为多个客户机执行工作。数据库系统还可以设计成具有能充分利用并行计算机系统结构的能力。分布式数据库跨越多个地理上分布的互相分离的计算机。</p><p>典型地,数据库应用可被分为运行在客户机上的前端和运行在后端的部分。</p><ul><li>在两层的体系结构中,前端直接和后端运行的数据库进行通信。</li><li>在三层结构中,后端又被分为应用服务器和数据库服务器<!--SSTStop--></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第1章 引言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.12 数据库用户和管理员</title>
      <link href="/ReadingNotes//dd7b989f/"/>
      <url>/ReadingNotes//dd7b989f/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/dd7b989f/#1-12-数据库用户和管理员" class="header_1">1.12 数据库用户和管理员</a>&nbsp;<br><a href="/ReadingNotes/dd7b989f/#1-12-1-数据库用户和用户界面" class="header_1">1.12.1 数据库用户和用户界面</a>&nbsp;<br><a href="/ReadingNotes/dd7b989f/#1-无经验的用户" class="header_2">1. 无经验的用户</a>&nbsp;<br><a href="/ReadingNotes/dd7b989f/#2-应用程序员" class="header_2">2. 应用程序员</a>&nbsp;<br><a href="/ReadingNotes/dd7b989f/#3-老练的用户" class="header_2">3. 老练的用户</a>&nbsp;<br><a href="/ReadingNotes/dd7b989f/#4-专门的用户" class="header_2">4. 专门的用户</a>&nbsp;<br><a href="/ReadingNotes/dd7b989f/#1-12-2-数据库管理员" class="header_1">1.12.2 数据库管理员</a>&nbsp;<br><a href="/ReadingNotes/dd7b989f/#什么叫数据库管理员" class="header_2">什么叫数据库管理员</a>&nbsp;<br><a href="/ReadingNotes/dd7b989f/#数据管理员的作用" class="header_2">数据管理员的作用</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="1-12-数据库用户和管理员"><a href="#1-12-数据库用户和管理员" class="headerlink" title="1.12 数据库用户和管理员"></a>1.12 数据库用户和管理员</h1><p>使用数据库的人员可分为<code>数据库用户</code>和<code>数据库管理员</code>。</p><h1 id="1-12-1-数据库用户和用户界面"><a href="#1-12-1-数据库用户和用户界面" class="headerlink" title="1.12.1 数据库用户和用户界面"></a>1.12.1 数据库用户和用户界面</h1><p>根据所期望的与系统交互方式的不同,数据库系统的用户可以分为四种不同类型。系统为不同类型的用户设计了不同类型的用户界面。</p><h2 id="1-无经验的用户"><a href="#1-无经验的用户" class="headerlink" title="1. 无经验的用户"></a>1. 无经验的用户</h2><p>无经验的用户( <code>naive user)</code>是默认经验的用户,他们通过激活事先已经写好的应用程序同系统进行交互。</p><h2 id="2-应用程序员"><a href="#2-应用程序员" class="headerlink" title="2. 应用程序员"></a>2. 应用程序员</h2><p>应用程序员是编写应用程序的计算机专业人员。有很多工具可以供应用程序员选择来开发用户界面。快速应用开发工具是使应用程序员能够尽量少编写程序就可以构造出表格和报表的工具。</p><h2 id="3-老练的用户"><a href="#3-老练的用户" class="headerlink" title="3. 老练的用户"></a>3. 老练的用户</h2><p>老练的用户不通过编写程序来同系统交互,而是<code>用数据库査询语言或数据分析软件这样的工具</code>来表达他们的要求。<code>分析员</code>通过提交查询来研究数据库中的数据,所以属于老练的用户</p><h2 id="4-专门的用户"><a href="#4-专门的用户" class="headerlink" title="4. 专门的用户"></a>4. 专门的用户</h2><p>专门的用户是编写专门的、不适合于传统数据处理框架的数据库应用的富有经验的用户。这样的应用包括:计算机辅助设计系统、知识库和专家系统、存储复杂结构数据(如图形数据和声音数据)的系统,以及环境建模系统。</p><h1 id="1-12-2-数据库管理员"><a href="#1-12-2-数据库管理员" class="headerlink" title="1.12.2 数据库管理员"></a>1.12.2 数据库管理员</h1><h2 id="什么叫数据库管理员"><a href="#什么叫数据库管理员" class="headerlink" title="什么叫数据库管理员"></a>什么叫数据库管理员</h2><p>对系统进行集中控制的人称作<code>数据库管理员</code>( <code>Data Base Administrator</code>,<code>DBA)</code>。</p><h2 id="数据管理员的作用"><a href="#数据管理员的作用" class="headerlink" title="数据管理员的作用"></a>数据管理员的作用</h2><p><code>DBA</code>的作用包括:</p><ul><li>模式定义(<code>schema definition</code>)。<code>DBA</code>通过用<code>DDL</code>书写的一系列定义来创建最初的数据库模式。</li><li>存储结构及存取方法定义</li><li>模式及物理组织的修改。由数据库管理员(<code>DBA)</code>对模式和物理组织进行修改,以反映机构的需求变化,或为提高性能选择不同的物理组织。</li><li>数据访问授权。通过授予不同类型的权限,数据库管理员可以规定不同的用户各自可以访问的数据库的部分。授权信息保存在一个特殊的系统结构中,一旦系统中有访问数据的要求,数据库系统就去查阅这些信息。</li><li>日常维护。数据库管理员的日常维护活动有:<ul><li>定期备份数据库,或者在磁带上或者在远程服务器上,以防止像洪水之类的灾难发生时数据丢失。</li><li>确保正常运转时所需的空余磁盘空间,并且在需要时升级磁盘空间。</li><li>监视数据库的运行,并确保数据库的性能不因一些用户提交了花费时间较多的任务就下降很多。</li></ul></li></ul><!--SSTStop-->]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第1章 引言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.11 特种数据库</title>
      <link href="/ReadingNotes//88e5a463/"/>
      <url>/ReadingNotes//88e5a463/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/88e5a463/#1-11-特种数据库" class="header_1">1.11 特种数据库</a>&nbsp;<br><a href="/ReadingNotes/88e5a463/#1-11-1-基于对象的数据模型" class="header_1">1.11.1 基于对象的数据模型</a>&nbsp;<br><a href="/ReadingNotes/88e5a463/#1-11-2-半结构化数据模型" class="header_1">1.11.2 半结构化数据模型</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="1-11-特种数据库"><a href="#1-11-特种数据库" class="headerlink" title="1.11 特种数据库"></a>1.11 特种数据库</h1><h1 id="1-11-1-基于对象的数据模型"><a href="#1-11-1-基于对象的数据模型" class="headerlink" title="1.11.1 基于对象的数据模型"></a>1.11.1 基于对象的数据模型</h1><p>现在主要的数据库厂商都支持<strong>对象-关系数据模型</strong>`这是一个将面向对象数据模型和关系数据模型的特点结合在一起的数据模型。它<strong>扩展了传统的关系模型,增加了新的特征如结构和集合类型,以及面向对象特性</strong>。第22章介绍对象-关系数据模型。</p><h1 id="1-11-2-半结构化数据模型"><a href="#1-11-2-半结构化数据模型" class="headerlink" title="1.11.2 半结构化数据模型"></a>1.11.2 半结构化数据模型</h1><p>半结构化数据模型<strong>允许那些<code>相同类型的数据项</code>有不同的属性集的数据</strong>。<br><code>XML</code>提供了表达含有嵌套结构的数据的方法,能够灵活组织数据结构。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第1章 引言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.10 数据挖掘与信息检索</title>
      <link href="/ReadingNotes//b6a36e9e/"/>
      <url>/ReadingNotes//b6a36e9e/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/b6a36e9e/#1-10-数据挖掘与信息检索" class="header_1">1.10 数据挖掘与信息检索</a>&nbsp;<br><a href="/ReadingNotes/b6a36e9e/#数据挖掘简介" class="header_2">数据挖掘简介</a>&nbsp;<br><a href="/ReadingNotes/b6a36e9e/#信息检索系统简介" class="header_2">信息检索系统简介</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="1-10-数据挖掘与信息检索"><a href="#1-10-数据挖掘与信息检索" class="headerlink" title="1.10 数据挖掘与信息检索"></a>1.10 数据挖掘与信息检索</h1><h2 id="数据挖掘简介"><a href="#数据挖掘简介" class="headerlink" title="数据挖掘简介"></a>数据挖掘简介</h2><p>数据挖掘(<code>data mining</code>)这个术语指<strong>半自动地分析大型数据库并从中找出有用的模式的过程</strong>。<br>和人工智能中的知识发现(也称为机器学习( <code>machine learning)</code>或者统计分析一样,数据挖掘试图<strong>从数据中寻找规则或模式</strong>。</p><p>但是,数据挖掘和机器学习、统计分析不一样的地方在于:据挖掘处理的主要是存储在磁盘上的大量数据。也就是说,<strong>数据挖掘就是在数据库中发现知识</strong>。</p><p>通常在数据挖掘中还需要人参与,现实中的数据挖掘是一个半自动的过程。</p><h2 id="信息检索系统简介"><a href="#信息检索系统简介" class="headerlink" title="信息检索系统简介"></a>信息检索系统简介</h2><p>信息检索系统和数据库系统很大程度上是相同的——特别是基于辅助存储器的数据存储和检索。但是信息系统领域与数据库系统所强调的重点是不同的,信息系统重点强调基于关键词的查询,文档与查询的相似度,以及文档的分析、分类和索引。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第1章 引言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.9 数据库体系结构</title>
      <link href="/ReadingNotes//d2a689c8/"/>
      <url>/ReadingNotes//d2a689c8/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/d2a689c8/#1-9-数据库体系结构" class="header_1">1.9 数据库体系结构</a>&nbsp;<br><a href="/ReadingNotes/d2a689c8/#体系结构分类" class="header_2">体系结构分类</a>&nbsp;<br><a href="/ReadingNotes/d2a689c8/#两层体系结构" class="header_3">两层体系结构</a>&nbsp;<br><a href="/ReadingNotes/d2a689c8/#三层体系结构" class="header_3">三层体系结构</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="1-9-数据库体系结构"><a href="#1-9-数据库体系结构" class="headerlink" title="1.9 数据库体系结构"></a>1.9 数据库体系结构</h1><p>数据库系统的体系结构很大程度上取决于数据库系统所运行的计算机系统。数据库系统可以是<code>集中式的</code>、<code>客户服务器式的</code>(一台服务器为多个客户机执行任务);也可以针对<code>并行计算机体系结构设计数据库系统</code>;<code>分布式数据库</code>包含地理上分离的多台计算机。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/ShuJuKuXiTongGaiNian/ch1/2.png" alt="这里有一张图片"><br>今天数据库系统的大多数用户并不直接面对数据库系统,而是通过网络与其相连。因此我们可区分远程数据库用户工作用的<strong>客户机</strong>( <code>client)</code>和运行数据库系统的<strong>服务器</strong>( <code>server)</code>。</p><h2 id="体系结构分类"><a href="#体系结构分类" class="headerlink" title="体系结构分类"></a>体系结构分类</h2><p>数据库应用通常可分为两层体系结构或三层体系结构<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/ShuJuKuXiTongGaiNian/ch1/3.png" alt="这里有一张图片"></p><h3 id="两层体系结构"><a href="#两层体系结构" class="headerlink" title="两层体系结构"></a>两层体系结构</h3><p>在一个两层体系结构中,应用程序驻留在客户机上,通过査询语言表达式来调用服务器上的数据库系统功能。像<code>ODBC</code>和<code>JDBC</code>这样的应用程序接口标准被用于进行客户端和服务器的交互。</p><h3 id="三层体系结构"><a href="#三层体系结构" class="headerlink" title="三层体系结构"></a>三层体系结构</h3><p>在一个三层体系结构(<code>three-tier architecture</code>)中,<strong>客户机只作为一个前端并且不包含任何直接的数据库调用</strong>。客户端通常通过一个<code>表单界面</code>与应用服务器(<code>application server</code>)进行通信。而应用服务器与数据库系统通信以访问数据。应用程序的业务逻辑( <code>business logic</code>),也就是说在何种条件下做出何种反应,被嵌入到<code>应用服务器</code>中,而不是分布在多个客户机上。<strong>三层结构的应用更适合大型应用和互联网上的应用</strong>。</p><!--SSTStop-->]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第1章 引言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.8 事务管理</title>
      <link href="/ReadingNotes//aeeedf36/"/>
      <url>/ReadingNotes//aeeedf36/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/aeeedf36/#1-8-事务管理" class="header_1">1.8 事务管理</a>&nbsp;<br><a href="/ReadingNotes/aeeedf36/#原子性" class="header_2">原子性</a>&nbsp;<br><a href="/ReadingNotes/aeeedf36/#一致性" class="header_2">一致性</a>&nbsp;<br><a href="/ReadingNotes/aeeedf36/#持久性" class="header_2">持久性</a>&nbsp;<br><a href="/ReadingNotes/aeeedf36/#什么是事务" class="header_2">什么是事务</a>&nbsp;<br><a href="/ReadingNotes/aeeedf36/#事务管理器" class="header_2">事务管理器</a>&nbsp;<br><a href="/ReadingNotes/aeeedf36/#恢复管理器" class="header_3">恢复管理器</a>&nbsp;<br><a href="/ReadingNotes/aeeedf36/#并发控制管理器" class="header_3">并发控制管理器</a>&nbsp;<br><a href="/ReadingNotes/aeeedf36/#事务已经应用广泛了" class="header_2">事务已经应用广泛了</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="1-8-事务管理"><a href="#1-8-事务管理" class="headerlink" title="1.8 事务管理"></a>1.8 事务管理</h1><p>通常,对数据库的几个操作合起来形成一个逻辑单元。如1.2节所示的例子是一个资金转账,其中一个系(A系)的账户进行取出操作,而另一个系(B系)的账户进行存入操作。显然,这两个操作必须保证要么都发生要么都不发生。也就是说,资金转账必须完成或根本不发生。</p><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>这种要么完成要么不发生的要求称为<strong>原子性</strong>( <code>atomicity)</code>。</p><h2 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h2><p>除此以外,资金转账还必须保持数据库的一致性。也就是说,<strong>A和B的余额之和应该是保持不变的</strong>。这种正确性的要求称作<strong>一致性</strong>(<code>consistency</code>)。</p><h2 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h2><p>最后,当资金转账成功结束后,即使发生系统故障,账户A和账户B的余额也应该保持转账成功结束后的新值。这种保持的要求称作<strong>持久性</strong>(<code>durability</code>)。</p><h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h2><p><strong>事务(<code>transaction</code>)是数据库应用中<code>完成单一逻辑功能的操作集合</code></strong>。每一个事务是一个既具原子性又具一致性的单元。因此,我们要求事务不违反任何的数据库一致性约束,也就是说,<strong>如果事务启动时数据库是一致的,那么当这个事务成功结束时数据库也应该是一致的</strong>。然而,在事务执行过程中,必要时允许暂时的不一致,因为无论是A取出的操作在前还是B存入的操作在前,这两个操作都必然有一个先后次序。这种暂时的不一致虽然是必需的,但在故障发生时,很可能导致问题的产生。</p><p><strong>适当地定义各个事务是程序员的职责</strong>,事务的定义应使之能保持数据库的一致性。<br>例如,资金从A系的账户转到B系的账户这个事务可以被定义为由两个单独的程序组成:一个对账户A执行取出操作,另一个对账户B执行存入操作。这两个程序的依次执行可以保持一致性。但是,这两个程序自身都不是把数据库从一个一致的状态转入一个新的一致的状态,因此它们都不是事务。</p><h2 id="事务管理器"><a href="#事务管理器" class="headerlink" title="事务管理器"></a>事务管理器</h2><p><strong>事务管理器</strong>(<code>transaction manager</code>)包括<code>并发控制管理器</code>和<code>恢复管理器</code>。</p><h3 id="恢复管理器"><a href="#恢复管理器" class="headerlink" title="恢复管理器"></a>恢复管理器</h3><p><strong>原子性和持久性的保证是数据库系统自身的职责</strong>,确切地说,是<strong>恢复管理器</strong>(<code>recovery manager</code>)的职责。在没有故障发生的情况下,所有事务均成功完成,这时要保证原子性很容易。但是,由于各种各样的故障,事务并不总能成功执行完毕。为了保证原子性,失败的事务必须对数据库状态不产生任何影响。因此,数据库必须被恢复到该失败事务开始执行以前的状态。这种情况下数据库系统必须进行故障恢复( <code>failure recovery)</code>,即<strong>检测系统故障并将数据库恢复到故障发生以前的状态</strong>。</p><h3 id="并发控制管理器"><a href="#并发控制管理器" class="headerlink" title="并发控制管理器"></a>并发控制管理器</h3><p>最后,当多个事务同时对数据库进行更新时,即使每个单独的事务都是正确的,数据的一致性也可能被破坏。<strong>并发控制管理器</strong>(<code>concurrency-control manager</code>)控制并发事务间的相互影响,保证数据库致性。</p><h2 id="事务已经应用广泛了"><a href="#事务已经应用广泛了" class="headerlink" title="事务已经应用广泛了"></a>事务已经应用广泛了</h2><p>事务的概念已经广泛应用在数据库系统和应用当中。虽然最初是在金融应用中使用事务,现在事务已经使用在电信业的实时应用中,以及长时间的活动如产品设计和工作流管理中。</p><!--SSTStop-->]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第1章 引言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.7 数据存储和查询</title>
      <link href="/ReadingNotes//293a982a/"/>
      <url>/ReadingNotes//293a982a/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/293a982a/#1-7-数据存储和查询" class="header_1">1.7 数据存储和查询</a>&nbsp;<br><a href="/ReadingNotes/293a982a/#1-7-1-存储管理器" class="header_1">1.7.1 存储管理器</a>&nbsp;<br><a href="/ReadingNotes/293a982a/#存储管理部件" class="header_2">存储管理部件</a>&nbsp;<br><a href="/ReadingNotes/293a982a/#存储管理器实现的数据结构" class="header_2">存储管理器实现的数据结构</a>&nbsp;<br><a href="/ReadingNotes/293a982a/#1-7-2-查询处理器" class="header_1">1.7.2 查询处理器</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="1-7-数据存储和查询"><a href="#1-7-数据存储和查询" class="headerlink" title="1.7 数据存储和查询"></a>1.7 数据存储和查询</h1><p>数据库系统划分为不同的模块,每个模块完成整个系统的一个功能。数据库系统的功能部件大致可分为<code>存储管理器</code>和<code>查询处理部件</code>。<br>存储管理非常重要,因为数据库常常需要大量存储空间。企业的大型数据库的大小达到数百个<code>gigabyte</code>,甚至达到<code>terabyte</code>。一个<code>gigabyte</code>大约等于1000个(实际上是1024个) <code>megabyte</code>(十亿字节),一个<code>terabyte</code>等于一百万个<code>megabyte</code>(一万亿个字节)。</p><p>由于计算机主存不可能存储这么多信息,所以信息被存储在磁盘上。需要时数据在主存和磁盘间移动。由于相对于中央处理器的速度来说数据出入磁盘的速度很慢,因此数据库系统对数据的组织必须满足使磁盘和主存之间数据的移动最小化。<br>査询处理也非常重要,因为它帮助数据库系统简化和方便了数据的访问。查询处理器使得数据库用户能够获得很高的性能,同时可以在视图的层次上工作,不必承受了解系统实现的物理层次细节的负担。<br>将在逻辑层编写的更新和查询转变成物理层的高效操作序列,这是数据库系统的任务</p><h1 id="1-7-1-存储管理器"><a href="#1-7-1-存储管理器" class="headerlink" title="1.7.1 存储管理器"></a>1.7.1 存储管理器</h1><p>存储管理器负责与文件管理器进行交互。原始数据通过操作系统提供的文件系统存储在磁盘上。存储管理器将各种<code>DML</code>语句翻译为底层文件系统命令。因此,存储管理器负责数据库中数据的存储、检索和更新。</p><h2 id="存储管理部件"><a href="#存储管理部件" class="headerlink" title="存储管理部件"></a>存储管理部件</h2><p>存储管理部件包括:</p><ol><li><strong>权限及完整性管理器</strong>(<code>authonzation and integnty manager</code>),它检测是否满足完整性约束,并检查试图访问数据的用户的权限。</li><li><strong>事务管理器</strong>(<code>transaction manager)</code>,它保证即使发生了故障,数据库也保持在一致的(正确的)状态,并保证并发事务的执行不发生冲突。</li><li><strong>文件管理器</strong>(<code>file manager</code>),它管理磁盘存储空间的分配,管理用于表示磁盘上所存储信息的数据结构</li><li><strong>缓冲区管理器</strong>(<code>buffer manager</code>),它负责将数据从磁盘上取到内存中来,并决定哪些数据应被缓冲存储在内存中。缓冲区管理器是数据库系统中的一个关键部分,因为它使数据库可以处理比内存更大的数据。</li></ol><h2 id="存储管理器实现的数据结构"><a href="#存储管理器实现的数据结构" class="headerlink" title="存储管理器实现的数据结构"></a>存储管理器实现的数据结构</h2><p>存储管理器实现了几种数据结构,作为系统物理实现的一部分</p><ul><li><strong>数据文件</strong>(<code>data files</code>),存储数据库自身。</li><li><strong>数据字典</strong>(<code>data dictionary</code>),存储关于数据库结构的<code>元数据</code>,尤其是<code>数据库模式</code></li><li><strong>索引</strong>(<code>index</code>),提供对数据项的快速访问。和书中的索引一样,数据库索引提供了指向包含特定值的数据的指针。例如,我们可以运用索引找到具有特定的<code>ID</code>的<code>instructor</code>记录,或者具有特定的<code>name</code>的所有<code>instructor</code>记录。<code>散列是另外一种索引方式</code>,在某些情况下速度更快,但不是在所有情况下都这样。</li></ul><p>我们在第10章讨论存储介质、文件结构和缓冲区管理,第11章讨论通过索引和散列高效访问据的方法。</p><h1 id="1-7-2-查询处理器"><a href="#1-7-2-查询处理器" class="headerlink" title="1.7.2 查询处理器"></a>1.7.2 查询处理器</h1><p>查询处理器组件包括:<br><code>DDL</code>解释器(<code>DDL interpreter</code>),它解释<code>DDL</code>语句并将这些定义记录在数据字典中。<br><code>DML</code>编译器(<code>DML compiler</code>),将查询语言中的<code>DML</code>语句翻译为一个执行方案,包括一系列查询执行引擎能理解的低级指令。<br>查询执行引擎(<code>query evaluation engine</code>),执行由<code>DML</code>编译器产生的低级指令。<br>一个査询通常可被翻译成多种等价的具有相同结果的执行方案的一种。<code>DML</code>编译器还进行查询优化(<code>query optimization</code>),也就是从几种选择中选出代价最小的一种。</p><!--SSTStop-->]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第1章 引言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.6 数据库设计</title>
      <link href="/ReadingNotes//a67e593b/"/>
      <url>/ReadingNotes//a67e593b/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/a67e593b/#1-6-数据库设计" class="header_1">1.6 数据库设计</a>&nbsp;<br><a href="/ReadingNotes/a67e593b/#1-6-1-设计过程" class="header_1">1.6.1 设计过程</a>&nbsp;<br><a href="/ReadingNotes/a67e593b/#确定需求" class="header_2">确定需求</a>&nbsp;<br><a href="/ReadingNotes/a67e593b/#概念设计阶段" class="header_2">概念设计阶段</a>&nbsp;<br><a href="/ReadingNotes/a67e593b/#逻辑设计阶段" class="header_2">逻辑设计阶段</a>&nbsp;<br><a href="/ReadingNotes/a67e593b/#物理设计阶段" class="header_2">物理设计阶段</a>&nbsp;<br><a href="/ReadingNotes/a67e593b/#1-6-2-大学机构的数据库设计" class="header_1">1.6.2 大学机构的数据库设计</a>&nbsp;<br><a href="/ReadingNotes/a67e593b/#1-6-3-实体-联系模型" class="header_1">1.6.3 实体-联系模型</a>&nbsp;<br><a href="/ReadingNotes/a67e593b/#什么是实体" class="header_2">什么是实体</a>&nbsp;<br><a href="/ReadingNotes/a67e593b/#通过属性的集合来描述实体" class="header_2">通过属性的集合来描述实体</a>&nbsp;<br><a href="/ReadingNotes/a67e593b/#什么是联系" class="header_2">什么是联系</a>&nbsp;<br><a href="/ReadingNotes/a67e593b/#什么是实体集" class="header_2">什么是实体集</a>&nbsp;<br><a href="/ReadingNotes/a67e593b/#什么是联系集" class="header_2">什么是联系集</a>&nbsp;<br><a href="/ReadingNotes/a67e593b/#实体-联系图-entity-relationship-diagram-E-R图" class="header_2">实体-联系图 entity-relationship diagram E-R图</a>&nbsp;<br><a href="/ReadingNotes/a67e593b/#E-R图符号" class="header_3">E-R图符号</a>&nbsp;<br><a href="/ReadingNotes/a67e593b/#映射基数" class="header_3">映射基数</a>&nbsp;<br><a href="/ReadingNotes/a67e593b/#1-6-4-规范化" class="header_1">1.6.4 规范化</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="1-6-数据库设计"><a href="#1-6-数据库设计" class="headerlink" title="1.6 数据库设计"></a>1.6 数据库设计</h1><p>数据库设计的主要内容是<code>数据库模式</code>的设计。为设计一个满足企业需求模型的完整的数据库应用环境还要考虑更多的问题。在本书中,我们先着重讨论<code>数据库查询语句的书写</code>以及<code>数据库模式的设计</code>,第9章将讨论<code>应用设计的整个过程</code>。</p><h1 id="1-6-1-设计过程"><a href="#1-6-1-设计过程" class="headerlink" title="1.6.1 设计过程"></a>1.6.1 设计过程</h1><h2 id="确定需求"><a href="#确定需求" class="headerlink" title="确定需求"></a>确定需求</h2><p>高层的数据模型为数据库设计者提供了一个概念框架,去说明数据库用户的数据需求,以及将怎样构造数据库结构以满足这些需求。因此,数据库设计的初始阶段是全面刻画预期的数据库用户的数据需求。为了完成这个任务,数据库设计者有必要和领域专家、数据库用户广泛地交流。这个阶段的成果是<code>制定出用户需求的规格文档</code>。</p><h2 id="概念设计阶段"><a href="#概念设计阶段" class="headerlink" title="概念设计阶段"></a>概念设计阶段</h2><p>下一步,设计者选择一个数据模型,并运用该选定的数据模型的概念,<strong>将那些需求转换成一个数据库的<code>概念模式</code></strong>。在这个概念设计阶段开发出来的模式提供了企业的详细概述。设计者再复审这个模式,确保所有的数据需求都满足并且相互之间没有冲突,在检查过程中设计者也可以去掉些冗余的特性。这一阶段的重点是描述数据以及它们之间的联系,而不是指定物理的存储细节。<br>从关系模型的角度来看,<code>概念设计阶段</code>涉及<strong>决定数据库中应该包括哪些<code>属性</code></strong>,以及<strong>如何将这些<code>属性</code>组织到多个<code>表</code>中</strong>。前者基本上是商业的决策,在本书中我们不进一步讨论。而后者主要是计算机科学的问题,解决这个问题主要有两种方法:</p><ul><li>一种是使用实体-联系模型(见1.6.3节),</li><li>另一种是引入一套算法(通称为规范化),这套算法将所有属性集作为输入,生成一组关系表(见1.6.4节)。</li></ul><p>一个开发完全的概念模式还将指出企业的功能需求。在<code>功能需求说明</code>中,用户描述数据之上的各种操作(或事务),例如<code>更新数据</code>、<code>检索特定的数据</code>、<code>删除数据</code>等。在概念设计的这个阶段,设计者可以对模式进行复审,确保它满足功能需求。</p><h2 id="逻辑设计阶段"><a href="#逻辑设计阶段" class="headerlink" title="逻辑设计阶段"></a>逻辑设计阶段</h2><p>在逻辑设计阶段( <code>logical-designphrase)</code>,设计者将高层的<code>概念模式</code>映射到要使用的数据库系统的<code>数据模型</code>上;这样,设计者将得到的特定系统的数据库模式</p><h2 id="物理设计阶段"><a href="#物理设计阶段" class="headerlink" title="物理设计阶段"></a>物理设计阶段</h2><p>在这个阶段中指定数据库的物理特性,这些特性包括文件组织的形式以及内部的存储结构,这些内容将在第10章中讨论。</p><h1 id="1-6-2-大学机构的数据库设计"><a href="#1-6-2-大学机构的数据库设计" class="headerlink" title="1.6.2 大学机构的数据库设计"></a>1.6.2 大学机构的数据库设计</h1><p>为了阐明设计过程,我们来看如何为大学做数据库设计。初始的<code>用户需求说明</code>可以基于与数据库用户的交流以及设计者自己对大学机构的分析。这个设计阶段中的需求描述是制定数据库的概念结构的基础。以下是大学的主要特性:</p><ul><li><code>大学</code>分成多个系。每个系由自己唯一的名字(<code>dept_name</code>)来标识,坐落在特定的建筑物(<code>building</code>)中,有它的经费预算(<code>budget</code>)。</li><li>每一个系有一个开设的课程列表。每门课程有课程号(<code>course_id</code>)、课程名(<code>title</code>)、系名(<code>dept_name</code>)和学分( <code>credits</code>),还可能有先修要求(<code>prerequisites</code>)。</li><li><code>教师</code>使用唯一的标识号(<code>ID</code>)来标识。每位教师有姓名(<code>name</code>)、所在的系(<code>dept_name</code>)和工资(<code>salary</code>).</li><li><code>学生</code>使用唯一的标识号(<code>ID</code>)来标识。每位学生有姓名(<code>name</code>)、主修的系(<code>dept_name</code>)和已修学分数( <code>tot_cred</code>)。</li><li><code>大学</code>维护一个<code>教室列表</code>,详细说明楼名(<code>building</code>)、房间号( <code>room_number</code>)和容量(<code>capacity</code>)</li><li><code>大学</code>维护开设的所有<code>课程(开课)的列表</code>。课程由课程号( <code>course_id)</code>、开课号(<code>sec_id)</code>、年(<code>year</code>)和学期( <code>semester</code>)来标识,与之相关联的有学期(<code>semester</code>)、年(<code>year</code>)、楼名(<code>building</code>)、房间号(<code>room_number</code>)和时段号(<code>time_slot_id</code>,即上课的时间)。</li><li><code>系</code>有一个<code>教学任务列表</code>,说明每位教师的授课情况。</li><li>大学有一个所有学生课程注册的列表,说明每位学生选择了哪些课程的哪个课程。</li></ul><p>一个真正的大学数据库会比上述的设计复杂得多。然而,我们就用这个简化了的模型来帮助你理解概念思想,避免你迷失在复杂设计的细节中。</p><h1 id="1-6-3-实体-联系模型"><a href="#1-6-3-实体-联系模型" class="headerlink" title="1.6.3 实体-联系模型"></a>1.6.3 实体-联系模型</h1><p><code>实体-联系</code>(<code>E-R</code>)数据模型<strong>描述了一组称作<code>实体</code>的基本对象之间的联系</strong>。</p><h2 id="什么是实体"><a href="#什么是实体" class="headerlink" title="什么是实体"></a>什么是实体</h2><p>实体是现实世界中可区别于其他对象的一件”事情”或一个”物体”。例如,每个人是一个实体,每个银行账户也是个实体。</p><h2 id="通过属性的集合来描述实体"><a href="#通过属性的集合来描述实体" class="headerlink" title="通过属性的集合来描述实体"></a>通过属性的集合来描述实体</h2><p><strong>数据库中通过<code>属性集合</code>来描述<code>实体</code></strong>。例如,属性<code>dept_name</code>、 <code>building</code>与<code>budget</code>可以描述大学中的一个系,并且它们也组成了<code>department</code>实体集的属性。类似地,<code>ID</code>、<code>name</code>和<code>salary</code>这几个属性可以描述<code>instructor</code>实体。</p><p>因为可能存在两位教师有相同的名字和相同的工资,但又必须给每位教师分配唯一的教师标识,所以我们用额外的属性ID来唯一标识教师。在美国,社会保障号是美国政府分配给每个美国人的一个唯一的号码,所以许多机构用一个人的<code>社会保障号</code>作为他的唯一标识。</p><h2 id="什么是联系"><a href="#什么是联系" class="headerlink" title="什么是联系"></a>什么是联系</h2><p><strong>联系(<code>relationship</code>)是几个实体之间的关联</strong>。例如, <code>member</code>联系将一位教师和她所在的系关联在起。</p><h2 id="什么是实体集"><a href="#什么是实体集" class="headerlink" title="什么是实体集"></a>什么是实体集</h2><p>同一类型的所有实体的集合称作<code>实体集</code>(<code>entity set</code>),</p><h2 id="什么是联系集"><a href="#什么是联系集" class="headerlink" title="什么是联系集"></a>什么是联系集</h2><p>同一类型的所有联系的集合称作<code>联系集</code>(<code>relationship set</code>)。</p><h2 id="实体-联系图-entity-relationship-diagram-E-R图"><a href="#实体-联系图-entity-relationship-diagram-E-R图" class="headerlink" title="实体-联系图 entity-relationship diagram E-R图"></a>实体-联系图 entity-relationship diagram E-R图</h2><p>数据库的总体<code>逻辑结构(逻辑模式)</code>可以用实体-联系图进行图形化表示。有几种方法来画这样的图。最常用的方法之一是采用<strong>统一建模语言</strong>(<code>UML</code>)。</p><h3 id="E-R图符号"><a href="#E-R图符号" class="headerlink" title="E-R图符号"></a>E-R图符号</h3><p>在我们使用的基于<code>UML</code>的符号中,<code>E-R</code>图如下表示:</p><ul><li><code>实体</code>用<code>矩形框表示</code>,实体名在头部,属性名列在下面。</li><li><code>联系</code>用连接两个相关的实体集的<code>菱形表示</code>,联系名放在菱形内部</li></ul><p>作为例子,我们来看一下大学数据库中包括教师和系以及它们之间的关联的部分。对应的<code>E-R</code>图如图1-3所示。<code>E-R</code>图表示出有<code>instructor</code>和<code>departmen</code>这两个实体集,它们具有先前已经列出的一些属性。这个图还指明了在教师和系之间的<code>member</code>联系。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/ShuJuKuXiTongGaiNian/ch1/1.png" alt="这里有一张图片"></p><h3 id="映射基数"><a href="#映射基数" class="headerlink" title="映射基数"></a>映射基数</h3><p>除了实体和联系外,<code>E-R</code>模型还描绘了数据库必须遵守的对其内容的某些约束。一个重要的约束是<code>映射基数</code>,它表示通过某个联系集能与一实体进行关联的实体数目。例如,如果一<strong>位教师只能属于一个系</strong>,<code>E-R</code>模型就能表达出这种约束。<br><code>实体-联系模型</code>在数据库设计中使用广泛,在第7章中将详细研究。</p><h1 id="1-6-4-规范化"><a href="#1-6-4-规范化" class="headerlink" title="1.6.4 规范化"></a>1.6.4 规范化</h1><p>设计关系数据库所用到的另外一种方法是通常被称为<code>规范化</code>的过程。<code>规范化</code>的目标是生成一个关系模式集合,使我们存储信息时<code>没有不必要的冗余</code>,同时又能很轻易地检索数据。<br>这种方法是设计一种符合适当的<code>范式</code>的模式,为确定一个关系模式是否符合想要的范式,我们需要额外的 关于用数据库建模的 现实世界中机构的信息。最常用的方法是使用<code>函数依赖</code>(<code>functional dependency</code>),我们将在8.4节讨论。</p><p>为了理解规范化的必要性,我们看一看在不好的数据库设计中会发生什么问题。一个不好的设计可能会包括如下不良特性:</p><ol><li>信息重复</li><li>缺乏表达某些信息的能力</li></ol><p>规范化的详尽理论已经研究形成,它有助于形式化地定义什么样的数据库设计是不好的,以及如何得到我们想要的设计。第8章将讨论关系数据库设计,包括规范化。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第1章 引言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.5 关系数据库</title>
      <link href="/ReadingNotes//fa82473e/"/>
      <url>/ReadingNotes//fa82473e/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/fa82473e/#1-5-关系数据库" class="header_1">1.5 关系数据库</a>&nbsp;<br><a href="/ReadingNotes/fa82473e/#1-5-1-表" class="header_1">1.5.1 表</a>&nbsp;<br><a href="/ReadingNotes/fa82473e/#1-5-2-数据操纵语言" class="header_1">1.5.2 数据操纵语言</a>&nbsp;<br><a href="/ReadingNotes/fa82473e/#1-5-3-数据定义语言" class="header_1">1.5.3 数据定义语言</a>&nbsp;<br><a href="/ReadingNotes/fa82473e/#1-5-4-来自应用程序的数据库访问" class="header_1">1.5.4 来自应用程序的数据库访问</a>&nbsp;<br><a href="/ReadingNotes/fa82473e/#通过宿主语言来执行DML语句" class="header_2">通过宿主语言来执行DML语句</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="1-5-关系数据库"><a href="#1-5-关系数据库" class="headerlink" title="1.5 关系数据库"></a>1.5 关系数据库</h1><p><code>关系数据库</code>基于<code>关系模型</code>,<strong>使用一系列<code>表</code>来表达数据以及这些数据之间的联系</strong>。关系数据库也包括<code>DML</code>和<code>DDL</code>。在第2章中,我们简单介绍关系模型的基本概念。多数的商用关系数据库系统使用<code>SQL</code>语言,该语言将在第3章、第4章和第5章中详细介绍。第6章我们将讨论其他有影响的语言。</p><h1 id="1-5-1-表"><a href="#1-5-1-表" class="headerlink" title="1.5.1 表"></a>1.5.1 表</h1><p>每个表有多个列,每个列有唯一的名字。</p><p>关系模型是基于<code>记录</code>的模型的一个<code>实例</code>。基于记录的模型,之所以有此称谓,是因为数据库的结构是几种固定格式的记录。每个表包含一种特定类型的记录。每种<code>记录类型</code>定义固定数目的字段或属性。表的<code>列</code>对应记录类型的<code>属性</code>。</p><p><strong>表可以存储在文件</strong>中。例如,一个特殊的字符(比如逗号)可以用来分隔记录的不同属性,另一特殊的字符(比如换行符)可以用来分隔记录。对于数据库的开发者和用户,关系模型屏蔽了这些低层实现细节。</p><p>在关系模型中,有可能创建一些有问题的模式,比如出现不必要的冗余信息。在第8章我们将研究如何区分好的和不好的模式设计。</p><h1 id="1-5-2-数据操纵语言"><a href="#1-5-2-数据操纵语言" class="headerlink" title="1.5.2 数据操纵语言"></a>1.5.2 数据操纵语言</h1><p><code>SQL</code><strong>查询语言</strong>是非过程化的。它以几个表作为输人(也可能只有一个),总是<strong>仅返回一个表</strong>。<strong>查询可以涉及来自不止一个表的信息</strong>。</p><h1 id="1-5-3-数据定义语言"><a href="#1-5-3-数据定义语言" class="headerlink" title="1.5.3 数据定义语言"></a>1.5.3 数据定义语言</h1><p><code>SQL</code>提供了一个丰富的<code>DDL</code>语言,通过它,我们可以<code>定义表</code>、<code>完整性约束</code>、<code>断言</code>,等等。</p><h1 id="1-5-4-来自应用程序的数据库访问"><a href="#1-5-4-来自应用程序的数据库访问" class="headerlink" title="1.5.4 来自应用程序的数据库访问"></a>1.5.4 来自应用程序的数据库访问</h1><p>有一些计算可以用通用的程序设计语言来表达,但无法通过<code>SQL</code>来表达。<code>SQL</code>还不支持诸如从用户那儿输入、输出到显示器,或者通过网络通信这样的动作。这样的计算和动作必须用一种<code>宿主</code>语言来写,比如C、C++或<code>Java</code>,在<code>宿主语言</code>中使用嵌入式的<code>SQL</code>查询来访问数据库中的数据。</p><h2 id="通过宿主语言来执行DML语句"><a href="#通过宿主语言来执行DML语句" class="headerlink" title="通过宿主语言来执行DML语句"></a>通过宿主语言来执行DML语句</h2><p>为了访问数据库,<strong><code>DML</code>语句需要由宿主语言来执行</strong>。有两种途径可以做到这一点</p><ul><li>一种是通过提供应用程序接口来将<code>DML</code>和<code>DDL</code>的语句发送给数据库,再取回结果。例如:<ul><li>C语言的开放数据库连接<code>ODBC</code></li><li><code>Java</code>数据库连接<code>JDBC</code></li></ul></li><li>另一种是通过扩展宿主语言的语法,在宿主语言的程序中嵌人<code>DML</code>调用。通常用一个特殊字符作为<code>DML</code>调用的开始,然后通过<code>DML</code>预编译器来将<code>DML</code>语句转变成宿主语言中的过程调用。<!--SSTStop--></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第1章 引言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.4 数据库语言</title>
      <link href="/ReadingNotes//17bdafe5/"/>
      <url>/ReadingNotes//17bdafe5/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/17bdafe5/#1-4-数据库语言" class="header_1">1.4 数据库语言</a>&nbsp;<br><a href="/ReadingNotes/17bdafe5/#1-4-1-数据操纵语言" class="header_1">1.4.1 数据操纵语言</a>&nbsp;<br><a href="/ReadingNotes/17bdafe5/#数据操纵语言分类" class="header_2">数据操纵语言分类</a>&nbsp;<br><a href="/ReadingNotes/17bdafe5/#查询" class="header_2">查询</a>&nbsp;<br><a href="/ReadingNotes/17bdafe5/#1-4-2-数据定义语言" class="header_1">1.4.2 数据定义语言</a>&nbsp;<br><a href="/ReadingNotes/17bdafe5/#约束" class="header_2">约束</a>&nbsp;<br><a href="/ReadingNotes/17bdafe5/#有哪些约束" class="header_3">有哪些约束</a>&nbsp;<br><a href="/ReadingNotes/17bdafe5/#数据字典介绍" class="header_2">数据字典介绍</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="1-4-数据库语言"><a href="#1-4-数据库语言" class="headerlink" title="1.4 数据库语言"></a>1.4 数据库语言</h1><p>数据库系统提供<code>数据定义语言</code>(<code>data-definition language</code>)来<code>定义数据库模式</code>,以及<code>数据操纵语言</code>(<code>data-manipulation language)</code>来表达数据库的<code>査询</code>和<code>更新</code>。而实际上,数据定义和数据操纵语言并不是两种分离的语言,相反地,它们简单地构成了单一的数据库语言(如广泛使用的<code>SQL</code>语言)的不同部分。</p><h1 id="1-4-1-数据操纵语言"><a href="#1-4-1-数据操纵语言" class="headerlink" title="1.4.1 数据操纵语言"></a>1.4.1 数据操纵语言</h1><p>数据操纵语言(<code>Data-Manipulation Language,DML</code>)使得用户可以<code>访问</code>或<code>操纵</code>那些按照某种适当的数据模型组织起来的数据。有以下访问类型:</p><ul><li>对存储在数据库中的信息进行检索。</li><li>向数据库中插入新的信息。</li><li>从数据库中删除信息。</li><li>修改数据库中存储的信息。</li></ul><h2 id="数据操纵语言分类"><a href="#数据操纵语言分类" class="headerlink" title="数据操纵语言分类"></a>数据操纵语言分类</h2><p>通常有两类基本的数据操纵语言:</p><ol><li>过程化<code>DML(procedural DML)</code>要求<strong>用户指定需要什么数据以及如何获得这些数据</strong>。</li><li>声明式<code>DML(declarative DML)</code>(也称为非过程化<code>DML)</code>只要求<strong>用户指定需要什么数据,而不指明如何获得这些数据</strong>。</li></ol><p>通常<strong>声明式<code>DML</code></strong>比<strong>过程化<code>DML</code></strong>易学易用。但是,由于用户不必指明如何获得数据,数据库系统必须找出一种访问数据的高效途径</p><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>查询(<code>query</code>)是要求对信息进行检索的语句。<code>DML</code>中涉及信息检索的部分称作查询语言<code>query language</code>。实践中常把<code>查询语言</code>和<code>数据操纵语言</code>作为同义词使用,尽管从技术上来说这并不正确.</p><h1 id="1-4-2-数据定义语言"><a href="#1-4-2-数据定义语言" class="headerlink" title="1.4.2 数据定义语言"></a>1.4.2 数据定义语言</h1><p><code>数据库模式</code>是通过一系列定义来说明的,这些定义由一种称作<code>数据定义语言</code>(<code>Data-DefinitionLanguage,DDL</code>)的特殊语言来表达。<code>DDL</code>也可用于定义数据的其他特征。<br>数据库系统所使用的<code>存储结构</code>和<code>访问方式</code>是通过一系列特殊的<code>DDL</code>语句来说明的,这种特殊的<code>DDL</code>称作<strong>数据存储和定义语言</strong>(<code>data storage and definition)</code>。这些语句<strong>定义了数据库模式的实现细节</strong>,而这些细节对用户来说通常是不可见的。</p><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>存储在数据库中的数据值必须满足某些一致性约束( <code>consistency constraint)</code>。例如,假设大学要求个系的账户余额必须不能为负值。<code>DDL</code>语言提供了指定这种约束的工具。每当数据库被更新时,数据库系统都会检查这些约束。通常,约束可以是关于数据库的任意谓词。然而,如果要测试任意谓词,可能代价比较高。因此,数据库系统实现可以以最小代价测试的<code>完整性约束</code></p><h3 id="有哪些约束"><a href="#有哪些约束" class="headerlink" title="有哪些约束"></a>有哪些约束</h3><ol><li><strong>域约束</strong>(<code>domain constraint</code>)。每个属性都必须对应于一个所有可能的取值构成的域(例如,整数型、字符型、日期/时间型)。<strong>声明一种属性属于某种具体的域就相当于约束它可以取的值</strong>。域约束是完整性约束的最基本形式。每当有新数据项插入到数据库中,系统就能方便地进行域约束检测。</li><li><strong>参照完整性约束</strong>(<code>referential integrity</code>)。我们常常希望,<strong>一个关系中给定属性集上的取值也在另一关系的某一属性集的取值中出现</strong>(参照完整性)。例如,每门课程所列出的系必须是实际存在的系。更准确地说,一个<code>course</code>记录中的<code>dept_name</code>值必须出现在<code>department</code>关系中的某个记录的<code>dept_name</code>属性中。数据库的修改会导致参照完整性的破坏。当参照完整性约束被违反时,通常的处理是拒绝执行导致完整性被破坏的操作。</li><li><strong>断言</strong>(<code>assertion)</code>。<strong>一个断言就是数据库需要时刻满足的某一条件</strong>。<strong><code>域约束</code>和<code>参照完整性约束</code>是断言的特殊形式</strong>。然而,还有许多约束不能仅用这几种特殊形式表达。例如,”每一学期每个系必须至少开设5门课程”,必须表达成一个断言。断言创建以后,系统会检测其有效性。如果断言有效,则以后只有不破坏断言的数据库更新才被允许。</li><li><strong>授权</strong>(<code>authorization)</code>。我们也许想对用户加以区别,对于不同的用户在数据库中的不同数据值上允许不同的访问类型。这些区别以授权来表达,最常见的是:<ul><li><strong>读权限</strong>( <code>read authorization)</code>,允许读取数据,但不能修改数据;</li><li><strong>插入权限</strong>( <code>insert authorization)</code>,允许插入新数据,但不允许修改已有数据;</li><li><strong>更新权限</strong>( <code>update authorization)</code>,允许修改,但不能删除数据;</li><li><strong>删除权限</strong>( <code>deleteauthorization)</code>,允许删除数据。<br>我们可以赋予用户所有的权限,或者没有或部分拥有这些权限。</li></ul></li></ol><h2 id="数据字典介绍"><a href="#数据字典介绍" class="headerlink" title="数据字典介绍"></a>数据字典介绍</h2><p>正如其他任何程序设计语言一样,<strong>数据定义语言</strong>(<code>DDL</code>)以一些指令(语句)作为输入,生成一些输出。<br><code>DDL</code>的<code>输出</code>放在数据字典(<code>data dictionary</code>)中,数据字典包含了元数据(<code>metadata</code>),<strong>元数据是关于数据的数据</strong>。<br>可把数据字典看作一种特殊的表,这种表只能由数据库系统本身(不是常规的用户)来访问和修改。在读取和修改实际的数据前,数据库系统先要参考数据字典。</p><!--SSTStop-->]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第1章 引言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.2 数据库系统的目标</title>
      <link href="/ReadingNotes//f6bbcb52/"/>
      <url>/ReadingNotes//f6bbcb52/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/f6bbcb52/#1-2-数据库系统的目标" class="header_1">1.2 数据库系统的目标</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="1-2-数据库系统的目标"><a href="#1-2-数据库系统的目标" class="headerlink" title="1.2 数据库系统的目标"></a>1.2 数据库系统的目标</h1><p>数据库系统作为商业数据计算机化管理的早期方法而产生。作为20世纪60年代这类方法的典型实例之一,考虑大学组织中的一个部分,除其他数据外,需要保存关于所有教师、学生、系和开设课程的信息。在计算机中保存这些信息的一种方法是将它们<code>存放在操作系统文件</code>中。为了使用户可以对信息进行操作,系统中应有一些对文件进行操作的应用程序,包括:</p><ul><li>增加新的学生、教师和课程。</li><li>为课程注册学生,并产生班级花名册。</li><li>为学生填写成绩、计算绩点(<code>GPA)</code>、产生成绩单。</li></ul><p>这些应用程序是由系统程序员根据大学的需求编写的</p><p><strong>这篇文章说了使用文件系统的弊端</strong>,没啥要记的.</p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第1章 引言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.3 数据视图</title>
      <link href="/ReadingNotes//444bcfb7/"/>
      <url>/ReadingNotes//444bcfb7/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/444bcfb7/#1-3-数据视图" class="header_1">1.3 数据视图</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="1-3-数据视图"><a href="#1-3-数据视图" class="headerlink" title="1.3 数据视图"></a>1.3 数据视图</h1>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第1章 引言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.3.3 数据模型</title>
      <link href="/ReadingNotes//1500a729/"/>
      <url>/ReadingNotes//1500a729/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/1500a729/#1-3-3-数据模型" class="header_1">1.3.3 数据模型</a>&nbsp;<br><a href="/ReadingNotes/1500a729/#数据模型的分类" class="header_2">数据模型的分类</a>&nbsp;<br><a href="/ReadingNotes/1500a729/#关系模型relational-model" class="header_3">关系模型relational model</a>&nbsp;<br><a href="/ReadingNotes/1500a729/#实体-联系模型entity-relationship-model" class="header_3">实体-联系模型entity-relationship model</a>&nbsp;<br><a href="/ReadingNotes/1500a729/#基于对象的数据模型object-based-data-model" class="header_3">基于对象的数据模型object-based data model</a>&nbsp;<br><a href="/ReadingNotes/1500a729/#半结构化数据模型semistructured-data-model" class="header_3">半结构化数据模型semistructured data model</a>&nbsp;<br><a href="/ReadingNotes/1500a729/#网状数据模型和层次数据模型" class="header_2">网状数据模型和层次数据模型</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="1-3-3-数据模型"><a href="#1-3-3-数据模型" class="headerlink" title="1.3.3 数据模型"></a>1.3.3 数据模型</h1><p>数据库结构的基础是<code>数据模型</code>(<code>data model</code>)。数据模型是一个描述数据、数据联系、数据语义以及致性约束的概念工具的集合。数据模型提供了一种描述物理层、逻辑层以及视图层数据库设计的方式。</p><h2 id="数据模型的分类"><a href="#数据模型的分类" class="headerlink" title="数据模型的分类"></a>数据模型的分类</h2><p>数据模型可被划分为四类</p><h3 id="关系模型relational-model"><a href="#关系模型relational-model" class="headerlink" title="关系模型relational model"></a>关系模型relational model</h3><p><strong>关系模型<code>用表的集合</code>来表示数据和数据间的联系</strong>。每个表有多个列,每列有唯一的列名。<br>关系模型是<code>基于记录</code>的模型的一种。基于记录的模型的名称的由来是因为数据库是由若干种固定格式的记录来构成的。每个表包含某种特定类型的记录。每个记录类型定义了固定数目的字段(或属性)。表的列对应于记录类型的属性。<br><strong>关系数据模型是使用最泛的数据模型</strong>,当今大量的数据库系统都基于这种关系模型。<strong>第2~8章</strong>将详细介绍关系模型。</p><h3 id="实体-联系模型entity-relationship-model"><a href="#实体-联系模型entity-relationship-model" class="headerlink" title="实体-联系模型entity-relationship model"></a>实体-联系模型entity-relationship model</h3><p>实体-联系(<code>E-R</code>)数据模型基于对现实世界的这样种认识:现实世界由一组称作实体的基本对象以及这些对象间的联系构成。<br>实体是现实世界中<code>可区别于其他对象的</code>一件”事情”或一个”物体”。<br><strong><code>实体-联系模型</code>被广泛用于数据库设计</strong>。<strong>第7章</strong>将详细探讨该模型。</p><h3 id="基于对象的数据模型object-based-data-model"><a href="#基于对象的数据模型object-based-data-model" class="headerlink" title="基于对象的数据模型object-based data model"></a>基于对象的数据模型object-based data model</h3><p>面向对象的程序设计(特别是<code>Java</code>、C++或C#)已经成为占主导地位的软件开发方法。这导致面向对象数据模型的发展。<br><strong>面向对象的数据模型可以看成是<code>E-R</code>模型增加了封装、方法(函数)和对象标识等概念后的扩展</strong>。<code>对象-关系数据模型</code>结合了面向对象的数据模型和关系数据模型的特征。<strong>第22章</strong>将讲述<code>对象-关系数据模型</code>。</p><h3 id="半结构化数据模型semistructured-data-model"><a href="#半结构化数据模型semistructured-data-model" class="headerlink" title="半结构化数据模型semistructured data model"></a>半结构化数据模型semistructured data model</h3><p>半结构化数据模型允许那些相同类型的数据项含有不同的属性集的数据定义。这和早先提到的数据模型形成了对比:在那些数据模型中所有某种特定类型的数据项必须有相同的属性集。<strong>可扩展标记语言<code>XML</code>被广泛地用来表示半结构化数据</strong>。这将在第23章中详述。</p><h2 id="网状数据模型和层次数据模型"><a href="#网状数据模型和层次数据模型" class="headerlink" title="网状数据模型和层次数据模型"></a>网状数据模型和层次数据模型</h2><p>在历史上,网状数据模型(<code>network data model)</code>和层次数据模型(<code>hierarchical data model</code>)先于关系数据模型出现。这些模型和底层的实现联系很紧密,并且使数据建模复杂化。因此,<strong>除了在某些地方仍在使用的旧数据库中之外,如今它们已经很少被使用了</strong>。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第1章 引言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.1 数据库系统的应用</title>
      <link href="/ReadingNotes//3b2a3d49/"/>
      <url>/ReadingNotes//3b2a3d49/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/3b2a3d49/#1-1-数据库系统的应用" class="header_1">1.1 数据库系统的应用</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="1-1-数据库系统的应用"><a href="#1-1-数据库系统的应用" class="headerlink" title="1.1 数据库系统的应用"></a>1.1 数据库系统的应用</h1><p>比如,当你访问一家在线书店,浏览一本书或一个音乐集时,其实你正在访问存储在某个数据库中的数据。<br>当你确认了一个网上订购,你的订单也就保存在了某个数据库中。<br>当你访问一个银行网站,检索你的账户余额和交易信息时,这些信息也是从银行的数据库系统中取出来的。<br>当你访问一个网站时,关于你的一些信息可能会从某个数据库中取出,并且选择出那些适合显示给你的广告。此外,关于你访问网络的数据也可能会存储在一个数据库中。</p><p>因此,尽管用户界面隐藏了访问数据库的细节,大多数人甚至没有意识到他们正在和一个数据库打交道,然而访问数据库已经成为当今几乎每个人生活中不可默认的组成部分。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第1章 引言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第1章 引言</title>
      <link href="/ReadingNotes//45e697d2/"/>
      <url>/ReadingNotes//45e697d2/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/45e697d2/#第1章-引言" class="header_1">第1章 引言</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="第1章-引言"><a href="#第1章-引言" class="headerlink" title="第1章 引言"></a>第1章 引言</h1><p>据库管理系统( <code>Data Base- management System,DBMS)</code>由一个互相关联的<code>数据的集合</code>和一组<code>用以访问这些数据的程序</code>组成。这个数据集合通常称作数据库( <code>database)</code>,其中包含了关于某个企业的信息。<br><code>DBMS</code>的主要目标是要提供一种可以<code>方便</code>、<code>高效</code>地存取数据库信息的途径。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 第1章 引言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统概念 原书第6版 前言</title>
      <link href="/ReadingNotes//4a592fe4/"/>
      <url>/ReadingNotes//4a592fe4/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/4a592fe4/#数据库系统概念-原书第6版-前言" class="header_1">数据库系统概念 原书第6版 前言</a>&nbsp;<br><a href="/ReadingNotes/4a592fe4/#本书的组织" class="header_1">本书的组织</a>&nbsp;<br><a href="/ReadingNotes/4a592fe4/#综述-第1章" class="header_2">综述(第1章)</a>&nbsp;<br><a href="/ReadingNotes/4a592fe4/#第一部分-关系数据库-第2章至第6章" class="header_2">第一部分:关系数据库(第2章至第6章)</a>&nbsp;<br><a href="/ReadingNotes/4a592fe4/#第二部分-数据库设计-第7章至第9章" class="header_2">第二部分:数据库设计(第7章至第9章)</a>&nbsp;<br><a href="/ReadingNotes/4a592fe4/#第三部分-数据存储和查询-第10章至第13章" class="header_2">第三部分:数据存储和查询(第10章至第13章)</a>&nbsp;<br><a href="/ReadingNotes/4a592fe4/#第四部分-事务管理-第14章至第16章" class="header_2">第四部分:事务管理(第14章至第16章)</a>&nbsp;<br><a href="/ReadingNotes/4a592fe4/#第五部分-系统体系结构-第17章至第19章" class="header_2">第五部分:系统体系结构(第17章至第19章)</a>&nbsp;<br><a href="/ReadingNotes/4a592fe4/#第六部分-数据仓库-数据挖掘与信息检索-第20章和第21章" class="header_2">第六部分:数据仓库 数据挖掘与信息检索(第20章和第21章)</a>&nbsp;<br><a href="/ReadingNotes/4a592fe4/#第七部分-特种数据库-第22章和第23章" class="header_2">第七部分:特种数据库(第22章和第23章)</a>&nbsp;<br><a href="/ReadingNotes/4a592fe4/#第八部分-高级主题-第24章至第26章" class="header_2">第八部分:高级主题(第24章至第26章)</a>&nbsp;<br><a href="/ReadingNotes/4a592fe4/#第九部分-实例研究-第27章至第30章" class="header_2">第九部分:实例研究(第27章至第30章)</a>&nbsp;<br><a href="/ReadingNotes/4a592fe4/#第十部分-附录-附录A到附录E" class="header_2">第十部分:附录(附录A到附录E)</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="数据库系统概念-原书第6版-前言"><a href="#数据库系统概念-原书第6版-前言" class="headerlink" title="数据库系统概念 原书第6版 前言"></a>数据库系统概念 原书第6版 前言</h1><h1 id="本书的组织"><a href="#本书的组织" class="headerlink" title="本书的组织"></a>本书的组织</h1><p>本书组织成十个主要部分:</p><h2 id="综述-第1章"><a href="#综述-第1章" class="headerlink" title="综述(第1章)"></a>综述(第1章)</h2><p>第1章对数据库系统的性质和目标进行了一般性综述。我们解释了数据库系统的概念是如何发展的,各数据库系统的共同特性是什么,数据库系统能为用户做什么,以及数据库系统如何与操作系统交互。我们还引人了一个数据库应用的例子:包括多个系、教员、学生和课程的一个大学机构。<code>这个应用作为贯穿全书的运行实例</code>。这一章本质上是诱导性、历史性和解释性的。</p><h2 id="第一部分-关系数据库-第2章至第6章"><a href="#第一部分-关系数据库-第2章至第6章" class="headerlink" title="第一部分:关系数据库(第2章至第6章)"></a>第一部分:关系数据库(第2章至第6章)</h2><p>第2章介绍了数据的关系模型,包括基本概念诸如<code>关系数据库的结构</code>、<code>数据库模式</code>、<code>码</code>、<code>模式图</code>、关系查询语言和关系操作等。第3~5章主要介绍最具影响力的面向用户的关系语言—<code>SQL</code>。第6章介绍形式化的<code>关系查询语言</code>,包括<code>关系代数</code>、元组关系演算和域关系演算。这部分描述了<code>数据操纵</code>,包括<code>查询</code>、<code>修改</code>、<code>插入</code>和<code>删除</code>(假设已有一个模式设计)。关于模式设计的问题延迟到第二部分讲述。</p><h2 id="第二部分-数据库设计-第7章至第9章"><a href="#第二部分-数据库设计-第7章至第9章" class="headerlink" title="第二部分:数据库设计(第7章至第9章)"></a>第二部分:数据库设计(第7章至第9章)</h2><p>第7章给出了数据库设计过程的概要介绍,主要侧重于用<code>实体-联系数据模型</code>来进行数据库设计。实体-联系模型为数据库设计问题,以及我们在数据模型的约束下捕获现实应用的语义时所遇到的问题提供了一个高层视图。<code>UML</code>类图表也在这一章中讲述。<br>第8章介绍关系数据库设计理论。这一章讲述函数依赖和规范化,重点强调提出各种范式的动机,以及它们的直观含义。这一章以关系设计的概览开始,依赖于对函数依赖的逻辑蕴涵的直观理解。这使得规范化的概念可以在函数依赖理论的完整内容之前先作介绍。函数依赖理论将在本章中稍后部分讨论。教师可以只选用8.1节至8.3节这些较前面的章节,而不会丢失连贯性。不过,完整地讲授这一章将有利于学生对规范化概念形成较好的理解,从而诱导出函数依赖理论中一些较艰深的概念。<br>第9章讲述应用设计和开发。这一章侧重于用基于<code>Web</code>的界面构建数据库应用。另外,这一章还讲述了应用安全性。</p><h2 id="第三部分-数据存储和查询-第10章至第13章"><a href="#第三部分-数据存储和查询-第10章至第13章" class="headerlink" title="第三部分:数据存储和查询(第10章至第13章)"></a>第三部分:数据存储和查询(第10章至第13章)</h2><p>第10章讨论存储设备、文件和数据存储结构。<br>第11章中介绍多种数据存取技术,包括B树索引和散列。<br>第12章和第13章阐述查询执行算法和查询优化。这两章使用户能更好地理解数据库的存储和检索的内部机制。</p><h2 id="第四部分-事务管理-第14章至第16章"><a href="#第四部分-事务管理-第14章至第16章" class="headerlink" title="第四部分:事务管理(第14章至第16章)"></a>第四部分:事务管理(第14章至第16章)</h2><p>第14章着重介绍事务处理系统的基本概念,包括<code>原子性</code>、<code>一致性</code>、<code>隔离性</code>和<code>持久性</code>。它还提供了用于保证这些特性的方法的一个概述,包括封锁和快照隔离性。<br>第15章重点讲述<code>并发控制</code>,并介绍保证可串行化的几种技术,包括<code>封锁</code>、<code>时间戳</code>和<code>乐观</code>(有效性检查)技术。在这一章中还讨论死锁问题,并介绍保证可串行化的其他方法,特别是详细讨论广泛使用的快照隔离方法。<br>第16章讨论在系统崩溃和存储器故障情况下保证事务正确执行的主要技术。这些技术包括日志、检查点和数据库转储。被广泛使用的<code>ARIES</code>算法也在这里做了介绍</p><h2 id="第五部分-系统体系结构-第17章至第19章"><a href="#第五部分-系统体系结构-第17章至第19章" class="headerlink" title="第五部分:系统体系结构(第17章至第19章)"></a>第五部分:系统体系结构(第17章至第19章)</h2><p>第17章介绍计算机系统体系结构,并描述了作为基础的计算机系统对于数据库系统的影响。在这一章中讨论了集中式系统、客户-服务器系统、并行和分布式体系结构。<br>在第18章关于并行数据库的讨论中,我们探讨了各种并行技术,包括L0并行、查询间并行和查询内并行,以及操作间并行和操作内并行。这一章中还讨论了并行系统设计。<br>第19章讨论分布式数据库系统,在分布式数据库系统的环境下重新讨论数据库设计、事务管理、查询执行和优化问题。这一章还包括了故障时的系统可用性问题,并介绍了异构分布式数据库、基于云的数据库和分布式目录系统</p><h2 id="第六部分-数据仓库-数据挖掘与信息检索-第20章和第21章"><a href="#第六部分-数据仓库-数据挖掘与信息检索-第20章和第21章" class="headerlink" title="第六部分:数据仓库 数据挖掘与信息检索(第20章和第21章)"></a>第六部分:数据仓库 数据挖掘与信息检索(第20章和第21章)</h2><p>第20章介绍数据仓库和数据挖掘的概念。第21章描述用于查询文本数据的信息检索技术,包括在<code>Web</code>搜索引擎中使用的基于超链接的技术。</p><h2 id="第七部分-特种数据库-第22章和第23章"><a href="#第七部分-特种数据库-第22章和第23章" class="headerlink" title="第七部分:特种数据库(第22章和第23章)"></a>第七部分:特种数据库(第22章和第23章)</h2><p>第22章介绍<code>基于对象的数据库</code>。该章讲述了<code>对象-关系数据模型</code>,该模型扩展了关系数据模型以支持复杂数据类型、类型继承和对象标识。该章还描述了用面向对象的编程语言来访问数据库。<br>第23章介绍数据表示的<code>XML</code>标准,它正日益广泛地应用于复杂数据交换和存储。这一章还描述了<code>XML</code>的查询语言</p><h2 id="第八部分-高级主题-第24章至第26章"><a href="#第八部分-高级主题-第24章至第26章" class="headerlink" title="第八部分:高级主题(第24章至第26章)"></a>第八部分:高级主题(第24章至第26章)</h2><p>第24章讨论应用开发中的高级话题,包括<code>性能调整</code>、性能评测标准、数据库应用测试和标准化。<br>第25章介绍空间和地理数据、时间数据、多媒体数据以及移动和个人数据库管理中的问题。<br>最后,第26章讨论髙级事务处理。这一章的内容包括事务处理监控器、事务工作流、电子商务、高性能事务系统、实时事务系统和持续长时间的事务。</p><h2 id="第九部分-实例研究-第27章至第30章"><a href="#第九部分-实例研究-第27章至第30章" class="headerlink" title="第九部分:实例研究(第27章至第30章)"></a>第九部分:实例研究(第27章至第30章)</h2><p>在这一部分我们对四个领先的数据库系统进行实例研究,包括<code>PostgreSQL</code>、 <code>Oracle</code>、 <code>IBM DB2</code>和<code>Microsoft SQL Server</code>。这几章中列举了上述每一种系统的独有特性,描述了它们的内部结构,提供了关于各个产品的丰富的有用信息,帮助读者了解前面各部分描述的各种实现技术是如何使用到实际系统中的。这几章中还包括实际系统设计中的几个有趣的方面。</p><h2 id="第十部分-附录-附录A到附录E"><a href="#第十部分-附录-附录A到附录E" class="headerlink" title="第十部分:附录(附录A到附录E)"></a>第十部分:附录(附录A到附录E)</h2><p>我们提供5个附录,包括一些历史性的和高级的内容;这些附录只在本书的<code>Web</code>站点中联机提供。只有附录A(详细的大学模式)例外,它给出了我们的大学模式的细节,包括完整的模式、<code>DDL</code>和所有的表。这个附录出现在纸质版本中。<br>附录B(高级关系数据库设计)描述了高级关系数据库设计,包括多值依赖理论、连接依赖、投影连接和域一码范式。这个附录是为希望更详细地研究关系数据库设计理论的读者,以及希望在课程中这样做的教师准备的。这个附录同样只是联机提供,就在本书的网站上。<br>附录C(其他关系查询语言)描述其他的关系查询语言,包括<code>QBE Microsoft Access</code>和<code>Datalog</code><br>虽然大多数新的数据库应用系统使用<code>关系模型</code>或<code>对象-关系模型</code>,但网状的和层次的数据模型在一些遗留应用中也仍然在使用。为了满足希望了解这些数据模型的读者的需要,我们给出了描述网状和层次的数据模型的附录,分别为附录D(<code>网状模型</code>)和附录E(<code>层次模型</code>)</p><!--SSTStop-->]]></content>
      
      
      <categories>
          
          <category> 数据库系统概念 原书第6版 </category>
          
          <category> 前言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>10.2 模板方法模式的定义</title>
      <link href="/ReadingNotes//95d0c0d7/"/>
      <url>/ReadingNotes//95d0c0d7/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/95d0c0d7/#10-2-模板方法模式的定义" class="header_1">10.2 模板方法模式的定义</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="10-2-模板方法模式的定义"><a href="#10-2-模板方法模式的定义" class="headerlink" title="10.2 模板方法模式的定义"></a>10.2 模板方法模式的定义</h1><p>定义一个操作中的算法的框架,而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式之禅(第2版) </category>
          
          <category> 第二部分 真刀实枪 23种设计模式完美演绎 </category>
          
          <category> 第10章 模板方法模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>10.1 辉煌工程 制造悍马</title>
      <link href="/ReadingNotes//6800df02/"/>
      <url>/ReadingNotes//6800df02/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/6800df02/#10-1-辉煌工程-制造悍马" class="header_1">10.1 辉煌工程 制造悍马</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="10-1-辉煌工程-制造悍马"><a href="#10-1-辉煌工程-制造悍马" class="headerlink" title="10.1 辉煌工程 制造悍马"></a>10.1 辉煌工程 制造悍马</h1><p>抽象是所有子类的共性封装。<br>注意在软件开发过程中,如果相同的一段代码复制过两次,就需要对设计产生怀疑,架构师要明确地说明为什么相同的逻辑要出现两次或更多次。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式之禅(第2版) </category>
          
          <category> 第二部分 真刀实枪 23种设计模式完美演绎 </category>
          
          <category> 第10章 模板方法模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>9.4 最佳实践</title>
      <link href="/ReadingNotes//6e01efda/"/>
      <url>/ReadingNotes//6e01efda/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/6e01efda/#9-4-最佳实践" class="header_1">9.4 最佳实践</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="9-4-最佳实践"><a href="#9-4-最佳实践" class="headerlink" title="9.4 最佳实践"></a>9.4 最佳实践</h1><p>抽象工厂模式是一个简单的模式,使用的场景非常多,大家在软件产品开发过程中,涉及不同操作系统的时候,都可以考虑使用抽象工厂模式,例如一个应用,需要在三个不同平台(<code>Windows</code>、<code>Linux</code>、<code>Android</code>上运行,你会怎么设计?分别设计三套不同的应用?非也,<strong>通过抽象工厂模式屏蔽掉操作系统对应用的影响</strong>。三个不同操作系统上的软件功能、应用逻辑、<code>UI</code>都应该是非常类似的,唯一不同的是调用不同的工厂方法,由不同的产品类去处理与操作系统交互的信息。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式之禅(第2版) </category>
          
          <category> 第二部分 真刀实枪 23种设计模式完美演绎 </category>
          
          <category> 第9章 抽象工厂模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>9.3 抽象工厂模式的应用</title>
      <link href="/ReadingNotes//8d6289e/"/>
      <url>/ReadingNotes//8d6289e/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/8d6289e/#9-3-抽象工厂模式的应用" class="header_1">9.3 抽象工厂模式的应用</a>&nbsp;<br><a href="/ReadingNotes/8d6289e/#9-3-1-抽象工厂模式的优点" class="header_2">9.3.1 抽象工厂模式的优点</a>&nbsp;<br><a href="/ReadingNotes/8d6289e/#9-3-2-抽象工厂模式的缺点" class="header_2">9.3.2 抽象工厂模式的缺点</a>&nbsp;<br><a href="/ReadingNotes/8d6289e/#9-3-3-抽象工厂模式的使用场景" class="header_2">9.3.3 抽象工厂模式的使用场景</a>&nbsp;<br><a href="/ReadingNotes/8d6289e/#9-3-4-抽象工厂模式的注意事项" class="header_2">9.3.4 抽象工厂模式的注意事项</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="9-3-抽象工厂模式的应用"><a href="#9-3-抽象工厂模式的应用" class="headerlink" title="9.3 抽象工厂模式的应用"></a>9.3 抽象工厂模式的应用</h1><h2 id="9-3-1-抽象工厂模式的优点"><a href="#9-3-1-抽象工厂模式的优点" class="headerlink" title="9.3.1 抽象工厂模式的优点"></a>9.3.1 抽象工厂模式的优点</h2><p>● 封装性,每个产品的实现类不是高层模块要关心的,它要关心的是什么?是接口,是抽象,它不关心对象是如何创建出来,这由谁负责呢?工厂类,只要知道工厂类是谁,我就能创建出一个需要的对象,省时省力,优秀设计就应该如此。<br>● 产品族内的约束为非公开状态。例如生产男女比例的问题上,猜想女娲娘娘肯定有自己的打算,不能让女盛男衰,否则女性的优点不就体现不出来了吗?那在抽象工厂模式,就应该有这样的一个约束:每生产1个女性,就同时生产出1.2个男性,这样的生产过程对调用工厂类的高层模块来说是透明的,它不需要知道这个约束,我就是要一个黄色女性产品就可以了,具体的产品族内的约束是在工厂内实现的。</p><h2 id="9-3-2-抽象工厂模式的缺点"><a href="#9-3-2-抽象工厂模式的缺点" class="headerlink" title="9.3.2 抽象工厂模式的缺点"></a>9.3.2 抽象工厂模式的缺点</h2><p>抽象工厂模式的最大缺点就是产品族扩展非常困难<br>抽象工厂模式的最大缺点就是产品族扩展非常困难,为什么这么说呢?我们以通用代码为例,如果要增加一个产品C,也就是说产品家族由原来的2个增加到3个,看看我们的程序有多大改动吧!抽象类<code>AbstractCreator</code>要增加一个方法<code>createProductC()</code>,然后两个实现类都要修改,想想看,这严重违反了开闭原则,而且我们一直说明抽象类和接口是一个契约。改变契约,所有与契约有关系的代码都要修改,那么这段代码叫什么?叫”有毒代码”,——只要与这段代码有关系,就可能产生侵害的危险!</p><h2 id="9-3-3-抽象工厂模式的使用场景"><a href="#9-3-3-抽象工厂模式的使用场景" class="headerlink" title="9.3.3 抽象工厂模式的使用场景"></a>9.3.3 抽象工厂模式的使用场景</h2><p>抽象工厂模式的使用场景定义非常简单:一个对象族(或是一组没有任何关系的对象)都有相同的约束,则可以使用抽象工厂模式。什么意思呢?例如一个文本编辑器和一个图片处理器,都是软件实体,但是<code>*nix</code>下的文本编辑器和<code>Windows</code>下的文本编辑器虽然功能和界面都相同,但是代码实现是不同的,图片处理器也有类似情况。也就是具有了共同的约束条件:操作系统类型。于是我们可以使用抽象工厂模式,产生不同操作系统下的编辑器和图片处理器。</p><h2 id="9-3-4-抽象工厂模式的注意事项"><a href="#9-3-4-抽象工厂模式的注意事项" class="headerlink" title="9.3.4 抽象工厂模式的注意事项"></a>9.3.4 抽象工厂模式的注意事项</h2>]]></content>
      
      
      <categories>
          
          <category> 设计模式之禅(第2版) </category>
          
          <category> 第二部分 真刀实枪 23种设计模式完美演绎 </category>
          
          <category> 第9章 抽象工厂模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>9.2 抽象工厂模式的定义</title>
      <link href="/ReadingNotes//706b4323/"/>
      <url>/ReadingNotes//706b4323/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/706b4323/#9-2-抽象工厂模式的定义" class="header_1">9.2 抽象工厂模式的定义</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="9-2-抽象工厂模式的定义"><a href="#9-2-抽象工厂模式的定义" class="headerlink" title="9.2 抽象工厂模式的定义"></a>9.2 抽象工厂模式的定义</h1><p>为创建一组相关或相互依赖的对象提供一个接口,而且无须指定它们的具体类。<br>抽象工厂模式的通用类图<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/SheJiMoShiZhiChan2/ch9/1.png" alt="这里有一张图片"></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式之禅(第2版) </category>
          
          <category> 第二部分 真刀实枪 23种设计模式完美演绎 </category>
          
          <category> 第9章 抽象工厂模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>9.1 女娲的失误</title>
      <link href="/ReadingNotes//10fc050a/"/>
      <url>/ReadingNotes//10fc050a/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/10fc050a/#9-1-女娲的失误" class="header_1">9.1 女娲的失误</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="9-1-女娲的失误"><a href="#9-1-女娲的失误" class="headerlink" title="9.1 女娲的失误"></a>9.1 女娲的失误</h1>]]></content>
      
      
      <categories>
          
          <category> 设计模式之禅(第2版) </category>
          
          <category> 第二部分 真刀实枪 23种设计模式完美演绎 </category>
          
          <category> 第9章 抽象工厂模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8.5 最佳实践</title>
      <link href="/ReadingNotes//5d669f3d/"/>
      <url>/ReadingNotes//5d669f3d/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/5d669f3d/#8-5-最佳实践" class="header_1">8.5 最佳实践</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="8-5-最佳实践"><a href="#8-5-最佳实践" class="headerlink" title="8.5 最佳实践"></a>8.5 最佳实践</h1>]]></content>
      
      
      <categories>
          
          <category> 设计模式之禅(第2版) </category>
          
          <category> 第二部分 真刀实枪 23种设计模式完美演绎 </category>
          
          <category> 第8章 工厂方法模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8.4 工厂方法模式的扩展</title>
      <link href="/ReadingNotes//8cf7060e/"/>
      <url>/ReadingNotes//8cf7060e/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/8cf7060e/#8-4-工厂方法模式的扩展" class="header_1">8.4 工厂方法模式的扩展</a>&nbsp;<br><a href="/ReadingNotes/8cf7060e/#1-缩小为简单工厂模式" class="header_2">1. 缩小为简单工厂模式</a>&nbsp;<br><a href="/ReadingNotes/8cf7060e/#2-升级为多个工厂类" class="header_2">2. 升级为多个工厂类</a>&nbsp;<br><a href="/ReadingNotes/8cf7060e/#3-替代单例模式" class="header_2">3. 替代单例模式</a>&nbsp;<br><a href="/ReadingNotes/8cf7060e/#4-延迟初始化" class="header_2">4. 延迟初始化</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="8-4-工厂方法模式的扩展"><a href="#8-4-工厂方法模式的扩展" class="headerlink" title="8.4 工厂方法模式的扩展"></a>8.4 工厂方法模式的扩展</h1><p>工厂方法模式有很多扩展,而且与其他模式结合使用威力更大,下面将介绍4种扩展。</p><h2 id="1-缩小为简单工厂模式"><a href="#1-缩小为简单工厂模式" class="headerlink" title="1. 缩小为简单工厂模式"></a>1. 缩小为简单工厂模式</h2><h2 id="2-升级为多个工厂类"><a href="#2-升级为多个工厂类" class="headerlink" title="2. 升级为多个工厂类"></a>2. 升级为多个工厂类</h2><h2 id="3-替代单例模式"><a href="#3-替代单例模式" class="headerlink" title="3. 替代单例模式"></a>3. 替代单例模式</h2><h2 id="4-延迟初始化"><a href="#4-延迟初始化" class="headerlink" title="4. 延迟初始化"></a>4. 延迟初始化</h2>]]></content>
      
      
      <categories>
          
          <category> 设计模式之禅(第2版) </category>
          
          <category> 第二部分 真刀实枪 23种设计模式完美演绎 </category>
          
          <category> 第8章 工厂方法模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8.3 工厂方法模式的应用</title>
      <link href="/ReadingNotes//afdad7af/"/>
      <url>/ReadingNotes//afdad7af/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/afdad7af/#8-3-工厂方法模式的应用" class="header_1">8.3 工厂方法模式的应用</a>&nbsp;<br><a href="/ReadingNotes/afdad7af/#8-3-1-工厂方法模式的优点" class="header_2">8.3.1 工厂方法模式的优点</a>&nbsp;<br><a href="/ReadingNotes/afdad7af/#8-3-2-工厂方法模式的使用场景" class="header_2">8.3.2 工厂方法模式的使用场景</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="8-3-工厂方法模式的应用"><a href="#8-3-工厂方法模式的应用" class="headerlink" title="8.3 工厂方法模式的应用"></a>8.3 工厂方法模式的应用</h1><h2 id="8-3-1-工厂方法模式的优点"><a href="#8-3-1-工厂方法模式的优点" class="headerlink" title="8.3.1 工厂方法模式的优点"></a>8.3.1 工厂方法模式的优点</h2><p>首先,良好的封装性,代码结构清晰。一个对象创建是有条件约束的,如<strong>一个调用者需要一个具体的产品对象,只要知道这个产品的类名(或约束字符串)就可以了,不用知道创建对象的艰辛过程</strong>,降低模块间的耦合。<br>其次,工厂方法模式的扩展性非常优秀。在增加产品类的情况下,只要适当地修改具体的工厂类或扩展一个工厂类,就可以完成”拥抱变化”。例如在我们的例子中,需要增加一个棕色人种,则只需要增加一个<code>BrownHuman</code>类,工厂类不用任何修改就可完成系统扩展。<br>再次,屏蔽产品类。这一特点非常重要,产品类的实现如何变化,调用者都不需要关心,它只需要关心产品的接口,只要接口保持不变,系统中的上层模块就不要发生变化。因为产品类的实例化工作是由工厂类负责的,一个产品对象具体由哪一个产品生成是由工厂类决定的。在数据库开发中,大家应该能够深刻体会到工厂方法模式的好处:如果使用<code>JDBC</code>连接数据库,数据库从<code>MySQL</code>切换到<code>Oracle</code>,需要改动的地方就是切换一下驱动名称(前提条件是<code>SQL</code>语句是标准语句),其他的都不需要修改,这是工厂方法模式灵活性的一个直接案例。<br>最后,工厂方法模式是典型的解耦框架。高层模块值需要知道产品的抽象类,其他的实现类都不用关心,符合迪米特法则,我不需要的就不要去交流;也符合依赖倒置原则,只依赖产品类的抽象;当然也符合里氏替换原则,使用产品子类替换产品父类,没问题!</p><h2 id="8-3-2-工厂方法模式的使用场景"><a href="#8-3-2-工厂方法模式的使用场景" class="headerlink" title="8.3.2 工厂方法模式的使用场景"></a>8.3.2 工厂方法模式的使用场景</h2><p>首先,工厂方法模式是<code>new</code>一个对象的替代品,所以在所有需要生成对象的地方都可以使用,但是需要慎重地考虑是否要增加一个工厂类进行管理,增加代码的复杂度。<br>其次,需要灵活的、可扩展的框架时,可以考虑采用工厂方法模式。万物皆对象,那万物也就皆产品类,例如需要设计一个连接邮件服务器的框架,有三种网络协议可供选择:<code>POP3</code>、<code>IMAP</code>、<code>HTTP</code>,我们就可以把这三种连接方法作为产品类,定义一个接口如<code>IConnectMail</code>,然后定义对邮件的操作方法,用不同的方法实现三个具体的产品类(也就是连接方式)再定义一个工厂方法,按照不同的传入条件,选择不同的连接方式。如此设计,可以做到完美的扩展,如某些邮件服务器提供了<code>WebService</code>接口,很好,我们只要增加一个产品类就可以了。<br>再次,工厂方法模式可以用在异构项目中,例如通过<code>WebService</code>与一个非<code>Java</code>的项目交互,虽然<code>WebService</code>号称是可以做到异构系统的同构化,但是在实际的开发中,还是会碰到很多问题,如类型问题、<code>WSDL</code>文件的支持问题,等等。从<code>WSDL</code>中产生的对象都认为是一个产品,然后由一个具体的工厂类进行管理,减少与外围系统的耦合。<br>最后,可以使用在测试驱动开发的框架下。例如,测试一个类A,就需要把与类A有关联关系的类B也同时产生出来,我们可以使用工厂方法模式把类B虚拟出来,避免类A与类B的耦合。目前由于<code>JMock</code>和<code>EasyMock</code>的诞生,该使用场景已经弱化了,读者可以在遇到此种情况时直接考虑使用<code>JMock</code>或<code>EasyMock</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式之禅(第2版) </category>
          
          <category> 第二部分 真刀实枪 23种设计模式完美演绎 </category>
          
          <category> 第8章 工厂方法模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8.2 工厂方法模式的定义</title>
      <link href="/ReadingNotes//d767bc12/"/>
      <url>/ReadingNotes//d767bc12/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/d767bc12/#8-2-工厂方法模式的定义" class="header_1">8.2 工厂方法模式的定义</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="8-2-工厂方法模式的定义"><a href="#8-2-工厂方法模式的定义" class="headerlink" title="8.2 工厂方法模式的定义"></a>8.2 工厂方法模式的定义</h1><p>定义一个用于创建对象的接口,让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式之禅(第2版) </category>
          
          <category> 第二部分 真刀实枪 23种设计模式完美演绎 </category>
          
          <category> 第8章 工厂方法模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.9 UML关系</title>
      <link href="/ReadingNotes//5ef57039/"/>
      <url>/ReadingNotes//5ef57039/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/5ef57039/#3-9-UML关系" class="header_1">3.9 UML关系</a>&nbsp;<br><a href="/ReadingNotes/5ef57039/#3-9-1-关联关系-assocration" class="header_1">3.9.1 关联关系(assocration)</a>&nbsp;<br><a href="/ReadingNotes/5ef57039/#关联关系的图像表示" class="header_2">关联关系的图像表示</a>&nbsp;<br><a href="/ReadingNotes/5ef57039/#举例" class="header_2">举例</a>&nbsp;<br><a href="/ReadingNotes/5ef57039/#关联关系和依赖关系的不同" class="header_2">关联关系和依赖关系的不同</a>&nbsp;<br><a href="/ReadingNotes/5ef57039/#关联关系在代码中的体现" class="header_2">关联关系在代码中的体现</a>&nbsp;<br><a href="/ReadingNotes/5ef57039/#关联关系的多重性" class="header_2">关联关系的多重性</a>&nbsp;<br><a href="/ReadingNotes/5ef57039/#举例-父子结构" class="header_2">举例: 父子结构</a>&nbsp;<br><a href="/ReadingNotes/5ef57039/#3-9-2-依赖关系-dependency" class="header_1">3.9.2 依赖关系(dependency)</a>&nbsp;<br><a href="/ReadingNotes/5ef57039/#依赖关系的图形" class="header_2">依赖关系的图形</a>&nbsp;<br><a href="/ReadingNotes/5ef57039/#依赖关系和关联关系的不同" class="header_2">依赖关系和关联关系的不同</a>&nbsp;<br><a href="/ReadingNotes/5ef57039/#举例说明" class="header_2">举例说明</a>&nbsp;<br><a href="/ReadingNotes/5ef57039/#依赖代码里的体现" class="header_2">依赖代码里的体现</a>&nbsp;<br><a href="/ReadingNotes/5ef57039/#使用关联关系的情况" class="header_2">使用关联关系的情况</a>&nbsp;<br><a href="/ReadingNotes/5ef57039/#使用依赖关系的情况" class="header_2">使用依赖关系的情况</a>&nbsp;<br><a href="/ReadingNotes/5ef57039/#杜绝双向依赖" class="header_2">杜绝双向依赖</a>&nbsp;<br><a href="/ReadingNotes/5ef57039/#3-9-3-扩展关系-extends" class="header_1">3.9.3 扩展关系(extends)</a>&nbsp;<br><a href="/ReadingNotes/5ef57039/#3-9-4-包含关系-include" class="header_1">3.9.4 包含关系(include)</a>&nbsp;<br><a href="/ReadingNotes/5ef57039/#3-9-5-实现关系-realize" class="header_1">3.9.5 实现关系(realize)</a>&nbsp;<br><a href="/ReadingNotes/5ef57039/#3-9-6-精化关系-refine" class="header_1">3.9.6 精化关系(refine)</a>&nbsp;<br><a href="/ReadingNotes/5ef57039/#3-9-7-泛化关系-generalization" class="header_1">3.9.7 泛化关系(generalization)</a>&nbsp;<br><a href="/ReadingNotes/5ef57039/#3-9-8-聚合关系-aggregation" class="header_1">3.9.8 聚合关系(aggregation)</a>&nbsp;<br><a href="/ReadingNotes/5ef57039/#聚合-整体不存-部分仍在" class="header_2">聚合 整体不存 部分仍在</a>&nbsp;<br><a href="/ReadingNotes/5ef57039/#3-9-9-组合关系-composition" class="header_1">3.9.9 组合关系(composition)</a>&nbsp;<br><a href="/ReadingNotes/5ef57039/#组合-整体不存-部分也不存" class="header_2">组合 整体不存 部分也不存</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="3-9-UML关系"><a href="#3-9-UML关系" class="headerlink" title="3.9 UML关系"></a>3.9 UML关系</h1><p>在<code>UML</code>中,关系是非常重要的语义,它抽象出对象之间的联系,让对象构成某个特定的结构。本节将列举出<code>UML</code>所定义的关系,并解释它们的语义。</p><h1 id="3-9-1-关联关系-assocration"><a href="#3-9-1-关联关系-assocration" class="headerlink" title="3.9.1 关联关系(assocration)"></a>3.9.1 关联关系(assocration)</h1><h2 id="关联关系的图像表示"><a href="#关联关系的图像表示" class="headerlink" title="关联关系的图像表示"></a>关联关系的图像表示</h2><p>关联关系是用<strong>一条直线</strong>表示的</p><p>它描述不同类的对象之间的结构关系,关联关系是一种<code>静态关系</code>,通常与运行状态无关,而是由”常识”、”规则”、”法律”等因素决定的,所以关联关系是一种”强关联”的关系。</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>例如,</p><ul><li>公司与员工之间一对多就是一种符合”常识”的关系;</li><li>乘车人和车票之间的一对一关系是符合”规则”的关系;</li><li>公民和身份证之间的一对一关系是符合”法律”的关系;</li></ul><h2 id="关联关系和依赖关系的不同"><a href="#关联关系和依赖关系的不同" class="headerlink" title="关联关系和依赖关系的不同"></a>关联关系和依赖关系的不同</h2><p><strong>关联关系用来定义对象之间静态的、天然的结构</strong>。这与依赖关系是不同的,依赖关系表达的是对象之间临时性的、动态的关系。</p><h2 id="关联关系在代码中的体现"><a href="#关联关系在代码中的体现" class="headerlink" title="关联关系在代码中的体现"></a>关联关系在代码中的体现</h2><p>在最终的代码里,<strong>关联对象通常是以实例变量(<code>成员变量</code>)的形式实现的</strong>。<br>与依赖相比,<strong>关联的两个对象之间通常不会相互直接使用</strong>,尽管它们相互”知道”对方的存在,但一般都是由外部对象来访问的,如一个外部访问者可以通过员工对象获得公司对象。</p><h2 id="关联关系的多重性"><a href="#关联关系的多重性" class="headerlink" title="关联关系的多重性"></a>关联关系的多重性</h2><p>关联关系具有多重性,常见为<code>一对一关联</code>、<code>一对多关联</code>、<code>多对多关联</code>等,也可以是<code>任意多重性关联</code>,如<code>*</code>对<code>*</code>关联(*代表任意数)。</p><h2 id="举例-父子结构"><a href="#举例-父子结构" class="headerlink" title="举例: 父子结构"></a>举例: 父子结构</h2><p>例如对象之间的<code>父子</code>结构,如果是无方向的,表明父子对象相互<strong>拥有对方的<code>实例变量</code></strong>;如果是有方向的,如父到子,则表明父对象有子对象的实例变量,但子对象没有父对象的实例变量。</p><h1 id="3-9-2-依赖关系-dependency"><a href="#3-9-2-依赖关系-dependency" class="headerlink" title="3.9.2 依赖关系(dependency)"></a>3.9.2 依赖关系(dependency)</h1><h2 id="依赖关系的图形"><a href="#依赖关系的图形" class="headerlink" title="依赖关系的图形"></a>依赖关系的图形</h2><p>依赖关系是用一条带箭头的虚线表示的,如果箭头从A指向B,则表示A依赖B。<br>依赖关系描述了<strong>一个对象在运行期会<code>使用</code>到另一个对象</strong>这样的关系</p><h2 id="依赖关系和关联关系的不同"><a href="#依赖关系和关联关系的不同" class="headerlink" title="依赖关系和关联关系的不同"></a>依赖关系和关联关系的不同</h2><p>与关联关系不同的是,依赖关系是一种<code>临时性</code>的关系,它通常都是在<code>运行期</code>产生,并且随着运行场景的不同,依赖关系也可能发生变化。</p><h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><p>例如<code>人</code>和<code>船</code>这两个对象,</p><ul><li>如果运行场景是开动轮船,那么轮船依赖于人(水手);</li><li>如果场景变为渡海,那就变成人依赖于船了。</li></ul><p>可见,依赖关系是一种”弱”关系,它不是天然存在的,并且会随着运行场景的变化而变化。<br>如人和刀这两个对象,平时它们是没有关系的,但在削苹果这个场景里,人依赖于刀;脱离了这个场景,或者说当场景结束后,依赖关系也就不存在了。</p><h2 id="依赖代码里的体现"><a href="#依赖代码里的体现" class="headerlink" title="依赖代码里的体现"></a>依赖代码里的体现</h2><p>一般而言,依赖关系在最终的代码里体现为<strong>类构造方法、类方法等的<code>传入参数</code></strong>。与关联关系相比,依赖关系除了临时”知道”对方外,还会”使用”对方的属性或方法。从这个角度讲,<strong>被依赖的对象改变会导致依赖对象的修改</strong>。</p><h2 id="使用关联关系的情况"><a href="#使用关联关系的情况" class="headerlink" title="使用关联关系的情况"></a>使用关联关系的情况</h2><p>A对象对B对象没有操作,这时A仅仅是”知道”B对象,并且B修改了方法后,A并不变化,则使用关联关系。</p><h2 id="使用依赖关系的情况"><a href="#使用依赖关系的情况" class="headerlink" title="使用依赖关系的情况"></a>使用依赖关系的情况</h2><p>如果A对象在某个场景当中使用了B对象的属性或方法,则B的修改会导致A的修改,这时A依赖于B,要使用关联关系.</p><h2 id="杜绝双向依赖"><a href="#杜绝双向依赖" class="headerlink" title="杜绝双向依赖"></a>杜绝双向依赖</h2><p>同样的,依赖也有单向依赖和双向依赖之分。但是依赖关系却不像关联关系那样有带箭头和不带箭头的区分,统统都是带箭头的。这是因为在面向对象里,<strong>双向依赖是一种非常不好的结构</strong>,<strong>我们总是应当保持单向依赖,杜绝双向依赖关系的产生</strong></p><h1 id="3-9-3-扩展关系-extends"><a href="#3-9-3-扩展关系-extends" class="headerlink" title="3.9.3 扩展关系(extends)"></a>3.9.3 扩展关系(extends)</h1><h1 id="3-9-4-包含关系-include"><a href="#3-9-4-包含关系-include" class="headerlink" title="3.9.4 包含关系(include)"></a>3.9.4 包含关系(include)</h1><p>这两个关系主要用在用例图,先留着,有空再看</p><h1 id="3-9-5-实现关系-realize"><a href="#3-9-5-实现关系-realize" class="headerlink" title="3.9.5 实现关系(realize)"></a>3.9.5 实现关系(realize)</h1><p>实现关系是用一条<strong>带空心三角形箭头的虚线</strong>表示的</p><h1 id="3-9-6-精化关系-refine"><a href="#3-9-6-精化关系-refine" class="headerlink" title="3.9.6 精化关系(refine)"></a>3.9.6 精化关系(refine)</h1><p>精化关系先省略,用到再说</p><h1 id="3-9-7-泛化关系-generalization"><a href="#3-9-7-泛化关系-generalization" class="headerlink" title="3.9.7 泛化关系(generalization)"></a>3.9.7 泛化关系(generalization)</h1><p>泛化关系是用一条<strong>带空心三角形箭头的直线</strong>表示的,</p><p>泛化关系可用于建模过程中的任意一个阶段,说明两个对象之间的<code>继承关系</code>,泛化关系表示一个类对另一个类的继承。</p><h1 id="3-9-8-聚合关系-aggregation"><a href="#3-9-8-聚合关系-aggregation" class="headerlink" title="3.9.8 聚合关系(aggregation)"></a>3.9.8 聚合关系(aggregation)</h1><p>聚合关系是用一条<strong>带空心菱形箭头的直线</strong>表示的.<br>聚合关系用于类图,特别用于表示实体对象之间的关系,<strong>表达整体由部分<code>构成</code></strong>的语义。例如个部门由许多人员构成。</p><h2 id="聚合-整体不存-部分仍在"><a href="#聚合-整体不存-部分仍在" class="headerlink" title="聚合 整体不存 部分仍在"></a>聚合 整体不存 部分仍在</h2><p>与组合关系不同的是,整体和部分不是强依赖的,<strong>即使整体不存在了,部分仍然存在</strong>。例如部门撤销以后,人员不会因此而消失,他们依然存在。</p><h1 id="3-9-9-组合关系-composition"><a href="#3-9-9-组合关系-composition" class="headerlink" title="3.9.9 组合关系(composition)"></a>3.9.9 组合关系(composition)</h1><p>组合关系是用一条<strong>带实心菱形箭头的直线</strong>表示的<br>组合关系用于类图,特别用于表示实体对象关系,表达<strong>整体<code>拥有</code>部分</strong>的语义。例如母公司拥有许多子公司。</p><h2 id="组合-整体不存-部分也不存"><a href="#组合-整体不存-部分也不存" class="headerlink" title="组合 整体不存 部分也不存"></a>组合 整体不存 部分也不存</h2><p>组合关系是一种强依赖的特殊聚合关系,如果整体不存在了,则部分也将消亡。例如母公司解体了,子公司也将不再存在。</p><!--SSTStop-->]]></content>
      
      
      <categories>
          
          <category> 大象 Thinking in UML(第2版) </category>
          
          <category> 第3章 UML核心元素 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>7.4 单例模式的扩展</title>
      <link href="/ReadingNotes//e5d2c6ad/"/>
      <url>/ReadingNotes//e5d2c6ad/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/e5d2c6ad/#7-4-单例模式的扩展" class="header_1">7.4 单例模式的扩展</a>&nbsp;<br><a href="/ReadingNotes/e5d2c6ad/#代码清单7-5-固定数量的皇帝类" class="header_2">代码清单7-5 固定数量的皇帝类</a>&nbsp;<br><a href="/ReadingNotes/e5d2c6ad/#有上限的多例模式" class="header_2">有上限的多例模式</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="7-4-单例模式的扩展"><a href="#7-4-单例模式的扩展" class="headerlink" title="7.4 单例模式的扩展"></a>7.4 单例模式的扩展</h1><p>是如果要求一个类只能产生两三个对象呢?该怎么实现?我们还以皇帝为例来说明。</p><h2 id="代码清单7-5-固定数量的皇帝类"><a href="#代码清单7-5-固定数量的皇帝类" class="headerlink" title="代码清单7-5 固定数量的皇帝类"></a>代码清单7-5 固定数量的皇帝类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Emperor</span> </span>&#123;</span><br><span class="line">     <span class="comment">//定义最多能产生的实例数量</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> maxNumOfEmperor = <span class="number">2</span>;    </span><br><span class="line">     <span class="comment">//每个皇帝都有名字，使用一个ArrayList来容纳，每个对象的私有属性</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;String&gt; nameList=<span class="keyword">new</span> ArrayList&lt;String&gt;(); </span><br><span class="line">     <span class="comment">//定义一个列表，容纳所有的皇帝实例</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;Emperor&gt; emperorList=<span class="keyword">new</span> ArrayList&lt;Emperor&gt;();</span><br><span class="line">     <span class="comment">//当前皇帝序列号</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> countNumOfEmperor =<span class="number">0</span>;   </span><br><span class="line">     <span class="comment">//产生所有的对象</span></span><br><span class="line">     <span class="keyword">static</span>&#123;</span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;maxNumOfEmperor;i++)&#123;  </span><br><span class="line">                     emperorList.add(<span class="keyword">new</span> Emperor(<span class="string">"皇"</span>+(i+<span class="number">1</span>)+<span class="string">"帝"</span>));</span><br><span class="line">             &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="title">Emperor</span><span class="params">()</span></span>&#123;</span><br><span class="line">             <span class="comment">//世俗和道德约束你，目的就是不产生第二个皇帝</span></span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="comment">//传入皇帝名称，建立一个皇帝对象</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="title">Emperor</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">             nameList.add(name);</span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="comment">//随机获得一个皇帝对象</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Emperor <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">             Random random = <span class="keyword">new</span> Random();</span><br><span class="line">             <span class="comment">//随机拉出一个皇帝，只要是个精神领袖就成</span></span><br><span class="line">             countNumOfEmperor = random.nextInt(maxNumOfEmperor);</span><br><span class="line">             <span class="keyword">return</span> emperorList.get(countNumOfEmperor);         </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//皇帝发话了</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">             System.out.println(nameList.get(countNumOfEmperor));       </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>Emperor</code>中使用了两个<code>ArrayList</code>分别存储实例和实例变量。当然,<strong>如果考虑到线程安全问题可以使用<code>Vector</code>来代替</strong></p><h2 id="有上限的多例模式"><a href="#有上限的多例模式" class="headerlink" title="有上限的多例模式"></a>有上限的多例模式</h2><p><strong>这种需要产生固定数量对象的模式就叫做<code>有上限的多例模式</code></strong>,它是单例模式的一种扩展,采用有上限的多例模式,我们可以在设计时决定在内存中有多少个实例,方便系统进行扩展,修正单例可能存在的性能问题,提供系统的响应速度。例如读取文件,我们可以在系统启动时完成初始化工作,在内存中启动固定数量的<code>reader</code>实例,然后在需要读取文件时就可以快速响应。</p><!--SSTStop-->]]></content>
      
      
      <categories>
          
          <category> 设计模式之禅(第2版) </category>
          
          <category> 第二部分 真刀实枪 23种设计模式完美演绎 </category>
          
          <category> 第7章 单例模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>7.5 最佳实践</title>
      <link href="/ReadingNotes//d38cf807/"/>
      <url>/ReadingNotes//d38cf807/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/d38cf807/#7-5-最佳实践" class="header_1">7.5 最佳实践</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="7-5-最佳实践"><a href="#7-5-最佳实践" class="headerlink" title="7.5 最佳实践"></a>7.5 最佳实践</h1><p>单例模式是23个模式中比较简单的模式,应用也非常广泛,如在<code>Spring</code>中,每个<code>Bean</code>默认就是单例的,这样做的优点是<code>Spring</code>容器可以管理这些<code>Bean</code>的生命期,决定什么时候创建出来,什么时候销毁,销毁的时候要如何处理,等等。如果采用非单例模式(<code>Prototype</code>类型),则<code>Bean</code>初始化后的管理交由J2EE容器,<code>Spring</code>容器不再跟踪管理<code>Bean</code>的生命周期。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式之禅(第2版) </category>
          
          <category> 第二部分 真刀实枪 23种设计模式完美演绎 </category>
          
          <category> 第7章 单例模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8.1 女娲造人的故事</title>
      <link href="/ReadingNotes//ea99dde/"/>
      <url>/ReadingNotes//ea99dde/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/ea99dde/#8-1-女娲造人的故事" class="header_1">8.1 女娲造人的故事</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="8-1-女娲造人的故事"><a href="#8-1-女娲造人的故事" class="headerlink" title="8.1 女娲造人的故事"></a>8.1 女娲造人的故事</h1><p>这部分是个例子,没啥好录的</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式之禅(第2版) </category>
          
          <category> 第二部分 真刀实枪 23种设计模式完美演绎 </category>
          
          <category> 第8章 工厂方法模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>7.3 单例模式的应用</title>
      <link href="/ReadingNotes//4220861f/"/>
      <url>/ReadingNotes//4220861f/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/4220861f/#7-3-单例模式的应用" class="header_1">7.3 单例模式的应用</a>&nbsp;<br><a href="/ReadingNotes/4220861f/#7-3-1-单例模式的优点" class="header_2">7.3.1 单例模式的优点</a>&nbsp;<br><a href="/ReadingNotes/4220861f/#7-3-2-单例模式的缺点" class="header_2">7.3.2 单例模式的缺点</a>&nbsp;<br><a href="/ReadingNotes/4220861f/#7-3-3-单例模式的使用场景" class="header_2">7.3.3 单例模式的使用场景</a>&nbsp;<br><a href="/ReadingNotes/4220861f/#7-3-4-单例模式的注意事项" class="header_2">7.3.4 单例模式的注意事项</a>&nbsp;<br><a href="/ReadingNotes/4220861f/#代码清单7-4-线程不安全的-懒汉式单例" class="header_3">代码清单7-4 线程不安全的 懒汉式单例</a>&nbsp;<br><a href="/ReadingNotes/4220861f/#什么情况下对象可以被复制" class="header_2">什么情况下对象可以被复制</a>&nbsp;<br><a href="/ReadingNotes/4220861f/#如何防止单例对象被复制" class="header_2">如何防止单例对象被复制</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="7-3-单例模式的应用"><a href="#7-3-单例模式的应用" class="headerlink" title="7.3 单例模式的应用"></a>7.3 单例模式的应用</h1><h2 id="7-3-1-单例模式的优点"><a href="#7-3-1-单例模式的优点" class="headerlink" title="7.3.1 单例模式的优点"></a>7.3.1 单例模式的优点</h2><ul><li>由于单例模式在内存中只有一个实例,<strong>减少了内存开支</strong>,特别是一个对象需要频繁地创建、销毁时,而且创建或销毁时性能又无法优化,单例模式的优势就非常明显。</li><li>由于单例模式只生成一个实例,所以减少了系统的性能开销,当一个对象的产生需要比较多的资源时,如读取配置、产生其他依赖对象时,则可以通过在应用启动时直接产生一个单例对象,然后用永久驻留内存的方式来解决(在<code>Java EE</code>中采用单例模式时需要注意<code>JVM</code>垃圾回收机制)。</li><li>单例模式<code>可以避免对资源的多重占用</code>,例如一个写文件动作,由于只有一个实例存在内存中,避免对同一个资源文件的同时写操作。</li><li>单例模式可以在系统设置全局的访问点,优化和共享资源访问,例如可以设计一个单例类,负责所有数据表的映射处理。</li></ul><h2 id="7-3-2-单例模式的缺点"><a href="#7-3-2-单例模式的缺点" class="headerlink" title="7.3.2 单例模式的缺点"></a>7.3.2 单例模式的缺点</h2><ul><li>单例模式一般没有接口,<code>扩展很困难</code>,若要扩展,除了修改代码基本上没有第二种途径可以实现。单例模式为什么不能增加接口呢?因为接口对单例模式是没有任何意义的,它要求”自行实例化”,并且提供单一实例、接口或抽象类是不可能被实例化的。当然,在特殊情况下,单例模式可以实现接口、被继承等,需要在系统开发中根据环境判断。</li><li>单例模式对测试是不利的。在并行开发环境中,如果单例模式没有完成,是不能进行测试的,没有接口也不能使用<code>mock</code>的方式虚拟一个对象。</li><li>单例模式与单一职责原则有冲突。一个类应该只实现一个逻辑,而不关心它是否是单例的,是不是要单例取决于环境,单例模式把”要单例”和业务逻辑融合在一个类中。</li></ul><h2 id="7-3-3-单例模式的使用场景"><a href="#7-3-3-单例模式的使用场景" class="headerlink" title="7.3.3 单例模式的使用场景"></a>7.3.3 单例模式的使用场景</h2><p>在一个系统中,要求一个类有且仅有一个对象,如果出现多个对象就会出现”不良反应”,可以采用单例模式,具体的场景如下:</p><ol><li>要求生成唯一序列号的环境;</li><li>在整个项目中需要一个共享访问点或共享数据,例如一个<code>Web</code>页面上的计数器,可以不用把每次刷新都记录到数据库中,使用单例模式保持计数器的值,并确保是线程安全的;</li><li>创建一个对象需要消耗的资源过多,如要访问IO和数据库等资源;</li><li>需要定义大量的静态常量和静态方法(如工具类)的环境,可以采用单例模式(当然,也可以直接声明为<code>static</code>的方式)。</li></ol><h2 id="7-3-4-单例模式的注意事项"><a href="#7-3-4-单例模式的注意事项" class="headerlink" title="7.3.4 单例模式的注意事项"></a>7.3.4 单例模式的注意事项</h2><p>首先,在高并发情况下,<code>请注意单例模式的线程同步问题</code>。单例模式有几种不同的实现方式,上面的例子不会出现产生多个实例的情况,但是如代码清单7-4所示的单例模式就需要考虑线程同步。</p><h3 id="代码清单7-4-线程不安全的-懒汉式单例"><a href="#代码清单7-4-线程不安全的-懒汉式单例" class="headerlink" title="代码清单7-4 线程不安全的 懒汉式单例"></a>代码清单7-4 线程不安全的 懒汉式单例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>; </span><br><span class="line">     <span class="comment">//限制产生多个对象</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="comment">//通过该方法获得实例对象</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">             <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span> singleton;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该单例模式在低并发的情况下尚不会出现问题,若系统压力增大,并发量增加时则可能在内存中出现多个实例,破坏了最初的预期。为什么会出现这种情况呢?如一个线程A执行到<code>singleton = new Singleton()</code>,但还没有获得对象(对象初始化是需要时间的),第二个线程B也在执行,执行到(<code>singleton == null</code>)判断,那么线程B获得判断条件也是为真,于是继续运行下去,线程A获得了一个对象,线程B也获得了一个对象,在内存中就<code>出现两个对象</code>!</p><p>解决线程不安全的方法很有多,可以在<code>getSingleton</code>方法前加<code>synchronized</code>关键字,也可以在<code>getSingleton</code>方法内增加<code>synchronized</code>来实现,但都不是最优秀的单例模式,建议读者使用如代码清单7-3所示的方式(有的书上把代码清单7-3中的单例称为<code>饿汉式单例</code>,在代码清单7-4中增加了<code>synchronized</code>的单例称为<code>懒汉式单例</code>)。</p><h2 id="什么情况下对象可以被复制"><a href="#什么情况下对象可以被复制" class="headerlink" title="什么情况下对象可以被复制"></a>什么情况下对象可以被复制</h2><p>在<code>Java</code>中<strong>,对象默认是不可以被复制的</strong>,若实现了<code>Cloneable</code>接口,并实现了<code>clone</code>方法,则可以直接通过对象复制方式创建一个新对象,对象复制是不用调用类的构造函数,因此<strong>即使是私有的构造函数,对象仍然可以被复制</strong>。</p><h2 id="如何防止单例对象被复制"><a href="#如何防止单例对象被复制" class="headerlink" title="如何防止单例对象被复制"></a>如何防止单例对象被复制</h2><p><strong>单例类不要实现<code>Cloneable</code>接口</strong>。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式之禅(第2版) </category>
          
          <category> 第二部分 真刀实枪 23种设计模式完美演绎 </category>
          
          <category> 第7章 单例模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>7.2 单例模式的定义</title>
      <link href="/ReadingNotes//c2e9de52/"/>
      <url>/ReadingNotes//c2e9de52/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/c2e9de52/#7-2-单例模式的定义" class="header_1">7.2 单例模式的定义</a>&nbsp;<br><a href="/ReadingNotes/c2e9de52/#清单7-3-线程安全的-饿汉式单例" class="header_2">清单7-3 线程安全的 饿汉式单例</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="7-2-单例模式的定义"><a href="#7-2-单例模式的定义" class="headerlink" title="7.2 单例模式的定义"></a>7.2 单例模式的定义</h1><p>单例模式(<code>Singleton Pattern)是一个比较简单的模式,其定义如下:确保某一个类只有一个实例,而且</code>自行实例化`并向整个系统提供这个实例:</p><p><code>Singleton</code>类称为单例类,通过使用<code>private</code>的构造函数确保了在一个应用中只产生一个实例,并且是自行实例化的(在<code>Singleton</code>中自己使用<code>new Singleton()</code>)。<br>单例模式的通用源代码如代码清单7-3所示。</p><h2 id="清单7-3-线程安全的-饿汉式单例"><a href="#清单7-3-线程安全的-饿汉式单例" class="headerlink" title="清单7-3 线程安全的 饿汉式单例"></a>清单7-3 线程安全的 饿汉式单例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton singleton = <span class="keyword">new</span> Singleton();        </span><br><span class="line">     <span class="comment">//限制产生多个对象</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//通过该方法获得实例对象</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">             <span class="keyword">return</span> singleton;</span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="comment">//类中其他方法，尽量是static</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!--SSTStop-->]]></content>
      
      
      <categories>
          
          <category> 设计模式之禅(第2版) </category>
          
          <category> 第二部分 真刀实枪 23种设计模式完美演绎 </category>
          
          <category> 第7章 单例模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>7.1 我是皇帝我独苗</title>
      <link href="/ReadingNotes//a2282b7c/"/>
      <url>/ReadingNotes//a2282b7c/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/a2282b7c/#7-1-我是皇帝我独苗" class="header_1">7.1 我是皇帝我独苗</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="7-1-我是皇帝我独苗"><a href="#7-1-我是皇帝我独苗" class="headerlink" title="7.1 我是皇帝我独苗"></a>7.1 我是皇帝我独苗</h1>]]></content>
      
      
      <categories>
          
          <category> 设计模式之禅(第2版) </category>
          
          <category> 第二部分 真刀实枪 23种设计模式完美演绎 </category>
          
          <category> 第7章 单例模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>6.2 开闭原则的庐山真面目</title>
      <link href="/ReadingNotes//f479faa6/"/>
      <url>/ReadingNotes//f479faa6/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/f479faa6/#6-2-开闭原则的庐山真面目" class="header_1">6.2 开闭原则的庐山真面目</a>&nbsp;<br><a href="/ReadingNotes/f479faa6/#什么是软件实体" class="header_2">什么是软件实体</a>&nbsp;<br><a href="/ReadingNotes/f479faa6/#开闭原则的要求" class="header_2">开闭原则的要求</a>&nbsp;<br><a href="/ReadingNotes/f479faa6/#变化分类" class="header_2">变化分类</a>&nbsp;<br><a href="/ReadingNotes/f479faa6/#1-逻辑变化" class="header_3">1. 逻辑变化</a>&nbsp;<br><a href="/ReadingNotes/f479faa6/#2-子模块变化" class="header_3">2. 子模块变化</a>&nbsp;<br><a href="/ReadingNotes/f479faa6/#3-可见视图变化" class="header_3">3. 可见视图变化</a>&nbsp;<br><a href="/ReadingNotes/f479faa6/#项目的基本过程" class="header_2">项目的基本过程</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="6-2-开闭原则的庐山真面目"><a href="#6-2-开闭原则的庐山真面目" class="headerlink" title="6.2 开闭原则的庐山真面目"></a>6.2 开闭原则的庐山真面目</h1><p>开闭原则的定义已经非常明确地告诉我们:<code>软件实体</code>应该<code>对扩展开放</code>,<code>对修改关闭</code>,其含义是说<strong>一个软件实体应该通过扩展来实现变化,而不是通过修改已有的代码来实现变化</strong>。</p><h2 id="什么是软件实体"><a href="#什么是软件实体" class="headerlink" title="什么是软件实体"></a>什么是软件实体</h2><p>软件实体包括以下几个部分:</p><ol><li>项目或软件产品中按照一定的逻辑规则划分的模块。</li><li>抽象和类。</li><li>方法。</li></ol><h2 id="开闭原则的要求"><a href="#开闭原则的要求" class="headerlink" title="开闭原则的要求"></a>开闭原则的要求</h2><p>开闭原则告诉<strong>我们应尽量通过扩展软件实体的行为来实现变化,而不是通过修改已有的代码来完成变化</strong>,它是为软件实体的未来事件而制定的对现行开发设计进行约束的一个原则。<br>注意开闭原则对扩展开放,对修改关闭,并不意味着不做任何修改,低层模块的变更,必然要有高层模块进行耦合,否则就是一个孤立无意义的代码片段。</p><h2 id="变化分类"><a href="#变化分类" class="headerlink" title="变化分类"></a>变化分类</h2><p>我们可以把变化归纳为以下三种类型：</p><h3 id="1-逻辑变化"><a href="#1-逻辑变化" class="headerlink" title="1. 逻辑变化"></a>1. 逻辑变化</h3><p>只变化一个逻辑,而不涉及其他模块,比如原有的一个算法是<code>a*b+c</code>,现在需要修改为<code>a*b*c</code>,<strong>可以通过<code>修改原有类中的方法</code>的方式来完成</strong>,前提条件是所有依赖或关联类都按照相同的逻辑处理。</p><h3 id="2-子模块变化"><a href="#2-子模块变化" class="headerlink" title="2. 子模块变化"></a>2. 子模块变化</h3><p>一个模块变化,会对其他的模块产生影响,特别是<code>一个低层次的模块变化必然引起高层模块的变化</code>,因此在通过扩展完成变化时,高层次的模块修改是必然的。</p><h3 id="3-可见视图变化"><a href="#3-可见视图变化" class="headerlink" title="3. 可见视图变化"></a>3. 可见视图变化</h3><p>可见视图是提供给客户使用的界面,如<code>JSP</code>程序、<code>Swing</code>界面等,该部分的变化一般会引起连锁反应。</p><ul><li>如果仅仅是界面上按钮、文字的重新排布倒是简单,</li><li>最司空见惯的是业务耦合变化,什么意思呢?一个展示数据的列表,按照原有的需求是6列,突然有一天要增加1列,而且这一列要跨N张表,处理M个逻辑才能展现出来,这样的变化是比较恐怖的,但<code>还是可以通过扩展来完成变化</code>,这就要看我们原有的设计是否灵活。<h2 id="项目的基本过程"><a href="#项目的基本过程" class="headerlink" title="项目的基本过程"></a>项目的基本过程</h2>一个项目的基本过程应该是这样的:<code>项目开发</code>、<code>重构</code>、<code>测试</code>、<code>投产</code>、<code>运维</code>。其中的</li><li>重构可以对原有的设计和代码进行修改,</li><li>运维尽量减少对原有代码的修改,保持历史代码的纯洁性,提高系统的稳定性。<!--SSTStop--></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式之禅(第2版) </category>
          
          <category> 第一部分 大旗不挥 谁敢冲锋 6大设计原则全新解读 </category>
          
          <category> 第6章 开闭原则 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>6.3 为什么要采用开闭原则</title>
      <link href="/ReadingNotes//9343d0df/"/>
      <url>/ReadingNotes//9343d0df/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/9343d0df/#6-3-为什么要采用开闭原则" class="header_1">6.3 为什么要采用开闭原则</a>&nbsp;<br><a href="/ReadingNotes/9343d0df/#1-开闭原则对测试的影响" class="header_2">1. 开闭原则对测试的影响</a>&nbsp;<br><a href="/ReadingNotes/9343d0df/#通过修改实现变化的困难" class="header_3">通过修改实现变化的困难</a>&nbsp;<br><a href="/ReadingNotes/9343d0df/#2-开闭原则可以提高复用性" class="header_2">2. 开闭原则可以提高复用性</a>&nbsp;<br><a href="/ReadingNotes/9343d0df/#为什么要复用" class="header_3">为什么要复用</a>&nbsp;<br><a href="/ReadingNotes/9343d0df/#如何提高复用率" class="header_3">如何提高复用率</a>&nbsp;<br><a href="/ReadingNotes/9343d0df/#具体做法" class="header_3">具体做法</a>&nbsp;<br><a href="/ReadingNotes/9343d0df/#3-开闭原则可以提高可维护性" class="header_2">3. 开闭原则可以提高可维护性</a>&nbsp;<br><a href="/ReadingNotes/9343d0df/#4-面向对象开发的要求" class="header_2">4. 面向对象开发的要求</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="6-3-为什么要采用开闭原则"><a href="#6-3-为什么要采用开闭原则" class="headerlink" title="6.3 为什么要采用开闭原则"></a>6.3 为什么要采用开闭原则</h1><p>开闭原则是最基础的一个原则。前五个原则就指导设计的工具和方法,而开闭原则才是其精神领袖。<br>开闭原则是非常重要的,可通过以下几个方面来理解其重要性。</p><h2 id="1-开闭原则对测试的影响"><a href="#1-开闭原则对测试的影响" class="headerlink" title="1. 开闭原则对测试的影响"></a>1. 开闭原则对测试的影响</h2><h3 id="通过修改实现变化的困难"><a href="#通过修改实现变化的困难" class="headerlink" title="通过修改实现变化的困难"></a>通过修改实现变化的困难</h3><p>所有已经投产的代码都是有意义的,并且都受系统规则的约束,这样的代码都要经过”千锤百炼”的测试过程,不仅保证逻辑是正确的,还要保证苛刻条件(高压力、异常、错误)下不产生”有毒代码<code>&quot;(Poisonous Code</code>),因此有变化提出时,如果我们修改原来健壮的代码,就需要把原有的测试过程回笼一遍,需要进行单元测试、功能测试、集成测试甚至是验收测试.<br>想着通过修改一个方法或多个方法代码来完成变化,基本上就是痴人说梦,该类的所有测试方法都要重构,想象一下你在一堆你并不熟悉的代码中进行重构时的感觉吧<br>所以,我们需要<strong>通过扩展来实现业务逻辑的变化,而不是修改</strong>。</p><h2 id="2-开闭原则可以提高复用性"><a href="#2-开闭原则可以提高复用性" class="headerlink" title="2. 开闭原则可以提高复用性"></a>2. 开闭原则可以提高复用性</h2><h3 id="为什么要复用"><a href="#为什么要复用" class="headerlink" title="为什么要复用"></a>为什么要复用</h3><p>复用可以<code>减少代码量</code>,避免相同的逻辑分散在多个角落,避免日后的<code>维护人员</code>为了修改一个微小的缺陷或增加新功能而要在整个项目中到处查找相关的代码,然后发出对<code>开发人员</code>“极度失望”的感慨。</p><h3 id="如何提高复用率"><a href="#如何提高复用率" class="headerlink" title="如何提高复用率"></a>如何提高复用率</h3><p>缩小逻辑粒度,直到一个逻辑不可再拆分为止,粒度越小,被复用的可能性就越大。</p><h3 id="具体做法"><a href="#具体做法" class="headerlink" title="具体做法"></a>具体做法</h3><p><code>通过原子逻辑的组合</code>得到业务逻辑,而不是在一个类中独立实现一个业务逻辑。</p><h2 id="3-开闭原则可以提高可维护性"><a href="#3-开闭原则可以提高可维护性" class="headerlink" title="3. 开闭原则可以提高可维护性"></a>3. 开闭原则可以提高可维护性</h2><p>维护人员最乐意做的事情就是<code>扩展一个类</code>,而不是修改一个类,甭管原有的代码写得多么优秀还是多么糟糕,让维护人员读懂原有的代码,然后再修改,是一件很痛苦的事情。</p><h2 id="4-面向对象开发的要求"><a href="#4-面向对象开发的要求" class="headerlink" title="4. 面向对象开发的要求"></a>4. 面向对象开发的要求</h2><p>在设计之初考虑到所有可能变化的因素,然后留下接口。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式之禅(第2版) </category>
          
          <category> 第一部分 大旗不挥 谁敢冲锋 6大设计原则全新解读 </category>
          
          <category> 第6章 开闭原则 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>6.4 如何使用开闭原则</title>
      <link href="/ReadingNotes//a24250d9/"/>
      <url>/ReadingNotes//a24250d9/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/a24250d9/#6-4-如何使用开闭原则" class="header_1">6.4 如何使用开闭原则</a>&nbsp;<br><a href="/ReadingNotes/a24250d9/#如何把开闭原则应用到实例工作中" class="header_2">如何把开闭原则应用到实例工作中</a>&nbsp;<br><a href="/ReadingNotes/a24250d9/#1-抽象约束" class="header_3">1. 抽象约束</a>&nbsp;<br><a href="/ReadingNotes/a24250d9/#2-元数据-metadata-控制模块行为" class="header_3">2. 元数据(metadata)控制模块行为</a>&nbsp;<br><a href="/ReadingNotes/a24250d9/#什么是元数据" class="header_4">什么是元数据</a>&nbsp;<br><a href="/ReadingNotes/a24250d9/#3-制定项目章程" class="header_3">3. 制定项目章程</a>&nbsp;<br><a href="/ReadingNotes/a24250d9/#4-封装变化" class="header_3">4. 封装变化</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="6-4-如何使用开闭原则"><a href="#6-4-如何使用开闭原则" class="headerlink" title="6.4 如何使用开闭原则"></a>6.4 如何使用开闭原则</h1><p>开闭原则是一个非常虚的原则,前面5个原则是对开闭原则的具体解释。</p><h2 id="如何把开闭原则应用到实例工作中"><a href="#如何把开闭原则应用到实例工作中" class="headerlink" title="如何把开闭原则应用到实例工作中"></a>如何把开闭原则应用到实例工作中</h2><h3 id="1-抽象约束"><a href="#1-抽象约束" class="headerlink" title="1. 抽象约束"></a>1. 抽象约束</h3><p>抽象是对一组事物的通用描述,没有具体的实现,也就表示它可以有非常多的可能性,可以跟随需求的变化而变化。因此,通过接口或抽象类可以约束一组可能变化的行为,并且能够实现对扩展开放,其包含三层含义:</p><ul><li>第一,通过<code>接口或抽象类约束扩展</code>,对扩展进行边界限定,不允许出现在接口或抽象类中不存在的<code>public</code>方法;</li><li>第二,参数类型、引用对象尽量使用接口或者抽象类,而不是实现类;</li><li>第三,抽象层尽量保持稳定,一旦确定即不允许修改。</li></ul><p>要实现对扩展开放，首要的前提条件就是抽象约束。</p><h3 id="2-元数据-metadata-控制模块行为"><a href="#2-元数据-metadata-控制模块行为" class="headerlink" title="2. 元数据(metadata)控制模块行为"></a>2. 元数据(metadata)控制模块行为</h3><h4 id="什么是元数据"><a href="#什么是元数据" class="headerlink" title="什么是元数据"></a>什么是元数据</h4><p>元数据是用来描述环境和数据的数据,通俗地说就是<code>配置参数</code>,参数可以从<code>配置文件</code>中获得,也可以从数据库中获得。<br>元数据使用达到极致的就是控制反转(<code>Inversion of Control</code>),使用最多的就是<code>Spring</code>容器。</p><h3 id="3-制定项目章程"><a href="#3-制定项目章程" class="headerlink" title="3. 制定项目章程"></a>3. 制定项目章程</h3><p>在一个团队中,建立项目章程是非常重要的,因为章程中指定了所有人员都必须遵守的约定,对项目来说,<strong>约定优于配置</strong>。<br>相信大家都做过项目,会发现一个项目会产生非常多的配置文件。举个简单的例子,以<code>SSH</code>项目开发为例,一个项目中的<code>Bean</code>配置文件就非常多,管理非常麻烦。如果需要扩展,就需要增加子类,并修改<code>SpringContext</code>文件。<br>然而,如果你在项目中指定这样一个章程:<strong>所有的<code>Bean</code>都自动注入,使用<code>Annotation</code>进行装配,进行扩展时,甚至只用写一个子类,然后由持久层生成对象,其他的都不需要修改</strong>。这就需要项目内约束,每个项目成员都必须遵守,该方法需要一个团队有较高的自觉性,需要一个较长时间的磨合,一旦项目成员都熟悉这样的规则,比通过接口或抽象类进行约束效率更高,而且扩展性一点也没有减少。</p><h3 id="4-封装变化"><a href="#4-封装变化" class="headerlink" title="4. 封装变化"></a>4. 封装变化</h3><p>对变化的封装包含两层含义:</p><ul><li>第一,将相同的变化封装到一个接口或抽象类中;</li><li>第二,将不同的变化封装到不同的接口或抽象类中,不应该有两个不同的变化出现在同一个接口或抽象类中。<!--SSTStop--></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式之禅(第2版) </category>
          
          <category> 第一部分 大旗不挥 谁敢冲锋 6大设计原则全新解读 </category>
          
          <category> 第6章 开闭原则 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>6.5 最佳实践</title>
      <link href="/ReadingNotes//7de46996/"/>
      <url>/ReadingNotes//7de46996/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/7de46996/#6-5-最佳实践" class="header_1">6.5 最佳实践</a>&nbsp;<br><a href="/ReadingNotes/7de46996/#设计原则回顾" class="header_2">设计原则回顾</a>&nbsp;<br><a href="/ReadingNotes/7de46996/#使用开闭原则需要注意的问题" class="header_2">使用开闭原则需要注意的问题</a>&nbsp;<br><a href="/ReadingNotes/7de46996/#开闭原则也只是一个原则" class="header_3">开闭原则也只是一个原则</a>&nbsp;<br><a href="/ReadingNotes/7de46996/#项目规章非常重要" class="header_3">项目规章非常重要</a>&nbsp;<br><a href="/ReadingNotes/7de46996/#预知变化" class="header_3">预知变化</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="6-5-最佳实践"><a href="#6-5-最佳实践" class="headerlink" title="6.5 最佳实践"></a>6.5 最佳实践</h1><h2 id="设计原则回顾"><a href="#设计原则回顾" class="headerlink" title="设计原则回顾"></a>设计原则回顾</h2><p>我们在前5章中讲过如下设计原则</p><ul><li><code>Single Responsibility Principle</code>:单一职责原则</li><li><code>Liskov Substitution Principle</code>:里氏替换原则</li><li><code>Dependence Inversion Principle</code>:依赖倒置原则</li><li><code>Interface Segregation Principle</code>:接口隔离原则</li><li><code>Law of Demeter</code>:迪米特法则</li><li><code>Open Closed Principle</code>:开闭原则</li></ul><p>而开闭原则又是重中之重,是最基础的原则,是其他5大原则的精神领袖。</p><h2 id="使用开闭原则需要注意的问题"><a href="#使用开闭原则需要注意的问题" class="headerlink" title="使用开闭原则需要注意的问题"></a>使用开闭原则需要注意的问题</h2><h3 id="开闭原则也只是一个原则"><a href="#开闭原则也只是一个原则" class="headerlink" title="开闭原则也只是一个原则"></a>开闭原则也只是一个原则</h3><p>开闭原则只是精神口号,实现拥抱变化的方法非常多,并不局限于这6大设计原则,但是<strong>遵循这6大设计原则基本上可以应对大多数变化。因此,我们在项目中应尽量采用这6大原则,适当时候可以进行扩充</strong>,例如通过类文件替换的方式完全可以解决系统中的一些缺陷。</p><h3 id="项目规章非常重要"><a href="#项目规章非常重要" class="headerlink" title="项目规章非常重要"></a>项目规章非常重要</h3><h3 id="预知变化"><a href="#预知变化" class="headerlink" title="预知变化"></a>预知变化</h3><!--SSTStop-->]]></content>
      
      
      <categories>
          
          <category> 设计模式之禅(第2版) </category>
          
          <category> 第一部分 大旗不挥 谁敢冲锋 6大设计原则全新解读 </category>
          
          <category> 第6章 开闭原则 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5.3 最佳实践</title>
      <link href="/ReadingNotes//acee96d2/"/>
      <url>/ReadingNotes//acee96d2/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/acee96d2/#5-3-最佳实践" class="header_1">5.3 最佳实践</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="5-3-最佳实践"><a href="#5-3-最佳实践" class="headerlink" title="5.3 最佳实践"></a>5.3 最佳实践</h1><p>迪米特法则的核心观念就是<code>类间解耦</code>,<code>弱耦合</code>,只有弱耦合了以后,类的复用率才可以提高。其要求的结果就是<code>产生了大量的中转或跳转类,导致系统的复杂性提高,同时也为维护带来了难度</code>。读者在采用迪米特法则时需要反复权衡,既做到让结构清晰,又做到高内聚低耦合。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式之禅(第2版) </category>
          
          <category> 第一部分 大旗不挥 谁敢冲锋 6大设计原则全新解读 </category>
          
          <category> 第5章 迪米特法则 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>6.1 开闭原则的定义</title>
      <link href="/ReadingNotes//30451b55/"/>
      <url>/ReadingNotes//30451b55/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/30451b55/#6-1-开闭原则的定义" class="header_1">6.1 开闭原则的定义</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="6-1-开闭原则的定义"><a href="#6-1-开闭原则的定义" class="headerlink" title="6.1 开闭原则的定义"></a>6.1 开闭原则的定义</h1><p>开闭原则的定义:<br>一个软件实体如类、模块和函数应该<strong>对扩展开放,对修改关闭</strong>。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式之禅(第2版) </category>
          
          <category> 第一部分 大旗不挥 谁敢冲锋 6大设计原则全新解读 </category>
          
          <category> 第6章 开闭原则 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5.1 迪米特法则的定义</title>
      <link href="/ReadingNotes//2b18c70b/"/>
      <url>/ReadingNotes//2b18c70b/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/2b18c70b/#5-1-迪米特法则的定义" class="header_1">5.1 迪米特法则的定义</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="5-1-迪米特法则的定义"><a href="#5-1-迪米特法则的定义" class="headerlink" title="5.1 迪米特法则的定义"></a>5.1 迪米特法则的定义</h1><p>迪米特法则(<code>Law of Demeter,LoD)</code>也称<code>为最少知识原则</code>(<code>Least Knowledge Principle,LKP)</code>,虽然名字不同,但描述的是同一个规则:<strong>一个对象应该对其他对象有最少的了解</strong>。通俗地讲,一个类应该对自己需要耦合或调用的类知道得最少,你(被耦合或调用的类)的内部是如何复杂都和我没关系,那是你的事情,我就知道你提供的这么多<code>public</code>方法,我就调用这么多,其他的我一概不关心。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式之禅(第2版) </category>
          
          <category> 第一部分 大旗不挥 谁敢冲锋 6大设计原则全新解读 </category>
          
          <category> 第5章 迪米特法则 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5.2 我的知识你知道得越少越好</title>
      <link href="/ReadingNotes//43d792f3/"/>
      <url>/ReadingNotes//43d792f3/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/43d792f3/#5-2-我的知识你知道得越少越好" class="header_1">5.2 我的知识你知道得越少越好</a>&nbsp;<br><a href="/ReadingNotes/43d792f3/#1-只和朋友交流" class="header_2">1. 只和朋友交流</a>&nbsp;<br><a href="/ReadingNotes/43d792f3/#什么是朋友类" class="header_3">什么是朋友类</a>&nbsp;<br><a href="/ReadingNotes/43d792f3/#2-朋友间也是有距离的" class="header_2">2. 朋友间也是有距离的</a>&nbsp;<br><a href="/ReadingNotes/43d792f3/#3-是自己的就是自己的" class="header_2">3. 是自己的就是自己的</a>&nbsp;<br><a href="/ReadingNotes/43d792f3/#4-谨慎使用Serializable" class="header_2">4. 谨慎使用Serializable</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="5-2-我的知识你知道得越少越好"><a href="#5-2-我的知识你知道得越少越好" class="headerlink" title="5.2 我的知识你知道得越少越好"></a>5.2 我的知识你知道得越少越好</h1><p>迪米特法则对类的低耦合提出了明确的要求,其包含以下4层含义。</p><h2 id="1-只和朋友交流"><a href="#1-只和朋友交流" class="headerlink" title="1. 只和朋友交流"></a>1. 只和朋友交流</h2><p>迪米特法则还有一个英文解释是<code>:Only talk to your immediate friends</code>(只与直接的朋友通信。)</p><p>什么叫做直接的朋友呢?每个对象都必然会与其他对象有耦合关系,<strong>两个对象之间的耦合就成为朋友关系</strong>,这种关系的类型有很多,例如<strong>组合、聚合、依赖</strong>等。下面我们将举例说明如何才能做到只与直接的朋友交流。</p><h3 id="什么是朋友类"><a href="#什么是朋友类" class="headerlink" title="什么是朋友类"></a>什么是朋友类</h3><p>出现在<code>成员变量</code>、<code>方法的输入输出参数</code>中的类称为<code>成员朋友类</code>，而出现在方法体内部的类不属于朋友类。<br>迪米特法则告诉我们<code>一个类只和朋友类交流</code>。</p><p>注意<code>一个类只和朋友交流,不与陌生类交流</code>,不要出现<code>getA().getB().getC().getD()</code>这种情况(在一种极端的情况下允许出现这种访问,即每一个点号后面的返回类型都相同),<code>类与类之间的关系是建立在类间的</code>,而不是方法间,因此<code>一个方法中尽量不引入一个当前类中不存在的对象</code>,当然,<code>JDK API</code>提供的类除外。</p><h2 id="2-朋友间也是有距离的"><a href="#2-朋友间也是有距离的" class="headerlink" title="2. 朋友间也是有距离的"></a>2. 朋友间也是有距离的</h2><p>一个类公开的<code>public</code>属性或方法越多,修改时涉及的面也就越大,变更引起的风险扩散也就越大。因此,为了保持朋友类间的距离,在设计时需要反复衡量:</p><ul><li>是否还可以再减少<code>public</code>方法和属性,</li><li>是否可以修改为<code>private</code>、<code>package</code>、<code>protected</code>等访问权限,</li><li>是否可以加上<code>final</code>关键字等。</li></ul><p>注意迪米特法则要求类尽量不要对外公布太多的<code>public</code>方法和非静态的<code>public</code>变量,尽量内敛,多使用<code>private</code>、<code>package</code>、<code>protected</code>等访问权限。</p><h2 id="3-是自己的就是自己的"><a href="#3-是自己的就是自己的" class="headerlink" title="3. 是自己的就是自己的"></a>3. 是自己的就是自己的</h2><p>在实际应用中经常会出现这样<strong>一个方法放在本类中也可以,放在其他类中也没有错</strong>,那怎么去衡量呢?你可以坚持这样一个原则:<strong>如果一个方法放在本类中,既不增加类间关系,也对本类不产生负面影响,那就放置在本类中</strong>。</p><h2 id="4-谨慎使用Serializable"><a href="#4-谨慎使用Serializable" class="headerlink" title="4. 谨慎使用Serializable"></a>4. 谨慎使用Serializable</h2><!--SSTStop-->]]></content>
      
      
      <categories>
          
          <category> 设计模式之禅(第2版) </category>
          
          <category> 第一部分 大旗不挥 谁敢冲锋 6大设计原则全新解读 </category>
          
          <category> 第5章 迪米特法则 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.4 最佳实践</title>
      <link href="/ReadingNotes//674bad83/"/>
      <url>/ReadingNotes//674bad83/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/674bad83/#4-4-最佳实践" class="header_1">4.4 最佳实践</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="4-4-最佳实践"><a href="#4-4-最佳实践" class="headerlink" title="4.4 最佳实践"></a>4.4 最佳实践</h1><p>接口隔离原则是对接口的定义,同时也是对类的定义,接口和类尽量使用原子接口或原子类来组装。但是,这个原子该怎么划分是设计模式中的一大难题,在实践中可以根据以下几个规则来衡量:</p><ul><li>一个接口只服务于一个子模块或业务逻辑;</li><li>通过业务逻辑压缩接口中的<code>public</code>方法,接口时常去回顾,尽量让接口达到”满身筋骨肉”,而不是”肥嘟嘟”的一大堆方法;</li><li>已经被污染了的接口,尽量去修改,若变更的风险较大,则采用<code>适配器模式</code>进行转化处理;</li><li>了解环境,拒绝盲从。每个项目或产品都有特定的环境因素,环境不同,接口拆分的标准就不同。深入了解业务逻辑,才能设计出最好的接口。</li></ul><p>接口隔离原则和其他设计原则一样,都需要花费较多的时间和精力来进行设计和筹划,但是它带来了设计的灵活性,让你可以在业务人员提出”无理”要求时轻松应付。</p><p><strong>贯彻使用接口隔离原则最好的方法就是<code>一个接口一个方法</code></strong>,保证绝对符合接口隔离原则(有可能不符合单一职责原则),但你会采用吗?不会,除非你是疯子!那怎么才能正确地使用接口隔离原则呢?答案是<strong>根据经验和常识决定接口的粒度大小</strong>,<br>接口粒度太小,导致接口数据剧增,开发人员呛死在接口的海洋里;<br>接口粒度太大,灵活性降低,无法提供定制服务,给整体项目带来无法预料的风险。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式之禅(第2版) </category>
          
          <category> 第一部分 大旗不挥 谁敢冲锋 6大设计原则全新解读 </category>
          
          <category> 第4章 接口隔离原则 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.3 保证接口的纯洁性</title>
      <link href="/ReadingNotes//8b3424c2/"/>
      <url>/ReadingNotes//8b3424c2/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/8b3424c2/#4-3-保证接口的纯洁性" class="header_1">4.3 保证接口的纯洁性</a>&nbsp;<br><a href="/ReadingNotes/8b3424c2/#1-接口要尽量小" class="header_2">1. 接口要尽量小</a>&nbsp;<br><a href="/ReadingNotes/8b3424c2/#2-接口要高内聚" class="header_2">2. 接口要高内聚</a>&nbsp;<br><a href="/ReadingNotes/8b3424c2/#什么是高内聚" class="header_3">什么是高内聚</a>&nbsp;<br><a href="/ReadingNotes/8b3424c2/#接口如何做到高内聚" class="header_3">接口如何做到高内聚</a>&nbsp;<br><a href="/ReadingNotes/8b3424c2/#3-定制服务" class="header_2">3. 定制服务</a>&nbsp;<br><a href="/ReadingNotes/8b3424c2/#4-接口设计是有限度的" class="header_2">4. 接口设计是有限度的</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="4-3-保证接口的纯洁性"><a href="#4-3-保证接口的纯洁性" class="headerlink" title="4.3 保证接口的纯洁性"></a>4.3 保证接口的纯洁性</h1><p>接口隔离原则是对接口进行规范约束,其包含以下4层含义:</p><h2 id="1-接口要尽量小"><a href="#1-接口要尽量小" class="headerlink" title="1. 接口要尽量小"></a>1. 接口要尽量小</h2><p>这是接口隔离原则的核心定义,不出现臃肿的接口(<code>Fat Interface)</code>,这要求我们尽量拆分接口,但是”小”是有限度的。<strong>根据接口隔离原则拆分接口时,首先必须满足单一职责原则</strong>。</p><h2 id="2-接口要高内聚"><a href="#2-接口要高内聚" class="headerlink" title="2. 接口要高内聚"></a>2. 接口要高内聚</h2><h3 id="什么是高内聚"><a href="#什么是高内聚" class="headerlink" title="什么是高内聚"></a>什么是高内聚</h3><p>高内聚就是提高接口、类、模块的处理能力,减少对外的交互。</p><h3 id="接口如何做到高内聚"><a href="#接口如何做到高内聚" class="headerlink" title="接口如何做到高内聚"></a>接口如何做到高内聚</h3><p>具体到接口隔离原则就是,要求在接口中<strong>尽量少公布<code>public</code>方法</strong>,接口是对外的承诺,承诺越少对系统的开发越有利,变更的风险也就越少,同时也有利于降低成本。</p><h2 id="3-定制服务"><a href="#3-定制服务" class="headerlink" title="3. 定制服务"></a>3. 定制服务</h2><p>定制服务就是单独为一个个体提供优良的服务。我们在做系统设计时也需要考虑对系统之间或模块之间的接口采用定制服务。采用定制服务就必然有一个要求:<strong>只提供访问者需要的方法.</strong></p><h2 id="4-接口设计是有限度的"><a href="#4-接口设计是有限度的" class="headerlink" title="4. 接口设计是有限度的"></a>4. 接口设计是有限度的</h2><p>接口的设计粒度越小,系统越灵活,这是不争的事实。但是,灵活的同时也带来了结构的复杂化,开发难度增加,可维护性降低,这不是一个项目或产品所期望看到的,所以接口设计一定要注意适度,这个”度”如何来判断呢?<strong>根据经验和常识判断</strong>,没有一个固化或可测量的标准。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式之禅(第2版) </category>
          
          <category> 第一部分 大旗不挥 谁敢冲锋 6大设计原则全新解读 </category>
          
          <category> 第4章 接口隔离原则 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.1 接口隔离原则的定义</title>
      <link href="/ReadingNotes//c0f708d5/"/>
      <url>/ReadingNotes//c0f708d5/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/c0f708d5/#4-1-接口隔离原则的定义" class="header_1">4.1 接口隔离原则的定义</a>&nbsp;<br><a href="/ReadingNotes/c0f708d5/#接口分类" class="header_2">接口分类</a>&nbsp;<br><a href="/ReadingNotes/c0f708d5/#1-实例接口-Object-Interface" class="header_3">1. 实例接口(`Object Interface`)</a>&nbsp;<br><a href="/ReadingNotes/c0f708d5/#2-类接口-Class-Interface" class="header_3">2. 类接口(`Class Interface`)</a>&nbsp;<br><a href="/ReadingNotes/c0f708d5/#隔离的两个定义" class="header_2">隔离的两个定义</a>&nbsp;<br><a href="/ReadingNotes/c0f708d5/#接口隔离原则和单一职责原则的区别" class="header_2">接口隔离原则和单一职责原则的区别</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="4-1-接口隔离原则的定义"><a href="#4-1-接口隔离原则的定义" class="headerlink" title="4.1 接口隔离原则的定义"></a>4.1 接口隔离原则的定义</h1><h2 id="接口分类"><a href="#接口分类" class="headerlink" title="接口分类"></a>接口分类</h2><h3 id="1-实例接口-Object-Interface"><a href="#1-实例接口-Object-Interface" class="headerlink" title="1. 实例接口(Object Interface)"></a>1. 实例接口(<code>Object Interface</code>)</h3><p>在<code>Java</code>中声明一个类,然后用<code>new</code>关键字产生一个实例,它是对一个类型的事物的描述,这是一种接口。<br>比如你定义<code>Person</code>这个类,然后使用<code>Person zhangSan=new Person()</code>产生了一个实例,这个实例要遵从的标准就是<code>Person</code>这个类,<code>Person</code>类就是<code>zhangSan</code>的接口。从这个角度来看,<strong><code>Java</code>中的类也是一种接口</strong>。</p><h3 id="2-类接口-Class-Interface"><a href="#2-类接口-Class-Interface" class="headerlink" title="2. 类接口(Class Interface)"></a>2. 类接口(<code>Class Interface</code>)</h3><p>就是使用的<code>interface</code>关键字定义的接口。</p><h2 id="隔离的两个定义"><a href="#隔离的两个定义" class="headerlink" title="隔离的两个定义"></a>隔离的两个定义</h2><ol><li>客户端不应该依赖它不需要的接口。</li><li>类间的依赖关系应该建立在最小的接口上。</li></ol><p>通俗一点讲:<strong>接口尽量细化,同时接口中的方法尽量少</strong>。</p><h2 id="接口隔离原则和单一职责原则的区别"><a href="#接口隔离原则和单一职责原则的区别" class="headerlink" title="接口隔离原则和单一职责原则的区别"></a>接口隔离原则和单一职责原则的区别</h2><ul><li>单一职责要求的是类和接口职责单一,注重的是职责,这是业务逻辑上的划分,</li><li>而接口隔离原则要求接口的方法尽量少。</li></ul><p>例如一个接口的职责可能包含10个方法,这10个方法都放在一个接口中,并且提供给多个模块访问,这中做法</p><ul><li>按照单一职责原则是允许的,</li><li>按照接口隔离原则是不允许的,</li></ul><p>因为<code>接口隔离原则</code>要求”尽量使用多个专门的接口”。专门的接口就是指提供给每个模块的都应该是单一接口,提供给几个模块就应该有几个接口,而不是建立一个庞大的臃肿的接口,容纳所有的客户端访问。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式之禅(第2版) </category>
          
          <category> 第一部分 大旗不挥 谁敢冲锋 6大设计原则全新解读 </category>
          
          <category> 第4章 接口隔离原则 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.2 美女何其多 观点各不同</title>
      <link href="/ReadingNotes//80170aaf/"/>
      <url>/ReadingNotes//80170aaf/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/80170aaf/#4-2-美女何其多-观点各不同" class="header_1">4.2 美女何其多 观点各不同</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="4-2-美女何其多-观点各不同"><a href="#4-2-美女何其多-观点各不同" class="headerlink" title="4.2 美女何其多 观点各不同"></a>4.2 美女何其多 观点各不同</h1><p>把一个臃肿的接口变更为两个独立的接口所依赖的原则就是接口隔离原则。<br>接口是我们设计时对外提供的契约,通过分散定义多个接口,可以预防未来变更的扩散,提高系统的灵活性和可维护性。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式之禅(第2版) </category>
          
          <category> 第一部分 大旗不挥 谁敢冲锋 6大设计原则全新解读 </category>
          
          <category> 第4章 接口隔离原则 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.4 最佳实践</title>
      <link href="/ReadingNotes//9ab255f6/"/>
      <url>/ReadingNotes//9ab255f6/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/9ab255f6/#3-4-最佳实践" class="header_1">3.4 最佳实践</a>&nbsp;<br><a href="/ReadingNotes/9ab255f6/#接口-抽象类-实现类各自应该负责什么" class="header_2">接口 抽象类 实现类各自应该负责什么</a>&nbsp;<br><a href="/ReadingNotes/9ab255f6/#什么是依赖正置" class="header_2">什么是依赖正置</a>&nbsp;<br><a href="/ReadingNotes/9ab255f6/#依赖倒置" class="header_2">依赖倒置</a>&nbsp;<br><a href="/ReadingNotes/9ab255f6/#依赖倒置原则的核心" class="header_2">依赖倒置原则的核心</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="3-4-最佳实践"><a href="#3-4-最佳实践" class="headerlink" title="3.4 最佳实践"></a>3.4 最佳实践</h1><p>依赖倒置原则的本质就是通过抽象(接口或抽象类)使各个类或模块的实现彼此独立,不互相影响,实现模块间的松耦合,我们怎么在项目中使用这个规则呢?只要遵循以下的几个规则就可以:</p><ol><li><strong>每个类尽量都有接口或抽象类</strong>,或者抽象类和接口两者都具备，这是依赖倒置的基本要求,接口和抽象类都是属于抽象的,有了抽象才可能依赖倒置。</li><li>变量的<code>表面类型</code>尽量是接口或者是抽象类</li><li><strong>类尽量不要从具体类派生</strong></li><li><strong>尽量不要覆写基类的方法</strong>。如果基类是一个抽象类,而且这个方法已经实现了,子类尽量不要覆写。类间依赖的是抽象,覆写了抽象方法,对依赖的稳定性会产生一定的影响。</li><li>结合里氏替换原则使用。</li></ol><h2 id="接口-抽象类-实现类各自应该负责什么"><a href="#接口-抽象类-实现类各自应该负责什么" class="headerlink" title="接口 抽象类 实现类各自应该负责什么"></a>接口 抽象类 实现类各自应该负责什么</h2><ul><li>接口负责定义<code>public</code>属性和方法,并且声明与其他对象的依赖关系,</li><li>抽象类负责公共构造部分的实现,</li><li>实现类准确的实现业务逻辑,同时在适当的时候对父类进行细化。</li></ul><h2 id="什么是依赖正置"><a href="#什么是依赖正置" class="headerlink" title="什么是依赖正置"></a>什么是依赖正置</h2><p>依赖正置就是<strong>类间的依赖是实现类间的依赖</strong>,也就是<strong>面向实现编程</strong>,这也是正常人的思维方式,我要开奔驰车就依赖奔驰车,我要使用笔记本电脑就直接依赖笔记本电脑。</p><h2 id="依赖倒置"><a href="#依赖倒置" class="headerlink" title="依赖倒置"></a>依赖倒置</h2><p>面向接口编程。</p><h2 id="依赖倒置原则的核心"><a href="#依赖倒置原则的核心" class="headerlink" title="依赖倒置原则的核心"></a>依赖倒置原则的核心</h2><p>在项目中,<strong>大家只要记住是”面向接口编程”就基本上抓住了依赖倒置原则的核心</strong><br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式之禅(第2版) </category>
          
          <category> 第一部分 大旗不挥 谁敢冲锋 6大设计原则全新解读 </category>
          
          <category> 第3章 依赖倒置原则 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.3 依赖的三种写法</title>
      <link href="/ReadingNotes//d99f0317/"/>
      <url>/ReadingNotes//d99f0317/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/d99f0317/#3-3-依赖的三种写法" class="header_1">3.3 依赖的三种写法</a>&nbsp;<br><a href="/ReadingNotes/d99f0317/#1-构造函数传递依赖对象" class="header_2">1.构造函数传递依赖对象</a>&nbsp;<br><a href="/ReadingNotes/d99f0317/#2-Setter方法传递依赖对象" class="header_2">2.Setter方法传递依赖对象</a>&nbsp;<br><a href="/ReadingNotes/d99f0317/#3-接口声明依赖对象" class="header_2">3.接口声明依赖对象</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="3-3-依赖的三种写法"><a href="#3-3-依赖的三种写法" class="headerlink" title="3.3 依赖的三种写法"></a>3.3 依赖的三种写法</h1><p>对象的依赖关系有三种方式来传递,如下所示。</p><h2 id="1-构造函数传递依赖对象"><a href="#1-构造函数传递依赖对象" class="headerlink" title="1.构造函数传递依赖对象"></a>1.构造函数传递依赖对象</h2><p>在类中通过构造函数声明依赖对象,按照依赖注入的说法,这种方式叫做构造函数注入。</p><h2 id="2-Setter方法传递依赖对象"><a href="#2-Setter方法传递依赖对象" class="headerlink" title="2.Setter方法传递依赖对象"></a>2.Setter方法传递依赖对象</h2><p>在抽象中设置<code>Setter</code>方法声明依赖关系,依照依赖注入的说法,这是<code>Setter</code>依赖注入,按照这种方式的注入。</p><h2 id="3-接口声明依赖对象"><a href="#3-接口声明依赖对象" class="headerlink" title="3.接口声明依赖对象"></a>3.接口声明依赖对象</h2><p>在接口的方法中声明依赖对象,该方法也叫做接口注入。</p><!--SSTStop-->]]></content>
      
      
      <categories>
          
          <category> 设计模式之禅(第2版) </category>
          
          <category> 第一部分 大旗不挥 谁敢冲锋 6大设计原则全新解读 </category>
          
          <category> 第3章 依赖倒置原则 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.2 言而无信 你太需要契约</title>
      <link href="/ReadingNotes//a3a0630/"/>
      <url>/ReadingNotes//a3a0630/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/a3a0630/#3-2-言而无信，你太需要契约" class="header_1">3.2 言而无信，你太需要契约</a>&nbsp;<br><a href="/ReadingNotes/a3a0630/#依赖倒置的优点" class="header_2">依赖倒置的优点</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="3-2-言而无信，你太需要契约"><a href="#3-2-言而无信，你太需要契约" class="headerlink" title="3.2 言而无信，你太需要契约"></a>3.2 言而无信，你太需要契约</h1><h2 id="依赖倒置的优点"><a href="#依赖倒置的优点" class="headerlink" title="依赖倒置的优点"></a>依赖倒置的优点</h2><p>采用依赖倒置原则可以减少类间的耦合性,提高系统的稳定性,降低并行开发引起的风险,提高代码的可读性和可维护性。</p><p>接口只是一个抽象化的概念，是对一类事物的最抽象描述，具体的实现代码由相应的实现类来完成<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式之禅(第2版) </category>
          
          <category> 第一部分 大旗不挥 谁敢冲锋 6大设计原则全新解读 </category>
          
          <category> 第3章 依赖倒置原则 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.1 依赖倒置原则的定义</title>
      <link href="/ReadingNotes//493b2419/"/>
      <url>/ReadingNotes//493b2419/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/493b2419/#第3章-依赖倒置原则" class="header_1">第3章 依赖倒置原则</a>&nbsp;<br><a href="/ReadingNotes/493b2419/#依赖倒置原则的定义" class="header_2">依赖倒置原则的定义</a>&nbsp;<br><a href="/ReadingNotes/493b2419/#什么是低层模块" class="header_2">什么是低层模块</a>&nbsp;<br><a href="/ReadingNotes/493b2419/#什么是高层模块" class="header_2">什么是高层模块</a>&nbsp;<br><a href="/ReadingNotes/493b2419/#抽象" class="header_2">抽象</a>&nbsp;<br><a href="/ReadingNotes/493b2419/#细节" class="header_2">细节</a>&nbsp;<br><a href="/ReadingNotes/493b2419/#依赖倒置原则在Java语言中的表现" class="header_2">依赖倒置原则在Java语言中的表现</a>&nbsp;<br><a href="/ReadingNotes/493b2419/#精简定义" class="header_3">精简定义</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="第3章-依赖倒置原则"><a href="#第3章-依赖倒置原则" class="headerlink" title="第3章 依赖倒置原则"></a>第3章 依赖倒置原则</h1><p>依赖倒置原则(<code>Dependence Inversion Principle,DIP</code>)</p><h2 id="依赖倒置原则的定义"><a href="#依赖倒置原则的定义" class="headerlink" title="依赖倒置原则的定义"></a>依赖倒置原则的定义</h2><ul><li>高层模块不应该依赖低层模块，两者都应该依赖其抽象；</li><li>抽象不应该依赖细节；</li><li>细节应该依赖抽象。</li></ul><h2 id="什么是低层模块"><a href="#什么是低层模块" class="headerlink" title="什么是低层模块"></a>什么是低层模块</h2><p>每一个逻辑的实现都是由原子逻辑组成的，不可分割的原子逻辑就是低层模块</p><h2 id="什么是高层模块"><a href="#什么是高层模块" class="headerlink" title="什么是高层模块"></a>什么是高层模块</h2><p>原子逻辑的再组装就是高层模块。</p><h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p>在<code>Java</code>语言中,<strong>抽象就是指接口或抽象类</strong>,两者都是不能直接被实例化的;</p><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p><strong>细节就是实现类</strong>,实现接口或继承抽象类而产生的类就是细节,其特点就是可以直接被实例化,也就是可以加上一个关键字<code>new</code>产生一个对象。</p><h2 id="依赖倒置原则在Java语言中的表现"><a href="#依赖倒置原则在Java语言中的表现" class="headerlink" title="依赖倒置原则在Java语言中的表现"></a>依赖倒置原则在Java语言中的表现</h2><ul><li>模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，<strong>其依赖关系是通过接口或抽象类产生的</strong>；</li><li>接口或抽象类不依赖于实现类；</li><li>实现类依赖接口或抽象类。</li></ul><h3 id="精简定义"><a href="#精简定义" class="headerlink" title="精简定义"></a>精简定义</h3><p>更加精简的定义就是<code>&quot;面向接口编程&quot;</code>,<code>面向接口编程</code>是<code>OOD</code>(<code>Object-Oriented Design</code>,面向对象设计)的精髓之一。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式之禅(第2版) </category>
          
          <category> 第一部分 大旗不挥 谁敢冲锋 6大设计原则全新解读 </category>
          
          <category> 第3章 依赖倒置原则 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2.3 最佳实践</title>
      <link href="/ReadingNotes//51176ea7/"/>
      <url>/ReadingNotes//51176ea7/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/51176ea7/#2-3-最佳实践" class="header_1">2.3 最佳实践</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="2-3-最佳实践"><a href="#2-3-最佳实践" class="headerlink" title="2.3 最佳实践"></a>2.3 最佳实践</h1><p>在项目中,采用里氏替换原则时,尽量避免子类的”个性”,一旦子类有”个性”,这个子类和父类之间的关系就很难调和了,把子类当做父类使用,子类的”个性”被抹杀——委屈了点;把子类单独作为一个业务来使用,则会让代码间的耦合关系变得扑朔迷离——缺乏类替换的标准<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式之禅(第2版) </category>
          
          <category> 第一部分 大旗不挥 谁敢冲锋 6大设计原则全新解读 </category>
          
          <category> 第2章 里氏替换原则 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2.2 纠纷不断 规则压制</title>
      <link href="/ReadingNotes//53a72729/"/>
      <url>/ReadingNotes//53a72729/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/53a72729/#2-2-纠纷不断-规则压制" class="header_1">2.2 纠纷不断 规则压制</a>&nbsp;<br><a href="/ReadingNotes/53a72729/#1-子类必须完全实现父类的方法" class="header_2">1. 子类必须完全实现父类的方法</a>&nbsp;<br><a href="/ReadingNotes/53a72729/#2-子类可以有自己的个性" class="header_2">2.子类可以有自己的个性</a>&nbsp;<br><a href="/ReadingNotes/53a72729/#3-覆盖或实现父类的方法时输入参数可以被放大" class="header_2">3.覆盖或实现父类的方法时输入参数可以被放大</a>&nbsp;<br><a href="/ReadingNotes/53a72729/#4-覆写或实现父类的方法时输出结果可以被缩小" class="header_2">4.覆写或实现父类的方法时输出结果可以被缩小</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="2-2-纠纷不断-规则压制"><a href="#2-2-纠纷不断-规则压制" class="headerlink" title="2.2 纠纷不断 规则压制"></a>2.2 纠纷不断 规则压制</h1><p>里氏替换原则为良好的继承定义了一个规范,一句简单的定义包含了4层含义。</p><h2 id="1-子类必须完全实现父类的方法"><a href="#1-子类必须完全实现父类的方法" class="headerlink" title="1. 子类必须完全实现父类的方法"></a>1. 子类必须完全实现父类的方法</h2><p>注意:在类中调用其他类时务必要使用父类或接口,如果不能使用父类或接口,则说明类的设计已经违背了<code>LSP</code>原则。<br>注意:如果子类不能完整地实现父类的方法,或者父类的某些方法在子类中已经发生”畸变”,则建议断开父子继承关系,采用依赖、聚集、组合等关系代替继承。</p><h2 id="2-子类可以有自己的个性"><a href="#2-子类可以有自己的个性" class="headerlink" title="2.子类可以有自己的个性"></a>2.子类可以有自己的个性</h2><h2 id="3-覆盖或实现父类的方法时输入参数可以被放大"><a href="#3-覆盖或实现父类的方法时输入参数可以被放大" class="headerlink" title="3.覆盖或实现父类的方法时输入参数可以被放大"></a>3.覆盖或实现父类的方法时输入参数可以被放大</h2><p>子类中方法的前置条件必须与超类中被覆写的方法的前置条件相同或者更宽松。</p><h2 id="4-覆写或实现父类的方法时输出结果可以被缩小"><a href="#4-覆写或实现父类的方法时输出结果可以被缩小" class="headerlink" title="4.覆写或实现父类的方法时输出结果可以被缩小"></a>4.覆写或实现父类的方法时输出结果可以被缩小</h2><!--SSTStop-->]]></content>
      
      
      <categories>
          
          <category> 设计模式之禅(第2版) </category>
          
          <category> 第一部分 大旗不挥 谁敢冲锋 6大设计原则全新解读 </category>
          
          <category> 第2章 里氏替换原则 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2.1 爱恨纠葛的父子关系</title>
      <link href="/ReadingNotes//73b5386c/"/>
      <url>/ReadingNotes//73b5386c/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/73b5386c/#第2章-里氏替换原则-2-1-爱恨纠葛的父子关系" class="header_1">第2章 里氏替换原则 2.1 爱恨纠葛的父子关系</a>&nbsp;<br><a href="/ReadingNotes/73b5386c/#继承的优点" class="header_2">继承的优点</a>&nbsp;<br><a href="/ReadingNotes/73b5386c/#继承的缺点" class="header_2">继承的缺点</a>&nbsp;<br><a href="/ReadingNotes/73b5386c/#什么是里氏替换原则" class="header_2">什么是里氏替换原则</a>&nbsp;<br><a href="/ReadingNotes/73b5386c/#里氏替换原则定义" class="header_2">里氏替换原则定义</a>&nbsp;<br><a href="/ReadingNotes/73b5386c/#第1中定义" class="header_3">第1中定义</a>&nbsp;<br><a href="/ReadingNotes/73b5386c/#第2中定义" class="header_3">第2中定义</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="第2章-里氏替换原则-2-1-爱恨纠葛的父子关系"><a href="#第2章-里氏替换原则-2-1-爱恨纠葛的父子关系" class="headerlink" title="第2章 里氏替换原则 2.1 爱恨纠葛的父子关系"></a>第2章 里氏替换原则 2.1 爱恨纠葛的父子关系</h1><h2 id="继承的优点"><a href="#继承的优点" class="headerlink" title="继承的优点"></a>继承的优点</h2><p>在面向对象的语言中，继承是必不可少的、非常优秀的语言机制，它有如下优点：</p><ul><li><code>代码共享</code>,减少创建类的工作量,每个子类都拥有父类的方法和属性;</li><li><code>提高代码的重用性</code>;</li><li>子类可以形似父类,但又异于父类,”龙生龙,凤生凤,老鼠生来会打洞”是说子拥有父的”种”,”世界上没有两片完全相同的叶子”是指明子与父的不同;</li><li><code>提高代码的可扩展性</code>,实现父类的方法就可以”为所欲为”了,君不见很多开源框架扩展接口都是通过继承父类来完成的;</li><li>提高产品或项目的开放性。</li></ul><h2 id="继承的缺点"><a href="#继承的缺点" class="headerlink" title="继承的缺点"></a>继承的缺点</h2><ul><li>继承是侵入性的。<strong>只要继承，就必须拥有父类的所有属性和方法</strong>；</li><li>降低代码的灵活性。<strong>子类必须拥有父类的属性和方法</strong>，让子类自由的世界中多了些约束；</li><li>增强了耦合性。<strong>当父类的常量、变量和方法被修改时,需要考虑子类的修改</strong>,而且在缺乏规范的环境下,这种修改可能带来非常糟糕的结果——大段的代码需要重构。</li></ul><h2 id="什么是里氏替换原则"><a href="#什么是里氏替换原则" class="headerlink" title="什么是里氏替换原则"></a>什么是里氏替换原则</h2><p>里氏替换原则(<code>Liskov Substitution Principle,LSP</code>)。</p><h2 id="里氏替换原则定义"><a href="#里氏替换原则定义" class="headerlink" title="里氏替换原则定义"></a>里氏替换原则定义</h2><h3 id="第1中定义"><a href="#第1中定义" class="headerlink" title="第1中定义"></a>第1中定义</h3><p>如果对每一个类型为S的对象o1,都有类型为T的对象o2,使得以T定义的所有程序P在所有的对象o1都代换成o2时,程序P的行为没有发生变化,那么类型S是类型T的子类型。</p><h3 id="第2中定义"><a href="#第2中定义" class="headerlink" title="第2中定义"></a>第2中定义</h3><p><strong>所有引用基类的地方必须能透明地使用其子类的对象</strong>。</p><p>第二个定义是最清晰明确的,通俗点讲,<strong>只要父类能出现的地方子类就可以出现,而且替换为子类也不会产生任何错误或异常,使用者可能根本就不需要知道是父类还是子类</strong>。但是,反过来就不行了,有子类出现的地方,父类未必就能适应。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式之禅(第2版) </category>
          
          <category> 第一部分 大旗不挥 谁敢冲锋 6大设计原则全新解读 </category>
          
          <category> 第2章 里氏替换原则 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.4 最佳实践</title>
      <link href="/ReadingNotes//1d127095/"/>
      <url>/ReadingNotes//1d127095/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/1d127095/#1-4-最佳实践" class="header_1">1.4 最佳实践</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="1-4-最佳实践"><a href="#1-4-最佳实践" class="headerlink" title="1.4 最佳实践"></a>1.4 最佳实践</h1><p>对于单一职责原则,我的建议是<strong>接口一定要做到单一职责</strong>,<strong>类的设计尽量做到只有一个原因引起变化</strong>。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式之禅(第2版) </category>
          
          <category> 第一部分 大旗不挥 谁敢冲锋 6大设计原则全新解读 </category>
          
          <category> 第1章 单一职责原则 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.3 我单纯 所以我快乐</title>
      <link href="/ReadingNotes//28161de8/"/>
      <url>/ReadingNotes//28161de8/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/28161de8/#1-3-我单纯-所以我快乐" class="header_1">1.3 我单纯 所以我快乐</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="1-3-我单纯-所以我快乐"><a href="#1-3-我单纯-所以我快乐" class="headerlink" title="1.3 我单纯 所以我快乐"></a>1.3 我单纯 所以我快乐</h1><!--SSTStart--><p><strong>单一职责适用于接口、类,同时也适用于方法</strong>,什么意思呢?<strong>一个方法尽可能做一件事情</strong>,比如一个方法修改用户密码,不要把这个方法放到”修改用户信息”方法中。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式之禅(第2版) </category>
          
          <category> 第一部分 大旗不挥 谁敢冲锋 6大设计原则全新解读 </category>
          
          <category> 第1章 单一职责原则 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.2 绝杀技 打破你的传统思维</title>
      <link href="/ReadingNotes//5116627/"/>
      <url>/ReadingNotes//5116627/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/5116627/#单一职责的好处" class="header_1">单一职责的好处</a>&nbsp;<br><a href="/ReadingNotes/5116627/#使用单一职责的困难" class="header_1">使用单一职责的困难</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="单一职责的好处"><a href="#单一职责的好处" class="headerlink" title="单一职责的好处"></a>单一职责的好处</h1><ul><li>类的复杂性降低，实现什么职责都有清晰明确的定义；</li><li>可读性提高，复杂性降低，那当然可读性提高了；</li><li>可维护性提高，可读性提高，那当然更容易维护了；</li><li>变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。</li></ul><h1 id="使用单一职责的困难"><a href="#使用单一职责的困难" class="headerlink" title="使用单一职责的困难"></a>使用单一职责的困难</h1><p>单一职责原则最难划分的就是职责,一个职责一个接口。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式之禅(第2版) </category>
          
          <category> 第一部分 大旗不挥 谁敢冲锋 6大设计原则全新解读 </category>
          
          <category> 第1章 单一职责原则 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.1 我是牛类 我可以担任多职吗</title>
      <link href="/ReadingNotes//31f94edd/"/>
      <url>/ReadingNotes//31f94edd/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/31f94edd/#什么是单一职责原则" class="header_1">什么是单一职责原则</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="什么是单一职责原则"><a href="#什么是单一职责原则" class="headerlink" title="什么是单一职责原则"></a>什么是单一职责原则</h1><p>单一职责原则的英文名称是<code>Single Responsibility Principle</code>,简称是<code>SRP</code>，单一职责原则的定义是:<strong>应该有且仅有一个原因引起类的变更</strong>。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式之禅(第2版) </category>
          
          <category> 第一部分 大旗不挥 谁敢冲锋 6大设计原则全新解读 </category>
          
          <category> 第1章 单一职责原则 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之禅(第2版) 前言</title>
      <link href="/ReadingNotes//5784bd5f/"/>
      <url>/ReadingNotes//5784bd5f/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/5784bd5f/#设计模式之禅-第2版-前言" class="header_1">设计模式之禅(第2版) 前言</a>&nbsp;<br><a href="/ReadingNotes/5784bd5f/#设计模式是什么" class="header_2">设计模式是什么</a>&nbsp;<br><a href="/ReadingNotes/5784bd5f/#第2版与第1版的区别" class="header_2">第2版与第1版的区别</a>&nbsp;<br><a href="/ReadingNotes/5784bd5f/#本书的特色" class="header_2">本书的特色</a>&nbsp;<br><a href="/ReadingNotes/5784bd5f/#如何阅读本书" class="header_2">如何阅读本书</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="设计模式之禅-第2版-前言"><a href="#设计模式之禅-第2版-前言" class="headerlink" title="设计模式之禅(第2版) 前言"></a>设计模式之禅(第2版) 前言</h1><h2 id="设计模式是什么"><a href="#设计模式是什么" class="headerlink" title="设计模式是什么"></a>设计模式是什么</h2><p>设计模式是一套理论，是由软件界的先辈们总结出的<strong>一套可以反复使用的经验</strong>，它可以提高代码的可重用性，增强系统的可维护性，以及解决一系列的复杂问题。</p><h2 id="第2版与第1版的区别"><a href="#第2版与第1版的区别" class="headerlink" title="第2版与第1版的区别"></a>第2版与第1版的区别</h2><p>第2版第38章中新增了4种新的设计模式：<code>对象池模式</code>、<code>雇工模式</code>、<code>黑板模式</code>、<code>空指针模式</code>。</p><h2 id="本书的特色"><a href="#本书的特色" class="headerlink" title="本书的特色"></a>本书的特色</h2><p>每个设计模式讲解完毕之后,我都附加了两个非常精华的部分:设计模式扩展和最佳实践。<br>本书还有设计模式PK和混编设计模式两部分内容教你如何自如地去运用这些设计模式</p><h2 id="如何阅读本书"><a href="#如何阅读本书" class="headerlink" title="如何阅读本书"></a>如何阅读本书</h2><p>本书中所有的例子都是用<code>Java</code>语言来实现的。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式之禅(第2版) </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.6 设计模式怎样解决设计问题</title>
      <link href="/ReadingNotes//35722a76/"/>
      <url>/ReadingNotes//35722a76/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/35722a76/#1-6-设计模式怎样解决设计问题" class="header_1">1.6 设计模式怎样解决设计问题</a>&nbsp;<br><a href="/ReadingNotes/35722a76/#1-6-1-寻找合适的对象" class="header_1">1.6.1 寻找合适的对象</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="1-6-设计模式怎样解决设计问题"><a href="#1-6-设计模式怎样解决设计问题" class="headerlink" title="1.6 设计模式怎样解决设计问题"></a>1.6 设计模式怎样解决设计问题</h1><p>设计模式采用多种方法解决面向对象设计者经常碰到的问题。这里给出几个问题以及使用设计模式解决它们的方法。</p><h1 id="1-6-1-寻找合适的对象"><a href="#1-6-1-寻找合适的对象" class="headerlink" title="1.6.1 寻找合适的对象"></a>1.6.1 寻找合适的对象</h1><p>面向对象程序由对象组成,<code>对象</code>包括<code>数据</code>和<code>对数据进行操作的过程</code>,过程通常称为方法或操作。对象在收到客户的请求(或消息)后,执行相应的操作。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 可复用面向对象软件的基础 </category>
          
          <category> 第1章 引言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.5 组织编目</title>
      <link href="/ReadingNotes//346efbd8/"/>
      <url>/ReadingNotes//346efbd8/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/346efbd8/#1-5-组织编目" class="header_1">1.5 组织编目</a>&nbsp;<br><a href="/ReadingNotes/346efbd8/#设计模式的分类" class="header_2">设计模式的分类</a>&nbsp;<br><a href="/ReadingNotes/346efbd8/#设计模式分类的准则" class="header_2">设计模式分类的准则</a>&nbsp;<br><a href="/ReadingNotes/346efbd8/#根据目的分类" class="header_3">根据目的分类</a>&nbsp;<br><a href="/ReadingNotes/346efbd8/#根据范围分类" class="header_3">根据范围分类</a>&nbsp;<br><a href="/ReadingNotes/346efbd8/#组织模式方式" class="header_2">组织模式方式</a>&nbsp;<br><a href="/ReadingNotes/346efbd8/#其他组织模式的方法" class="header_2">其他组织模式的方法</a>&nbsp;<br><a href="/ReadingNotes/346efbd8/#设计模式之间的关系" class="header_2">设计模式之间的关系</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="1-5-组织编目"><a href="#1-5-组织编目" class="headerlink" title="1.5 组织编目"></a>1.5 组织编目</h1><p>设计模式在粒度和抽象层次上各不相同。由于存在众多的设计模式,我们希望用一种式将它们组织起来。这一节将对设计模式进行分类以便于我们对各族相关的模式进行引用。<code>分类有助于更快地学习目录中的模式</code>,且对发现新的模式也有指导作用。</p><h2 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h2><div class="table-container"><table><thead><tr><th style="text-align:left">范围</th><th style="text-align:left">创建型</th><th style="text-align:left">结构型</th><th style="text-align:left">行为型</th></tr></thead><tbody><tr><td style="text-align:left">用于类</td><td style="text-align:left"><code>Factory Method(3.3)</code></td><td style="text-align:left"><code>Adapter(类)(4.1)</code></td><td style="text-align:left"><code>Interpreter(5.3)</code>、<code>Template Method(5.10)</code></td></tr><tr><td style="text-align:left">用于对象</td><td style="text-align:left"><code>Abstract Factory (3.1)</code>、<code>Builder(3.2)</code>、<code>Prototype(3.4)</code>、<code>Singleton (3.5)</code></td><td style="text-align:left"><code>Adapter(对象)(4.1)</code>、<code>Bridge(4.2)</code>、<code>Composite(4.3)</code>、<code>Decorator(4.4)</code>、<code>Facade(4.5)</code>、<code>Flyweight(4.6)</code>、<code>Proxy (4.7)</code></td><td style="text-align:left"><code>Chain of Responsibility(5.1)</code>、<code>Command(5.2)</code>、<code>Iterator(5.4)</code>、<code>Iterator(5.4)</code>、<code>Mediator(5.5)</code>、<code>Memento(5.6)</code>、<code>Observer(5.7)</code>、<code>State(5.8)</code>、<code>Strategy(5.9)</code>、<code>Visitor(5.10)</code></td></tr></tbody></table></div><h2 id="设计模式分类的准则"><a href="#设计模式分类的准则" class="headerlink" title="设计模式分类的准则"></a>设计模式分类的准则</h2><p>我们根据两条准则对模式进行分类。</p><h3 id="根据目的分类"><a href="#根据目的分类" class="headerlink" title="根据目的分类"></a>根据目的分类</h3><p>第一是<code>目的</code>准则,即模式是用来完成什么工作的。模式依据其目的可分为:</p><ol><li>创建型(<code>Creational</code>)、</li><li>结构型(<code>Structural</code>)、</li><li>行为型(<code>Behavioral</code>)、</li></ol><p>这三种。</p><ul><li>创建型模式<code>与对象的创建有关</code>;</li><li>结构型模式<code>处理类或对象的组合</code>;</li><li>行为型模式<code>对类或对象怎样交互和怎样分配职责进行描述</code>。</li></ul><h3 id="根据范围分类"><a href="#根据范围分类" class="headerlink" title="根据范围分类"></a>根据范围分类</h3><p>第二是范围准则,指定模式主要是<code>用于类</code>还是<code>用于对象</code>。</p><ul><li>类模式<strong>处理类和子类之间的关系</strong>,这些关系通过继承建立,是静态的,在编译时刻便确定下来了。</li><li>对象模式<strong>处理对象间的关系</strong>,这些关系在运行时刻是可以变化的,更具动态性。</li></ul><p>从某种意义上来说,几乎所有模式都使用继承机制,所以”类模式”只指那些集中于处理类间关系的模式,而大部分模式都属于对象模式的范畴。</p><h2 id="组织模式方式"><a href="#组织模式方式" class="headerlink" title="组织模式方式"></a>组织模式方式</h2><ul><li><code>创建型 类模式</code>将对象的部分创建工作<code>延迟到子类</code>,而<code>创建型 对象模式</code>则将它<code>延迟</code>到另个对象中。</li><li><code>结构型 类模式</code>使用继承机制来组合类,而<code>结构型 对象模式</code>则描述了对象的组装方式。</li><li><code>行为型 类模式</code>使用继承描述算法和控制流,而<code>行为型 对象模式</code>则描述一组对象怎样协作完成单个对象所无法完成的任务。</li></ul><h2 id="其他组织模式的方法"><a href="#其他组织模式的方法" class="headerlink" title="其他组织模式的方法"></a>其他组织模式的方法</h2><p>有些模式经常会被绑在一起使用,例如, <code>Composite</code>常和<code>Iterator</code>或<code>Visitor</code>一起使用;<br>有些模式是可替代的,例如, <code>Prototype</code>常用来替代<code>AbstractFactory</code>;<br>有些模式尽管使用意图不同,但产生的设计结果是很相似的,例如, <code>Composite</code>和<code>Decorator</code>的结构图是相似的。<br><!--SSTStop--></p><h2 id="设计模式之间的关系"><a href="#设计模式之间的关系" class="headerlink" title="设计模式之间的关系"></a>设计模式之间的关系</h2><p>还有一种方式是根据模式的”相关模式”部分所描述的它们怎样互相引用来组织设计模式。图1-1给出了模式关系的图形说明。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/SheJiMoShiKeFuYongMianXiangDuiXiangRuanJianDeJiChu/ch1/2.png" alt="这里有一张图片"><br>显然,存在着许多组织设计模式的方法。从多角度去思考模式有助于对它们的功能、差异和应用场合的更深入理解。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 可复用面向对象软件的基础 </category>
          
          <category> 第1章 引言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.4 设计模式的编目</title>
      <link href="/ReadingNotes//20eb0841/"/>
      <url>/ReadingNotes//20eb0841/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/20eb0841/#1-4-设计模式的编目" class="header_1">1.4 设计模式的编目</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="1-4-设计模式的编目"><a href="#1-4-设计模式的编目" class="headerlink" title="1.4 设计模式的编目"></a>1.4 设计模式的编目</h1><p>从第3章开始的模式目录中共包含23个设计模式。它们的名字和意图列举如下,以使你有个基本了解。每个模式名后括号中标出模式所在的章节我们整本书都将遵从这个约定)</p><ol><li><code>AbstractFactory(3.1)</code>:提供一个创建一系列相关或相互依赖对象的接口,而无需指定它们具体的类。</li><li><code>FactoryMethod(3.3)</code>:定义一个用于创建对象的接口,让子类决定将哪一个类实例化。<code>Factory Method</code>使一个类的实例化延迟到其子类。</li><li><code>Adapter(4.1)</code>:将一个类的接口转换成客户希望的另外一个接口。 <code>Adapter</code>模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</li><li><code>Bridge(4.2)</code>:将抽象部分与它的实现部分分离,使它们都可以独立地变化。</li><li><code>Builder(3.2)</code>:将一个复杂对象的构建与它的表示分离,使得同样的构建过程可以创建不同的表示。</li><li><code>Chain of Responsibility(5.1)</code>:为解除请求的发送者和接收者之间耦合,而使多个对象都有机会处理这个请求。将这些对象连成一条链,并沿着这条链传递该请求,直到有一个对象处理它。</li><li><code>Command(5.2)</code>:将一个请求封装为一个对象,从而使你可用不同的请求对客户进行参数化;对请求排队或记录请求日志,以及支持可取消的操作。</li><li><code>Composite(4.3)</code>:将对象组合成树形结构以表示”部分整体”的层次结构。 <code>Composite</code>使得客户对单个对象和复合对象的使用具有一致性。</li><li><code>Decorator(4.4)</code>:动态地给一个对象添加一些额外的职责。就扩展功能而言, <code>Decorator</code>模式比生成子类方式更为灵活。</li><li><code>Facade(4.5)</code>:为子系统中的一组接口提供一个一致的界面, <code>Facade</code>模式定义了一个高层接口,这个接口使得这一子系统更加容易使用。</li><li><code>Flyweight(4.6)</code>:运用共享技术有效地支持大量细粒度的对象。</li><li><code>Interpreter(5.3)</code>:给定一个语言,定义它的文法的一种表示,并定义一个解释器,该解释器使用该表示来解释语言中的句子。</li><li><code>Iterator(5.4)</code>:提供一种方法顺序访问一个聚合对象中各个元素,而又不需暴露该对象的内部表示。</li><li><code>Mediator(5.5)</code>:用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用,从而使其耦合松散,而且可以独立地改变它们之间的交互。</li><li><code>Memento(5.6)</code>:在不破坏封装性的前提下,捕获一个对象的内部状态,并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。</li><li><code>Observer(5.7)</code>:定义对象间的一种一对多的依赖关系,以便<strong>当一个对象的状态发生改变时,所有依赖于它的对象都得到通知并自动刷新</strong>。</li><li><code>Prototype(3.4)</code>:用原型实例指定创建对象的种类,并且通过拷贝这个原型来创建新的对象。</li><li><code>Proxy(4.7)</code>:为其他对象提供一个代理以控制对这个对象的访问。</li><li><code>Singleton(3.5)</code>:保证一个类仅有一个实例,并提供一个访问它的全局访问点。</li><li><code>State(5.8)</code>:允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。</li><li><code>Strategy(5.9)</code>:定义一系列的算法把它们一个个封装起来,并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户。</li><li><code>TemplateMethod(5.10)</code>:定义一个操作中的算法的骨架,而将一些步骤延迟到子类中。<code>TemplateMethod</code>使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤.。</li><li><code>Visitor(5.11)</code>:表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 可复用面向对象软件的基础 </category>
          
          <category> 第1章 引言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.3 描述设计模式</title>
      <link href="/ReadingNotes//1735c479/"/>
      <url>/ReadingNotes//1735c479/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/1735c479/#1-3-描述设计模式" class="header_1">1.3 描述设计模式</a>&nbsp;<br><a href="/ReadingNotes/1735c479/#设计模式的格式" class="header_2">设计模式的格式</a>&nbsp;<br><a href="/ReadingNotes/1735c479/#模式名和分类" class="header_3">模式名和分类</a>&nbsp;<br><a href="/ReadingNotes/1735c479/#意图" class="header_3">意图</a>&nbsp;<br><a href="/ReadingNotes/1735c479/#别名" class="header_3">别名</a>&nbsp;<br><a href="/ReadingNotes/1735c479/#动机" class="header_3">动机</a>&nbsp;<br><a href="/ReadingNotes/1735c479/#适用性" class="header_3">适用性</a>&nbsp;<br><a href="/ReadingNotes/1735c479/#结构" class="header_3">结构</a>&nbsp;<br><a href="/ReadingNotes/1735c479/#参与者" class="header_3">参与者</a>&nbsp;<br><a href="/ReadingNotes/1735c479/#协作" class="header_3">协作</a>&nbsp;<br><a href="/ReadingNotes/1735c479/#效果" class="header_3">效果</a>&nbsp;<br><a href="/ReadingNotes/1735c479/#实现" class="header_3">实现</a>&nbsp;<br><a href="/ReadingNotes/1735c479/#代码示例" class="header_3">代码示例</a>&nbsp;<br><a href="/ReadingNotes/1735c479/#相关模式" class="header_3">相关模式</a>&nbsp;<br><a href="/ReadingNotes/1735c479/#附录" class="header_2">附录</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="1-3-描述设计模式"><a href="#1-3-描述设计模式" class="headerlink" title="1.3 描述设计模式"></a>1.3 描述设计模式</h1><p>我们怎样描述设计模式呢?图形符号虽然很重要也很有用,却还远远不够,它们只是将设计过程的结果简单记录为类和对象之间的关系。为了达到设计复用,我们必须同时记录设计产生的决定过程、选择过程和权衡过程。具体的例子也是很重要的,它们让你看到实际的设计。</p><h2 id="设计模式的格式"><a href="#设计模式的格式" class="headerlink" title="设计模式的格式"></a>设计模式的格式</h2><p>我们将用统一的格式描述设计模式,每一个模式根据以下的模板被分成若干部分。模板具有统一的信息描述结构,有助于你更容易地学习、比较和使用设计模式。</p><h3 id="模式名和分类"><a href="#模式名和分类" class="headerlink" title="模式名和分类"></a>模式名和分类</h3><p>模式名简洁地描述了模式的本质。一个好的名字非常重要,因为它将成为你的设计词汇表中的一部分。模式的分类反映了我们将在1.5节介绍的方案。</p><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>是回答下列问题的简单陈述:</p><ol><li>该设计模式是做什么的?</li><li>它的基本原理和意图是什么?</li><li>它解决的是什么样的特定设计问题?</li></ol><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>模式的其他名称。</p><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>用以说明一个设计问题以及如何用模式中的类、对象来解决该问题的特定情景。该情景会帮助你理解随后对模式更抽象的描述。</p><h3 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h3><ol><li>什么情况下可以使用该设计模式?</li><li>该模式可用来改进哪些不良设计?</li><li>你怎样识别这些情况?</li></ol><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>采用<strong>基于对象建模技术</strong><code>(OMT)[RBP+91]</code>的表示法对模式中的类进行<strong>图形描述</strong>。我们也使用了<strong>交互图</strong><code>[JCJO92,BOO94]</code>来说明对象之间的请求序列和协作关系。附录B详细描述了这些表示法。</p><h3 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h3><p>指设计模式中的类和/或对象以及它们各自的职责。</p><h3 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h3><p>模式的参与者怎样协作以实现它们的职责。</p><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><ol><li>模式怎样支持它的目标?</li><li>使用模式的效果和所需做的权衡取舍?</li><li>系统结构的哪些方面可以独立改变?</li></ol><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>实现模式时需要知道的一些提示、技术要点及应避免的缺陷,以及是否存在某些特定于实现语言的问题。</p><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>用来说明怎样用C++或<code>Smalltalk</code>实现该模式的代码片段。</p><h3 id="相关模式"><a href="#相关模式" class="headerlink" title="相关模式"></a>相关模式</h3><ol><li>与这个模式紧密相关的模式有哪些?</li><li>其间重要的不同之处是什么?</li><li>这个模式应与哪些其他模式一起使用?</li></ol><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>附录提供的背景资料将帮助你理解模式以及关于模式的讨论。<br>附录A给出了我们使用的术语列表。<br>前面已经提到过的附录B则给出了各种表示法,我们也会在以后的讨论中简单介绍它们。<br>最后,附录C给出了我们在例子中使用的各基本类的源代码。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 可复用面向对象软件的基础 </category>
          
          <category> 第1章 引言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.2 Smalltalk MVC中的设计模式</title>
      <link href="/ReadingNotes//bb83b3f4/"/>
      <url>/ReadingNotes//bb83b3f4/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/bb83b3f4/#1-2-Smalltalk-MVC中的设计模式" class="header_1">1.2 Smalltalk MVC中的设计模式</a>&nbsp;<br><a href="/ReadingNotes/bb83b3f4/#MVC含义" class="header_2">MVC含义</a>&nbsp;<br><a href="/ReadingNotes/bb83b3f4/#MVC作用" class="header_2">MVC作用</a>&nbsp;<br><a href="/ReadingNotes/bb83b3f4/#模型刷新视图" class="header_2">模型刷新视图</a>&nbsp;<br><a href="/ReadingNotes/bb83b3f4/#MVC用到的设计模式" class="header_2">MVC用到的设计模式</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="1-2-Smalltalk-MVC中的设计模式"><a href="#1-2-Smalltalk-MVC中的设计模式" class="headerlink" title="1.2 Smalltalk MVC中的设计模式"></a>1.2 Smalltalk MVC中的设计模式</h1><p>在<code>Smalltalk-80</code>中,类的<code>模型/视图/控制器</code>( <code>Model/View/Controller)</code>三元组(<code>MVC)</code>被用来构建用户界面。透过<code>MVC</code>来看设计模式将帮助我们理解”模式”这一术语的含义。</p><h2 id="MVC含义"><a href="#MVC含义" class="headerlink" title="MVC含义"></a>MVC含义</h2><p><code>MVC</code>包括三类对象。</p><ol><li>模型<code>Model</code>是应用对象,</li><li>视图<code>View</code>是它在屏幕上的表示,</li><li>控制器<code>Controller</code>定义用户界面对用户输入的响应方式。</li></ol><h2 id="MVC作用"><a href="#MVC作用" class="headerlink" title="MVC作用"></a>MVC作用</h2><p>不使用<code>MVC</code>,用户界面设计往往将这些对象混在一起,而<code>MVC</code>则将它们分离以提高灵活性和复用性。</p><h2 id="模型刷新视图"><a href="#模型刷新视图" class="headerlink" title="模型刷新视图"></a>模型刷新视图</h2><p><code>MVC</code>通过建立一个”订购/通知”协议来分离视图和模型。视图必须保证它的显示正确地反映了模型的状态。<strong>一旦模型的数据发生变化,模型将通知有关的视图,每个视图相应地得到刷新自已的机会</strong>。这种方法可以让你为一个模型提供不同的多个视图表现形式,也能够为一个模型创建新的视图而无须重写模型。<br><!--SSTStop--></p><p>下图显示了一个模型和三个视图(为了简单起见我们省略了控制器)。模型包含一些数据值,视图通过电子表格、柱状图、饼图这些不同的方式来显示这些数据。<strong>当模型的数据发生变化时,模型就通知它的视图</strong>,而视图将与模型通信以访问这些数据值<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/SheJiMoShiKeFuYongMianXiangDuiXiangRuanJianDeJiChu/ch1/1.png" alt="这里有一张图片"><br>表面上看,这个例子反映了将<code>视图</code>和<code>模型</code>分离的设计,然而这个设计还可用于解决更一般的问题:<code>将对象分离,使得一个对象的改变能够影响另一些对象,而这个对象并不需要知道那些被影响的对象的细节</code>。这个更一般的设计被描述成<code>Observer</code>模式(见5.7小节)<br><code>MVC</code>的另一个特征是视图可以嵌套。例如,按钮控制面板可以用一个嵌套了按钮的复杂视图来实现。对象查看器的用户界面可由嵌套的视图构成,这些视图又可复用于调试器。<code>MVC</code>用<code>View</code>类的子类— <code>CompositeView</code>类来支持嵌套视图。 <code>CompositeView</code>类的对象行为上类似于<code>View</code>类对象,一个组合视图可用于任何视图可用的地方,但是它包含并管理嵌套视图。<br>上例反映了可以将组合视图与其构件平等对待的设计,同样地,该设计也适用于更一般的问题:将一些对象划为一组,并将该组对象当作一个对象来使用。这个设计被描述为<code>Composite(4.3)</code>模式,该模式允许你创建一个类层次结构,一些子类定义了原子对象(如<code>Button</code>)而其他类定义了组合对象( <code>CompositeView)</code>,这些组合对象是由原子对象组合而成的更复杂的对象。<br><code>MVC</code>允许你在不改变视图外观的情况下改变视图对用户输人的响应方式。例如,你可能希望改变视图对键盘的响应方式,或希望使用弹出菜单而不是原来的命令键方式。<code>MVC</code>将响应机制封装在<code>Controller</code>对象中。存在着一个<code>Controller</code>的类层次结构,使得可以方便地对原有<code>Controller</code>做适当改变而创建新的<code>Controller</code><br><code>view</code>使用<code>Controller</code>子类的实例来实现一个特定的响应策略。要实现不同的响应策略只要用不同种类的<code>Controller</code>实例替换即可。甚至可以在运行时刻通过改变<code>View</code>的<code>Controller</code>来改变<code>View</code>对用户输人的响应方式。例如,一个<code>View</code>可以被禁止接收任何输入,只需给它一个忽略输入事件的<code>Controller</code>。<br><code>view-Controller</code>关系是<code>Strategy(5.9)</code>模式的一个例子。一个策略是一个表述算法的对象。当你想静态或动态地替换一个算法,或你有很多不同的算法,或算法中包含你想封装的复杂数据结构,这时策略模式是非常有用的。<br><!--SSTStart--></p><h2 id="MVC用到的设计模式"><a href="#MVC用到的设计模式" class="headerlink" title="MVC用到的设计模式"></a>MVC用到的设计模式</h2><p><code>MVC</code>还使用了其他的设计模式,如:用来指定视图缺省控制器的<code>FactoryMethod(3.3)</code>和用来增加视图滚动的<code>Decorator((4.4)</code>。但是<strong><code>MVC</code>的主要关系还是由<code>Observer</code>、 <code>Composite</code>和<code>Strategy</code>三个设计模式给出的</strong>。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 可复用面向对象软件的基础 </category>
          
          <category> 第1章 引言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.1 什么是设计模式</title>
      <link href="/ReadingNotes//5c218ac7/"/>
      <url>/ReadingNotes//5c218ac7/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/5c218ac7/#1-1-什么是设计模式" class="header_1">1.1 什么是设计模式</a>&nbsp;<br><a href="/ReadingNotes/5c218ac7/#设计模式的作用" class="header_2">设计模式的作用</a>&nbsp;<br><a href="/ReadingNotes/5c218ac7/#程序设计语言对设计模式的影响" class="header_2">程序设计语言对设计模式的影响</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="1-1-什么是设计模式"><a href="#1-1-什么是设计模式" class="headerlink" title="1.1 什么是设计模式"></a>1.1 什么是设计模式</h1><p><strong>模式的四个基本要素</strong><br>一般而言,一个模式有四个基本要素:</p><ol><li><strong>模式名称</strong>( <code>pattern name</code>)一个助记名,它用一两个词来<strong>描述模式的问题、解决方案和效果</strong>。命名一个新的模式增加了我们的设计词汇。设计模式允许我们在较高的抽象层次上进行设计。基于一个模式词汇表,我们自己以及同事之间就可以讨论模式并在编写文档时使用它们。模式名可以帮助我们思考,便于我们与其他人交流设计思想及设计结果。找到恰当的模式名也是我们设计模式编目工作的难点之一</li><li><strong>问题</strong>(<code>problem</code>)描述了<strong>应该在何时使用模式</strong>。它解释了设计问题和问题存在的前因后果,它可能描述了特定的设计问题,如怎样用对象表示算法等。也可能描述了导致不灵活设计的类或对象结构。<strong>有时候,问题部分会包括使用模式必须满足的一系列先决条件</strong>。</li><li><strong>解决方案</strong>(<code>solution</code>)描述了<strong>设计的组成成分</strong>,它们之间的相互关系及各自的职责和协作方式。因为模式就像一个模板,可应用于多种不同场合,所以解决方案并不描述一个特定而具体的设计或实现,而是提供设计问题的抽象描述和怎样用一个具有一般意义的元素组合类或对象组合)来解决这个问题。</li><li><strong>效果</strong>(<code>consequences</code>)描述了<strong>模式应用的效果及使用模式应权衡的问题</strong>。尽管我们描述设计决策时,并不总提到模式效果,但它们对于评价设计选择和理解使用模式的代价及好处具有重要意义。软件效果大多关注对时间和空间的衡量,它们也表述了语言和实现问题。因为复用是面向对象设计的要素之一,所以模式效果包括它对系统的灵活性、扩充性或可移植性的影响,显式地列出这些效果对理解和评价这些模式很有帮助。</li></ol><h2 id="设计模式的作用"><a href="#设计模式的作用" class="headerlink" title="设计模式的作用"></a>设计模式的作用</h2><p>本书中的设计模式是<strong>对被用来在特定场景下解决一般设计问题的类和相互通信的对象的描述</strong>。</p><p><strong>每一个设计模式都集中于一个<code>特定的面向对象设计问题</code>或设计要点,描述了什么时候使用它,在另一些设计约束条件下是否还能使用,以及使用的效果和如何取舍</strong>。既然我们最终要实现设计,设计模式还提供了<code>C++</code>和<code>Smalltalk</code>例代码来阐明其实现。</p><h2 id="程序设计语言对设计模式的影响"><a href="#程序设计语言对设计模式的影响" class="headerlink" title="程序设计语言对设计模式的影响"></a>程序设计语言对设计模式的影响</h2><p><strong>程序设计语言的选择非常重要,它将影响人们理解问题的出发点</strong>。<br><strong>对某些模式一种语言比另一种语言表述起来更容易一些</strong><br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 可复用面向对象软件的基础 </category>
          
          <category> 第1章 引言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.0 设计模式 可复用面向对象软件的基础 第1章前言</title>
      <link href="/ReadingNotes//7c617dcb/"/>
      <url>/ReadingNotes//7c617dcb/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/7c617dcb/#1-0-设计模式-可复用面向对象软件的基础-第1章前言" class="header_1">1.0 设计模式 可复用面向对象软件的基础 第1章前言</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="1-0-设计模式-可复用面向对象软件的基础-第1章前言"><a href="#1-0-设计模式-可复用面向对象软件的基础-第1章前言" class="headerlink" title="1.0 设计模式 可复用面向对象软件的基础 第1章前言"></a>1.0 设计模式 可复用面向对象软件的基础 第1章前言</h1><p><strong>这本书的目的就是将面向对象软件的设计经验作为设计模式记录下来</strong>。每一个设计模式系统地命名、解释和评价了面向对象系统中一个重要的和重复出现的设计。我们的目标是将设计经验以人们能够有效利用的形式记录下来。鉴于此目的,我们编写了一些最重要的设计模式,并以编目分类的形式将它们展现出来。<br><strong>设计模式使人们可以更加简单方便地<code>复用成功的设计和体系结构</code></strong>。将已证实的技术表述成设计模式也会使新系统开发者更加容易理解其设计思路。<strong>设计模式帮助你做出有利于系统复用的选择,避免设计损害了系统复用性</strong>。通过提供一个显式类和对象作用关系以及它们之间潜在联系的说明规范,设计模式甚至能够提高已有系统的文档管理和系统维护的有效性。简而言之,<strong>设计模式可以帮助设计者更快更好地完成系统设计</strong>。<br><strong>本书中涉及的设计模式并不描述新的或未经证实的设计,我们只收录那些在不同系统中多次使用过的成功设计</strong>。这些设计的绝大部分以往并无文档记录,它们或是来源于面向对象设计者圈子里的非正式交流,或是来源于某些成功的面向对象系统的某些部分,但对设计新手来说,这些东西是很难学得到的。尽管这些设计不包含新的思路,但我们用一种新的、便于理解的方式将其展现给读者,即:<strong>具有统一格式的、已分类编目的若干组设计模式</strong>。<br>尽管该书涉及较多的内容,但书中讨论的设计模式仅仅包含了一个设计行家所知道的部分。<strong>书中没有讨论与<code>并发</code>或<code>分布式</code>或<code>实时程序设计</code>有关的模式,也没有收录面向特定应用领域的模式</strong>。本书并不准备告诉你怎样构造用户界面、怎样写设备驱动程序或怎样使用面向对象数据库,这些方面都有自己的模式,将这些模式分类编目也是件很有意义的事。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 可复用面向对象软件的基础 </category>
          
          <category> 第1章 引言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式 可复用面向对象软件的基础 读者指南</title>
      <link href="/ReadingNotes//62cf50e2/"/>
      <url>/ReadingNotes//62cf50e2/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/62cf50e2/#设计模式-可复用面向对象软件的基础-读者指南" class="header_1">设计模式 可复用面向对象软件的基础 读者指南</a>&nbsp;<br><a href="/ReadingNotes/62cf50e2/#设计模式的分类" class="header_2">设计模式的分类</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="设计模式-可复用面向对象软件的基础-读者指南"><a href="#设计模式-可复用面向对象软件的基础-读者指南" class="headerlink" title="设计模式 可复用面向对象软件的基础 读者指南"></a>设计模式 可复用面向对象软件的基础 读者指南</h1><p>本书包括<strong>两个主要部分</strong>:</p><ul><li>第一部分(第1章和第2章)介绍了什么是设计模式以及它如何帮助你设计面向对象的软件系统。该部分包含了一个设计案例研究,展示了如何将设计模式应用于实际工作。</li><li>第二部分(第3、4、5章)则是实际设计模式的分类描述。</li></ul><h2 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h2><p>模式的分类描述构成了本书的主要部分,书中的章节根据模式的性质将其划分为三种类型:</p><ol><li>创建型(<code>creational</code>),</li><li>结构型(<code>structural</code>)</li><li>行为型(<code>behavioral</code>)。</li></ol><!--SSTStop--><p>可以从多个角度使用这个模式分类描述,例如,你可以从头至尾地阅读每一个模式,也可以随机浏览其中的任何个模式。另外一种方法是研究其中的一章,这将有助于理解原本密切关联的模式如何相互区分。<br>模式描述中的交叉引用将给你提供寻找其他相关模式的逻辑路径,它将帮助你看清楚模式是如何相互关联的、一个模式怎样与其他模式进行组合、以及哪些模式能在一起工作。图1-1将用图示方法展现这种关系。<br>阅读模式分类描述的另一种方法是<strong>问题导向法</strong>,你可以翻到书中的第1.6节查找有关设计可复用的面向对象系统过程中经常见到的问题,然后阅读解决这些问题的有关模式。有些读者首先通读模式分类描述,然后运用问题导向的方法将模式应用于他们的项目之中。</p><ul><li><code>Abstract Factory (3.1)</code></li><li><code>Adapter(4.1)</code></li><li><code>Composite(4.3)</code></li><li><code>Decorator(4.4)</code></li><li><code>Factory Method (3.3)</code></li><li><code>Observer(5.7)</code></li><li><code>Strategy(5.9)</code></li><li><code>Template Method (5.10)</code></li></ul><p>很难找到一个面向对象软件系统,它没有使用书中描述的若干模式。许多大型软件系统几乎用到了所有的这些模式。上述这组模式将有助于你进一步理解设计模式本身及一般意义下的优秀的面向对象设计。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 可复用面向对象软件的基础 </category>
          
          <category> 第0章 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式 可复用面向对象软件的基础 前言</title>
      <link href="/ReadingNotes//6b324c5e/"/>
      <url>/ReadingNotes//6b324c5e/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/6b324c5e/#设计模式-可复用面向对象软件的基础-前言" class="header_1">设计模式 可复用面向对象软件的基础 前言</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="设计模式-可复用面向对象软件的基础-前言"><a href="#设计模式-可复用面向对象软件的基础-前言" class="headerlink" title="设计模式 可复用面向对象软件的基础 前言"></a>设计模式 可复用面向对象软件的基础 前言</h1><p><strong>本书假设你至少已经比较熟悉一种面向对象编程语言,并且有一定的面向对象设计经验</strong>。当我们提及”类型”和”多态”,或”接口”继承与”实现”继承的关系时,你应该对这些概念了然于胸,而不必迫不及待地翻阅手头的字典。<br>另外,这是<strong>一本关于设计模式的书</strong>,它描述了在面向对象软件设计过程中<strong>针对特定问题的简洁而优雅的解决方案</strong>。<br><strong>设计模式并不要求使用独特的语言特性</strong>,<strong>所有的模式均可以用标准的面向对象语言实现</strong>,这也许有时会比特殊的解法多费一些功夫,但是为了增加软件的灵活性和可复用性,多做些工作是值得的。<br>一旦你理解了设计模式应用经验和体验后。你将拥有一种深刻的洞察力,以<strong>帮助你设计出更加灵活的、模块化的、可复用的和易理解的软件</strong><br>请记住,<strong>这不是一本读完一遍就可以束之高阁的书</strong>。我们希望你在软件设计过程中反复参阅此书,以获取设计灵感。<br><strong>我们并不认为这组设计模式是完整的和一成不变的,它只是我们目前对设计的思考的记录</strong>。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 可复用面向对象软件的基础 </category>
          
          <category> 第0章 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.4 FFmpeg的编解码工具ffmpeg</title>
      <link href="/ReadingNotes//2709f648/"/>
      <url>/ReadingNotes//2709f648/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/2709f648/#1-4-FFmpeg的编解码工具ffmpeg" class="header_1">1.4 FFmpeg的编解码工具ffmpeg</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="1-4-FFmpeg的编解码工具ffmpeg"><a href="#1-4-FFmpeg的编解码工具ffmpeg" class="headerlink" title="1.4 FFmpeg的编解码工具ffmpeg"></a>1.4 FFmpeg的编解码工具ffmpeg</h1><p><code>ffmpeg</code>是<code>FFmpeg</code>源代码编译后生成的一个可执行程序,其可以作为命令行工具使用。本节将通过实际的示例分析,对<code>ffmpeg</code>编解码工具的使用方法进行详细的介绍。<br>首先列举一个简单的例子:<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ffmpeg -i input.mp4 output.avi</span><br></pre></td></tr></table></figure><br>这条命令行执行过程输出如下:</p><p>这是一条简单的<code>ffmpeg</code>命令,可以看到,<code>ffmpeg</code>通过-i参数将<code>input.mp4</code>作为输入源输入,然后进行转码与转封装操作,输出到<code>output.avi</code>中,这条命令主要做了如下工作。</p><ol><li>获得输入源<code>input.mp4</code>。</li><li>转码。</li><li>输出文件<code>output.avi</code>。</li></ol><p>看似简单的两步主要的工作,其实远远不止是从后缀名为<code>MP4</code>的文件输出成后缀名为<code>AVI</code>的文件,因为在<code>ffmpeg</code>中,<code>MP4</code>与<code>AVI</code>是两种文件封装格式,并不是后缀名就可以决定的,例如上面的命令行同样可以写成这样:<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ffmpeg -i input.mp4 -f avi output.dat</span><br></pre></td></tr></table></figure><br>这条命令行执行过程输出如下:</p><p>这条<code>ffmpeg</code>命令相对于前面的那条命令做了一些改变,加了一个<code>&quot;-f&quot;</code>进行约束,<code>&quot;-f&quot;</code>参数的工作非常重要,它制定了输出文件的容器格式,所以可以看到输出的文件为<code>output.dat</code>,文件后缀名为<code>.dat</code>,但是其主要工作依然与之前的指令相同。<br>分析以上两个输出信息中的<code>Output#0</code>部分,可以看到输出的都是<code>AVI</code>,只是输出的文件名不同,其他内容均相同。<br><code>ffmpeg</code>的主要工作流程相对比较简单,具体如下。</p><ol><li>解封装(<code>Demuxing</code>)。</li><li>解码(<code>Decoding</code>)。</li><li>编码(<code>Encoding</code>)。</li><li>封装(<code>Muxing</code>)。</li></ol><p>其中需要经过6个步骤,具体如下。</p><ol><li>读取输入源。</li><li>进行音视频的解封装。</li><li>解码每一帧音视频数据。</li><li>编码每一帧音视频数据。</li><li>进行音视频的重新封装。</li><li>输出到目标。</li></ol><p><code>ffmpeg</code>整体处理的工作流程与步骤如图1-4所示。</p><p>从图1-4所示的工作流程可以看出,<br><code>ffmpeg</code>首先读取输入源;<br>然后通过<code>Demuxer</code>将音视频包进行解封装,这个动作通过调用<code>libavformat</code>中的接口即可实现<br>;接下来通过<code>Decoder</code>进行解码,将音视频通过<code>Decoder</code>解包成为<code>YVU</code>或者<code>PCM</code>这样的数据,<code>Decoder</code>通过<code>libavcodec</code>中的接口即可实现;<br>然后通过<code>Encoder</code>将对应的数据进行编码,编码可以通过<code>libavcodec</code>中的接口来实现;<br>接下来将编码后的音视频数据包通过<code>Muxer</code>进行封装,<code>Muxer</code>封装通过<code>libavformat</code>中的接口即可实现,输出成为输出流。</p>]]></content>
      
      
      <categories>
          
          <category> FFmpeg从入门到精通 </category>
          
          <category> 第一部分 FFmpeg的命令行使用篇 </category>
          
          <category> 第1章 FFmpeg简介 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.9 小结</title>
      <link href="/ReadingNotes//5a59fe6b/"/>
      <url>/ReadingNotes//5a59fe6b/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/5a59fe6b/#1-9-小结" class="header_1">1.9 小结</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="1-9-小结"><a href="#1-9-小结" class="headerlink" title="1.9 小结"></a>1.9 小结</h1><p>本章重点介绍了<code>FFmpeg</code>的获取、安装、容器封装与解封装的格式支持、音视频编码与解码的格式支持,以及流媒体传输协议的支持。综合来说,<code>FFmpeg</code>所支持的容器、编解码、协议相对来说比较全面,是一款功能强大的多媒体处理工具和开发套件。</p>]]></content>
      
      
      <categories>
          
          <category> FFmpeg从入门到精通 </category>
          
          <category> 第一部分 FFmpeg的命令行使用篇 </category>
          
          <category> 第1章 FFmpeg简介 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2.1 ffmpeg常用命令</title>
      <link href="/ReadingNotes//3e1012ee/"/>
      <url>/ReadingNotes//3e1012ee/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/3e1012ee/#2-1-ffmpeg常用命令" class="header_1">2.1 ffmpeg常用命令</a>&nbsp;<br><a href="/ReadingNotes/3e1012ee/#-L参数" class="header_2">-L参数</a>&nbsp;<br><a href="/ReadingNotes/3e1012ee/#-version参数" class="header_2">-version参数</a>&nbsp;<br><a href="/ReadingNotes/3e1012ee/#-formats参数" class="header_2">-formats参数</a>&nbsp;<br><a href="/ReadingNotes/3e1012ee/#查看是否支持某种编码或解码格式" class="header_2">查看是否支持某种编码或解码格式</a>&nbsp;<br><a href="/ReadingNotes/3e1012ee/#查看支持的滤镜" class="header_2">查看支持的滤镜</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="2-1-ffmpeg常用命令"><a href="#2-1-ffmpeg常用命令" class="headerlink" title="2.1 ffmpeg常用命令"></a>2.1 ffmpeg常用命令</h1><p><code>ffmpeg</code>在做音视频编解码时非常方便,所以在很多场景下转码使用的是<code>ffmpeg</code>,通过<code>ffmpeg --help</code>可以看到<code>ffmpeg</code>常见的命令大概分为6个部分,具体如下。</p><ul><li><code>ffmpeg</code>信息查询部分</li><li>公共操作参数部分</li><li>文件主要操作参数部分</li><li>视频操作参数部分</li><li>音频操作参数部分</li><li>字幕操作参数部分</li></ul><p><code>ffmpeg</code>信息查询部分的主要参数具体如下:</p><p>通过<code>ffmpeg --help</code>查看到的<code>help</code>信息是<code>ffmpeg</code>命令的基础信息,如果想获得高级参数部分,那么可以通过使用<code>ffmpeg --help long</code>参数来查看,如果希望获得全部的帮助信息,那么可以通过使用<code>ffmpeg --help full</code>参数来获得。</p><h2 id="L参数"><a href="#L参数" class="headerlink" title="-L参数"></a>-L参数</h2><p>通过<code>-L</code>参数,可以看到<code>ffmpeg</code>目前所支持的<code>license</code>协议;</p><h2 id="version参数"><a href="#version参数" class="headerlink" title="-version参数"></a>-version参数</h2><p>通过<code>-version</code>参数,可以查看<code>ffmpeg</code>的版本,包括子模块的详细版本信息,如<code>libavformat</code>、<code>libavcodec</code>、<code>libavutil</code>、<code>libavfilter</code>、<code>libswscale</code>、<code>libswresample</code>的版本:</p><h2 id="formats参数"><a href="#formats参数" class="headerlink" title="-formats参数"></a>-formats参数</h2><p>使用<code>ffmpeg</code>转码,有时候可能会遇到无法解析的视频文件或者无法生成视频文件,报错提示不支持生成对应的视频文件,这时候就需要查看当前使用的<code>ffmpeg</code>是否支持对应的视频文件格式,需要使用<code>ffmpeg -formats</code>参数来查看:</p><p>根据上面输出的信息可以看到,输出的内容分为3个部分,具体如下。</p><ul><li>第一列是多媒体文件封装格式的<code>Demuxing</code>支持与<code>Muxing</code>支持</li><li>第二列是多媒体文件格式</li><li>第三列是文件格式的详细说明</li></ul><h2 id="查看是否支持某种编码或解码格式"><a href="#查看是否支持某种编码或解码格式" class="headerlink" title="查看是否支持某种编码或解码格式"></a>查看是否支持某种编码或解码格式</h2><p>使用<code>ffmpeg</code>命令时,可能会出现<code>ffmpeg</code>不支持某种编码格式或者某种解码格式的错误提示信息,这种错误常见于并未将该编码器或者解码器集成到<code>ffmpeg</code>中,若想查看<code>ffmpeg</code>是否支持<code>H.264</code>编码或者解码,</p><ul><li>可以通过<code>ffmpeg -codecs</code>查看全部信息,</li><li>也可以通过<code>ffmpeg -encoders</code>查看<code>ffmpeg</code>是否支持<code>H.264</code>编码器,</li><li>或者通过<code>ffmpeg -decoders</code>查看<code>ffmpeg</code>是否支持<code>H.264</code>解码器。</li></ul><p><code>ffmpeg-decoders</code>命令行执行后,输出如下:</p><p>输出信息中包含了三部分内容,具体如下。</p><ul><li>第一列包含6个字段,第一个字段用来表示此编码器为音频、视频还是字幕,第二个字段表示帧级别的多线程支持,第三个字段表示分片级别的多线程,第四个字段表示该编码为试验版本,第五个字段表示<code>draw horiz band</code>模式支持,第六个字段表示直接渲染模式支持</li><li>第二列是编码格式</li><li>第三列是编码格式的详细说明</li></ul><p><code>ffmpeg-encoders</code>命令执行后,输出如下:<br>输出信息中同样包含了三部分内容,具体如下。</p><ul><li>第一列包含6个字段,第一个字段用来表示此编码器为音频、视频还是字幕,第二个字段表示帧级别的多线程支持,第三个字段表示分片级别的多线程,第四个字段表示该编码为试验版本,第五个字段表示<code>draw horiz band</code>模式支持,第六个字段表示直接渲染模式支持</li><li>第二列是编码格式</li><li>第三列是编码格式的详细说明</li></ul><h2 id="查看支持的滤镜"><a href="#查看支持的滤镜" class="headerlink" title="查看支持的滤镜"></a>查看支持的滤镜</h2><p>除了查看<code>ffmpeg</code>支持的封装(<code>Muxer)</code>格式与解封装(<code>Demuxer)</code>格式、编码(<code>Encoder)</code>类型与解码(<code>Decoder)</code>类型,还可以通过<code>ffmpeg -filters</code>查看<code>ffmpeg</code>支持哪些滤镜:</p>]]></content>
      
      
      <categories>
          
          <category> FFmpeg从入门到精通 </category>
          
          <category> 第一部分 FFmpeg的命令行使用篇 </category>
          
          <category> 第2章 FFmpeg工具使用基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第2章 FFmpeg工具使用基础 本章概览</title>
      <link href="/ReadingNotes//80a8481e/"/>
      <url>/ReadingNotes//80a8481e/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/80a8481e/#第2章-FFmpeg工具使用基础-本章概览" class="header_1">第2章 FFmpeg工具使用基础 本章概览</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="第2章-FFmpeg工具使用基础-本章概览"><a href="#第2章-FFmpeg工具使用基础-本章概览" class="headerlink" title="第2章 FFmpeg工具使用基础 本章概览"></a>第2章 FFmpeg工具使用基础 本章概览</h1><p><code>FFmpeg</code>中常用的工具主要是<code>ffmpeg</code>、<code>ffprobe</code>、<code>ffplay</code>,它们分别用作多媒体的编解码工具、内容分析工具和播放器,本章将重点介绍这三个工具的常用命令。<br>本章主要介绍如下几个方面。</p><ul><li>2.1节将重点介绍<code>ffmpeg</code>命令,介绍<code>ffmpeg</code>常用的参数用法并举例说明,例如如何查看<code>ffmpeg</code>的帮助信息,如何通过<code>ffmpeg</code>的帮助信息快速了解转码参数并快速上手使用。</li><li>2.2节将重点介绍<code>ffprobe</code>命令,介绍<code>ffprobe</code>进行音视频数据分析的常用参数,并通过实例介绍如何分析视频文件的流信息、包信息、帧信息、导出数据等。</li><li>2.3节将重点介绍<code>ffplay</code>命令,介绍<code>ffplay</code>常用的参数使用及示例,例如,如何使用<code>ffplay</code>定制化窗口播放视频、输出音频可视化数据、输出视频可视化数据等。</li></ul>]]></content>
      
      
      <categories>
          
          <category> FFmpeg从入门到精通 </category>
          
          <category> 第一部分 FFmpeg的命令行使用篇 </category>
          
          <category> 第2章 FFmpeg工具使用基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.8 FFmpeg编码支持与定制</title>
      <link href="/ReadingNotes//9c051dcd/"/>
      <url>/ReadingNotes//9c051dcd/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/9c051dcd/#1-8-FFmpeg编码支持与定制" class="header_1">1.8 FFmpeg编码支持与定制</a>&nbsp;<br><a href="/ReadingNotes/9c051dcd/#1-8-2-FFmpeg的解码器支持" class="header_1">1.8.2 FFmpeg的解码器支持</a>&nbsp;<br><a href="/ReadingNotes/9c051dcd/#1-8-3-FFmpeg的封装支持" class="header_1">1.8.3 FFmpeg的封装支持</a>&nbsp;<br><a href="/ReadingNotes/9c051dcd/#1-8-4-FFmpeg的解封装支持" class="header_1">1.8.4 FFmpeg的解封装支持</a>&nbsp;<br><a href="/ReadingNotes/9c051dcd/#1-8-5-FFmpeg的通信协议支持" class="header_1">1.8.5 FFmpeg的通信协议支持</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="1-8-FFmpeg编码支持与定制"><a href="#1-8-FFmpeg编码支持与定制" class="headerlink" title="1.8 FFmpeg编码支持与定制"></a>1.8 FFmpeg编码支持与定制</h1><p><code>FFmpeg</code>本身支持一些音视频编码格式、文件封装格式与流媒体传输协议,但是支持的数量依然有限,<code>FFmpeg</code>所做的只是提供一套基础的框架,所有的编码格式、文件封装格式与流媒体协议均可以作为<code>FFmpeg</code>的一个模块挂载在<code>FFmpeg</code>框架中。这些模块以第三方的外部库的方式提供支持,可以通过<code>FFmpeg</code>源码的<code>configure</code>命令查看<code>FFmpeg</code>所支持的音视频编码格式、文件封装格式与流媒体传输协议,对于<code>FFmpeg</code>不支持的格式,可以通过<code>configure--help</code>查看所需要的第三方外部库,然后通过增加对应的编译参数选项进行支持。帮助信息内容输出如下:</p><p>通过以上帮助信息的输出内容可以看到,<code>FFmpeg</code>所支持的外部库相对来说比较多,主要包含如下列表:<br>这些外部库可以通过<code>configure</code>进行定制,在编译好的<code>FFmpeg</code>可执行程序中也可以看到编译时定制的<code>FFmpeg</code>的外部库:<br>例如需要自己配置<code>FFmpeg</code>支持哪些格式,比如仅支持<code>H.264</code>视频与<code>AAC</code>音频编码,可以调整配置项将其简化如下:<br>命令行执行后的输出内容如下:</p><p>省略…</p><h1 id="1-8-2-FFmpeg的解码器支持"><a href="#1-8-2-FFmpeg的解码器支持" class="headerlink" title="1.8.2 FFmpeg的解码器支持"></a>1.8.2 FFmpeg的解码器支持</h1><p><code>FFmpeg</code>源代码本身包含了很多的解码支持,解码主要是在输入的时候进行解码,也可以理解为将压缩过的编码进行解压缩,关于解码的支持,可以通过<code>./configure-list-decoders</code>命令来进行查看:</p><p>从上面的输出信息中可以看到<code>FFmpeg</code>所支持的解码器模块<code>decoders</code>支持了<code>MPEG4</code>、<code>H.264</code>、<code>H.265(HEVC)</code>、<code>MP3</code>等格式。</p><h1 id="1-8-3-FFmpeg的封装支持"><a href="#1-8-3-FFmpeg的封装支持" class="headerlink" title="1.8.3 FFmpeg的封装支持"></a>1.8.3 FFmpeg的封装支持</h1><p><code>FFmpeg</code>的封装(<code>Muxing</code>)是指将压缩后的编码封装到一个容器格式中,如果要查看<code>FFmpeg</code>源代码中都可以支持哪些容器格式,可以通过命令<code>./configure--list-muxers</code>来查看:</p><p>从封装(又称复用)格式所支持的信息中可以看到,<code>FFmpeg</code>支持生成裸流文件,如<code>H.264</code>、<code>AAC</code>、<code>PCM</code>,也支持一些常见的格式,如<code>MP3</code>、<code>MP4</code>、<code>FLV</code>、<code>M3U8</code>、<code>WEBM</code>等。</p><h1 id="1-8-4-FFmpeg的解封装支持"><a href="#1-8-4-FFmpeg的解封装支持" class="headerlink" title="1.8.4 FFmpeg的解封装支持"></a>1.8.4 FFmpeg的解封装支持</h1><p><code>FFmpeg</code>的解封装(<code>Demuxing)</code>是指将读入的容器格式拆解开,将里面压缩的音频流、视频流、字幕流、数据流等提取出来,如果要查看<code>FFmpeg</code>的源代码中都可以支持哪些输入的容器格式,可以通过命令<code>./configure--list-demuxers</code>来查看:</p><p>从解封装(<code>Demuxer</code>,又称解复用)格式支持信息中可以看到,<code>FFmpeg</code>源代码中已经支持的<code>demuxer</code>非常多,包含图片(<code>image</code>)、<code>MP3</code>、<code>FLV</code>、<code>MP4</code>、<code>MOV</code>、<code>AVI</code>等。</p><h1 id="1-8-5-FFmpeg的通信协议支持"><a href="#1-8-5-FFmpeg的通信协议支持" class="headerlink" title="1.8.5 FFmpeg的通信协议支持"></a>1.8.5 FFmpeg的通信协议支持</h1><p><code>FFmpeg</code>不仅仅支持本地的多媒体处理,而且还支持网络流媒体的处理,支持的网络流媒体协议相对来说也很全面,可以通过命令<code>./configure--list-protocols</code>查看:</p><p>从协议的相关信息列表中可以看到,<code>FFmpeg</code>支持的流媒体协议比较多,包括<code>MMS</code>、<code>HTTP</code>、<code>HTTPS</code>、<code>HLS(M3U8)</code>、<code>RTMP</code>、<code>RTP</code>,甚至支持<code>TCP</code>、<code>UDP</code>,其也支持使用<code>file</code>协议的本地文件操作和使用<code>concat</code>协议支持的多个文件串流操作,后面的章节中会有详细的介绍。</p>]]></content>
      
      
      <categories>
          
          <category> FFmpeg从入门到精通 </category>
          
          <category> 第一部分 FFmpeg的命令行使用篇 </category>
          
          <category> 第1章 FFmpeg简介 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.7 FFmpeg编译</title>
      <link href="/ReadingNotes//720bfeb/"/>
      <url>/ReadingNotes//720bfeb/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/720bfeb/#1-7-FFmpeg编译" class="header_1">1.7 FFmpeg编译</a>&nbsp;<br><a href="/ReadingNotes/720bfeb/#1-7-1-FFmpeg之Windows平台编译" class="header_1">1.7.1 FFmpeg之Windows平台编译</a>&nbsp;<br><a href="/ReadingNotes/720bfeb/#1-7-2-FFmpeg之Linux平台编译" class="header_1">1.7.2 FFmpeg之Linux平台编译</a>&nbsp;<br><a href="/ReadingNotes/720bfeb/#1-7-3-FFmpeg之OS-X平台编译" class="header_1">1.7.3 FFmpeg之OS X平台编译</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="1-7-FFmpeg编译"><a href="#1-7-FFmpeg编译" class="headerlink" title="1.7 FFmpeg编译"></a>1.7 FFmpeg编译</h1><p>我现在还没有这个需求,这一节先不看<br><!--SSTStop--><br><code>FFmpeg</code>在官方网站中提供了已经编译好的可执行文件。因为<code>FFmpeg</code>是开源的,所以也可以根据自己的需要进行手动编译。<code>FFmpeg</code>官方建议用户自行编译使用<code>FFmpeg</code>的最新版本,因为对于一些操作系统,比如<code>Linux</code>系统(无论是<code>Ubuntu</code>还是<code>RedHat)</code>,如果使用系统提供的软件库安装<code>ffmpeg</code>时会发现其版本相对比较老旧,比如使用<code>apt-get install ffmpeg</code>或者<code>yum install ffmpeg</code>安装<code>ffmpeg</code>,那么默认支持的版本都很老,有些新的功能并不支持,如一些新的封装格式或者通信协议。因此初学者学会编译<code>FFmpeg</code>就至关重要了,因此可以方便以后根据自己的需求进行功能的裁剪。</p><h1 id="1-7-1-FFmpeg之Windows平台编译"><a href="#1-7-1-FFmpeg之Windows平台编译" class="headerlink" title="1.7.1 FFmpeg之Windows平台编译"></a>1.7.1 FFmpeg之Windows平台编译</h1><h1 id="1-7-2-FFmpeg之Linux平台编译"><a href="#1-7-2-FFmpeg之Linux平台编译" class="headerlink" title="1.7.2 FFmpeg之Linux平台编译"></a>1.7.2 FFmpeg之Linux平台编译</h1><h1 id="1-7-3-FFmpeg之OS-X平台编译"><a href="#1-7-3-FFmpeg之OS-X平台编译" class="headerlink" title="1.7.3 FFmpeg之OS X平台编译"></a>1.7.3 FFmpeg之OS X平台编译</h1>]]></content>
      
      
      <categories>
          
          <category> FFmpeg从入门到精通 </category>
          
          <category> 第一部分 FFmpeg的命令行使用篇 </category>
          
          <category> 第1章 FFmpeg简介 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.6 FFmpeg的多媒体分析器ffprobe</title>
      <link href="/ReadingNotes//86679a98/"/>
      <url>/ReadingNotes//86679a98/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/86679a98/#1-6-FFmpeg的多媒体分析器ffprobe" class="header_1">1.6 FFmpeg的多媒体分析器ffprobe</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="1-6-FFmpeg的多媒体分析器ffprobe"><a href="#1-6-FFmpeg的多媒体分析器ffprobe" class="headerlink" title="1.6 FFmpeg的多媒体分析器ffprobe"></a>1.6 FFmpeg的多媒体分析器ffprobe</h1><p><code>ffprobe</code>也是<code>FFmpeg</code>源码编译后生成的一个可执行程序。<code>ffprobe</code>是一个非常强大的多媒体分析工具,可以从媒体文件或者媒体流中获得你想要了解的媒体信息,比如音频的参数、视频的参数、媒体容器的参数信息等。<br>例如它可以帮助分析某个媒体容器中的音频是什么编码格式、视频是什么编码格式,同时还可以得到媒体文件中媒体的总时长、复合码率等信息。<br>使用<code>ffprobe</code>可以分析媒体文件中每个包的长度、包的类型、帧的信息等。后面章节将会对<code>ffprobe</code>进行详细的介绍,下面列举一个简单的例子,以对<code>ffprobe</code>有一个基本的概念:<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ffprobe –show_streams output.mp4</span><br></pre></td></tr></table></figure><br>命令行执行之后将会输出如下内容:<br>根据输出内容可以看到,使用<code>ffprobe</code>能够查看<code>MP4</code>文件容器中的流的信息,其包含了一个视频流,由于该文件中只有视频流,流相关的信息是通过<code>[STREAM][/STREAM]</code>的方式展现出来的,在<code>[STREAM]</code>与<code>[/STREAM]</code>之间的信息即为该<code>MP4</code>文件的视频流信息。当视频文件容器中包含音频流与视频流或者更多路流时,会通过<code>[STREAM]</code>与<code>[/STREAM]</code>进行多个流的分隔,分隔后采用<code>index</code>来进行流的索引信息的区分。</p>]]></content>
      
      
      <categories>
          
          <category> FFmpeg从入门到精通 </category>
          
          <category> 第一部分 FFmpeg的命令行使用篇 </category>
          
          <category> 第1章 FFmpeg简介 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.5 FFmpeg的播放器ffplay</title>
      <link href="/ReadingNotes//e93a2ed4/"/>
      <url>/ReadingNotes//e93a2ed4/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/e93a2ed4/#1-5-FFmpeg的播放器ffplay" class="header_1">1.5 FFmpeg的播放器ffplay</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="1-5-FFmpeg的播放器ffplay"><a href="#1-5-FFmpeg的播放器ffplay" class="headerlink" title="1.5 FFmpeg的播放器ffplay"></a>1.5 FFmpeg的播放器ffplay</h1><p><code>FFmpeg</code>不但可以提供转码、转封装等功能,同时还提供了播放器相关功能,使用<code>FFmpeg</code>的<code>avformat</code>与<code>avcodec</code>,可以播放各种媒体文件或者流。如果想要使用<code>ffplay</code>,那么系统首先需要有<code>SDL</code>来进行<code>ffplay</code>的基础支撑。<br><code>ffplay</code>是<code>FFmpeg</code>源代码编译后生成的另一个可执行程序,与<code>ffmpeg</code>在<code>FFmpeg</code>项目中充当的角色基本相同,可以作为测试工具进行使用,<code>ffplay</code>提供了音视频显示和播放相关的图像信息、音频的波形信息等。<br>注意:<br>有时通过源代码编译生成<code>ffplay</code>不一定能够成功,因为<code>ffplay</code>在旧版本时依赖于<code>SDL-1.2</code>,而<code>ffplay</code>在新版本时依赖于<code>SDL-2.0</code>,需要安装对应的<code>SDL</code>才能生成<code>ffplay</code>。</p>]]></content>
      
      
      <categories>
          
          <category> FFmpeg从入门到精通 </category>
          
          <category> 第一部分 FFmpeg的命令行使用篇 </category>
          
          <category> 第1章 FFmpeg简介 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.3 FFmpeg的基本组成</title>
      <link href="/ReadingNotes//72820b8d/"/>
      <url>/ReadingNotes//72820b8d/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/72820b8d/#1-3-FFmpeg的基本组成" class="header_1">1.3 FFmpeg的基本组成</a>&nbsp;<br><a href="/ReadingNotes/72820b8d/#-1-FFmpeg的封装模块AVFormat" class="header_2">(1)FFmpeg的封装模块AVFormat</a>&nbsp;<br><a href="/ReadingNotes/72820b8d/#-2-FFmpeg的编解码模块AVCodec" class="header_2">(2)FFmpeg的编解码模块AVCodec</a>&nbsp;<br><a href="/ReadingNotes/72820b8d/#-3-FFmpeg的滤镜模块AVFilter" class="header_2">(3)FFmpeg的滤镜模块AVFilter</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="1-3-FFmpeg的基本组成"><a href="#1-3-FFmpeg的基本组成" class="headerlink" title="1.3 FFmpeg的基本组成"></a>1.3 FFmpeg的基本组成</h1><p><code>FFmpeg</code>框架的基本组成包含<code>AVFormat</code>、<code>AVCodec</code>、<code>AVFilter</code>、<code>AVDevice</code>、<code>AVUtil</code>等模块库。<br>下面针对这些模块做一个大概的介绍。</p><h2 id="1-FFmpeg的封装模块AVFormat"><a href="#1-FFmpeg的封装模块AVFormat" class="headerlink" title="(1)FFmpeg的封装模块AVFormat"></a>(1)FFmpeg的封装模块AVFormat</h2><p><code>AVFormat</code>中实现了目前多媒体领域中的绝大多数媒体封装格式,包括封装和解封装,如:</p><ul><li><code>MP4</code>、<code>FLV</code>、<code>KV</code>、<code>TS</code>等<code>文件封装格式</code>,</li><li><code>RTMP</code>、<code>RTSP</code>、<code>MMS</code>、<code>HLS</code>等<code>网络协议封装格式</code>。</li></ul><p><code>FFmpeg</code>是否支持某种媒体封装格式,取决于编译时是否包含了该格式的封装库。根据实际需求,可进行媒体封装格式的扩展,增加自己定制的封装格式,即在<code>AVFormat</code>中增加自己的封装处理模块。</p><h2 id="2-FFmpeg的编解码模块AVCodec"><a href="#2-FFmpeg的编解码模块AVCodec" class="headerlink" title="(2)FFmpeg的编解码模块AVCodec"></a>(2)FFmpeg的编解码模块AVCodec</h2><p><code>AVCodec</code>中实现了目前多媒体领域绝大多数常用的编解码格式,<strong>既支持编码,也支持解码</strong>。<code>AVCodec</code>除了支持<code>MPEG4</code>、<code>AAC</code>、<code>MJPEG</code>等<strong>自带的媒体编解码格式</strong>之外,还支持<strong>第三方的编解码器</strong>,如:</p><ul><li><code>H.264(AVC)</code>编码,需要使用x264编码器;</li><li><code>H.265(HEVC)</code>编码,需要使用x265编码器;</li><li><code>MP3(mp3lame)</code>编码,需要使用<code>libmp3lame</code>编码器。</li></ul><p>如果希望增加自己的编码格式,或者硬件编解码,则需要在<code>AVCodec</code>中增加相应的编解码模块,关于<code>AVCode</code>的更多相关信息以及使用信息将会在后面的章节中进行详细的介绍。</p><h2 id="3-FFmpeg的滤镜模块AVFilter"><a href="#3-FFmpeg的滤镜模块AVFilter" class="headerlink" title="(3)FFmpeg的滤镜模块AVFilter"></a>(3)FFmpeg的滤镜模块AVFilter</h2><p><code>AVFilter</code>库提供了一个通用的音频、视频、字幕等滤镜处理框架。在<code>AVFilter</code>中,滤镜框架可以有多个输入和多个输出。我们参考下面这个滤镜处理的例子,如图1-2所示。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/FFmpegCongRuMenDaoJingTong/Ch1/1.png" alt="这里有一张图片"><br>图1-2所示样例中的滤镜处理将输入的视频切割成了两部分流,一部分流抛给<code>crop</code>滤镜与<code>vflip</code>滤镜处理模块进行操作,另一部分保持原样,当<code>crop</code>滤镜与<code>vflip</code>滤镜处理操作完成之后,将流合并到原有的<code>overlay</code>图层中,并显示在最上面一层,输出新的视频。对应的命令行如下:<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ffmpeg -i INPUT -vf "split [main][tmp]; [tmp] crop=iw:ih/<span class="number">2</span>:<span class="number">0</span>:<span class="number">0</span>, vflip [flip]; [main][flip] overlay=<span class="number">0</span>:H/<span class="number">2</span>" OUTPUT</span><br></pre></td></tr></table></figure><br>下面看一下具体的执行情况,以验证该命令的可行性:</p><p>这部分命令比较复杂先省略,后面看懂了的话再更新吧!</p>]]></content>
      
      
      <categories>
          
          <category> FFmpeg从入门到精通 </category>
          
          <category> 第一部分 FFmpeg的命令行使用篇 </category>
          
          <category> 第1章 FFmpeg简介 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.2 FFmpeg的历史</title>
      <link href="/ReadingNotes//829f4072/"/>
      <url>/ReadingNotes//829f4072/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/829f4072/#1-2-FFmpeg的历史" class="header_1">1.2 FFmpeg的历史</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="1-2-FFmpeg的历史"><a href="#1-2-FFmpeg的历史" class="headerlink" title="1.2 FFmpeg的历史"></a>1.2 FFmpeg的历史</h1><!--replace:FFmpeg=F F M peg--><p>想要深入了解一个软件、一个系统,首先要了解其发展史,下面就来介绍一下<code>FFmpeg</code>的整体发展过程。<br><code>FFmpeg</code>由法国天才程序员<code>Fabrice Bellard</code>在2000年时开发出初版;后来发展到2004年,<code>Fabrice``Bellard</code>找到了<code>FFmpeg</code>的接手人,这个人就是至今还在维护<code>FFmpeg</code>的<code>Michael Niedermayer</code>。<code>Michael Niedermayer</code>对<code>FFmpeg</code>的贡献非常大,其将滤镜子系统<code>libavfilter</code>加入<code>FFmpeg</code>项目中,使得<code>FFmpeg</code>的多媒体处理更加多样、更加方便。在<code>FFmpeg</code>发布了0.5版本之后,很长一段时间没有进行新版本的发布,直到后来<code>FFmpeg</code>采用<code>Git</code>作为版本控制服务器以后才开始继续进行代码更新、版本发布,当然也是时隔多年之后了;2011年3月,在<code>FFmpeg</code>项目中有一些提交者对<code>FFmpeg</code>的项目管理方式并不满意,因而重新创建了一个新的项目,命名为<code>Libav</code>,该项目尽管至今并没有<code>FFmpeg</code>发展这么迅速,但是提交权限相对<code>FFmpeg</code>更加开放;2015年8月,<code>Michael Niedermayer</code>主动辞去<code>FFmpeg</code>项目负责人的职务。<code>Michael Niedermayter</code>从<code>Libav</code>中移植了大量的代码和功能至<code>FFmpeg</code>中,<code>Michael``Niedermayer</code>辞职的主要目的是希望两个项目最终能够一起发展,若能够合并则更好。时至今日,在大多数的<code>Linux</code>发行版本系统中已经使用<code>FFmpeg</code>来进行多媒体处理。<br>作为一套开源的音视频编解码套件,<code>FFmpeg</code>可以通过互联网自由获取。<code>FFmpeg</code>的源码<code>Git</code>库提供了多站同步的获取方式:</p><ul><li><a href="git://source.ffmpeg.org/ffmpeg.git">git://source.ffmpeg.org/ffmpeg.git</a></li><li><a href="http://git.videolan.org/?p=ffmpeg.git" target="_blank" rel="noopener">http://git.videolan.org/?p=ffmpeg.git </a></li><li><a href="https://github.com/FFmpeg/FFmpeg" target="_blank" rel="noopener">https://github.com/FFmpeg/FFmpeg</a></li></ul><p><code>FFmpeg</code>发展至今,已经被许多开源项目所采用,如<code>ijkplayer</code>、<code>ffmpeg2theora</code>、<code>VLC</code>、<code>MPlayer</code>、<code>HandBrake</code>、<code>Blender</code>、<code>Google Chrome</code>等。<br><code>DirectShow/VFW</code>的<code>ffdshow</code>(外部工程)和<code>QuickTime</code>的<code>Perian</code>(外部工程)也采用了<code>FFmpeg</code>。</p><p>由于<code>FFmpeg</code>是在<code>LGPL/GPL</code>协议下发布的(如果使用了<code>GPL</code>协议发布的模块则必须采用<code>GPL</code>协议),任何人都可以自由使用,但必须严格遵守<code>LGPL/GPL</code>协议。随着参与的人越来越多,<code>FFmpeg</code>的发展也越来越快,至本书完稿,<code>FFmpeg</code>已经发布到3.3版本。</p><!--SSTStop-->]]></content>
      
      
      <categories>
          
          <category> FFmpeg从入门到精通 </category>
          
          <category> 第一部分 FFmpeg的命令行使用篇 </category>
          
          <category> 第1章 FFmpeg简介 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.1 FFmpeg的定义</title>
      <link href="/ReadingNotes//33deceb3/"/>
      <url>/ReadingNotes//33deceb3/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/33deceb3/#1-1-FFmpeg的定义" class="header_1">1.1 FFmpeg的定义</a>&nbsp;<br><a href="/ReadingNotes/33deceb3/#FFmpeg名字解释" class="header_2">FFmpeg名字解释</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="1-1-FFmpeg的定义"><a href="#1-1-FFmpeg的定义" class="headerlink" title="1.1 FFmpeg的定义"></a>1.1 FFmpeg的定义</h1><p><code>FFmpeg</code>既是一款音视频编解码工具,同时也是一组音视频编解码开发套件,作为编解码开发套件,它为开发者提供了丰富的音视频处理的调用接口。<br><code>FFmpeg</code>提供了多种媒体格式的封装和解封装,包括多种音视频编码、多种协议的流媒体、多种色彩格式转换、多种采样率转换、多种码率转换等;<code>FFmpeg</code>框架提供了多种丰富的插件模块,包含封装与解封装的插件、编码与解码的插件等。</p><h2 id="FFmpeg名字解释"><a href="#FFmpeg名字解释" class="headerlink" title="FFmpeg名字解释"></a>FFmpeg名字解释</h2><p><code>FFmpeg</code>中的<code>&quot;FF&quot;</code>指的是<code>&quot;Fast Forward&quot;</code>,<code>FFmpeg</code>中的<code>&quot;mpeg&quot;</code>则是人们通常理解的<code>Moving Picture Experts Group</code>(动态图像专家组),<code>FFmpeg</code>是一个很全面的图像处理套件。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> FFmpeg从入门到精通 </category>
          
          <category> 第一部分 FFmpeg的命令行使用篇 </category>
          
          <category> 第1章 FFmpeg简介 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第一部分 FFmpeg的命令行使用篇 前言</title>
      <link href="/ReadingNotes//7fc15dad/"/>
      <url>/ReadingNotes//7fc15dad/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/7fc15dad/#第一部分-FFmpeg的命令行使用篇-前言" class="header_2">第一部分 FFmpeg的命令行使用篇 前言</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h2 id="第一部分-FFmpeg的命令行使用篇-前言"><a href="#第一部分-FFmpeg的命令行使用篇-前言" class="headerlink" title="第一部分 FFmpeg的命令行使用篇 前言"></a>第一部分 FFmpeg的命令行使用篇 前言</h2><p>第一部分主要介绍<code>FFmpeg</code>的命令行使用,在使用<code>FFmpeg</code>命令行之前,首先需要了解<code>FFmpeg</code>的发展过程,搭建<code>FFmpeg</code>的使用环境,比如编译<code>FFmpeg</code>、生成文档、查找说明文档等,相关内容在第1章和第2章均会有详细的介绍。<br>从第3章开始将会进入稍微深入的使用环节,由浅入深,讲解如何使用<code>FFmpeg</code>实现流媒体应用中的常见功能。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> FFmpeg从入门到精通 </category>
          
          <category> 第一部分 FFmpeg的命令行使用篇 </category>
          
          <category> 第1章 FFmpeg简介 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>FFmpeg从入门到精通 前言</title>
      <link href="/ReadingNotes//ae3baeda/"/>
      <url>/ReadingNotes//ae3baeda/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/ae3baeda/#FFmpeg从入门到精通-前言#" class="header_1">FFmpeg从入门到精通 前言#</a>&nbsp;<br><a href="/ReadingNotes/ae3baeda/#如何阅读本书" class="header_2">如何阅读本书</a>&nbsp;<br><a href="/ReadingNotes/ae3baeda/#本书源码" class="header_2">本书源码</a>&nbsp;<br><a href="/ReadingNotes/ae3baeda/#相关文档" class="header_2">相关文档</a>&nbsp;<br><a href="/ReadingNotes/ae3baeda/#官方文档资料" class="header_3">官方文档资料</a>&nbsp;<br><a href="/ReadingNotes/ae3baeda/#中文经典资料" class="header_3">中文经典资料</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="FFmpeg从入门到精通-前言"><a href="#FFmpeg从入门到精通-前言" class="headerlink" title="FFmpeg从入门到精通 前言"></a>FFmpeg从入门到精通 前言</h1><h2 id="如何阅读本书"><a href="#如何阅读本书" class="headerlink" title="如何阅读本书"></a>如何阅读本书</h2><p>本书一共包含10章,按照所讲述的内容以及所面向读者的不同层次,可以划分为两大部分,具体如下。</p><ul><li>第一部分为<code>FFmpeg</code>的命令行使用篇,包括第1章到第7章,介绍了<code>FFmpeg</code>的基础组成部分、<code>FFmpeg</code>工具使用、<code>FFmpeg</code>的封装操作、<code>FFmpeg</code>的转码操作、<code>FFmpeg</code>的流媒体操作、<code>FFmpeg</code>的滤镜操作和<code>FFmpeg</code>的设备操作。</li><li>第二部分为<code>FFmpeg</code>的<code>API</code>使用篇,包括第8章到第10章,介绍了<code>FFmpeg</code>封装部分的<code>API</code>使用操作、<code>FFmpeg</code>编解码部分的<code>API</code>使用操作和<code>FFmpeg</code>滤镜部分的<code>API</code>使用操作,相关操作均以实例方式进行说明,包括新<code>API</code>及旧<code>API</code>的操作。</li></ul><p>如果你已经能够通过源代码独立安装<code>FFmpeg</code>,那么可以跳过第1章直接从第2章开始阅读;如果你对命令行使用没有兴趣,或者希望使用<code>FFmpeg</code>的<code>API</code>开发,那么可以跳过前7章直接从第8章开始阅读。笔者建议最好是从第1章开始阅读。</p><h2 id="本书源码"><a href="#本书源码" class="headerlink" title="本书源码"></a>本书源码</h2><p>另外,本书代码相关的举例均可以在<code>FFmpeg</code>的源代码目录的<code>doc/examples</code>中获得,也可以通过<code>FFmpeg</code>官方网站的<a href="https://ffmpeg.org/doxygen/trunk/examples.html" target="_blank" rel="noopener">文档</a>获得</p><h2 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h2><p><code>FFmpeg</code>发展了至少17年,积累了极其丰富的资料,能够满足大部分的需求。由于<code>FFmpeg</code>的更新与版本的迭代,不同版本之间使用的参数相对来说会稍微有所不同,由于本书篇幅有限,所以<code>FFmpeg</code>的很多交流社区的资源同样值得参考。</p><h3 id="官方文档资料"><a href="#官方文档资料" class="headerlink" title="官方文档资料"></a>官方文档资料</h3><ul><li><code>FFmpeg</code><a href="http://ffmpeg.org/documentation.html" target="_blank" rel="noopener">官方文档</a></li><li><code>FFmpeg</code><a href="https://trac.ffmpeg.org" target="_blank" rel="noopener">官方wiki</a></li></ul><h3 id="中文经典资料"><a href="#中文经典资料" class="headerlink" title="中文经典资料"></a>中文经典资料</h3><ul><li><a href="http://blog.csdn.net/leixiaohua1020" target="_blank" rel="noopener">雷霄骅博士总结的资料</a></li><li><a href="http://www.rosoo.net" target="_blank" rel="noopener">罗索实验室</a></li><li><a href="http://bbs.chinaffmpeg.com" target="_blank" rel="noopener">ChinaFFmpeg</a></li></ul><p>除了以上这些信息，还可以通过Google、百度等搜索引擎获得大量相关资料。<br><code>FFmpeg</code>本身也提供了命令参数的详细说明,读者可以查看<code>FFmpeg</code>的帮助信息,后面的章节将会对此进行详细的介绍。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> FFmpeg从入门到精通 </category>
          
          <category> 前言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第1章 介绍Java EE平台</title>
      <link href="/ReadingNotes//c8363f/"/>
      <url>/ReadingNotes//c8363f/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/c8363f/#第1章-介绍Java-EE平台" class="header_1">第1章 介绍Java EE平台</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="第1章-介绍Java-EE平台"><a href="#第1章-介绍Java-EE平台" class="headerlink" title="第1章 介绍Java EE平台"></a>第1章 介绍Java EE平台</h1><p>本章内容:</p><ul><li><code>Java SE</code>和<code>Java EE</code>版本时间线</li><li>介绍<code>Servlet</code>、过滤器、监听器和<code>JSP</code></li><li>了解<code>WAR</code>和<code>EAR</code>文件,以及类加载器层次</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java Web高级编程 </category>
          
          <category> 第1部分 创建企业级应用程序 </category>
          
          <category> 第1章 介绍Java EE平台 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第1部分 创建企业级应用程序</title>
      <link href="/ReadingNotes//715b25eb/"/>
      <url>/ReadingNotes//715b25eb/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/715b25eb/#第1部-分创建企业级应用程序" class="header_1">第1部 分创建企业级应用程序</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="第1部-分创建企业级应用程序"><a href="#第1部-分创建企业级应用程序" class="headerlink" title="第1部 分创建企业级应用程序"></a>第1部 分创建企业级应用程序</h1><p>第1章:介绍<code>Java EE</code>平台<br>第2章:使用<code>Web</code>容器<br>第3章:创建第一个<code>Servlet</code><br>第4章:使用<code>JPS</code>显示页面内容<br>第5章:使用会话维持状态<br>第6章:在<code>JsP</code>中使用表达式语言<br>第7章:使用<code>Java</code>标准标签库<br>第8章:编写自定义标签和函数库<br>第9章:使用过滤器改进应用程序<br>第10章:在应用程序中使用<code>Websocke</code>进行交互<br>第11章:使用日志监控应用程序</p>]]></content>
      
      
      <categories>
          
          <category> Java Web高级编程 </category>
          
          <category> 第1部分 创建企业级应用程序 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java Web高级编程 前言</title>
      <link href="/ReadingNotes//487481ea/"/>
      <url>/ReadingNotes//487481ea/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/487481ea/#代码示例" class="header_1">代码示例</a>&nbsp;<br><a href="/ReadingNotes/487481ea/#Maven依赖" class="header_1">Maven依赖</a>&nbsp;<br><a href="/ReadingNotes/487481ea/#将安全相关的内容安排在最后的原因" class="header_1">将安全相关的内容安排在最后的原因</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><p>作为一本软件开发书籍,该书广泛地应用了代码示例,通过它们证明我们正在讨论的主题。大多数情况下,这些示例都是完整的<code>IDE</code>项目,你可以在DE中打开、编译和执行。所有的示例都可以从<code>wrox.com</code>代码下载网站和这个<a href="http://www.tupwk.com.cn/downpage" target="_blank" rel="noopener">网址</a>获得。请访问<a href="http://www.wrox.com/go/projavaforwebapps" target="_blank" rel="noopener">网址</a>并单击<code>Download code</code>选项卡。你可以将所有代码示例下载为单个ZP文件或者将每章的示例单独下载为一个ZP文件。在每章的示例中,可以找到每个示例的两个版本:一个<code>IntelliJ IDEA</code>项目和一个<code>Eclipse</code>项目。使用自己选择的IDE对应的版本即可。如果你使用的不是这两种<code>IDE</code>中的某一个,那么你的<code>IDE</code>应该能够将<code>IntelliJ IDEA</code>项目作为简单的<code>Maven</code>项目导入。</p><h1 id="Maven依赖"><a href="#Maven依赖" class="headerlink" title="Maven依赖"></a>Maven依赖</h1><p>本书中的样例代码将广泛运用第三方依赖,例如<code>Spring Framework</code>、 <code>Hibernate ORM</code>和<code>Spring Security</code>。在下载网站的代码中包含这些依赖<code>JAR</code>,将使下载文件变大,你可能需要下载几百兆的文件。为了解决这个问题,样例代码将使用<code>Apache Maven</code>及其依赖管理功能。所有的示例项目都是<code>Maven</code>项目。在<code>IDE</code>中打开每个项目时,<code>IDE</code>将自动在本地<code>Maven</code>库中查找这些依赖,或者如果需要的话,<code>IDE</code>将下载它们到本地<code>Maven</code>库中。<br>在每章的首页,你将会看到一个标题为”本章新增的<code>Maven</code>依赖”的区域。该部分列出了本章中新增的<code>Maven</code>依赖。你也可以查看<code>pom. xml</code>文件来检查每个示例项目的依赖。某些章节未引入新的<code>Maven</code>依赖,但大多数章节都引入了。<br>每个<code>Maven</code>依赖都会有作用域,用于定义依赖在哪个类路径上可用。</p><ul><li>最常见的作用域——<code>&quot;compile&quot;</code>作用域——表示该依赖在项目的编译类路径上、单元测试编译和执行类路径上以及运行应用程序时的最终运行时类路径上可用。在<code>Java EE Web</code>应用程序中,这意味着依赖将被复制到所部署的应用程序中。</li><li><code>&quot; runtime&quot;</code>作用域表示依赖将在单元测试执行和运行时执行类路径上可用,但不像<code>&quot; compile&quot;</code>作用域一样在编译应用程序或者执行单元测试时也可用。一个运行时依赖将被复制到所部署的应用程序中。</li><li>最后,<code>&quot; provided&quot;</code>作用域表示运行应用程序的容器将会提供该依赖。</li></ul><p>在<code>Java EE</code>应用程序中,这意味着依赖已经在<code>Servlet</code>容器或应用服务器的类路径上了,因此不需要再复制到部署的应用程序中。 <code>Maven</code>和<code>IDE</code>将保证在编译应用程序和执行单元测试时,<code>&quot; provided&quot;</code>作用域的依赖是可用的。 <code>Maven</code>还有其他类型的作用域,但在本书中将只会用到这些。<br>在文本和示例项目中,有一些<code>Maven</code>依赖将会包含排除( (<code>exclusions)</code>),用于忽略某些特定的依赖——它们被称为临时依赖。很多时候这些排除都是多余的,列出它们只是为了使代码更清晰。当某个依赖依赖于另一个旧版本的依赖,而不是现在正在使用的依赖时,通过排除可以更清楚地表示这里出现了矛盾,并且避免了由<code>Maven</code>的最近算法所引起的问题。不过,某些排除的存在是由于<code>Java Se</code>或<code>Java ee</code>的新版本已经提供了依赖,或者因为依赖ID发生了变化。当出现这种情况时,文本中会进行提示。</p><h1 id="将安全相关的内容安排在最后的原因"><a href="#将安全相关的内容安排在最后的原因" class="headerlink" title="将安全相关的内容安排在最后的原因"></a>将安全相关的内容安排在最后的原因</h1><p>坦白地说,应用程序安全会影响其他内容的学习。在产品中添加认证和授权所使用的技术将会干扰你的代码,并使学习过程变得困难。安全是第一位的,而且一直记得安全问题永远也不是错误。不过,只要使用了正确的工具,在项目完成(或基本上完成之后为它添加验证和授权也是相当简单的一件事。<strong>本书首先将关注于如何使用工业标准工具创建出高质量、特性丰富的<code>web</code>应用程序。在学会了创建强大应用程序所需的技能之后,本书的第Ⅳ部分将向你展示如何为现有的应用程序添加认证和授权,保护它不受未授权的和恶意访问的攻击</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> Java Web高级编程 </category>
          
          <category> 第0部分 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.2 IntelliJ 简介</title>
      <link href="/ReadingNotes//5b4f8c0a/"/>
      <url>/ReadingNotes//5b4f8c0a/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/5b4f8c0a/#1-2-IntelliJ-简介" class="header_1">1.2 IntelliJ 简介</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="1-2-IntelliJ-简介"><a href="#1-2-IntelliJ-简介" class="headerlink" title="1.2 IntelliJ 简介"></a>1.2 IntelliJ 简介</h1>]]></content>
      
      
      <categories>
          
          <category> 精通Spring MVC4 </category>
          
          <category> 第1章 快速搭建Spring Web应用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.1 Spring Tool Suite 简介</title>
      <link href="/ReadingNotes//29580cd4/"/>
      <url>/ReadingNotes//29580cd4/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/29580cd4/#1-1-Spring-Tool-Suite简介" class="header_1">1.1 Spring Tool Suite简介</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="1-1-Spring-Tool-Suite简介"><a href="#1-1-Spring-Tool-Suite简介" class="headerlink" title="1.1 Spring Tool Suite简介"></a>1.1 Spring Tool Suite简介</h1><p>如果要开始学习<code>Spring</code>并使用<code>Spring</code>社区所提供的指南和<code>Starter</code>项目的话,那么最好的起步方式之一就是下载<code>Spring Tool Suite(STS)</code>。<strong><code>STS</code> 是一个自定义版本的<code>Eclipse</code></strong>,它被用来与各种<code>Spring</code> 项目进行协作,它同时还包括<code>Groovy</code> 和<code>Gradle</code> 功能。即便如此,你可能像我一样,还会使用其他的<code>IDE</code>,但是,我强烈建议你给<code>STS</code>一个机会,因为它通过<code>&quot;Getting Started&quot;</code>项目,能够让你快速地了解<code>Spring</code>广阔的生态系统。<br>所以,你可以访问<a href="https://Spring.io/tools/sts/all" target="_blank" rel="noopener">这个网站</a>下载<code>STS</code> 的最新发布版。在生成第一个<code>Spring Boot</code>项目之前,首先需要安装<code>Gradle</code>对<code>STS</code>的支持。在<code>Dashboard</code>中,可以看到<code>&quot;Manage IDE Extensions&quot;</code>按钮,然后,需要在<code>&quot;Language and framework tooling&quot;</code>区域中选择下载<code>&quot;Gradle Support&quot;</code>。<br>还推荐你下载<code>&quot;Groovy Eclipse&quot;</code>以及<code>&quot;Groovy 2.4 compiler&quot;</code>,如图1-1 所示,在本书的后文中,介绍使用<code>geb</code>构建验收测试时会用到它们。</p>]]></content>
      
      
      <categories>
          
          <category> 精通Spring MVC4 </category>
          
          <category> 第1章 快速搭建Spring Web应用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第1章 快速搭建Spring Web应用</title>
      <link href="/ReadingNotes//dbeeb1cb/"/>
      <url>/ReadingNotes//dbeeb1cb/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/dbeeb1cb/#第1章快速搭建Spring-Web应用" class="header_1">第1章快速搭建Spring Web应用</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="第1章快速搭建Spring-Web应用"><a href="#第1章快速搭建Spring-Web应用" class="headerlink" title="第1章快速搭建Spring Web应用"></a>第1章快速搭建Spring Web应用</h1><p>在本章中,我们将会直接接触代码并搭建一个<code>Web</code>应用,本书的其他章节将会基于该应用进行讲解。<br>在这里,我们将会使用<code>Spring Boot</code>的自动配置功能来构建应用,这样的话,就能完全避免使用样板式的配置文件。<br>本书将会从整体上介绍<code>Spring Boot</code>是如何运行的以及该如何对其进行配置,共有4种方式来开启一个<code>Spring</code>项目:</p><ul><li>使用<code>Spring Tool Suite</code>生成<code>Starter</code>代码； </li><li>使用<code>IntelliJ IDEA 14.1</code>，它对<code>Spring Boot</code>提供了良好的支持； </li><li>借助<code>Spring</code>站点，从 <code>http://start.Spring.io</code>上下载可配置的<code>ZIP</code> 文件； </li><li>使用到<code>http://start.Spring.io</code> 站点的<code>curl</code>命令来达到相同的效果。 </li></ul><p>本书中将会使用<code>Gradle</code> 和<code>Java 8</code>,但是也不必为此感到担心。如果你还在使用<code>Maven</code>和更早版本的<code>Java</code>的话,相信你会发现这些技术也是很易于使用的。<br>很多官方的<code>Spring</code> 教程同时提供了<code>Gradle</code> 构建和<code>Maven</code> 构建,因此,如果你决定继续使用<code>Maven</code>的话,也能很容易地找到样例。<code>Spring 4</code>完全兼容<code>Java 8</code>,<strong>如果你不采用<code>Lambda</code>表达式来简化代码库的话,那真的是很遗憾的事情</strong>。<br>本书同时还会为你展示一些<code>Git</code> 命令。笔者认为,跟踪工作进展并在稳定的状态进行提交是一件好事。另外,这样还能很容易地将你的工作成果与本书提供的源码进行对比。<br>本书第9章将借助<code>Heroku</code>部署我们的应用,建议从一开始就使用<code>Git</code>对代码进行版本管理。在本章中,关于如何开始使用<code>Git</code>,我会给出一些建议。</p>]]></content>
      
      
      <categories>
          
          <category> 精通Spring MVC4 </category>
          
          <category> 第1章 快速搭建Spring Web应用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前言</title>
      <link href="/ReadingNotes//7819a34e/"/>
      <url>/ReadingNotes//7819a34e/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/7819a34e/#前言" class="header_1">前言</a>&nbsp;<br><a href="/ReadingNotes/7819a34e/#本书所涵盖的内容" class="header_2">本书所涵盖的内容</a>&nbsp;<br><a href="/ReadingNotes/7819a34e/#阅读本书所需的前提条件" class="header_2">阅读本书所需的前提条件</a>&nbsp;<br><a href="/ReadingNotes/7819a34e/#本书为谁而作" class="header_2">本书为谁而作</a>&nbsp;<br><a href="/ReadingNotes/7819a34e/#示例代码下载" class="header_2">示例代码下载</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>作为<code>Web</code>开发人员,我愿意创建新的东西,将它们快速上线,然后将注意力转移到下一个新的想法上。<br>如今,所有的应用都互相连接在了一起,我们需要与社交媒体进行交互,促进产品和复杂系统的发展,为用户提供更大的价值。<br>直到现在,这些对于<code>Java</code> 开发人员来说都非常遥远和复杂。随着<code>Spring Boot</code> 的诞生和云平台的平民化,我们可以在有限的时间内创建精彩的应用并让所有的人来访问,而这个过程不需要花一分钱。<br>在本书中,我们将会从头开始构建一个有用的<code>Web</code>应用。这个应用有很多很棒的特性,如国际化、表单校验、分布式会话与缓存、社交登录、多线程编程等。<br>同时,我们还会对其进行完整的测试。<br>在本书结束之前,我们还会将这个小应用部署到云端,使它能够通过<code>Web</code>进行访问。<br>如果你觉得这挺有意思的话,那么就别浪费时间了,马上开始着手编码吧!</p><h2 id="本书所涵盖的内容"><a href="#本书所涵盖的内容" class="headerlink" title="本书所涵盖的内容"></a>本书所涵盖的内容</h2><p>第1章”快速搭建<code>Spring Web</code>应用”能够让我们非常快速地开始使用<code>Spring Boot</code>。本章介绍了让我们更具生产效益的工具,如<code>Spring Tool Suite</code> 和<code>Git</code>,本章还会帮助我们搭建应用的主体框架,并见识<code>Spring Boot</code>背后的魔力。<br>第2章”精通<code>MVC</code>架构”指导我们创建一个小的<code>Twitter</code>搜索引擎,同时,本章还涵盖了<code>Spring MVC</code> 和<code>Web</code>架构的基础知识。<br>第3章”处理表单和复杂的<code>URL</code>映射”帮助你理解如何创建用户基本信息表单,本章介绍如何在服务端和客户端校验数据,并且让我们的应用支持多语言访问。<br>第4 章”文件上传与错误处理”将会指导你为基本信息表单添加文件上传功能,它阐述了如何在<code>Spring MVC</code>中恰当地处理错误并展示自定义的错误页面。<br>第5章”创建<code>RESTful</code>应用”阐述了<code>RESTful</code>架构的理念,它还帮助我们创建了一个可以通过<code>HTTP</code> 调用的用户管理<code>API</code>,这个过程中会看到帮助我们设计<code>API</code> 的工具,并且会讨论如何很简便地实现文档化。<br>第6 章”保护应用”将会指导我们如何保护应用,包括如何使用基本<code>HTTP</code> 认证保护<code>RESTful API</code>,以及如何保护登录页之后的<code>Web</code> 页面,它阐述了如何通过<code>Twitter</code>进行登录以及如何将会话保存在<code>Redis</code>中,从而允许我们的应用进行扩展。<br>第7章”单元测试与验收测试”帮助我们对应用进行测试。它讨论了测试与<code>TDD</code>,介绍了如何对控制器进行单元测试,如何使用现代的库设计端到端的测试。最后,介绍了<code>Groovy</code>如何提升测试的生产效率和可读性。<br>第8章”优化请求”对应用进行了优化。它包括缓存控制和<code>Gzip</code>,本章将教会我们如何把<code>Twitter</code>搜索结果缓存到内存和<code>Redis</code>中,以及如何对搜索实现多线程执行。除此之外,还会介绍如何实现<code>Etag</code> 和使用<code>WebSocket</code>。<br>第9章”将<code>Web</code>应用部署到云中”会指导我们对应用进行部署,通过对比,阐述了不同<code>PaaS</code> 解决方案的差异。然后,介绍了如何将应用部署到<code>Cloud Foundry</code>和<code>Heroku</code>中。<br>第10章”超越<code>Spring Web&quot;</code>在整体上讨论了<code>Spring</code>生态系统,介绍了现代<code>Web</code> 应用的组成部分以及后续的发展方向。</p><h2 id="阅读本书所需的前提条件"><a href="#阅读本书所需的前提条件" class="headerlink" title="阅读本书所需的前提条件"></a>阅读本书所需的前提条件</h2><p>尽管我们将要构建的是一个很高级的应用,但是并不需要你安装很多的东西。<br>我们将要构建的应用需要<code>Java 8</code>。<br>我们并不强制你使用<code>Git</code>,不过你绝对应该使用<code>Git</code>来对自己的应用进行版本控制。如果你希望将应用部署到<code>Heroku</code> 上,那么会需要用到它。另外,借助<code>Git</code>可以非常容易地回顾你的工作,通过查看代码的差异和历史来了解其演进过程。在第1 章中包含了很多开始使用<code>Git</code>的资源。<br>我还推荐你使用一个好的<code>IDE</code>。我们会看到如何使用<code>Spring Tool Suite</code>(免费)和<code>IntelliJ``Idea</code>(一个月的免费试用)实现快速起步。<br>如果你使用<code>Mac</code> 的话,应该了解一下<code>Homebrew(http``://brew.sh)</code>。通过使用这个包管理器,你可以安装本书中提到的所有工具。</p><h2 id="本书为谁而作"><a href="#本书为谁而作" class="headerlink" title="本书为谁而作"></a>本书为谁而作</h2><p>本书最适合已经熟悉<code>Spring</code> 编程基础知识并迫切希望扩展其<code>Web</code> 技能的开发人员。建议你事先掌握一些<code>Spring</code>框架的知识。</p><h2 id="示例代码下载"><a href="#示例代码下载" class="headerlink" title="示例代码下载"></a>示例代码下载</h2><p>你可以通过账号,在<a href="http://www.packtpub.com" target="_blank" rel="noopener">http://www.packtpub.com</a>下载所有你所购买的<code>Packt</code> 图书的示例代码文件。如果你是在其他途径购买的本书,那么可以访问<a href="http://www.packtpub.com/support" target="_blank" rel="noopener">http://www.packtpub.com/support</a>并进行注册,这些文件会直接邮件发送给你。<br>对于本书的样例代码,你也可以通过<a href="https://github.com/Mastering-Spring-MVC-4/mastering-spring-mvc4" target="_blank" rel="noopener">https://github.com/Mastering-Spring-MVC-4/mastering-spring-mvc4</a>进行下载。</p>]]></content>
      
      
      <categories>
          
          <category> 精通Spring MVC4 </category>
          
          <category> 第0章 前言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5.1.1 非类属性</title>
      <link href="/ReadingNotes//b6a9bf61/"/>
      <url>/ReadingNotes//b6a9bf61/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/b6a9bf61/#5-1-1-非类属性" class="header_1">5.1.1 非类属性</a>&nbsp;<br><a href="/ReadingNotes/b6a9bf61/#值回调" class="header_2">值回调</a>&nbsp;<br><a href="/ReadingNotes/b6a9bf61/#什么是值回调" class="header_3">什么是值回调</a>&nbsp;<br><a href="/ReadingNotes/b6a9bf61/#本文重点" class="header_1">本文重点</a>&nbsp;<br><a href="/ReadingNotes/b6a9bf61/#attr-方法" class="header_2">attr()方法</a>&nbsp;<br><a href="/ReadingNotes/b6a9bf61/#attr-方法的参数" class="header_3">attr()方法的参数</a>&nbsp;<br><a href="/ReadingNotes/b6a9bf61/#一个键值对参数" class="header_4">一个键值对参数</a>&nbsp;<br><a href="/ReadingNotes/b6a9bf61/#包换键值对的对象作为参数" class="header_4">包换键值对的对象作为参数</a>&nbsp;<br><a href="/ReadingNotes/b6a9bf61/#什么是值回调" class="header_3">什么是值回调</a>&nbsp;<br><a href="/ReadingNotes/b6a9bf61/#值回调可做什么" class="header_3">值回调可做什么</a>&nbsp;<br><a href="/ReadingNotes/b6a9bf61/#值回调的参数" class="header_3">值回调的参数</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="5-1-1-非类属性"><a href="#5-1-1-非类属性" class="headerlink" title="5.1.1 非类属性"></a>5.1.1 非类属性</h1><p>有时候,我们还需要操作其他一些属性,比如<code>id</code>、<code>rel</code>和<code>title</code>属性。<code>jQuery</code>为此也提供了<code>.attr()</code>和<code>.revoveAttr()</code>方法。这些方法让修改属性变成了小菜一碟。此外,通过<code>jQuery</code>还可以一次修改多个属性,同我们在第4章中使用<code>.css()</code>方法修改多个<code>CSS</code>属性的方式类似。<br>比如,我们可一次性修改链接的<code>id</code>、<code>rel</code>和<code>title</code>属性。首先来看一看我们例子中的<code>HTML</code>代码:</p><p>对于以上<code>HTML</code>,我们可以循环遍历<code>&lt;div class=&quot;chapter&quot;&gt;</code>中的每个链接,并逐个为它们添加属性。如果只想<code>为所有链接设置一个公共的属性值</code>,那么在<code>$(document).ready</code>处理程序中通过一行代码即可完成这一操作,如代码清单5-1所示。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Use attr() to add an id, rel, and title.</span></span><br><span class="line">  $(<span class="string">'div.chapter a'</span>).attr(&#123;<span class="attr">rel</span>: <span class="string">'external'</span>&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>与<code>.css()</code>方法很相似,<code>.attr()</code>方法也接受<code>一对</code>参数,第一个是属性名,第二个是属性值。不过,更常用的方式还是传入一个包含键值对的对象,如代码清单5-1所示。使用对象可以轻松地扩展,以便一次性地修改多个属性,如代码清单5-2所示。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  $(<span class="string">'div.chapter a'</span>).attr(&#123; </span><br><span class="line">    rel: <span class="string">'external'</span>, </span><br><span class="line">    title: <span class="string">'Learn more at Wikipedia'</span> </span><br><span class="line">  &#125;); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="值回调"><a href="#值回调" class="headerlink" title="值回调"></a>值回调</h2><p>如果我们想让每个匹配的元素都具有相同的一个或多个属性值,那么只要给<code>.attr()</code>传入一个静态的对象即可。不过,更常见的情况是为每个元素添加或修改的属性都必须具有不同的值。<br>例如,对于任何给定的文档,如果要保证<code>JavaScript</code>代码有效,那么每个id属性的值必须唯一。<strong>要为每个链接设置唯一的id,可以使用<code>jQuery</code>的<code>.css()</code>和<code>.each()</code>方法的另一个特性:<code>值回调</code></strong>。</p><h3 id="什么是值回调"><a href="#什么是值回调" class="headerlink" title="什么是值回调"></a>什么是值回调</h3><p><strong>值回调其实就是给参数传入一个函数,而不是传入具体的值。这个函数会针对匹配的元素集中的每个元素都调用一次,调用后的返回值将作为属性的值</strong>。例如,<strong>可以使用值回调来为每个元素生成唯一的<code>id</code>值</strong>,参见代码清单5-3。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  $(<span class="string">'div.chapter a'</span>).attr(&#123; </span><br><span class="line">    rel: <span class="string">'external'</span>, </span><br><span class="line">    title: <span class="string">'Learn more at Wikipedia'</span>, </span><br><span class="line">    id: <span class="function"><span class="keyword">function</span>(<span class="params">index, oldValue</span>) </span>&#123; </span><br><span class="line">      <span class="keyword">return</span> <span class="string">'wikilink-'</span> + index; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>每次触发值回调,都会给它传入<code>两个参数</code>。<br>第一个是一个整数,表示迭代次数,我们在此利用这个值为第一个链接生成的<code>id</code>是<code>wikilink-0</code>,为第二个链接生成的<code>id</code>是<code>wikilink-1</code>,以此类推。代码清单5-3并没有用到第二个参数,这个参数中保存的是修改之前属性的值。</p><h1 id="本文重点"><a href="#本文重点" class="headerlink" title="本文重点"></a>本文重点</h1><h2 id="attr-方法"><a href="#attr-方法" class="headerlink" title="attr()方法"></a>attr()方法</h2><p><code>attr()</code>方法可以设置属性,<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div.chapter a'</span>).attr(&#123;<span class="attr">rel</span>: <span class="string">'external'</span>&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="attr-方法的参数"><a href="#attr-方法的参数" class="headerlink" title="attr()方法的参数"></a>attr()方法的参数</h3><h4 id="一个键值对参数"><a href="#一个键值对参数" class="headerlink" title="一个键值对参数"></a>一个键值对参数</h4><p><code>.attr()</code>方法接受<code>一对</code>参数,第一个是属性名,第二个是属性值</p><h4 id="包换键值对的对象作为参数"><a href="#包换键值对的对象作为参数" class="headerlink" title="包换键值对的对象作为参数"></a>包换键值对的对象作为参数</h4><p>使用对象作为参数,可以轻松地扩展,以便一次性地修改多个属性。</p><h3 id="什么是值回调-1"><a href="#什么是值回调-1" class="headerlink" title="什么是值回调"></a>什么是值回调</h3><p><strong>值回调其实就是给参数传入一个函数,而不是传入具体的值。这个函数会针对匹配的元素集中的每个元素都调用一次,调用后的返回值将作为属性的值</strong>。</p><h3 id="值回调可做什么"><a href="#值回调可做什么" class="headerlink" title="值回调可做什么"></a>值回调可做什么</h3><p><strong>可以使用值回调来为每个元素生成唯一的<code>id</code>值</strong></p><h3 id="值回调的参数"><a href="#值回调的参数" class="headerlink" title="值回调的参数"></a>值回调的参数</h3><p>每次触发值回调,都会给它传入<code>两个参数</code></p><ul><li>第一个是一个整数,表示迭代次数。</li><li>第二个参数中保存的是修改之前属性的值。</li></ul>]]></content>
      
      
      <categories>
          
          <category> jQuery基础教程 第4版 </category>
          
          <category> 第5章 操作DOM </category>
          
          <category> 5.1 操作属性 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5.1 操作属性</title>
      <link href="/ReadingNotes//99e39859/"/>
      <url>/ReadingNotes//99e39859/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/99e39859/#5-1-操作属性" class="header_1">5.1 操作属性</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="5-1-操作属性"><a href="#5-1-操作属性" class="headerlink" title="5.1 操作属性"></a>5.1 操作属性</h1><p>在本书前4章里,我们经常使用<code>.addClass()</code>和<code>.removeClass()</code>方法来示范如何改变页面上元素的外观。虽然我们一般会说这两个方法在操作类属性,但<code>jQuery</code>实际上是在操作<code>DOM</code>中的<code>className</code>属性。换句话说,<code>.addClass()</code>方法创建或增加这个属性,而<code>.removeClass()</code>则删除或缩短该属性。而具备了这两种操作的<code>.toggleClass()</code>方法能够交替地添加和移除类。这样,我们就具有了处理类的一种有效而可靠的方式。这些方法特别有用,因为它们可以在某个类已经存在的情况下不添加该类(例如,不会出现<code>&lt;div class=&quot;first first&quot;&gt;</code>的情况) ,也可以正确处理给一个元素应用多个类的情况(比如<code>&lt;div class=&quot;first``second&quot;&gt;</code>)。</p>]]></content>
      
      
      <categories>
          
          <category> jQuery基础教程 第4版 </category>
          
          <category> 第5章 操作DOM </category>
          
          <category> 5.1 操作属性 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第5章 操作DOM</title>
      <link href="/ReadingNotes//9f710941/"/>
      <url>/ReadingNotes//9f710941/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/9f710941/#第5章-操作DOM" class="header_1">第5章 操作DOM</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="第5章-操作DOM"><a href="#第5章-操作DOM" class="headerlink" title="第5章 操作DOM"></a>第5章 操作DOM</h1><p>所谓<code>Web</code>体验,就是<code>Web</code>服务器与<code>Web</code>浏览器之间合作的结果。过去,都是由服务器生成<code>HTML</code>文档,然后浏览器负责解释并显示该文档。后来,正如我们所看到的,这种情况发生了变化,我们可以用<code>CSS</code>技术来动态修改页面的外观。然而,要想把<code>JavaScript</code>的威力真正发挥出来,还得学会修改文档本身。<br>本章将学习以下内容:</p><ol><li>利用<code>DOM</code>提供的接口修改文档;</li><li>在网页中根据需要创建元素和文本;</li><li>移动或删除元素;</li><li>通过添加、删除或修改它们的属性来实现文档内容的变换。<!--SSTStop--></li></ol>]]></content>
      
      
      <categories>
          
          <category> jQuery基础教程 第4版 </category>
          
          <category> 第5章 操作DOM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.6 小结</title>
      <link href="/ReadingNotes//65502783/"/>
      <url>/ReadingNotes//65502783/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/65502783/#4-6-小结" class="header_1">4.6 小结</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="4-6-小结"><a href="#4-6-小结" class="headerlink" title="4.6 小结"></a>4.6 小结</h1><p>通过使用本章介绍的效果方法,读者应该能够通过<code>JavaScript</code>来修改行内样式属性,为元素应用预定义的<code>jQuery</code>效果,创建自定义动画。特别地,我们学习了使用<code>.css()</code>或<code>.animate()</code>来渐进地增大或减小文本的大小,通过修改多个属性来逐渐显示和隐藏页面元素。此外,还学习了通过许多方式,同时地或相继地为多个元素实现动画效果。<br>在本书前面四章中,所有例子都只涉及了操作硬编码到页面的<code>HTML</code>中的元素。在第5章中,我们会探索直接操作<code>DOM</code>,包括使用<code>jQuery</code>来创建新元素的方式,以及把它们插入到选择的<code>DOM</code>结构中。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> jQuery基础教程 第4版 </category>
          
          <category> 第4章 样式与动画 </category>
          
          <category> 4.6 小结 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.5.3 简单概括</title>
      <link href="/ReadingNotes//54d133df/"/>
      <url>/ReadingNotes//54d133df/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/54d133df/#4-5-3-简单概括" class="header_1">4.5.3 简单概括</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="4-5-3-简单概括"><a href="#4-5-3-简单概括" class="headerlink" title="4.5.3 简单概括"></a>4.5.3 简单概括</h1><p>随着在应用效果时需要考虑的变化的增多,要记住这些效果是同时发生还是按顺序发生会变得越来越困难。因此,下面简单的概括可能会对你有所帮助。<br>(1) 一组元素上的效果:</p><ul><li>当在一个<code>.animate()</code>方法中以多个属性的方式应用时,是同时发生的;</li><li>当以方法连缀的形式应用时,是按顺序发生的(排队效果)——除非<code>queue</code>选项值为<code>false</code>。</li></ul><p>(2) 多组元素上的效果:</p><ul><li>默认情况下是同时发生的;</li><li>当在另一个效果方法或者在<code>.queue()</code>方法的回调函数中应用时,是按顺序发生的(排队效果)。<!--SSTStop--></li></ul>]]></content>
      
      
      <categories>
          
          <category> jQuery基础教程 第4版 </category>
          
          <category> 第4章 样式与动画 </category>
          
          <category> 4.5 并发与排队效果 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.5.2 处理多组元素</title>
      <link href="/ReadingNotes//f80559a9/"/>
      <url>/ReadingNotes//f80559a9/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/f80559a9/#4-5-2-处理多组元素" class="header_1">4.5.2 处理多组元素</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="4-5-2-处理多组元素"><a href="#4-5-2-处理多组元素" class="headerlink" title="4.5.2 处理多组元素"></a>4.5.2 处理多组元素</h1><p>与一组元素的情况不同,当为不同组的元素应用效果时,这些效果几乎会同时发生。为了示范这种并发的效果,我们可以在向上滑出一个段落时,向下滑入另一个段落。首先,要用到示例文档中的如下三、四段文本:<br>接着,为了更清楚地看到效果发生期间的变化,我们为第三段和第四段分别添加1像素宽的边框和灰色的背景。同时,在<code>DOM</code>就绪时立即隐藏第4段,参见代码清单4-23。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  $(<span class="string">'p'</span>).eq(<span class="number">2</span>).css(<span class="string">'border'</span>, <span class="string">'1px solid #333'</span>); </span><br><span class="line">  $(<span class="string">'p'</span>).eq(<span class="number">3</span>).css(<span class="string">'backgroundColor'</span>, <span class="string">'#ccc'</span>).hide(); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>这样,示例文档会显示开始的段落,然后是<code>read more</code>链接和带边框的段落,如图4-11所示。<br>最后,为第三段添加<code>click</code>处理程序,以便单击它时会将第3段向上滑(最终滑出视图) ,同时将第4段向下滑(最终滑入视图),参见代码清单4-24。<br>通过截取到的这两个滑动效果变化过程中的屏幕截图,如图4-12所示,可以证实,它们确实是同时发生的。<br>原来可见的第三个段落,正处于向上滑到一半的状态;与此同时,原来隐藏的第四个段落,正处于向下滑到一半的状态。<br><strong>排队回调函数</strong><br>为了对不同元素上的效果实现排队,<code>jQuery</code>为每个效果方法都提供了回调函数。同我们在事件处理程序和<code>.queue()</code>方法中看到的一样,回调函数就是作为方法的参数传递的一个普通函数。在效果方法中,它们是方法的最后一个参数。<br>当使用回调函数排队两个滑动效果时,可以在第3个段落滑上之前,先将第4个段落滑下。首先,我们看一看怎样通过回调函数设置<code>.slideDown()</code>方法,如代码清单4-25所示。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  $(<span class="string">'p'</span>).eq(<span class="number">2</span>) </span><br><span class="line">    .css(<span class="string">'border'</span>, <span class="string">'1px solid #333'</span>) </span><br><span class="line">    .click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">      $(<span class="keyword">this</span>).next().slideDown(<span class="string">'slow'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        $(<span class="keyword">this</span>).slideUp(<span class="string">'slow'</span>);  </span><br><span class="line">      &#125;); </span><br><span class="line">    &#125;); </span><br><span class="line">  $(<span class="string">'p'</span>).eq(<span class="number">3</span>).css(<span class="string">'backgroundColor'</span>, <span class="string">'#ccc'</span>).hide(); </span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><br>不过,这里我们需要注意的是,必须搞清楚要滑上的到底是哪个段落。因为回调函数位于<code>.slideDown()</code>方法中,所以<code>$(this)</code>的环境已经发生了改变。现在,<code>$(this)</code>已经不再是指向<code>.click()</code>的第三个段落了——由于<code>.slideDown()</code>方法是通过<code>$(this).next()</code>调用的,所以该方法中的一切现在都将<code>$(this)</code>视为下一个同辈元素,即第四个段落。因而,如果在回调函数中放入<code>$(this).slideUp(&#39;slow&#39;)</code>, 那么我们最终还会把刚刚显示出来的段落给隐藏起来。<br>可靠地引用<code>$(this)</code>的一种简单方法,就是在<code>.click()</code>方法内部把它保存到一个变量中,比如<code>var</code> <code>$ clickedItem</code> = <code>$(this)</code>。<br>这样,无论是在回调函数的外部还是内部,<code>$clickedItem</code>引用的都是第三个段落。使用了新变量之后的代码,参见代码清单4-26。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  $(<span class="string">'p'</span>).eq(<span class="number">2</span>) </span><br><span class="line">    .css(<span class="string">'border'</span>, <span class="string">'1px solid #333'</span>) </span><br><span class="line">    .click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">      <span class="keyword">var</span> $clickedItem = $(<span class="keyword">this</span>); </span><br><span class="line">      $clickedItem.next().slideDown(<span class="string">'slow'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">       $clickedItem.slideUp(<span class="string">'slow'</span>);  </span><br><span class="line">      &#125;); </span><br><span class="line">    &#125;); </span><br><span class="line">  $(<span class="string">'p'</span>).eq(<span class="number">3</span>).css(<span class="string">'backgroundColor'</span>, <span class="string">'#ccc'</span>).hide(); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>这次效果中途的屏幕截图如图4-13所示,第三段和第四段同时都是可见的,而且,第四段已经完成下滑,第三段刚要开始上滑。<br>既然讨论了回调函数,那么就可以回过头来基于代码清单4-22解决在接近一系列效果结束时改变背景颜色的问题了。这次,我们不像前面那样使用<code>.queue()</code>方法,而是使用回调函数,如代码清单4-27所示。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  $(<span class="string">'div.label'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> paraWidth = $(<span class="string">'div.speech p'</span>).outerWidth(); </span><br><span class="line">    <span class="keyword">var</span> $switcher = $(<span class="keyword">this</span>).parent(); </span><br><span class="line">    <span class="keyword">var</span> switcherWidth = $switcher.outerWidth(); </span><br><span class="line">    $switcher </span><br><span class="line">      .css(&#123;<span class="attr">position</span>: <span class="string">'relative'</span>&#125;) </span><br><span class="line">      .fadeTo(<span class="string">'fast'</span>, <span class="number">0.5</span>) </span><br><span class="line">      .animate(&#123; </span><br><span class="line">        left: paraWidth - switcherWidth </span><br><span class="line">      &#125;, &#123; </span><br><span class="line">        duration: <span class="string">'slow'</span>, </span><br><span class="line">        queue: <span class="literal">false</span> </span><br><span class="line">      &#125;) </span><br><span class="line">      .fadeTo(<span class="string">'slow'</span>, <span class="number">1.0</span>) </span><br><span class="line">      .slideUp(<span class="string">'slow'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        $switcher.css(&#123;<span class="attr">backgroundColor</span>: <span class="string">'#f00'</span>&#125;); </span><br><span class="line">      &#125;) </span><br><span class="line">      .slideDown(<span class="string">'slow'</span>); </span><br><span class="line">  &#125;); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>同前面一样,<code>&lt;div id=&quot;switcher&quot;&gt;</code>的背景颜色在它滑上之后滑下之前,变成了红色。注意,在使用交互的完成回调函数而不是<code>.queue()</code>时,不必在回调中调用<code>next()</code>。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> jQuery基础教程 第4版 </category>
          
          <category> 第4章 样式与动画 </category>
          
          <category> 4.5 并发与排队效果 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.5 并发与排队效果 4.5.1 处理一组元素</title>
      <link href="/ReadingNotes//8d0f89ac/"/>
      <url>/ReadingNotes//8d0f89ac/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/8d0f89ac/#4-5-并发与排队效果" class="header_1">4.5 并发与排队效果</a>&nbsp;<br><a href="/ReadingNotes/8d0f89ac/#4-5-1-处理一组元素" class="header_2">4.5.1 处理一组元素</a>&nbsp;<br><a href="/ReadingNotes/8d0f89ac/#1-越过队列" class="header_2">1. 越过队列</a>&nbsp;<br><a href="/ReadingNotes/8d0f89ac/#2-手工队列" class="header_2">2. 手工队列</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="4-5-并发与排队效果"><a href="#4-5-并发与排队效果" class="headerlink" title="4.5 并发与排队效果"></a>4.5 并发与排队效果</h1><p>通过刚才的例子,可以看出<code>.animate()</code>方法在为一组特定的元素创建并发效果时非常有用。然而,有的时候我们需要的则是排队效果,即让效果一个接一个地发生。</p><h2 id="4-5-1-处理一组元素"><a href="#4-5-1-处理一组元素" class="headerlink" title="4.5.1 处理一组元素"></a>4.5.1 处理一组元素</h2><p>当为同一组元素应用多重效果时,可以通过连缀这些效果轻易地实现排队。为了示范排队效果,我们仍以代码清单4-17为例,移动<code>Text Size</code>盒子、增加其高度、加宽其边框。不过,这次<strong>我们相继地执行这三个效果——很简单,只要把它们分别放在<code>.animate()</code>方法中并连缀起来即可</strong>,参见代码清单4-18。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  $(<span class="string">'div.label'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> paraWidth = $(<span class="string">'div.speech p'</span>).outerWidth(); </span><br><span class="line">    <span class="keyword">var</span> $switcher = $(<span class="keyword">this</span>).parent(); </span><br><span class="line">    <span class="keyword">var</span> switcherWidth = $switcher.outerWidth(); </span><br><span class="line">    $switcher </span><br><span class="line">      .css(&#123;<span class="attr">position</span>: <span class="string">'relative'</span>&#125;) </span><br><span class="line">      .animate(&#123;<span class="attr">left</span>: paraWidth - switcherWidth&#125;, <span class="string">'slow'</span>) </span><br><span class="line">      .animate(&#123;<span class="attr">height</span>: <span class="string">'+=20px'</span>&#125;, <span class="string">'slow'</span>) </span><br><span class="line">      .animate(&#123;<span class="attr">borderWidth</span>: <span class="string">'5px'</span>&#125;, <span class="string">'slow'</span>); </span><br><span class="line">  &#125;); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>虽然连缀允许我们把这两个<code>.animate()</code>方法放在同一行,但为了更好的可读性,这里故意将它们分开放在了各自的一行中。<br><strong>通过使用连缀,可以对其他任何<code>jQuery</code>效果进行排队</strong>,而并不限于<code>.animate()</code>方法。比如说,我们可以按照下列顺序对<code>&lt;div id=&quot;switcher&quot;&gt;</code>上的效果进行排队。<br>(1) 通过<code>.fadeTo()</code>将其不透明度减退为0.5。<br>(2) 通过<code>.animate()</code>将其移动到右侧。<br>(3) 通过<code>.fadeTo()</code>将其渐增回完全不透明。<br>(4) 通过<code>.slideUp()</code>隐藏它。<br>(5) 通过<code>.slideDown()</code>再将其显示出来。<br>我们所要做的,就是在代码中按照相同的顺序连缀这些效果,如代码清单4-19所示。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">'div.label'</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> paraWidth = $(<span class="string">'div.speech p'</span>).outerWidth();</span><br><span class="line">        <span class="keyword">var</span> $switcher = $(<span class="keyword">this</span>).parent();</span><br><span class="line">        <span class="keyword">var</span> switcherWidth = $switcher.outerWidth();</span><br><span class="line">        $switcher</span><br><span class="line">            .css(&#123; <span class="attr">position</span>: <span class="string">'relative'</span> &#125;)</span><br><span class="line">            .fadeTo(<span class="string">'fast'</span>, <span class="number">0.5</span>)</span><br><span class="line">            .animate(&#123; <span class="attr">left</span>: paraWidth - switcherWidth &#125;, <span class="string">'slow'</span>)</span><br><span class="line">            .fadeTo(<span class="string">'slow'</span>, <span class="number">1.0</span>)</span><br><span class="line">            .slideUp(<span class="string">'slow'</span>)</span><br><span class="line">            .slideDown(<span class="string">'slow'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="1-越过队列"><a href="#1-越过队列" class="headerlink" title="1. 越过队列"></a>1. 越过队列</h2><p>不过,要是想在这个<code>&lt;div&gt;</code>不透明度减退至一半的同时,把它移动到右侧应该怎么办呢?如果两个动画以相同速度执行,则可以简单地把它们组合到一个<code>.animate()</code>方法中。但这个例子中的<code>.fadeTo()</code>使用的速度字符串是’<code>fast&#39;</code>,而向右移动的动画使用的速度字符串是’<code>slow&#39;</code>。在这种情况下,第二种形式的<code>.animate()</code>方法又可以派上用场了,参见代码清单4-20。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  $(<span class="string">'div.label'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> paraWidth = $(<span class="string">'div.speech p'</span>).outerWidth(); </span><br><span class="line">    <span class="keyword">var</span> $switcher = $(<span class="keyword">this</span>).parent(); </span><br><span class="line">    <span class="keyword">var</span> switcherWidth = $switcher.outerWidth(); </span><br><span class="line">    $switcher </span><br><span class="line">      .css(&#123;<span class="attr">position</span>: <span class="string">'relative'</span>&#125;) </span><br><span class="line">      .fadeTo(<span class="string">'fast'</span>, <span class="number">0.5</span>) </span><br><span class="line">      .animate(&#123; </span><br><span class="line">        left: paraWidth - switcherWidth </span><br><span class="line">      &#125;, &#123; </span><br><span class="line">        duration: <span class="string">'slow'</span>, </span><br><span class="line">        queue: <span class="literal">false</span> </span><br><span class="line">      &#125;) </span><br><span class="line">      .fadeTo(<span class="string">'slow'</span>, <span class="number">1.0</span>) </span><br><span class="line">      .slideUp(<span class="string">'slow'</span>) </span><br><span class="line">      .slideDown(<span class="string">'slow'</span>); </span><br><span class="line">  &#125;); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>第二个参数(即选项对象)包含了<code>queue</code>选项,把该选项设置为<code>false</code>即可让当前动画与前一个动画同时开始。</p><h2 id="2-手工队列"><a href="#2-手工队列" class="headerlink" title="2. 手工队列"></a>2. 手工队列</h2><p>有关为一组元素应用排队效果的最后一个需要注意的问题,就是排队不能自动应用到其他的非效果方法,如<code>.css()</code>。下面,假设我们想在<code>.slideUp()</code>执行后但在<code>.slideDown()</code>执行前,把<code>&lt;div id=&quot;switcher&quot;&gt;</code>的背景颜色修改为红色,可以尝试像代码清单4-21这样来做。</p><p>然而,即使把修改背景颜色的代码放在连缀序列中正确的位置上,它也会在单击后立即执行。把非效果方法添加到队列中的一种方式,就是使用<code>.queue()</code>方法。代码清单4-22就是在这个例子中使用<code>.queue()</code>方法的代码片段。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//其他代码...</span></span><br><span class="line">    $(<span class="string">'div.label'</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> paraWidth = $(<span class="string">'div.speech p'</span>).outerWidth();</span><br><span class="line">        <span class="keyword">var</span> $switcher = $(<span class="keyword">this</span>).parent();</span><br><span class="line">        <span class="keyword">var</span> switcherWidth = $switcher.outerWidth();</span><br><span class="line">        $switcher</span><br><span class="line">            .css(&#123; <span class="attr">position</span>: <span class="string">'relative'</span> &#125;)</span><br><span class="line">            .fadeTo(<span class="string">'fast'</span>, <span class="number">0.5</span>)</span><br><span class="line">            .animate(&#123;</span><br><span class="line">                left: paraWidth - switcherWidth</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                    duration: <span class="string">'slow'</span>,</span><br><span class="line">                    queue: <span class="literal">false</span></span><br><span class="line">                &#125;)</span><br><span class="line">            .fadeTo(<span class="string">'slow'</span>, <span class="number">1.0</span>)</span><br><span class="line">            .slideUp(<span class="string">'slow'</span>)</span><br><span class="line">            .queue(<span class="function"><span class="keyword">function</span> (<span class="params">next</span>) </span>&#123;</span><br><span class="line">                $switcher.css(&#123; <span class="attr">backgroundColor</span>: <span class="string">'#f00'</span> &#125;);</span><br><span class="line">                next();</span><br><span class="line">            &#125;)</span><br><span class="line">            .slideDown(<span class="string">'slow'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>像这样传递一个回调函数,<code>.queue()</code>方法就可以把该函数添加到相应元素的效果队列中。在这个函数内部,我们把背景颜色设置为红色,然后又调用了<code>next()</code>方法,其返回的结果将作为参数传给回调函数。添加的这个<code>next</code> ()方法可以让队列在中断的地方再接续起来,然后再与后续的<code>.slideDown(&#39;slow&#39;)</code>连缀在一起。如果在此不使用<code>next()</code>方法,动画就会中断。<br>在下面讨论多组元素的效果之后,我们会介绍另一种向队列中添加非效果方法的方式。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> jQuery基础教程 第4版 </category>
          
          <category> 第4章 样式与动画 </category>
          
          <category> 4.5 并发与排队效果 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.4 创建自定义动画</title>
      <link href="/ReadingNotes//ec993adb/"/>
      <url>/ReadingNotes//ec993adb/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/ec993adb/#4-4-创建自定义动画" class="header_1">4.4 创建自定义动画</a>&nbsp;<br><a href="/ReadingNotes/ec993adb/#animate方法类型" class="header_2">animate方法类型</a>&nbsp;<br><a href="/ReadingNotes/ec993adb/#类型2" class="header_3">类型2</a>&nbsp;<br><a href="/ReadingNotes/ec993adb/#4-4-1-手工创建效果" class="header_1">4.4.1 手工创建效果</a>&nbsp;<br><a href="/ReadingNotes/ec993adb/#4-4-2-一次给多个属性添加动画效果" class="header_2">4.4.2 一次给多个属性添加动画效果</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="4-4-创建自定义动画"><a href="#4-4-创建自定义动画" class="headerlink" title="4.4 创建自定义动画"></a>4.4 创建自定义动画</h1><p>除了预置的效果方法外,<code>jQuery</code>还提供了一个强大的<code>.animate()</code>方法,用于创建控制更加精细的自定义动画。</p><h2 id="animate方法类型"><a href="#animate方法类型" class="headerlink" title="animate方法类型"></a>animate方法类型</h2><p><code>.animate()</code>方法有两种形式,第一种形式接收以下4个参数。</p><ol><li>一个包含样式属性及值的<code>对象</code>:与本章前面讨论的<code>.css()</code>方法中的参数类似。</li><li>可选的<code>时长</code>参数:既可以是预置的字符串,也可以是毫秒数值。</li><li>可选的<code>缓动</code>(<code>easing</code>)类型:现在我们先不介绍,这是第11章中将要讨论的一个高级选项。</li><li>可选的<code>回调函数</code>:将在本章后面讨论。把这4个参数放到一起,结果如下所示:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.animate(&#123;<span class="attr">property1</span>: <span class="string">'value1'</span>, <span class="attr">property2</span>: <span class="string">'value2'</span>&#125;,  </span><br><span class="line">duration, easing, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    alert(<span class="string">'The animation is finished.'</span>); </span><br><span class="line">  &#125; </span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="类型2"><a href="#类型2" class="headerlink" title="类型2"></a>类型2</h3>第二种形式接受两个参数,一个<code>属性对象</code>和一个<code>选项对象</code>:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.animate(&#123;properties&#125;, &#123;options&#125;)</span><br></pre></td></tr></table></figure>实际上,这里的第二个参数是把第一种形式的第2～4个参数封装在了另一个对象中,同时又添加了两个选项。考虑到可读性并调整了换行之后,调用第二种形式的方法的代码如下:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.animate(</span><br><span class="line">    &#123;</span><br><span class="line">        property1: <span class="string">'value1'</span>,</span><br><span class="line">        property2: <span class="string">'value2'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        duration: <span class="string">'value'</span>,</span><br><span class="line">        easing: <span class="string">'value'</span>,</span><br><span class="line">        specialEasing: </span><br><span class="line">        &#123;</span><br><span class="line">            property1: <span class="string">'easing1'</span>,</span><br><span class="line">            property2: <span class="string">'easing2'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        complete: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            alert(<span class="string">'The animation is finished.'</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        queue: <span class="literal">true</span>,</span><br><span class="line">        step: callback</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>现在,我们使用第一种形式的<code>.animate()</code>方法,但在本章后面介绍排队效果时会使用其第二种形式。<h1 id="4-4-1-手工创建效果"><a href="#4-4-1-手工创建效果" class="headerlink" title="4.4.1 手工创建效果"></a>4.4.1 手工创建效果</h1>现在,我们已经介绍了几个用于显示和隐藏元素的预定义方法。为了讨论<code>.animate()</code>方法,有必要看一看怎么通过这个低级接口来实现与调用<code>.slideToggle()</code>相同的效果。在此,我们把前面例子中调用<code>.slideToggle()</code>方法的代码替换成了自定义动画代码,参见代码清单4-13。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> $speech = $(<span class="string">'div.speech'</span>);</span><br><span class="line">  <span class="keyword">var</span> defaultSize = $speech.css(<span class="string">'fontSize'</span>);</span><br><span class="line">  $(<span class="string">'#switcher button'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="built_in">parseFloat</span>($speech.css(<span class="string">'fontSize'</span>));</span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">this</span>.id) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'switcher-large'</span>:</span><br><span class="line">        num *= <span class="number">1.4</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'switcher-small'</span>:</span><br><span class="line">        num /= <span class="number">1.4</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        num = <span class="built_in">parseFloat</span>(defaultSize);</span><br><span class="line">    &#125;</span><br><span class="line">    $speech.css(<span class="string">'fontSize'</span>, num + <span class="string">'px'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> $firstPara = $(<span class="string">'p'</span>).eq(<span class="number">1</span>);</span><br><span class="line">  $firstPara.hide();</span><br><span class="line">  $(<span class="string">'a.more'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">    <span class="comment">// 自定义动画</span></span><br><span class="line">    $firstPara.animate(&#123;<span class="attr">height</span>: <span class="string">'toggle'</span>&#125;, <span class="string">'slow'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> $link = $(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> ($link.text() == <span class="string">'read more'</span>) &#123;</span><br><span class="line">      $link.text(<span class="string">'read less'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      $link.text(<span class="string">'read more'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>通过这个例子可以看出,<code>.animate()</code>方法针对<code>CSS</code>属性提供了方便简写值:<code>&#39;show&#39;</code>、<code>&#39;hide&#39;</code>和<code>&#39;toggle&#39;</code>, 以便在简写方法不适用时提供另一种简化<code>.slideToggle()</code>等内置效果方法的方式。<h2 id="4-4-2-一次给多个属性添加动画效果"><a href="#4-4-2-一次给多个属性添加动画效果" class="headerlink" title="4.4.2 一次给多个属性添加动画效果"></a>4.4.2 一次给多个属性添加动画效果</h2>使用<code>.animate()</code>方法可以同时修改多个<code>CSS</code>属性。例如,要在切换第二个段落时,创建一个同时具有滑动和淡入淡出效果的动画,只需在<code>.animate()</code>方法的属性对象参数中添加一个<code>opacity</code>属性值对即可,参见代码清单4-14。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $firstPara = $(<span class="string">'p'</span>).eq(<span class="number">1</span>);</span><br><span class="line">$firstPara.hide();</span><br><span class="line">$(<span class="string">'a.more'</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">    $firstPara.animate(&#123;</span><br><span class="line">        opacity: <span class="string">'toggle'</span>,</span><br><span class="line">        height: <span class="string">'toggle'</span></span><br><span class="line">    &#125;, <span class="string">'slow'</span>);</span><br><span class="line">    <span class="keyword">var</span> $link = $(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> ($link.text() == <span class="string">'read more'</span>) &#123;</span><br><span class="line">        $link.text(<span class="string">'read less'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        $link.text(<span class="string">'read more'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>此外,不仅可以在简写效果方法中使用样式属性,也可以使用其他<code>CSS</code>属性,如:<code>left</code>、<code>top</code>、<code>fontSize</code>、<code>margin</code>、<code>padding</code>和<code>borderWidth</code>。还记得改变演讲段落文本大小的脚本吗?要实现同样的文本大小变化动画,只要把<code>.css()</code>方法替换成<code>.animate()</code>方法即可,参见代码清单4-15。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> $speech = $(<span class="string">'div.speech'</span>); </span><br><span class="line">  <span class="keyword">var</span> defaultSize = $speech.css(<span class="string">'fontSize'</span>); </span><br><span class="line">  $(<span class="string">'#switcher button'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> num = <span class="built_in">parseFloat</span>($speech.css(<span class="string">'fontSize'</span>)); </span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">this</span>.id) &#123; </span><br><span class="line">      <span class="keyword">case</span> <span class="string">'switcher-large'</span>: </span><br><span class="line">        num *= <span class="number">1.4</span>;       </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">      <span class="keyword">case</span> <span class="string">'switcher-small'</span>: </span><br><span class="line">        num /= <span class="number">1.4</span>; </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">      <span class="keyword">default</span>: </span><br><span class="line">        num = <span class="built_in">parseFloat</span>(defaultSize);  </span><br><span class="line">    &#125; </span><br><span class="line">    $speech.animate(&#123;<span class="attr">fontSize</span>: num + <span class="string">'px'</span>&#125;, <span class="string">'slow'</span>); </span><br><span class="line">  &#125;); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>再使用其他属性,则可以创造出更复杂的效果。例如,可以在把某个项从页面左侧移动到右侧的同时,让该项的高度增加20像素并使其边框宽度增加到5像素。下面,我们就把这个效果应用于<code>&lt;div id=&quot;switcher&quot;&gt;</code>盒子。图4-8显示了应用效果之前的画面。<br>在可变宽度的布局中,需要计算盒子在与页面右侧对齐之前应该移动的距离。假设段落宽度为100%,可以从段落宽度中减去<code>Text Size</code>盒子的宽度。<strong>我们使用<code>jQuery</code>的<code>.outWidth()</code>方法来计算宽度,包括内边距及边框宽度。我们还使用这个方法计算转换器新的<code>left</code>属性</strong>。对于这个例子而言,我们打算通过单击按钮上面的<code>Text Size</code>文本来触发动画,参见代码清单4-16。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  $(<span class="string">'div.label'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> paraWidth = $(<span class="string">'div.speech p'</span>).outerWidth(); </span><br><span class="line">    <span class="keyword">var</span> $switcher = $(<span class="keyword">this</span>).parent(); </span><br><span class="line">    <span class="keyword">var</span> switcherWidth = $switcher.outerWidth(); </span><br><span class="line">    $switcher.animate(&#123; </span><br><span class="line">      borderWidth: <span class="string">'5px'</span>, </span><br><span class="line">      left: paraWidth - switcherWidth, </span><br><span class="line">      height: <span class="string">'+=20px'</span> </span><br><span class="line">    &#125;, <span class="string">'slow'</span>); </span><br><span class="line">  &#125;); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>在此,有必要详细解释一下这些动画属性。首先,<code>borderWidth</code>属性很明显,只要给它指定一个常量值加一个单位即可,就像在样式表中一样。其次,<code>left</code>属性是计算的数值。这些属性值的单位后缀是可选的,如果不指定,就会默认以px作为单位。最后,<code>height</code>属性使用我们以前没有遇到过的语法,其中属性值前面的<code>+=</code>操作符表示相对值。在这里表示的意思不是以动画方式变化到20像素,而是在原来基础上再以动画方式变化20像素。因为涉及特殊字符问题,所以必须以字符串形式指定相对值,也就是说必须把值放到一对括号内。<!--SSTStop--></li></ol>]]></content>
      
      
      <categories>
          
          <category> jQuery基础教程 第4版 </category>
          
          <category> 第4章 样式与动画 </category>
          
          <category> 4.4 创建自定义动画 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.3.4 切换可见性</title>
      <link href="/ReadingNotes//1f645f17/"/>
      <url>/ReadingNotes//1f645f17/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/1f645f17/#4-3-4-切换可见性" class="header_1">4.3.4 切换可见性</a>&nbsp;<br><a href="/ReadingNotes/1f645f17/#如何切换可见性" class="header_2">如何切换可见性</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="4-3-4-切换可见性"><a href="#4-3-4-切换可见性" class="headerlink" title="4.3.4 切换可见性"></a>4.3.4 切换可见性</h1><p>有时候,我们需要切换某些元素的可见性,而不像前面例子中那样只把它们显示出来。要实现切换,可以先检查匹配元素的可见性,然后再添加适当的方法。在此,仍然以淡入淡出效果为例,可以把示例脚本修改为如代码清单4-11所示。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> $firstPara = $(<span class="string">'p'</span>).eq(<span class="number">1</span>); </span><br><span class="line">  $firstPara.hide();   </span><br><span class="line">  $(<span class="string">'a.more'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123; </span><br><span class="line">    event.preventDefault(); </span><br><span class="line">    <span class="keyword">if</span> ($firstPara.is(<span class="string">':hidden'</span>)) &#123; </span><br><span class="line">      $firstPara.fadeIn(<span class="string">'slow'</span>);  </span><br><span class="line">      $(<span class="keyword">this</span>).text(<span class="string">'read less'</span>); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">      $firstPara.fadeOut(<span class="string">'slow'</span>); </span><br><span class="line">      $(<span class="keyword">this</span>).text(<span class="string">'read more'</span>); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>与我们在本章前面所做的一样,首先缓存选择符以避免重复遍历<code>DOM</code>。而且,这里也不再隐藏被单击的链接,而是修改它的文本。<br>使用<code>if else</code>语句切换元素的可见性是非常自然的方式。但通过<code>jQuery</code>复合效果方法,却不一定非要使用这个条件语句(尽管在这个例子中,需要条件语句来修改链接的文本) 。</p><p><code>jQuery</code>提供了一个<code>.toggle()</code>方法,该方法的作用类似于<code>.show()</code>和<code>.hide()</code>方法,而且与它们一样的是,<code>.toggle()</code>方法时长参数也是可选的。<br>另一个复合方法是<code>.slideToggle()</code>,该方法通过逐渐增加或减少元素高度来显示或隐藏元素。代码清单4-12是使用<code>.slideToggle()</code>方法的脚本。</p><!--SSTStart--><h2 id="如何切换可见性"><a href="#如何切换可见性" class="headerlink" title="如何切换可见性"></a>如何切换可见性</h2><p>1.使用<code>if else</code>语句判断可见性,然后在调用显示,或隐藏方法实现<br>2.使用<code>jQuery</code>事项的方法实现,如下所示:</p><ul><li><code>.toggle()</code>方法可以可以切换<code>显示/隐藏</code>效果，可以理解为:交替执行<code>.show()</code>和<code>.hide()</code>这两个方法.</li><li><code>.slideToggle()</code>方法可以切换<code>滑上/滑下</code>效果，可以理解为:交替执行:<code>.slideDown()</code>和<code>.slideUp()</code>这两个方法</li><li><code>.fadeToggle()</code>方法可以切换<code>淡入/淡出</code>效果,可以理解为交替执行<code>.fadeIn(),.fadeOut()</code>这两个方法<!--SSTStop--></li></ul>]]></content>
      
      
      <categories>
          
          <category> jQuery基础教程 第4版 </category>
          
          <category> 第4章 样式与动画 </category>
          
          <category> 4.3 效果和时长 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.3.3 滑上和滑下</title>
      <link href="/ReadingNotes//f4792449/"/>
      <url>/ReadingNotes//f4792449/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/f4792449/#4-3-3-滑上和滑下" class="header_1">4.3.3 滑上和滑下</a>&nbsp;<br><a href="/ReadingNotes/f4792449/#文档流之外的元素适合淡入淡出" class="header_2">文档流之外的元素适合淡入淡出</a>&nbsp;<br><a href="/ReadingNotes/f4792449/#滑上滑下" class="header_2">滑上滑下</a>&nbsp;<br><a href="/ReadingNotes/f4792449/#两个方法的效果" class="header_2">两个方法的效果</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="4-3-3-滑上和滑下"><a href="#4-3-3-滑上和滑下" class="headerlink" title="4.3.3 滑上和滑下"></a>4.3.3 滑上和滑下</h1><h2 id="文档流之外的元素适合淡入淡出"><a href="#文档流之外的元素适合淡入淡出" class="headerlink" title="文档流之外的元素适合淡入淡出"></a>文档流之外的元素适合淡入淡出</h2><p>对于本来就处于文档流之外的元素,比较适合使用淡入和淡出动画。例如,对于那些覆盖在页面之上的”亮盒”元素来说,采用淡入和淡出就显得很自然。</p><p>不过,假如<strong>某个元素本来就处在文档流中</strong>,那再调用<code>.fadeIn()</code>就会导致文档”跳一下”,以便为新元素腾出地方来。但这种跳跃感在用户眼里就不总是那么美观了。</p><h2 id="滑上滑下"><a href="#滑上滑下" class="headerlink" title="滑上滑下"></a>滑上滑下</h2><p>,假如<strong>某个元素本来就处在文档流中</strong>,使用<code>jQuery</code>的<code>.slideDown()</code>和<code>.slideUp()</code>方法通常是正确的选择。这两个动画方法<strong>仅改变元素的高度</strong>。要让段落以垂直滑入的效果出现,可以像代码清单4-10这样调用<code>.slideDown(&#39;slow&#39;)</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  $(<span class="string">'p'</span>).eq(<span class="number">1</span>).hide();   </span><br><span class="line">  $(<span class="string">'a.more'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123; </span><br><span class="line">    event.preventDefault(); </span><br><span class="line">    $(<span class="string">'p'</span>).eq(<span class="number">1</span>).slideDown(<span class="string">'slow'</span>);  </span><br><span class="line">    $(<span class="keyword">this</span>).hide(); </span><br><span class="line">  &#125;); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>要实现相反的动画效果,应该调用<code>.slideUp()</code>。</p><h2 id="两个方法的效果"><a href="#两个方法的效果" class="headerlink" title="两个方法的效果"></a>两个方法的效果</h2><ul><li><code>.slideDown()</code>向下滑动,最终的效果是显示.</li><li><code>.slideUp()</code>向上滑动,最终的效果是隐藏<!--SSTStop--></li></ul>]]></content>
      
      
      <categories>
          
          <category> jQuery基础教程 第4版 </category>
          
          <category> 第4章 样式与动画 </category>
          
          <category> 4.3 效果和时长 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.3.2 淡入和淡出</title>
      <link href="/ReadingNotes//a547d4b0/"/>
      <url>/ReadingNotes//a547d4b0/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/a547d4b0/#4-3-2-淡入和淡出" class="header_1">4.3.2 淡入和淡出</a>&nbsp;<br><a href="/ReadingNotes/a547d4b0/#逐渐地增大不透明度" class="header_2">逐渐地增大不透明度</a>&nbsp;<br><a href="/ReadingNotes/a547d4b0/#逐渐减少不透明度" class="header_2">逐渐减少不透明度</a>&nbsp;<br><a href="/ReadingNotes/a547d4b0/#两个方法的效果" class="header_2">两个方法的效果</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="4-3-2-淡入和淡出"><a href="#4-3-2-淡入和淡出" class="headerlink" title="4.3.2 淡入和淡出"></a>4.3.2 淡入和淡出</h1><p>虽然使用<code>.show()</code>和<code>.hide()</code>方法在某种程度上可以创造漂亮的效果,但其效果有时候也可能会显得过于花哨。考虑到这一点,<code>jQuery</code>也提供了两个更为精细的内置动画方法。</p><h2 id="逐渐地增大不透明度"><a href="#逐渐地增大不透明度" class="headerlink" title="逐渐地增大不透明度"></a>逐渐地增大不透明度</h2><p>如果想在显示整个段落时,只是逐渐地增大其不透明度,那么可以使用<code>.fadeIn(&#39;slow&#39;)</code>方法,<code>.fadeIn()</code>方法会在一开始设置段落的尺寸,以便内容能够逐渐显示出来。</p><h2 id="逐渐减少不透明度"><a href="#逐渐减少不透明度" class="headerlink" title="逐渐减少不透明度"></a>逐渐减少不透明度</h2><p>类似地,要逐渐减少不透明度,可以使用<code>.fadeOut()</code>方法。</p><h2 id="两个方法的效果"><a href="#两个方法的效果" class="headerlink" title="两个方法的效果"></a>两个方法的效果</h2><ul><li><code>.fadeIn()</code>方法淡入,表示慢慢的进入显示器,也就是显示的意思</li><li><code>.fadeOut()</code>方法表示淡出,表示慢慢的移出显示器,也就是隐藏的意思<!--SSTStop--></li></ul>]]></content>
      
      
      <categories>
          
          <category> jQuery基础教程 第4版 </category>
          
          <category> 第4章 样式与动画 </category>
          
          <category> 4.3 效果和时长 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.3.1 指定显示速度</title>
      <link href="/ReadingNotes//57c04b63/"/>
      <url>/ReadingNotes//57c04b63/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/57c04b63/#4-3-1-指定显示速度" class="header_1">4.3.1 指定显示速度</a>&nbsp;<br><a href="/ReadingNotes/57c04b63/#使用字符串指定速度" class="header_2">使用字符串指定速度</a>&nbsp;<br><a href="/ReadingNotes/57c04b63/#使用毫秒数指定速度" class="header_2">使用毫秒数指定速度</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="4-3-1-指定显示速度"><a href="#4-3-1-指定显示速度" class="headerlink" title="4.3.1 指定显示速度"></a>4.3.1 指定显示速度</h1><h2 id="使用字符串指定速度"><a href="#使用字符串指定速度" class="headerlink" title="使用字符串指定速度"></a>使用字符串指定速度</h2><p>对于<code>jQuery</code>提供的任何效果,都可以指定两种预设的速度参数:’<code>slow&#39;</code>和’<code>fast&#39;</code>。</p><ul><li>使用<code>.show(&#39;slow&#39;)</code>会在600毫秒(0.6秒)内完成效果,</li><li>而<code>.show(&#39;fast&#39;)</code>则是200毫秒(0.2秒)。</li><li>如果传入的是其他字符串,<code>jQuery</code>就会在默认的400毫秒(0.4)秒内完成效果。</li></ul><h2 id="使用毫秒数指定速度"><a href="#使用毫秒数指定速度" class="headerlink" title="使用毫秒数指定速度"></a>使用毫秒数指定速度</h2><p>要指定更精确的速度,可以使用毫秒数值,例如<code>.show(850)</code>。注意,与字符串表示的速度参数名称不同,数值不需要使用引号。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> jQuery基础教程 第4版 </category>
          
          <category> 第4章 样式与动画 </category>
          
          <category> 4.3 效果和时长 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.3 效果和时长</title>
      <link href="/ReadingNotes//45c74840/"/>
      <url>/ReadingNotes//45c74840/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/45c74840/#4-3-效果和时长" class="header_1">4.3 效果和时长</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="4-3-效果和时长"><a href="#4-3-效果和时长" class="headerlink" title="4.3 效果和时长"></a>4.3 效果和时长</h1><p>当在<code>.show()</code>或<code>.hide()</code>中指定时长(或更准确地说,一个速度)参数时,就会产生动画效果,即效果会在一个特定的时间段内发生。<br>例如<code>.hide(&#39;duration&#39;)</code>方法,会同时减少元素的高度、宽度和不透明度,直至这3个属性的值都达到0,与此同时会为该元素应用<code>CSS</code>规则<code>display:none</code>。<br>而<code>.show(&#39; duration &#39;)</code>方法则会从上到下增大元素的高度,从左到右增大元素的宽度,同时从0到1增加元素的不透明度,直至其内容完全可见。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> jQuery基础教程 第4版 </category>
          
          <category> 第4章 样式与动画 </category>
          
          <category> 4.3 效果和时长 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.2 隐藏和显示元素</title>
      <link href="/ReadingNotes//24bfbf2c/"/>
      <url>/ReadingNotes//24bfbf2c/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/24bfbf2c/#4-2-隐藏和显示元素" class="header_1">4.2 隐藏和显示元素</a>&nbsp;<br><a href="/ReadingNotes/24bfbf2c/#本文重点" class="header_1">本文重点</a>&nbsp;<br><a href="/ReadingNotes/24bfbf2c/#隐藏元素" class="header_2">隐藏元素</a>&nbsp;<br><a href="/ReadingNotes/24bfbf2c/#显示元素" class="header_2">显示元素</a>&nbsp;<br><a href="/ReadingNotes/24bfbf2c/#eq方法" class="header_2">eq方法</a>&nbsp;<br><a href="/ReadingNotes/24bfbf2c/#event-preventDefault方法" class="header_2">event.preventDefault方法</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="4-2-隐藏和显示元素"><a href="#4-2-隐藏和显示元素" class="headerlink" title="4.2 隐藏和显示元素"></a>4.2 隐藏和显示元素</h1><p>基本的<code>.hide()</code>和<code>.show()</code>方法不带任何参数。可以把它们想象成类似<code>.css(&#39;display&#39;</code>,’<code>string&#39;)</code>方法的简写方式,其中<code>string</code>是适当的显示值。不错,这两个方法的作用就是立即隐藏或显示匹配的元素集合,不带任何动画效果。<br>其中,<strong><code>.hide()</code>方法会将匹配的元素集合的内联<code>style</code>属性设置为<code>display:none</code></strong>。但它的聪明之处是,它能够在把<code>display</code>的值变成<code>none</code>之前,记住原先的<code>display</code>值,通常是<code>block</code>、<code>inline</code>或<code>inline-block</code>。<br>恰好相反,<strong><code>.show()</code>方法会将匹配的元素集合的<code>display</code>属性,恢复为应用<code>display: none</code>之前的可见属性</strong>。<br><code>.show()</code>和<code>.hide()</code>的这种特性,使得它们非常适合隐藏那些默认的<code>display</code>属性在样式表中被修改的元素。例如,在默认情况下,<code>&lt;li&gt;</code>元素具有<code>display:list-item</code>属性。但是,为了构建水平的导航菜单,它们可能会被修改成<code>display:inline</code>。而在类似这样的<code>&lt;li&gt;</code>元素上面使用<code>.show()</code>方法,不会简单地把它重置为默认的<code>display:list-item</code>,因为那样会把<code>&lt;li&gt;</code>元素放到单独的一行中;相反,<code>.show()</code>方法会把它恢复为先前的<code>display:inline</code>状态,从而维持水平的菜单设计。<br>要示范这两个方法,最明显的例子就是在前面的<code>HTML</code>中再添加一个新段落,然后在第一个段落末尾加上一个<code>read more</code>链接:</p><p>当<code>DOM</code>就绪时,选择一个元素并调用<code>.hide()</code>方法,参见代码清单4-6。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  $(<span class="string">'p'</span>).eq(<span class="number">1</span>).hide();   </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>这里的<code>.eq()</code>方法与第2章中讨论的:eq()伪类相似。这个方法返回<code>jQuery</code>对象,其中包含一个元素(索引从0开始)。在这个例子中,<code>.eq()</code>方法选择第二个段落并隐藏该段落,结果看起来如图4-3所示。</p><h1 id="本文重点"><a href="#本文重点" class="headerlink" title="本文重点"></a>本文重点</h1><!--SSTStart--><h2 id="隐藏元素"><a href="#隐藏元素" class="headerlink" title="隐藏元素"></a>隐藏元素</h2><p>,<strong><code>.hide()</code>方法会将匹配的元素集合的内联<code>style</code>属性设置为<code>display:none</code></strong>。并且能够在把<code>display</code>的值变成<code>none</code>之前,记住原先的<code>display</code>值。</p><h2 id="显示元素"><a href="#显示元素" class="headerlink" title="显示元素"></a>显示元素</h2><p><code>.show()</code>方法会将匹配的元素集合的<code>display</code>属性,恢复为<code>hide()</code>方法应用<code>display: none</code>之前的可见属性</p><h2 id="eq方法"><a href="#eq方法" class="headerlink" title="eq方法"></a>eq方法</h2><p>这里的<code>.eq(x)</code>方法与第2章中讨论的<code>:eq()</code>伪类相似。这个方法返回<code>jQuery</code>对象中的<code>x+1</code>个元素(从0开始),例如<code>$(&#39;p&#39;).eq(1)</code>表示取得第2个段落.</p><h2 id="event-preventDefault方法"><a href="#event-preventDefault方法" class="headerlink" title="event.preventDefault方法"></a>event.preventDefault方法</h2><p><code>event.preventDefault</code>方法可以避免该事件对象默认操作,如果<code>event</code>是链接的话,则<code>event.preventDefault()</code>表示阻止链接的默认操作.</p><!--SSTStop-->]]></content>
      
      
      <categories>
          
          <category> jQuery基础教程 第4版 </category>
          
          <category> 第4章 样式与动画 </category>
          
          <category> 4.2 隐藏和显示元素 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.1.2 带厂商前缀的样式属性</title>
      <link href="/ReadingNotes//ea8dbdad/"/>
      <url>/ReadingNotes//ea8dbdad/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/ea8dbdad/#4-1-2-带厂商前缀的样式属性" class="header_1">4.1.2 带厂商前缀的样式属性</a>&nbsp;<br><a href="/ReadingNotes/ea8dbdad/#本文重点" class="header_2">本文重点</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="4-1-2-带厂商前缀的样式属性"><a href="#4-1-2-带厂商前缀的样式属性" class="headerlink" title="4.1.2 带厂商前缀的样式属性"></a>4.1.2 带厂商前缀的样式属性</h1><p>浏览器厂商在引入试验性的样式属性时,通常会在实现达到<code>CSS</code>规范要求之前,在属性名前面添加一个前缀。等到实现和规范都稳定之后,这些属性的前缀就会被去掉,让开发人员使用标准的名称。<br>因此,我们经常会在样式表里看到一些类似下面这样的<code>CSS</code>声明:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-webkit-property-name: value; </span><br><span class="line">-moz-property-name: value; </span><br><span class="line">-ms-property-name: value; </span><br><span class="line">-o-property-name: value; </span><br><span class="line">property-name: value;</span><br></pre></td></tr></table></figure><br>如果想在<code>JavaScript</code>中设置这些属性,需要提前检测它们在<code>DOM</code>中是否存在,从<code>propertName</code>到<code>WebkitPropertyName</code>,再到<code>msPropertyName</code>……都要检测。但<strong>在<code>jQuery</code>中,我们可以直接使用标准的属性名</strong>,比如:<code>.css(&#39;propertyName&#39;, &#39;value&#39;)</code>。如果样式对象中不存在这个属性,<code>jQuery</code>就会依次检测所有带前缀(<code>Webkit</code>、<code>O</code>、<code>Moz</code>、<code>ms</code>)的属性,然后使用第一个找到的那个属性。</p><h2 id="本文重点"><a href="#本文重点" class="headerlink" title="本文重点"></a>本文重点</h2><!--SSTStart--><p><strong>在<code>jQuery</code>中,应该直接使用标准的属性名</strong>,不要使用带浏览器前缀的属性名.<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> jQuery基础教程 第4版 </category>
          
          <category> 第4章 样式与动画 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.1.1 设置计算的样式属性值</title>
      <link href="/ReadingNotes//a3a6a163/"/>
      <url>/ReadingNotes//a3a6a163/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/a3a6a163/#4-1-1-设置计算的样式属性值" class="header_1">4.1.1 设置计算的样式属性值</a>&nbsp;<br><a href="/ReadingNotes/a3a6a163/#总结" class="header_1">总结</a>&nbsp;<br><a href="/ReadingNotes/a3a6a163/#-addClass-方法不适用于动态设置样式" class="header_2">.addClass()方法不适用于动态设置样式</a>&nbsp;<br><a href="/ReadingNotes/a3a6a163/#如何获取DOM元素中字体的大小" class="header_2">如何获取DOM元素中字体的大小</a>&nbsp;<br><a href="/ReadingNotes/a3a6a163/#保存jQuery对象的变量名命名规则" class="header_2">保存jQuery对象的变量名命名规则</a>&nbsp;<br><a href="/ReadingNotes/a3a6a163/#parseFloat-函数" class="header_2">parseFloat()函数</a>&nbsp;<br><a href="/ReadingNotes/a3a6a163/#parseFloat-函数的功能" class="header_3">parseFloat()函数的功能</a>&nbsp;<br><a href="/ReadingNotes/a3a6a163/#如何通过按钮来持续的增大或减小字体的大小" class="header_2">如何通过按钮来持续的增大或减小字体的大小</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="4-1-1-设置计算的样式属性值"><a href="#4-1-1-设置计算的样式属性值" class="headerlink" title="4.1.1 设置计算的样式属性值"></a>4.1.1 设置计算的样式属性值</h1><!--SSTStop--><p><strong>如果每次都增大或减小为预定的值,那么仍然可以使用<code>.addClass()</code>方法</strong>。但是,这次假设我们<strong>希望每单击一次按钮,文本的字体大小就会持续地递增或递减</strong>。虽然为每次单击定义一个单独的类,然后迭代这些类也是可能的,但更简单明了的方法是<strong>每次都以当前字体大小为基础,按照一个设定的系数(例如40%)来递增字体大小</strong>。<br>同以前一样,我们的代码仍然是从<code>$(document).ready()</code>和<code>$(&#39;#switcher-large&#39;).click()</code>事件处理程序开始,参见代码清单4-1。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(document).ready(function() &#123; </span><br><span class="line">  $(<span class="string">'#switcher-large'</span>).click(function() &#123; </span><br><span class="line">  &#125;); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>接着,<strong>通过<code>$(&#39;div.speech&#39;).css(&#39;fontSize&#39;)</code>可以轻而易举地取得当前的字体大小</strong>。不过,由于<strong>返回的值中包含数字值及其单位(<code>px</code>)</strong>,需要<code>去掉单位部分</code>才能执行计算。同样,在需要多次使用某个<code>jQuery</code>对象时,最好也把这个对象保存到一个变量中,从而达到缓存数据的目的。为此,就需要引入两个变量,参见代码清单4-2。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> $speech = $(<span class="string">'div.speech'</span>); </span><br><span class="line">  $(<span class="string">'#switcher-large'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> num = <span class="built_in">parseFloat</span>($speech.css(<span class="string">'fontSize'</span>)); </span><br><span class="line">  &#125;); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><script type="math/tex">(document).ready()`中的第一行代码把`<div class="speech">`保存到一个变量中。注意变量名`$speech`中的$。由于`</script>是<code>JavaScript</code>变量中合法的字符,因此<strong>可以利用$$<code>来提醒自己该变量中保存着一个</code>jQuery`对象</strong>。与<code>PHP</code>等编程语言不同,<code>$$符号在</code>jQuery<code>或者说</code>JavaScript<code>中没有特殊的含义。在</code>.click<code>处理程序中,**通过</code>parseFloat()<code>函数只取得字体大小属性中的数值部分**。</code>parseFloat()<code>函数会在一个字符串中从左到右地查找一个浮点(十进制)数。例如,它会将字符串&#39;12&#39;转换成数字12。另外,它还会去掉末尾的非数字字符,因此&#39;12</code>px’<code>就变成了12。如果字符串本身以一个非数字开头,那么</code>parseFloat()<code>会返回</code>NaN<code>,即</code>Not a Number<code>(非数字)。至此,所剩的就是修改解析后的数值并根据新值来重设字号大小了。在这个例子中,我们要在每次按钮被单击时把字号增大40%。为此,可以将</code>num<code>乘以1.4,然后再连接</code>num<code>和&#39;</code>px’<code>来设置字体大小,参见代码清单4-3。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> $speech = $(<span class="string">'div.speech'</span>); </span><br><span class="line">  $(<span class="string">'#switcher-large'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> num = <span class="built_in">parseFloat</span>($speech.css(<span class="string">'fontSize'</span>)); </span><br><span class="line">    num *= <span class="number">1.4</span>; </span><br><span class="line">    $speech.css(<span class="string">'fontSize'</span>, num + <span class="string">'px'</span>); </span><br><span class="line">  &#125;); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>现在,当用户单击</code>Bigger`按钮时,文本会变大,再次单击,会继续变大,如图4-2所示。</p><p>要通过单击<code>Smaller</code>按钮减小字体大小,应该使用除法而不是乘法,即<code>num /= 1.4</code>。同样,更好的方案是把对这两个按钮的单击操作,通过<code>&lt;div id=&quot;switcher&quot;&gt;</code>中的<code>&lt;button&gt;</code>元素组合到一个<code>.click()</code>处理程序中。在查找到数值后,再根据用户单击的按钮<code>ID</code>来决定使用乘法还是除法,如代码清单4-4。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> $speech = $(<span class="string">'div.speech'</span>); </span><br><span class="line">    $(<span class="string">'#switcher button'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> num = <span class="built_in">parseFloat</span>($speech.css(<span class="string">'fontSize'</span>)); </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.id== <span class="string">'switcher-large'</span>) &#123; </span><br><span class="line">      num *= <span class="number">1.4</span>; </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.id== <span class="string">'switcher-small'</span>) &#123; </span><br><span class="line">      num /= <span class="number">1.4</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    $speech.css(<span class="string">'fontSize'</span>, num + <span class="string">'px'</span>); </span><br><span class="line">  &#125;); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>根据第3章学习的内容,我们知道可以访问<code>this.id</code>得到<code>this</code>引用的<code>DOM</code>元素的<code>id</code>属性,因而就有了<code>if</code>和<code>else if</code>语句中的代码。这里,如果仅测试属性的值,使用<code>this</code>显然要比创建<code>jQuery</code>对象更有效。<br>如果提供一种方式能够返回字体大小的初始值当然更好了。为了做到这一点,可以在<code>DOM</code>就绪后立即把字体大小保存在一个变量中。然后,当用户单击<code>Default</code>按钮时,再使用这个变量的值。虽然可以通过再添加一个<code>else if</code>语句来处理这次单击,但此时改用<code>switch</code>语句应该更合适,参见代码清单4-5。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取要操作的DOM元素</span></span><br><span class="line">  <span class="keyword">var</span> $speech = $(<span class="string">'div.speech'</span>);</span><br><span class="line">  <span class="comment">// 保存原始的字体大小</span></span><br><span class="line">  <span class="keyword">var</span> defaultSize = $speech.css(<span class="string">'fontSize'</span>);</span><br><span class="line">  <span class="comment">// 监听按钮点击事件</span></span><br><span class="line">  $(<span class="string">'#switcher button'</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取字体大小</span></span><br><span class="line">    <span class="keyword">var</span> num = <span class="built_in">parseFloat</span>($speech.css(<span class="string">'fontSize'</span>));</span><br><span class="line">    <span class="comment">// 判断当前按钮的id</span></span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">this</span>.id) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'switcher-large'</span>:</span><br><span class="line">        num *= <span class="number">1.4</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'switcher-small'</span>:</span><br><span class="line">        num /= <span class="number">1.4</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        num = <span class="built_in">parseFloat</span>(defaultSize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重新设置字体的大小</span></span><br><span class="line">    $speech.css(<span class="string">'fontSize'</span>, num + <span class="string">'px'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>在此,仍然是检查<code>this.id</code>的值并据以改变字体大小,但如果它的值既不是<code>&#39;switcher-large&#39;</code>也不是<code>&#39;switcher-small&#39;</code>,那么就应该使用默认的初始字体大小。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><!--SSTStart--><h2 id="addClass-方法不适用于动态设置样式"><a href="#addClass-方法不适用于动态设置样式" class="headerlink" title=".addClass()方法不适用于动态设置样式"></a>.addClass()方法不适用于动态设置样式</h2><p><code>.addClass()</code>方法适用于设置样式为固定值的情况。<br>如果希望样式持续的增大或减小,则要定义多个类,然后再迭代这些类来实现持续变大或变小的效果.这种方式麻烦。</p><h2 id="如何获取DOM元素中字体的大小"><a href="#如何获取DOM元素中字体的大小" class="headerlink" title="如何获取DOM元素中字体的大小"></a>如何获取DOM元素中字体的大小</h2><p><code>$(&#39;选择符&#39;).css(&#39;fontSize&#39;)</code>可以轻而易举地取得该<code>DOM</code>中的字体大小,这个方法的返回值包含<code>数字</code>和<code>单位</code>。</p><h2 id="保存jQuery对象的变量名命名规则"><a href="#保存jQuery对象的变量名命名规则" class="headerlink" title="保存jQuery对象的变量名命名规则"></a>保存jQuery对象的变量名命名规则</h2><p><strong>可以在变量名中加入<code>$</code>符号来提醒自己该变量中保存着一个<code>jQuery</code>对象</strong></p><h2 id="parseFloat-函数"><a href="#parseFloat-函数" class="headerlink" title="parseFloat()函数"></a>parseFloat()函数</h2><h3 id="parseFloat-函数的功能"><a href="#parseFloat-函数的功能" class="headerlink" title="parseFloat()函数的功能"></a>parseFloat()函数的功能</h3><p><strong>parseFloat()函数可以取得字符串中的数字部分</strong>,例如:<strong>通过<code>parseFloat()</code>函数只取得字体大小属性中的数值部分</strong><br><code>parseFloat()</code>函数会在一个字符串中从左到右地查找一个浮点(十进制)数。例如,</p><ul><li>它会将字符串<code>&#39;12&#39;</code>转换成数字12。</li><li>另外,它还会去掉末尾的非数字字符,因此<code>&#39;12px&#39;</code>就变成了<code>12</code>。</li><li>如果字符串本身以一个非数字开头,那么<code>parseFloat()</code>会返回<code>NaN</code>,即<code>Not a Number</code>(非数字)。</li></ul><h2 id="如何通过按钮来持续的增大或减小字体的大小"><a href="#如何通过按钮来持续的增大或减小字体的大小" class="headerlink" title="如何通过按钮来持续的增大或减小字体的大小"></a>如何通过按钮来持续的增大或减小字体的大小</h2><p>在<code>$(document).ready()</code>方法的匿名函数中写入方法,算法描述如下</p><ul><li>1.获取要操作的<code>DOM</code>元素的<code>jQurey</code>对象</li><li>2.保存该<code>jQurey</code>对象的<code>fontSize</code>样式属性的值</li><li>3.监听按钮点击事件<ul><li>3.1获取<code>jQurey</code>对象的<code>fontSize</code>样式属性值中的数值部分</li><li>3.2根据触发点击事件<code>DOM</code>元素的id来判断具体触发的是哪个按钮<ul><li>如果是增大按钮,则使用乘法增大字体大小</li><li>如果是减小按钮,则使用除法减小字体大小</li><li>如果是默认按钮,则获取默认的<code>fontSize</code>属性值中的数值部分</li></ul></li></ul></li><li>4.拼接数值和单位组成<code>fontSize</code>的属性值,然后通过<code>jQury</code>对象的<code>css</code>方法更新<code>fontSize</code>属性的属性值</li></ul><!--SSTStop-->]]></content>
      
      
      <categories>
          
          <category> jQuery基础教程 第4版 </category>
          
          <category> 第4章 样式与动画 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.7 小结</title>
      <link href="/ReadingNotes//4b263c64/"/>
      <url>/ReadingNotes//4b263c64/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/4b263c64/#3-7-小结" class="header_1">3.7 小结</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="3-7-小结"><a href="#3-7-小结" class="headerlink" title="3.7 小结"></a>3.7 小结</h1><p>本章学习了各种响应用户及浏览器发起事件的方法,包括如何在页面加载时安全地执行代码、如何处理单击链接和悬停按钮时的鼠标事件,以及如何截获按键输入。<br>此外,我们介绍了事件系统的内部机制,并据以实现了事件委托和改变事件行为。我们甚至都可以模仿用户发起事件。<br>基于这些技术,可以构建极具交互性的页面。下一章,我们学习如何在这些交互中给用户提供反馈。<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> jQuery基础教程 第4版 </category>
          
          <category> 第3章 事件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.6 模仿用户操作</title>
      <link href="/ReadingNotes//910c0a03/"/>
      <url>/ReadingNotes//910c0a03/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/910c0a03/#3-6-模仿用户操作" class="header_1">3.6 模仿用户操作</a>&nbsp;<br><a href="/ReadingNotes/910c0a03/#-trigger-方法" class="header_2">.trigger()方法</a>&nbsp;<br><a href="/ReadingNotes/910c0a03/#-trigger-方法简写" class="header_2">.trigger()方法简写</a>&nbsp;<br><a href="/ReadingNotes/910c0a03/#响应键盘事件" class="header_2">响应键盘事件</a>&nbsp;<br><a href="/ReadingNotes/910c0a03/#键盘事件" class="header_3">键盘事件</a>&nbsp;<br><a href="/ReadingNotes/910c0a03/#两类键盘事件的用途" class="header_3">两类键盘事件的用途</a>&nbsp;<br><a href="/ReadingNotes/910c0a03/#键盘事件的目标" class="header_3">键盘事件的目标</a>&nbsp;<br><a href="/ReadingNotes/910c0a03/#什么样的元素可以获得键盘焦点" class="header_3">什么样的元素可以获得键盘焦点</a>&nbsp;<br><a href="/ReadingNotes/910c0a03/#应用事件冒泡" class="header_3">应用事件冒泡</a>&nbsp;<br><a href="/ReadingNotes/910c0a03/#如何知道用户按的是哪个键" class="header_3">如何知道用户按的是哪个键</a>&nbsp;<br><a href="/ReadingNotes/910c0a03/#知识总结" class="header_2">知识总结</a>&nbsp;<br><a href="/ReadingNotes/910c0a03/#模拟事件操作" class="header_3">模拟事件操作</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="3-6-模仿用户操作"><a href="#3-6-模仿用户操作" class="headerlink" title="3.6 模仿用户操作"></a>3.6 模仿用户操作</h1><p>有时候,即使某个事件没有真正发生,但如果能执行绑定到该事件的代码将会很方便。例如,假设我们想让样式转换器在一开始时处于折叠状态。那么,可以通过样式表来隐藏按钮,或者在<code>$(document).ready()</code>处理程序中调用<code>.hide()</code>方法。不过,还有一种方法,就是模拟单击样式转换器,以触发我们设定的折叠机制。</p><h2 id="trigger-方法"><a href="#trigger-方法" class="headerlink" title=".trigger()方法"></a>.trigger()方法</h2><p><strong>通过<code>.trigger()</code>方法就可以完成模拟事件的操作</strong>,如代码清单3-23所示。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  $(<span class="string">'#switcher'</span>).trigger(<span class="string">'click'</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>这样,随着页面加载完成,样式转换器也会被折叠起来,就好像是被单击了一样。<br>如果我们想向禁用<code>JavaScript</code>的用户隐藏一些内容,以实现优雅降级,那么这就是一种非常合适的方式。</p><h2 id="trigger-方法简写"><a href="#trigger-方法简写" class="headerlink" title=".trigger()方法简写"></a>.trigger()方法简写</h2><p><code>.trigger()</code>方法提供了一组与<code>.on()</code>方法相同的简写方法。当使用这些方法而不带参数时,结果将是触发操作而不是绑定行为,如代码清单3-24所示。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  $(<span class="string">'#switcher'</span>).click(); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="响应键盘事件"><a href="#响应键盘事件" class="headerlink" title="响应键盘事件"></a>响应键盘事件</h2><p>作为另一个例子,我们还可以向样式转换器中添加键盘快捷方式。当用户输入每种显示样式的第一个字母时,可以让页面像响应按钮被单击一样作出响应。要实现这种功能,需要先了解<code>键盘事件``,键盘事件</code>与鼠标事件稍有不同。</p><h3 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h3><p>键盘事件可以分为两类:</p><ol><li>直接对键盘按键给出响应的事件(<code>keyup</code>和<code>keydown</code>)</li><li>对文本输入给出响应的事件(<code>keypress</code>)。</li></ol><h3 id="两类键盘事件的用途"><a href="#两类键盘事件的用途" class="headerlink" title="两类键盘事件的用途"></a>两类键盘事件的用途</h3><p>输入一个字母的事件可能会对应着几个按键,例如输入大写的X要同时按<code>Shift</code>和<code>X</code>键。虽然各种浏览器的具体实现有所不同,但有一条实践经验还是比较可靠的:<strong>如果想知道用户按了哪个键,应该侦听<code>keyup</code>或<code>keydown</code>事件;如果想知道用户输入的是什么字符,应该侦听<code>keypress</code>事件</strong>。对于这里想要实现的功能而言,我们只想知道用户什么时候按下了<code>D</code>、<code>N</code>或<code>L</code>键,因而就要使用<code>keyup</code>。</p><h3 id="键盘事件的目标"><a href="#键盘事件的目标" class="headerlink" title="键盘事件的目标"></a>键盘事件的目标</h3><p>接下来,需要确定哪个元素应该侦听这个事件。相对于可以通过鼠标指针确定事件目标的鼠标事件而言,这个细节就没有那么明显了。事实上,<strong>键盘事件的目标是当前拥有<code>键盘焦点</code>的元素</strong>。元素的焦点可能会在几种情况下转移,包括单击鼠标和按下<code>Tab</code>键。</p><h3 id="什么样的元素可以获得键盘焦点"><a href="#什么样的元素可以获得键盘焦点" class="headerlink" title="什么样的元素可以获得键盘焦点"></a>什么样的元素可以获得键盘焦点</h3><p>并非所有元素都可以获得焦点,只有那些<code>默认情况下具有键盘驱动行为的元素</code>,如<code>表单字段</code>、<code>链接</code>,以及指定了<code>tabIndex</code>属性的元素<code>才可以获得焦点</code>。</p><h3 id="应用事件冒泡"><a href="#应用事件冒泡" class="headerlink" title="应用事件冒泡"></a>应用事件冒泡</h3><p>对于眼前的例子来说,哪个元素获得焦点其实并不重要,我们只想让转换器在用户按下某个键时能够有所反应。这一次,又可以利用事件冒泡了——因为可以假设所有键盘事件最终都会冒泡到<code>document</code>元素,所以可以把<code>keyup</code>事件直接绑定到该元素。</p><h3 id="如何知道用户按的是哪个键"><a href="#如何知道用户按的是哪个键" class="headerlink" title="如何知道用户按的是哪个键"></a>如何知道用户按的是哪个键</h3><p>最后,需要在<code>keyup</code>处理程序被触发时知道用户按下了哪个键。此时可以检查相应的事件对象,<strong>事件对象的<code>.which</code>属性包含着被按下的那个键的标识符。对于字母键而言,这个标识符就是相应大写字母的<code>ASCII</code>值</strong>。<br>因此,可以为字母和相应的按钮创建一个<code>对象字面量</code>。在用户按下某个键时,可以查找它的标识符是否在这个对象里,如果在则触发单击事件,参见代码清单3-25。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建快捷键对象</span></span><br><span class="line">  <span class="keyword">var</span> triggers = &#123;</span><br><span class="line">    D: <span class="string">'default'</span>,</span><br><span class="line">    N: <span class="string">'narrow'</span>,</span><br><span class="line">    L: <span class="string">'large'</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 注册匿名的键盘事件处理程序</span></span><br><span class="line">  $(<span class="built_in">document</span>).keyup(<span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取按下的键的标识,返回的是键的ASCII码</span></span><br><span class="line">    <span class="keyword">var</span> key = <span class="built_in">String</span>.fromCharCode(event.which);</span><br><span class="line">    <span class="comment">// 如果是快捷键</span></span><br><span class="line">    <span class="keyword">if</span> (key <span class="keyword">in</span> triggers) &#123;</span><br><span class="line">      <span class="comment">// 点击该快捷键对应的按钮</span></span><br><span class="line">      $(<span class="string">'#switcher-'</span> + triggers[key]).click();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>这样,按下这三个键中的任何一个,都会模拟鼠标对相应按钮的单击——前提是键盘事件没有被某些特性(例如<code>Firefox</code>的”在输入时搜索文本”功能)所截取。<br>除了使用<code>.trigger()</code>模拟单击外,下面我们再深入一步,看一看怎样把相关代码提取到一个函数中,以便更多处理程序(<code>click</code>和<code>keyup</code>)可以调用它。尽管在本例中没有必要这样做,但这种技术确实有利于消除冗余代码,参见代码清单3-26。</p><p>最后这次修改整合了本章前面所有的代码示例。我们把整块代码都挪到了<code>$(document).ready()</code>处理程序中,代码看起来没有那么冗长了。<br><!--SSTStop--><br><!--SSTStart--></p><h2 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h2><h3 id="模拟事件操作"><a href="#模拟事件操作" class="headerlink" title="模拟事件操作"></a>模拟事件操作</h3><ul><li><strong>通过<code>.trigger()</code>方法就可以完成模拟事件的操作</strong></li><li><code>.trigger()</code>方法简写形式:不带参数<code>.事件()</code>方法,例如不带参数的的<code>.click()</code>方法就是在带<code>DOM</code>元素上<code>触发</code>点击事件.</li></ul><p>键盘事件可以分为两类:</p><ol><li>直接对键盘按键给出响应的事件(<code>keyup</code>和<code>keydown</code>)</li><li>对文本输入给出响应的事件(<code>keypress</code>)。</li></ol><p><strong>默认情况下具有键盘驱动行为的元素才可以获得焦点</strong><br><strong>如果想知道用户按了哪个键,应该侦听<code>keyup</code>或<code>keydown</code>事件;如果想知道用户输入的是什么字符,应该侦听<code>keypress</code>事件</strong><br><strong>事件对象的<code>.which</code>属性包含着被按下的那个键的标识符。对于字母键而言,这个标识符就是相应大写字母的<code>ASCII</code>值</strong><br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> jQuery基础教程 第4版 </category>
          
          <category> 第3章 事件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.1 修改内联 CSS</title>
      <link href="/ReadingNotes//b34526ee/"/>
      <url>/ReadingNotes//b34526ee/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/b34526ee/#4-1-修改内联-CSS" class="header_1">4.1 修改内联 CSS</a>&nbsp;<br><a href="/ReadingNotes/b34526ee/#-css方法描述" class="header_2">.css方法描述</a>&nbsp;<br><a href="/ReadingNotes/b34526ee/#如何取样式属性的值" class="header_3">如何取样式属性的值</a>&nbsp;<br><a href="/ReadingNotes/b34526ee/#获取单个属性值" class="header_4">获取单个属性值</a>&nbsp;<br><a href="/ReadingNotes/b34526ee/#获取多个属性值" class="header_4">获取多个属性值</a>&nbsp;<br><a href="/ReadingNotes/b34526ee/#如何设置样式属性" class="header_3">如何设置样式属性</a>&nbsp;<br><a href="/ReadingNotes/b34526ee/#设置一个样式属性" class="header_4">设置一个样式属性</a>&nbsp;<br><a href="/ReadingNotes/b34526ee/#设置多个样式属性" class="header_4">设置多个样式属性</a>&nbsp;<br><a href="/ReadingNotes/b34526ee/#对象字面量" class="header_2">对象字面量</a>&nbsp;<br><a href="/ReadingNotes/b34526ee/#本文重点" class="header_1">本文重点</a>&nbsp;<br><a href="/ReadingNotes/b34526ee/#-css-方法" class="header_2">.css()方法</a>&nbsp;<br><a href="/ReadingNotes/b34526ee/#获取样式属性值" class="header_3">获取样式属性值</a>&nbsp;<br><a href="/ReadingNotes/b34526ee/#获取单个样式属性值" class="header_4">获取单个样式属性值</a>&nbsp;<br><a href="/ReadingNotes/b34526ee/#获取多个样式属性值" class="header_4">获取多个样式属性值</a>&nbsp;<br><a href="/ReadingNotes/b34526ee/#设置样式属性" class="header_3">设置样式属性</a>&nbsp;<br><a href="/ReadingNotes/b34526ee/#设置一个样式属性" class="header_4">设置一个样式属性</a>&nbsp;<br><a href="/ReadingNotes/b34526ee/#设置多个样式属性" class="header_4">设置多个样式属性</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="4-1-修改内联-CSS"><a href="#4-1-修改内联-CSS" class="headerlink" title="4.1 修改内联 CSS"></a>4.1 修改内联 CSS</h1><!--SSTStop--><p>在接触漂亮的<code>jQuery</code>效果之前,有必要先简单地谈一谈<code>CSS</code>。在前几章中,为了修改文档的外观,我们都是先在单独的样式表中为类定义好样式,然后再通过<code>jQuery</code>来添加或者移除这些类。<br>一般而言,这都是为<code>HTML</code>应用<code>CSS</code>的首选方式,因为这种方式不会影响样式表负责处理页面表现的角色。但是,在有些情况下,可能我们<strong>要使用的样式没有在样式表中定义,或者通过样式表定义不是那么容易</strong>。针对这种情况,<code>jQuery</code>提供了<code>.css()</code>方法。</p><h2 id="css方法描述"><a href="#css方法描述" class="headerlink" title=".css方法描述"></a>.css方法描述</h2><p>这个<code>.css()</code>方法集<code>getter</code>方法和<code>setter</code>方法于一身。通过<code>.css()</code>既可以设置<code>CSS</code>属性也可以获取<code>CSS</code>属性值</p><h3 id="如何取样式属性的值"><a href="#如何取样式属性的值" class="headerlink" title="如何取样式属性的值"></a>如何取样式属性的值</h3><h4 id="获取单个属性值"><a href="#获取单个属性值" class="headerlink" title="获取单个属性值"></a>获取单个属性值</h4><p>为<code>取得</code>某个样式属性的值,可以传递一个字符串形式的属性名作为<code>.css()</code>方法的参数,然后就得到一个字符串形式的属性值。</p><h4 id="获取多个属性值"><a href="#获取多个属性值" class="headerlink" title="获取多个属性值"></a>获取多个属性值</h4><p>要<code>取得</code>多个样式属性的值,可以<code>传入属性名的数组</code>作为作为<code>.css()</code>方法的参数,这样得到的是<code>属性和值</code>构成的<code>对象</code>。</p><p>对于由多个单词构成的属性名,<code>jQuery</code>既可以解释连字符版的<code>CSS</code>表示法(如<code>background-color</code>) ,也可以解释驼峰大小写形式的<code>DOM</code>表示法(如<code>backgroundColor</code>)。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取得单个属性的值,返回"value" </span></span><br><span class="line">.css(<span class="string">'property'</span>) </span><br><span class="line"><span class="comment">//取得多个属性的值,返回&#123;"property1": "value1", "property-2": "value2"&#125; </span></span><br><span class="line">.css([<span class="string">'property1'</span>, <span class="string">'property-2'</span>])</span><br></pre></td></tr></table></figure></p><h3 id="如何设置样式属性"><a href="#如何设置样式属性" class="headerlink" title="如何设置样式属性"></a>如何设置样式属性</h3><p>在<code>设置</code>样式属性时,<code>.css()</code>方法能够接受的参数有两种:</p><h4 id="设置一个样式属性"><a href="#设置一个样式属性" class="headerlink" title="设置一个样式属性"></a>设置一个样式属性</h4><p>传递两个参数作为<code>.css()</code>方法的参数,第一个参数是样式属性，第二个参数是该样式属性的值,示例代码如下:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单个属性及其值 </span></span><br><span class="line">.css(<span class="string">'property'</span>, <span class="string">'value'</span>)</span><br></pre></td></tr></table></figure></p><h4 id="设置多个样式属性"><a href="#设置多个样式属性" class="headerlink" title="设置多个样式属性"></a>设置多个样式属性</h4><p>传递一个由<code>属性-属性值</code>对构成的<code>对象</code>作为<code>.css()</code>方法的参数,示例代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//属性-值对构成的对象 </span></span><br><span class="line">.css(&#123; </span><br><span class="line">  property1: <span class="string">'value1'</span>, </span><br><span class="line">  <span class="string">'property-2'</span>: <span class="string">'value2'</span> </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="对象字面量"><a href="#对象字面量" class="headerlink" title="对象字面量"></a>对象字面量</h2><p>这些<code>键值对的集合</code>叫<code>对象字面量</code>,是在代码中直接创建的<code>JavaScript</code>对象。</p><p>一般来说,<code>数字值不需要加引号</code>而<code>字符串值需要加引号</code>。由于属性名是字符串,所以属性通常是需要加引号的。但是,如果对象字面量中的属性名是有效的<code>JavaScript</code>标识符,比如使用驼峰大小写形式的<code>DOM</code>表示法时,则可以省略引号。</p><p>使用<code>.css()</code>的方式与前面使用<code>.addClass()</code>的方式相同——将它<code>连缀</code>到<code>jQuery</code>对象后面,这个<code>jQuery</code>对象包含一组<code>DOM</code>元素。为此,我们仍以第3章的样式转换器为例,但这次使用的<code>HTML</code>稍有不同:<br>在通过链接的样式表为这个文档添加了一些基本样式规则之后,初始的页面如图4-1所示。</p><p>有了这些代码之后,单击<code>Bigger</code>和<code>Smaller</code>按钮,会增大或缩小<code>&lt;div class=&quot;speech&quot;&gt;</code>中文本的字体大小,而单击<code>Default</code>按钮,则会把<code>&lt;div class=&quot;speech&quot;&gt;</code>中文本的字体重置为初始大小。<br><!--SSTStart--></p><h1 id="本文重点"><a href="#本文重点" class="headerlink" title="本文重点"></a>本文重点</h1><h2 id="css-方法"><a href="#css-方法" class="headerlink" title=".css()方法"></a>.css()方法</h2><p><code>jQuery</code>提供的<code>.css()</code>方法<strong>用于要使用的样式没有在样式表中定义,或者通过样式表定义不是那么容易的情况下</strong>.<br>通过<code>.css()</code>既可以设置样式属性也可以获取样式属性的值.</p><h3 id="获取样式属性值"><a href="#获取样式属性值" class="headerlink" title="获取样式属性值"></a>获取样式属性值</h3><h4 id="获取单个样式属性值"><a href="#获取单个样式属性值" class="headerlink" title="获取单个样式属性值"></a>获取单个样式属性值</h4><p>为<code>取得</code>某个样式属性的值,可以传递一个字符串形式的属性名作为<code>.css()</code>方法的参数,然后就得到一个字符串形式的属性值。</p><h4 id="获取多个样式属性值"><a href="#获取多个样式属性值" class="headerlink" title="获取多个样式属性值"></a>获取多个样式属性值</h4><p>要<code>取得</code>多个样式属性的值,可以<code>传入属性名的数组</code>作为<code>.css()</code>方法的参数,这样得到的是<code>属性和值</code>构成的<code>对象</code>。</p><h3 id="设置样式属性"><a href="#设置样式属性" class="headerlink" title="设置样式属性"></a>设置样式属性</h3><h4 id="设置一个样式属性-1"><a href="#设置一个样式属性-1" class="headerlink" title="设置一个样式属性"></a>设置一个样式属性</h4><p>传递两个参数作为<code>.css()</code>方法的参数,第一个参数是样式属性，第二个参数是该样式属性的值</p><h4 id="设置多个样式属性-1"><a href="#设置多个样式属性-1" class="headerlink" title="设置多个样式属性"></a>设置多个样式属性</h4><p>传递一个由<code>属性-属性值对</code>构成的<code>对象</code>作为<code>.css()</code>方法的参数<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> jQuery基础教程 第4版 </category>
          
          <category> 第4章 样式与动画 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第4章 样式与动画</title>
      <link href="/ReadingNotes//7892b035/"/>
      <url>/ReadingNotes//7892b035/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/7892b035/#第4章-样式与动画" class="header_1">第4章 样式与动画</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="第4章-样式与动画"><a href="#第4章-样式与动画" class="headerlink" title="第4章 样式与动画"></a>第4章 样式与动画</h1><!--SSTStop--><p>通过<code>jQuery</code>,我们不仅能够轻松地为页面操作添加简单的视觉效果,甚至能创建更精致的动画。<br><code>jQuery</code>效果确实能增添艺术性,一个元素逐渐滑入视野而不是突然出现时,带给人的美感是不言而喻的。此外,当页面发生变化时,通过效果吸引用户的注意力,则会显著增强页面的可用性(在<code>Ajax</code>应用程序中尤其常见)。<br><!--SSTStart--><br>本章,我们将学习以下内容:</p><ol><li>动态修改元素的样式;</li><li>通过各种内置效果隐藏和显示元素;</li><li>创建自定义的元素动画;</li><li>实现一个接一个的效果排队。<!--SSTStop--></li></ol>]]></content>
      
      
      <categories>
          
          <category> jQuery基础教程 第4版 </category>
          
          <category> 第4章 样式与动画 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.1 简化Java开发</title>
      <link href="/ReadingNotes//28189e06/"/>
      <url>/ReadingNotes//28189e06/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/28189e06/#1-1-简化Java开发" class="header_1">1.1 简化Java开发</a>&nbsp;<br><a href="/ReadingNotes/28189e06/#1-1-1-激发POJO的潜能" class="header_2">1.1.1 激发POJO的潜能</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="1-1-简化Java开发"><a href="#1-1-简化Java开发" class="headerlink" title="1.1 简化Java开发"></a>1.1 简化Java开发</h1><p><code>Spring</code>是一个开源框架，最早由<code>Rod Johnson</code>创建，并在<a href="http://amzn.com/076454385" target="_blank" rel="noopener">《Expert One-on-One：J2EE Design and Development》</a>这本著作中进行了介绍。<code>Spring</code>是为了解决企业级应用开发的复杂性而创建的，使用<code>Spring</code>可以让简单的<code>JavaBean</code>实现之前只有<code>EJB</code>才能完成的事情。但<code>Spring</code>不仅仅局限于服务器端开发，任何<code>Java</code>应用都能在简单性、可测试性和松耦合等方面从<code>Spring</code>中获益。<br><code>bean</code>的各种名称……虽然<code>Spring</code>用<code>bean</code>或者<code>JavaBean</code>来表示应用组件，但并不意味着<code>Spring</code>组件必须要遵循<code>JavaBean</code>规范。一个<code>Spring</code>组件可以是任何形式的<code>POJO</code>。在本书中，我采用<code>JavaBean</code>的广泛定义，即<code>POJO</code>的同义词。<br>纵览全书，读者会发现<code>Spring</code> 可以做非常多的事情。但归根结底，支撑<code>Spring</code>的仅仅是少许的基本理念，所有的理念都可以追溯到<code>Spring</code>最根本的使命上：简化<code>Java</code>开发。<br>这是一个郑重的承诺。许多框架都声称在某些方面做了简化，但<code>Spring</code>的目标是致力于全方位的简化<code>Java</code>开发。这势必引出更多的解释，<code>Spring</code>是如何简化<code>Java</code>开发的？<br>为了降低<code>Java</code>开发的复杂性，<code>Spring</code>采取了以下4种关键策略：</p><ul><li>基于<code>POJO</code>的轻量级和最小侵入性编程；</li><li>通过依赖注入和面向接口实现松耦合；</li><li>基于切面和惯例进行声明式编程；</li><li>通过切面和模板减少样板式代码。</li></ul><p>几乎<code>Spring</code>所做的任何事情都可以追溯到上述的一条或多条策略。在本章的其他部分，我将通过具体的案例进一步阐述这些理念，以此来证明<code>Spring</code>是如何完美兑现它的承诺的，也就是简化<code>Java</code>开发。让我们先从基于<code>POJO</code>的最小侵入性编程开始。</p><h2 id="1-1-1-激发POJO的潜能"><a href="#1-1-1-激发POJO的潜能" class="headerlink" title="1.1.1 激发POJO的潜能"></a>1.1.1 激发POJO的潜能</h2><p>如果你从事<code>Java</code>编程有一段时间了,那么你或许会发现(可能你也实际使用过)很多框架通过强迫应用继承它们的类或实现它们的接口从而导致应用与框架绑死。一个典型的例子是<code>EJB 2</code>时代的无状态会话<code>bean</code>。早期的<code>EJB</code>是一个很容易想到的例子,不过这种侵入式的编程方式在早期版本的<code>Struts</code>、<code>WebWork</code>、<code>Tapestry</code>以及无数其他的<code>Java</code>规范和框架中都能看到。<br><code>Spring</code>竭力避免因自身的<code>API</code>而弄乱你的应用代码。<code>Spring</code>不会强迫你实现<code>Spring</code>规范的接口或继承<code>Spring</code>规范的类,相反,在基于<code>Spring</code>构建的应用中,它的类通常没有任何痕迹表明你使用了<code>Spring</code>。<br>最坏的场景是,一个类或许会使用<code>Spring</code>注解,但它依旧是<code>POJO</code>。不妨举个例子,请参考下面的<code>HelloWorldBean</code>类:</p>]]></content>
      
      
      <categories>
          
          <category> Spring实战 (第4版) </category>
          
          <category> 第1部分 Spring的核心 </category>
          
          <category> 第1章 Spring之旅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第1章 Spring之旅</title>
      <link href="/ReadingNotes//420ee57d/"/>
      <url>/ReadingNotes//420ee57d/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/420ee57d/#第1章-Spring之旅" class="header_1">第1章 Spring之旅</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="第1章-Spring之旅"><a href="#第1章-Spring之旅" class="headerlink" title="第1章 Spring之旅"></a>第1章 Spring之旅</h1><p>本章内容：</p><ul><li><code>Spring</code>的<code>bean</code>容器</li><li>介绍<code>Spring</code>的核心模块</li><li>更为强大的<code>Spring</code>生态系统</li><li><code>Spring</code>的新功能</li></ul><p>对于<code>Java</code>程序员来说，这是一个很好的时代。<br>在<code>Java</code>近20年的历史中，它经历过很好的时代，也经历过饱受诟病的时代。尽管有很多粗糙的地方,如<code>applet</code>、企业级<code>JavaBean</code>(<code>Enterprise JavaBean</code>,<code>EJB</code>)、<code>Java</code>数据对象(<code>Java Data Object</code>,<code>JDO</code>)以及无数的日志框架,但是作为一个平台,<code>Java</code>的历史是丰富多彩的,有很多的企业级软件都是基于这个平台构建的。<code>Spring</code>是<code>Java</code>历史中很重要的组成部分。<br>在诞生之初,创建<code>Spring</code>的主要目的是用来替代更加重量级的企业级<code>Java</code>技术,尤其是<code>EJB</code>。相对于<code>EJB</code>来说,<code>Spring</code>提供了更加轻量级和简单的编程模型。它增强了简单老式<code>Java</code>对象(<code>Plain Old Java object</code>,<code>POJO</code>)的功能,使其具备了之前只有<code>EJB</code>和其他企业级<code>Java</code>规范才具有的功能。随着时间的推移,<code>EJB</code>以及<code>Java 2</code>企业版(<code>Java 2 Enterprise Edition</code>,J2EE)在不断演化。<code>EJB</code>自身也提供了面向简单<code>POJO</code>的编程模型。现在,<code>EJB</code>也采用了依赖注入(<code>Dependency Injection</code>,DI)和面向切面编程(<code>Aspect-Oriented Programming</code>,<code>AOP</code>)的理念,这毫无疑问是受到<code>Spring</code>成功的启发。<br>尽管<code>J2EE</code>(现在称之为<code>JEE</code>)能够赶上<code>Spring</code>的步伐,但<code>Spring</code>也没有停止前进。<code>Spring</code>继续在其他领域发展,而<code>JEE</code>则刚刚开始涉及这些领域,或者还完全没有开始在这些领域的创新。移动开发、社交<code>API</code>集成、<code>NoSQL</code>数据库、云计算以及大数据都是<code>Spring</code>正在涉足和创新的领域。<code>Spring</code>的前景依然会很美好。正如我之前所言,对于<code>Java</code>开发者来说,这是一个很好的时代。<br>本书会对<code>Spring</code>进行研究,在这一章中,我们将会在较为宏观的层面上介绍<code>Spring</code>,让你对<code>Spring</code>是什么有直观的体验。本章将让读者对<code>Spring</code>所解决的各类问题有一个清晰的认识,同时为其他章奠定基础。</p>]]></content>
      
      
      <categories>
          
          <category> Spring实战 (第4版) </category>
          
          <category> 第1部分 Spring的核心 </category>
          
          <category> 第1章 Spring之旅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第1部分 Spring的核心</title>
      <link href="/ReadingNotes//2967a704/"/>
      <url>/ReadingNotes//2967a704/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/2967a704/#第1部分-Spring的核心" class="header_1">第1部分 Spring的核心</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="第1部分-Spring的核心"><a href="#第1部分-Spring的核心" class="headerlink" title="第1部分 Spring的核心"></a>第1部分 Spring的核心</h1><p><code>Spring</code>可以做很多事情，它为企业级开发提供给了丰富的功能，但是这些功能的底层都依赖于它的两个核心特性，也就是依赖注入（<code>dependency injection</code>，<code>DI</code>）和面向切面编程（<code>aspect-oriented programming</code>，<code>AOP</code>）。</p><ul><li>在第1章“<code>Spring</code>之旅”中，我将快速介绍一下<code>Spring</code>框架，包括<code>Spring DI</code>和<code>AOP</code>的概况，以及它们是如何帮助读者解耦应用组件的。</li><li>在第2章“装配<code>Bean</code>”中，我们将深入探讨如何将应用中的各个组件拼装在一起，读者将会看到<code>Spring</code>所提供的自动配置、基于<code>Java</code>的配置以及<code>XML</code>配置。</li><li>在第3章“高级装配”中，将会告别基础的内容，为读者展现一些最大化<code>Spring</code>威力的技巧和技术，包括条件化装配、处理自动装配时的歧义性、作用域以及<code>Spring</code>表达式语言。</li><li>在第4章“面向切面的<code>Spring</code>”中，展示如何使用<code>Spring</code>的<code>AOP</code>特性把系统级的服务（例如安全和审计）从它们所服务的对象中解耦出来。本章也为后面的第9章、第13章和第14章做了铺垫，这几章将会分别介绍如何将<code>Spring AOP</code>用于声明式安全以及缓存。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring实战 (第4版) </category>
          
          <category> 第1部分 Spring的核心 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring实战 第4版 前言</title>
      <link href="/ReadingNotes//5dbcb087/"/>
      <url>/ReadingNotes//5dbcb087/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/5dbcb087/#Spring实战-第4版-前言" class="header_1">Spring实战 第4版 前言</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="Spring实战-第4版-前言"><a href="#Spring实战-第4版-前言" class="headerlink" title="Spring实战 第4版 前言"></a>Spring实战 第4版 前言</h1><p>百尺竿头更进一步。十几年前,<code>Spring</code>刚刚进入<code>Java</code>开发领域,其目标是简化企业级<code>Java</code>开发。它使用更为简单和轻量级的模型,该模型基于简单老式的<code>Java</code>对象,以此挑战了当时重量级的开发模型。<br>现在，已经过去了很多年，<code>Spring</code>也发布了众多的版本，我们可以看到<code>Spring</code>在企业级应用开发领域已经有了巨大的影响力。对于无数的<code>Java</code>项目来说，它就是<code>事实上的标准</code>，并且对于一些规范和它本来想取代的框架，<code>Spring</code>也对其演进产生了影响。毫无疑问，如果<code>Spring</code>不挑战之前版本的企业级<code>JavaBean</code>（<code>EJB</code>）规范的话，现在的<code>EJB</code>规范肯定是完全不同的一个样子。<br>但是，<code>Spring</code>本身也在持续地演化和提升，它一直<code>致力于将困难的开发任务进行简化</code>，不断地为<code>Java</code>开发人员带来创新性的特性。在<code>Spring</code>最初所挑战的领域，<code>Spring</code>已经突飞猛进，涉及的范围扩展到<code>Java</code>应用开发的各个方面。<br>因此，为了介绍<code>Spring</code>的现状，我们需要对这本书升级了。在本书上一版出版到现在的几年间，发生了太多的事情，想在这一版中将所有的变化都涵盖进来是不可能的。不过，在第4版的《<code>Spring</code>实战》中，我依然会使其包含尽可能多的内容。下面列出了在这一版中新增的一些令人兴奋的新内容：</p><ul><li>强调基于<code>Java</code>的<code>Spring</code>配置，基于<code>Java</code>的配置方案几乎可以用在所有<code>Spring</code>开发领域之中；</li><li>条件化的配置以及<code>profile</code>特性能够让<code>Spring</code>在运行时确定该使用或忽略哪些<code>Spring</code>配置；</li><li><code>Spring MVC</code>的多项增强和改善，尤其是与创建<code>REST</code>服务相关的；</li><li>在<code>Spring</code>应用中使用<code>Thymeleaf</code>替代<code>JSP</code>；</li><li>使用基于<code>Java</code>的配置启用<code>Spring Security</code>；</li><li>使用<code>Spring Data</code>，在运行时自动为<code>JPA</code>、<code>MongoDB</code>和<code>Neo4j</code>生成<code>Repository</code>实现；</li><li><code>Spring</code>新提供的声明式缓存支持；</li><li>借助<code>WebSocket</code>和<code>STOMP</code>，实现异步的<code>Web</code>消息；</li><li><code>Spring Boot</code>，改变使用<code>Spring</code>游戏规则的新方法。</li></ul><p>如果在<code>Spring</code>方面读者已经有相当多经验的话,那么将会发现这些新元素对于自己的<code>Spring</code>工具箱来说是非常有价值的补充。如果读者是要学习<code>Spring</code>的新手,那么就赶上了学习<code>Spring</code>的一个好时代,这本书会帮助读者起步。</p><p>对于<code>Spring</code>的使用来说,这的确是一个令人兴奋的时代。在过去的12年里,在使用<code>Spring</code>进行开发以及编写与之相关的文章方面形成了一股浪潮。我迫不及待地想看到<code>Spring</code>接下来会做些什么!</p>]]></content>
      
      
      <categories>
          
          <category> Spring实战 (第4版) </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>精通Spring MVC4 译者序</title>
      <link href="/ReadingNotes//dbb822e5/"/>
      <url>/ReadingNotes//dbb822e5/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/dbb822e5/#精通Spring-MVC4-译者序" class="header_1">精通Spring MVC4 译者序</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="精通Spring-MVC4-译者序"><a href="#精通Spring-MVC4-译者序" class="headerlink" title="精通Spring MVC4 译者序"></a>精通Spring MVC4 译者序</h1>]]></content>
      
      
      <categories>
          
          <category> 精通Spring MVC4 </category>
          
          <category> 第0章 前言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring实战 第4版 内容提要</title>
      <link href="/ReadingNotes//907c6ccc/"/>
      <url>/ReadingNotes//907c6ccc/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/907c6ccc/#Spring实战-第4版-内容提要" class="header_1">Spring实战 第4版 内容提要</a>&nbsp;<br><a href="/ReadingNotes/907c6ccc/#关于本书" class="header_1">关于本书</a>&nbsp;<br><a href="/ReadingNotes/907c6ccc/#路线图" class="header_1">路线图</a>&nbsp;<br><a href="/ReadingNotes/907c6ccc/#第1部分" class="header_2">第1部分</a>&nbsp;<br><a href="/ReadingNotes/907c6ccc/#第2部分" class="header_2">第2部分</a>&nbsp;<br><a href="/ReadingNotes/907c6ccc/#第3部分" class="header_2">第3部分</a>&nbsp;<br><a href="/ReadingNotes/907c6ccc/#最后部分" class="header_2">最后部分</a>&nbsp;<br><a href="/ReadingNotes/907c6ccc/#代码规范与下载" class="header_1">代码规范与下载</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="Spring实战-第4版-内容提要"><a href="#Spring实战-第4版-内容提要" class="headerlink" title="Spring实战 第4版 内容提要"></a>Spring实战 第4版 内容提要</h1><p>本书是经典的、畅销的<code>Spring</code>学习和实践指南。<br>第4版针对<code>Spring4</code>进行了全面更新。全书分为4部分。</p><ul><li>第1部分介绍<code>Spring</code>框架的核心知识。</li><li>第2部分在此基础上介绍了如何使用<code>Spring</code>构建<code>Web</code>应用程序。</li><li>第3部分告别前端,介绍了如何在应用程序的后端使用<code>Spring</code>。</li><li>第4部分描述了如何使用<code>Spring</code>与其他的应用和服务进行集成。</li></ul><p>本书适用于已具有一定<code>Java</code>编程基础的读者,以及在<code>Java</code>平台下进行各类软件的开发人员、测试人员,尤其适用于企业级<code>Java</code>开发人员。本书既可以被刚开始学习<code>Spring</code>的读者当作学习指南,也可以被那些想深入了解<code>Spring</code>某方面功能的资深用户作为参考用书。</p><h1 id="关于本书"><a href="#关于本书" class="headerlink" title="关于本书"></a>关于本书</h1><p><code>Spring</code>框架是以简化<code>Java EE</code>应用程序的开发为目标而创建的。同样,本书是为了帮助读者更容易地使用<code>Spring</code>而编写的。我的目标不是为读者详细地列出<code>Spring API</code>,而是希望通过现实中的实际示例代码来为<code>Java EE</code>开发人员展现<code>Spring</code>框架。因为<code>Spring</code>是一个模块化的框架,所以这本书也是按照这种方式编写的。我们知道并不是所有的开发人员都有相同的需求,有些人想从头学习<code>Spring</code>,而有的可能只想排出几个主题,然后按照自己的节奏来学习。所以,本书既可以被刚开始学习<code>Spring</code>的读者当作学习指南,也可以被那些想深入了解某方面功能的读者作为参考。<br>本书适用于所有的<code>Java</code>开发人员,企业级<code>Java</code>开发人员将会发现更有帮助。我将会循序渐进地指导读者浏览本书中每章复杂的示例代码,但<code>Spring</code>的真正强大之处在于它能够使企业级应用程序的开发更简单。因此,企业级应用程序的开发人员会更加欣赏本书的示例代码。因为<code>Spring</code>的绝大部分内容都是提供企业级服务的,所以这里包含了许多<code>Spring</code>和<code>EJB</code>的比较。</p><h1 id="路线图"><a href="#路线图" class="headerlink" title="路线图"></a>路线图</h1><p>本书分为4部分。</p><ul><li>第1部分介绍<code>Spring</code>框架的核心知识。</li><li>第2部分在此基础上介绍如何使用<code>Spring</code>构建<code>Web</code>应用程序。</li><li>第3部分告别前端,介绍如何在应用程序的后端使用<code>Spring</code>。</li><li>第4部分描述如何使用<code>Spring</code>与其他的应用和服务进行集成。</li></ul><h2 id="第1部分"><a href="#第1部分" class="headerlink" title="第1部分"></a>第1部分</h2><p>在第1部分中,读者将会学习到<code>Spring</code>容器、依赖注入(<code>dependency injection</code>,<code>DI</code>)和面向切面编程(<code>aspect-oriented programming</code>,<code>AOP</code>),也就是<code>Spring</code>框架的核心。这能让读者很好地理解<code>Spring</code>的基础原理,而这些原理将会在本书各个章节都会用到。</p><ul><li>第1章将会概要地介绍<code>Spring</code>,包括DI和<code>AOP</code>的一些基本样例。同时,读者还会了解到更大的<code>Spring</code>生态系统的整体情况。</li><li>第2章更为详细地介绍DI,展现应用程序中的各个组件(<code>bean</code>)如何装配在一起。这包括基于<code>XML</code>装配、基于<code>Java</code>装配以及自动装配。</li><li>在掌握了基本的<code>bean</code>装配后,第3章会介绍几种高级装配技术,读者可能并不会经常用到这些技术,但是如果用到的话,本章的内容将会告诉读者如何发挥<code>Spring</code>容器最强大的威力。</li><li>第4章介绍如何使用<code>Spring</code>的<code>AOP</code>来为对象解耦那些对其提供服务的横切性关注点。这一章也为后面各章提供基础,在后面读者将会使用<code>AOP</code>来提供声明式服务,如事务、安全和缓存。</li></ul><h2 id="第2部分"><a href="#第2部分" class="headerlink" title="第2部分"></a>第2部分</h2><p>在第2部分中,读者将会看到如何使用<code>Spring</code>来构建<code>Web</code>应用程序。</p><ul><li>第5章介绍使用<code>Spring MVC</code>的基础知识，这是<code>Spring</code>中的基础<code>Web</code>框架。读者将会看到如何编写控制器来处理请求，并使用模型数据产生响应。</li><li>当控制器的工作完成后，模型数据必须要使用一个视图来进行渲染。第6章将会探讨在<code>Spring</code>中可以使用的各种视图技术，包括<code>JSP</code>、<code>Apache Tiles</code>以及<code>Thymeleaf</code>。</li><li>第7章的内容不再是<code>Spring MVC</code>的基础知识了，在本章中，读者将会学习到如何自定义<code>Spring MVC</code>配置、处理<code>multipart</code>类型的文件上传、处理在控制器中可能会出现的异常并且会通过<code>flash</code>属性在请求之间传递数据。</li><li>第8章将会介绍<code>Spring Web Flow</code>，这是<code>Spring MVC</code>的一个扩展，能够开发会话式的<code>Web</code>应用程序。在本章中，读者将会学习到如何构建引导用户完成特定流程的<code>Web</code>应用程序。</li><li>第9章读者将会学到如何使用<code>Spring Security</code>为自己的应用程序<code>Web</code>层实现安全性。</li></ul><h2 id="第3部分"><a href="#第3部分" class="headerlink" title="第3部分"></a>第3部分</h2><p>第3部分所关注的内容不再是应用程序的前端了,而是关注于如何处理和持久化数据。</p><ul><li>第10章首先会介绍如何使用<code>Spring</code>对<code>JDBC</code>的抽象实现关系型数据库中的数据持久化。</li><li>第11章从另外一个角度介绍数据持久化，也就是使用<code>Java</code>持久化<code>API</code>（<code>JPA</code>）存储关系型数据库中的数据。</li><li>第12章将会介绍如何将<code>Spring</code>与非关系型数据库结合使用，如<code>MongoDB</code>和<code>Neo4j</code>。</li><li>不管数据存储在什么地方，缓存都有助于性能的提升，这是通过只有在必要的时候才去查询数据库实现的。第13章将会为读者介绍<code>Spring</code>对声明式缓存的支持。</li><li>第14章重新回到<code>Spring Security</code>，将会介绍如何通过<code>AOP</code>将安全性应用到方法级别。</li></ul><h2 id="最后部分"><a href="#最后部分" class="headerlink" title="最后部分"></a>最后部分</h2><p>本书的最后一部分会介绍如何将<code>Spring</code>应用程序与其他系统进行集成。</p><ul><li>第15章将会学习如何创建与使用远程服务，包括<code>RMI</code>、<code>Hessian</code>、<code>Burlap</code>以及基于<code>SOAP</code>的服务。</li><li>第16章将会再次回到<code>Spring MVC</code>，我们将会看到如何创建<code>RESTful</code>服务，在这个过程中所使用的编程模型与之前在第5章中所描述的是一致的。</li><li>第17章将会探讨<code>Spring</code>对异步消息的支持，本章将会包括<code>Java</code>消息服务（<code>Java Message Service</code>，<code>JMS</code>）以及高级消息队列协议（<code>Advanced Message Queuing Protocol</code>，<code>AMQP</code>）。</li><li>在第18章中，异步消息有了新的花样，在这一章中读者会看到如何将<code>Spring</code>与<code>WebSocket</code>和<code>STOMP</code>结合起来，实现服务端与客户端之间的异步通信。</li><li>第19章将会介绍如何使用<code>Spring</code>发送<code>E-mail</code>。</li><li>第20章会关注于<code>Spring</code>对<code>Java</code>管理扩展（<code>Java Management Extensions</code>，<code>JMX</code>）功能的支持，借助这项功能可以对<code>Spring</code>应用程序进行监控和修改运行时配置。</li><li>最后，在第21章，读者将会看到一个全新并且会改变游戏规则的<code>Spring</code>使用方式，名为<code>Spring Boot</code>。我们将会看到<code>Spring Boot</code>如何将<code>Spring</code>应用中样板式的配置移除掉，这样就能让读者更加专注于业务功能。</li></ul><h1 id="代码规范与下载"><a href="#代码规范与下载" class="headerlink" title="代码规范与下载"></a>代码规范与下载</h1><p>本书中有大量的示例代码。这些代码将会使用固定宽度的代码字体。本书正文中的类名、方法名或<code>XML</code>片段也都使用代码字体。<br>很多<code>Spring</code>类和包的名字很长（不过会有较强的表达性）。鉴于此，我们有时候会用到换行符（➥）。<br>本书中的示例代码并不都是完整的。为了关注某个主题，我有时候只会展示类的一个或两个方法。本书所构建的应用程序完整代码可以在出版社站点上下载，地址是<a href="https://www.manning.com/books/spring-in-action-fourth-edition" target="_blank" rel="noopener">https://www.manning.com/books/spring-in-action-fourth-edition</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring实战 (第4版) </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>精通Spring MVC4 内容提要</title>
      <link href="/ReadingNotes//2f175477/"/>
      <url>/ReadingNotes//2f175477/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/2f175477/#精通Spring-MVC4-内容提要" class="header_1">精通Spring MVC4 内容提要</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="精通Spring-MVC4-内容提要"><a href="#精通Spring-MVC4-内容提要" class="headerlink" title="精通Spring MVC4 内容提要"></a>精通Spring MVC4 内容提要</h1><p>本书中从头开始构建了一个完整的<code>Web</code>应用。全书共10章,分别介绍了快速搭建<code>Spring``Web</code> 应用、精通<code>MVC</code> 结构、处理表单和复杂的<code>URL</code> 映射、文件上传与错误处理、创建<code>RESTful</code> 应用、保护应用、单元测试与验收测试、优化请求、将<code>Web</code> 应用部署到云等内容,循序渐进地讲解了<code>Spring MVC 4</code>的开发技巧。<br>本书最适合已经熟悉<code>Spring</code>编程基础知识并迫切希望扩展其<code>Web</code>技能的开发人员。通过阅读本书,读者将深度把握<code>Spring MVC</code> 的各项特性及实用技巧。</p>]]></content>
      
      
      <categories>
          
          <category> 精通Spring MVC4 </category>
          
          <category> 第0章 前言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第2部分 Java程序设计</title>
      <link href="/ReadingNotes//550a73ea/"/>
      <url>/ReadingNotes//550a73ea/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/550a73ea/#第2部分-Java程序设计" class="header_1">第2部分 Java程序设计</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="第2部分-Java程序设计"><a href="#第2部分-Java程序设计" class="headerlink" title="第2部分 Java程序设计"></a>第2部分 Java程序设计</h1><p>本部分 主要以<code>Java</code> 设计语言为基础, 通过大量实际的 例子分析各 大公司<code>Java</code> 面试题目, 从技术上分析面试题的内涵。 一般公司的 面试题 都是两套—— C++ 或<code>Java</code>, 面试者可以选择。<br>许多面试题 看似简单, 却需要深厚的 基本功才能给出完美的 解答。 企业要求面试者写 一个最简单的<code>final</code> 方法就可看出面试者在技术上究竟达到了 怎样的 程度, 我们能 真正写好一个<code>final</code> 方法吗? 我们都 觉得自己能, 可是我们写出的<code>final</code> 很可能只能拿到10 分中的2 分。 读者可从本 部分中 关于<code>Java</code> 的几个常见考 点, 如<code>reflection</code> 问题、 <code>I/O</code> 问题、面向对象及 接口等 方面看看自己属于什么样的 层次。 此外, 还有一些面试题 考查面试者敏捷的 思维能力。<br>分析这些面试题, 本身包含很强的 趣味性。 而作为 一名研发人员, 通过对这些 面试题的深入剖析则 可进一步增强自身的 内功。</p>]]></content>
      
      
      <categories>
          
          <category> Java程序员面试宝典 第4版 </category>
          
          <category> 第2部分 Java程序设计 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第5章 Java程序设计基本概念</title>
      <link href="/ReadingNotes//af245703/"/>
      <url>/ReadingNotes//af245703/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/af245703/#第5章-Java程序设计基本概念" class="header_1">第5章 Java程序设计基本概念</a>&nbsp;<br><a href="/ReadingNotes/af245703/#5-1-JVM" class="header_2">5. 1 JVM</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="第5章-Java程序设计基本概念"><a href="#第5章-Java程序设计基本概念" class="headerlink" title="第5章 Java程序设计基本概念"></a>第5章 Java程序设计基本概念</h1><p>对于一个求职者或者应届毕业生来说, 公司除了对项目经验有所问询之外, 最好的考试办法就是检查基本功, 包括编程风格, 以及对赋值语句、 递增语句、 类型转换、 数据交换等程序设计基本概念的理解。</p><h2 id="5-1-JVM"><a href="#5-1-JVM" class="headerlink" title="5. 1 JVM"></a>5. 1 JVM</h2>]]></content>
      
      
      <categories>
          
          <category> Java程序员面试宝典 第4版 </category>
          
          <category> 第2部分 Java程序设计 </category>
          
          <category> 第5章 Java程序设计基本概念 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.5 移除事件处理程序</title>
      <link href="/ReadingNotes//87b0a2b5/"/>
      <url>/ReadingNotes//87b0a2b5/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/87b0a2b5/#3-5-移除事件处理程序" class="header_1">3.5 移除事件处理程序</a>&nbsp;<br><a href="/ReadingNotes/87b0a2b5/#3-5-1-为事件处理程序添加命名空间" class="header_2">3.5.1 为事件处理程序添加命名空间</a>&nbsp;<br><a href="/ReadingNotes/87b0a2b5/#3-5-2-重新绑定事件" class="header_2">3.5.2 重新绑定事件</a>&nbsp;<br><a href="/ReadingNotes/87b0a2b5/#总结" class="header_1">总结</a>&nbsp;<br><a href="/ReadingNotes/87b0a2b5/#off方法" class="header_2">off方法</a>&nbsp;<br><a href="/ReadingNotes/87b0a2b5/#移除事件上的所有事件处理方法" class="header_3">移除事件上的所有事件处理方法</a>&nbsp;<br><a href="/ReadingNotes/87b0a2b5/#移除事件命名空间上的所有事假处理方法" class="header_3">移除事件命名空间上的所有事假处理方法</a>&nbsp;<br><a href="/ReadingNotes/87b0a2b5/#命名函数" class="header_3">命名函数</a>&nbsp;<br><a href="/ReadingNotes/87b0a2b5/#移除命名的事件处理方法" class="header_3">移除命名的事件处理方法</a>&nbsp;<br><a href="/ReadingNotes/87b0a2b5/#one方法" class="header_2">one方法</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="3-5-移除事件处理程序"><a href="#3-5-移除事件处理程序" class="headerlink" title="3.5 移除事件处理程序"></a>3.5 移除事件处理程序</h1><p>有时候,我们需要<strong>停用以前注册的事件处理程序</strong>。可能是因为页面的状态发生了变化,导致相应的操作不再有必要。处理这种情形的一种典型做法,就是在事件处理程序中使用条件语句。但是,如果能够完全移除处理程序绑定显然更有效率。<br>假设我们希望折叠样式转换器在页面没有使用正常样式的情况下保持扩展状态, 即当<code>Narrow Column</code>或<code>Large Print</code>按钮被选中时,单击样式转换器的背景区域不应该引发任何操作。为此,可以在单击非默认样式转换按钮时,调用<code>.off()</code>方法移除折叠处理程序,如代码清单3-18所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#switcher-narrow, #switcher-large'</span>).click(function () &#123;</span><br><span class="line"><span class="comment">// 移除DOM上的click程序,即折叠处理程序</span></span><br><span class="line">$(<span class="string">'#switcher'</span>).off(<span class="string">'click'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>现在,如果单击<code>Narrow Column</code>按钮,样式转换器(<code>&lt;div&gt;</code>)上的单击处理程序就会被移除。然后,再单击背景区域将不会导致它折叠起来。但是,按钮本身的作用却失效了!由于为使用事件委托而重写了按钮处理代码,因此按钮本身也带有样式转换器(<code>&lt;div&gt;</code>)的单击事件处理程序。换句话说,在调用<code>$(&#39;#switcher&#39;).off(&#39;click&#39;)</code>时,会导致按钮上绑定的两个事件处理程序都被移除。</p><h2 id="3-5-1-为事件处理程序添加命名空间"><a href="#3-5-1-为事件处理程序添加命名空间" class="headerlink" title="3.5.1 为事件处理程序添加命名空间"></a>3.5.1 为事件处理程序添加命名空间</h2><p>显然,应该让对<code>.off()</code>的调用更有针对性,以避免把注册的两个单击处理程序全都移除。达成目标的一种方式是使用<code>事件命名空间</code>,即<code>在绑定事件时引入附加信息,以便将来识别特定的处理程序</code>。要使用命名空间,需要退一步使用绑定事件处理程序的非简写方法,即<code>.on()</code>方法本身。<br>我们为<code>.on()</code>方法传递的第一个参数,应该是想要截获的事件的名称。不过,在此可以使用一种特殊的语法形式,即对事件加以细分,参见代码清单3-19。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$(document).ready(function() &#123; </span><br><span class="line">  $(<span class="string">'#switcher'</span>).on(<span class="string">'click.collapse'</span>, function(event) &#123; </span><br><span class="line">    <span class="keyword">if</span> (!$(event.target).is(<span class="string">'button'</span>)) &#123; </span><br><span class="line">      $(<span class="string">'#switcher button'</span>).toggleClass(<span class="string">'hidden'</span>); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;); </span><br><span class="line">  $(<span class="string">'#switcher-narrow, #switcher-large'</span>).click(function() &#123; </span><br><span class="line">    $(<span class="string">'#switcher'</span>).off(<span class="string">'click.collapse'</span>); </span><br><span class="line">  &#125;); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>对于事件处理系统而言,后缀<code>.collapse</code>是不可见的。换句话说,这里仍然会像编写<code>.on(&#39;click&#39;)</code>一样,让注册的函数响应单击事件。但是,通过附加的命名空间信息,则可以解除对这个特定处理程序的绑定,同时不影响为按钮注册的其他单击处理程序。</p><h2 id="3-5-2-重新绑定事件"><a href="#3-5-2-重新绑定事件" class="headerlink" title="3.5.2 重新绑定事件"></a>3.5.2 重新绑定事件</h2><p>现在单击<code>Narrow Column</code>或<code>Large Print</code>按钮,会导致样式转换器的折叠功能失效。可是,我们希望该功能在单击<code>Default</code>按钮时恢复。为此,应该在<code>Default</code>按钮被单击时,重新绑定事件处理程序。<br>首先,应该为事件处理程序起个名字,以便多次使用,参见代码清单3-20。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> toggleSwitcher = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (!$(event.target).is(<span class="string">'button'</span>)) &#123; </span><br><span class="line">      $(<span class="string">'#switcher button'</span>).toggleClass(<span class="string">'hidden'</span>); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;; </span><br><span class="line">  $(<span class="string">'#switcher'</span>).on(<span class="string">'click.collapse'</span>, toggleSwitcher); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>我们注意到,这里使用了另一种定义函数的语法,即没有使用函数声明(前置<code>function</code>关键字) ,而是将一个<code>匿名函数</code>表达式指定给了一个<code>局部变量</code>。除了两点微妙的差异(但在这里并不存在)之外,无论使用哪种语法,它们的功能都是等价的。这里使用函数表达式只是为了从形式上让事件处理程序与其他函数定义显得类似。<br>而且,我们知道传递给<code>.on()</code>的第二个参数是一个函数引用。在此需要强调一点,<strong>使用命名函数时,必须省略函数名称后面的圆括号</strong>。圆括号会导致函数被<code>调用</code>,而非被<code>引用</code>。<br>在函数有了可以引用的名字之后,将来就可以再次绑定而无需重新定义它了,如代码清单3-21所示<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//未完成的代码 </span></span><br><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> toggleSwitcher = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (!$(event.target).is(<span class="string">'button'</span>)) &#123; </span><br><span class="line">      $(<span class="string">'#switcher button'</span>).toggleClass(<span class="string">'hidden'</span>); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;; </span><br><span class="line">  $(<span class="string">'#switcher'</span>).on(<span class="string">'click.collapse'</span>, toggleSwitcher); </span><br><span class="line">  $(<span class="string">'#switcher-narrow, #switcher-large'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    $(<span class="string">'#switcher'</span>).off(<span class="string">'click.collapse'</span>); </span><br><span class="line">  &#125;); </span><br><span class="line">  $(<span class="string">'#switcher-default'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    $(<span class="string">'#switcher'</span>) </span><br><span class="line">      .on(<span class="string">'click.collapse'</span>, toggleSwitcher); </span><br><span class="line">  &#125;); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>这样,切换样式转换器的行为当文档加载后会被绑定。当单击<code>Narrow Column</code>或<code>Large Print</code>按钮时会解除绑定,而当此后再单击<code>Default</code>按钮时,又会恢复绑定。<br>使用命名函数还有另外一个好处,即不必再使用事件命名空间。因为<code>.off()</code>可以将这个命名函数作为第二个参数,结果只会解除对特定处理程序的绑定。但这样就会遇到另一个问题,当在<code>jQuery</code>中把处理程序绑定到事件时,之前绑定的处理程序仍然有效。在这个例子中,每次点击<code>Default</code>,就会有一个<code>toggleSwitcher</code>的副本被绑定到样式转换器。换句话说,在用户单击<code>Narrow</code>或<code>Large Print</code>之前(这样就可以一次性地解除对<code>toggleSwitcher</code>的绑定),每多单击一次都会多调用一次这个函数。<br>在绑定<code>toggleSwitcher</code>偶数次的情况下,单击样式转换器(不是按钮),好像一切都没有发生变化。事实上,这是因为切换了<code>hidden</code>类偶数次,结果状态与开始的时候相同。为了解决这个问题,可以在用户单击任意按钮时解除绑定,并在确定单击按钮的ID是<code>switcher-default</code>的情况下再重新绑定,参见代码清单3-22。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 定义命名函数</span></span><br><span class="line">  <span class="keyword">var</span> toggleSwitcher = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!$(event.target).is(<span class="string">'button'</span>)) &#123;</span><br><span class="line">      $(<span class="string">'#switcher button'</span>).toggleClass(<span class="string">'hidden'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 一上来就注册点击事件处理程序toggleSwitcher</span></span><br><span class="line">  $(<span class="string">'#switcher'</span>).on(<span class="string">'click'</span>, toggleSwitcher);</span><br><span class="line"></span><br><span class="line">  $(<span class="string">'#switcher button'</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 移除点击事件处理程序toggleSwitcher</span></span><br><span class="line">    $(<span class="string">'#switcher'</span>).off(<span class="string">'click'</span>, toggleSwitcher);</span><br><span class="line">    <span class="comment">// 该按钮时默认按钮</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.id == <span class="string">'switcher-default'</span>) &#123;</span><br><span class="line">      <span class="comment">// 注册点击事件处理程序toggleSwitcher</span></span><br><span class="line">      <span class="comment">// 同一个DOM上可以用多个点击事件处理程序,</span></span><br><span class="line">      $(<span class="string">'#switcher'</span>).on(<span class="string">'click'</span>, toggleSwitcher);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>对于只需触发一次,随后要立即解除绑定的情况也有一种简写方法——<code>.one()</code>,这个简写方法的用法如下:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#switcher'</span>).one(<span class="string">'click'</span>, toggleSwitcher);</span><br></pre></td></tr></table></figure><br>这样会使切换操作只发生一次，之后就再也不会发生。 </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><!--SSTStart--><h2 id="off方法"><a href="#off方法" class="headerlink" title="off方法"></a>off方法</h2><p><code>$(选择符).off(&quot;方法名称&quot;)</code>这个方法可以移除事件处理程序 </p><h3 id="移除事件上的所有事件处理方法"><a href="#移除事件上的所有事件处理方法" class="headerlink" title="移除事件上的所有事件处理方法"></a>移除事件上的所有事件处理方法</h3><p>如<code>$(&#39;#switcher&#39;).off(&#39;click&#39;);</code>可以移除id为<code>switcher</code>的<code>DOM</code>元素上<code>click</code>这个事件注册的所有处理方法。</p><h3 id="移除事件命名空间上的所有事假处理方法"><a href="#移除事件命名空间上的所有事假处理方法" class="headerlink" title="移除事件命名空间上的所有事假处理方法"></a>移除事件命名空间上的所有事假处理方法</h3><p>为了更精确的设置事件处理方法,可以给事件指定命名空间,在off方法上传入事件命名空间,可以移除该事件命名空间上的所有方法,例如: <code>$(&#39;#switcher&#39;).off(&#39;click.collapse&#39;)</code>; 这个方法可以移除事件命名空间click.collapse上所有的事件处理方法.</p><h3 id="命名函数"><a href="#命名函数" class="headerlink" title="命名函数"></a>命名函数</h3><p>所谓命名函数,将一个<code>匿名函数</code>表达式指定给了一个<code>局部变量</code>,这个局部变量就是一个命名函数.引用命名函数时不要带括号,带括号会使得函数被调用,而不是被引用.</p><h3 id="移除命名的事件处理方法"><a href="#移除命名的事件处理方法" class="headerlink" title="移除命名的事件处理方法"></a>移除命名的事件处理方法</h3><p>可以把事件处理方法赋值给一个变量,也就是给事件处理方法命名,这样的话,off方法可以直接移除事件上的该方法,而不需要指定命名空间,例如:<code>$(&#39;#switcher&#39;).off(&#39;click&#39;, toggleSwitcher)</code>;</p><h2 id="one方法"><a href="#one方法" class="headerlink" title="one方法"></a>one方法</h2><p><code>one</code>方法可以触发一次,触发后立即解除.<br><!--SSTStop--></p>]]></content>
      
      
      <categories>
          
          <category> jQuery基础教程 第4版 </category>
          
          <category> 第3章 事件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.4 通过事件对象改变事件的旅程</title>
      <link href="/ReadingNotes//a4e0166f/"/>
      <url>/ReadingNotes//a4e0166f/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/a4e0166f/#3-4-通过事件对象改变事件的旅程" class="header_1">3.4 通过事件对象改变事件的旅程</a>&nbsp;<br><a href="/ReadingNotes/a4e0166f/#3-4-1-事件目标" class="header_2">3.4.1 事件目标</a>&nbsp;<br><a href="/ReadingNotes/a4e0166f/#3-4-2-停止事件传播" class="header_2">3.4.2 停止事件传播</a>&nbsp;<br><a href="/ReadingNotes/a4e0166f/#3-4-3-阻止默认操作" class="header_2">3.4.3 阻止默认操作</a>&nbsp;<br><a href="/ReadingNotes/a4e0166f/#3-4-4-事件委托" class="header_2">3.4.4 事件委托</a>&nbsp;<br><a href="/ReadingNotes/a4e0166f/#is-与-hasClass" class="header_3">is()与`.hasClass()</a>&nbsp;<br><a href="/ReadingNotes/a4e0166f/#3-4-5-使用内置的事件委托功能" class="header_2">3.4.5 使用内置的事件委托功能</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="3-4-通过事件对象改变事件的旅程"><a href="#3-4-通过事件对象改变事件的旅程" class="headerlink" title="3.4 通过事件对象改变事件的旅程"></a>3.4 通过事件对象改变事件的旅程</h1><p>我们在前面已经举例说明事件冒泡可能会导致问题的一种情形。为了展示一种<code>.hover()</code>也无能为力的情况,需要改变前面实现的折叠行为。<br>假设我们希望增大触发样式转换器折叠或扩展的可单击区域。一种方案就是将事件处理程序从标签移至包含它的<code>&lt;div&gt;</code>元素。在代码清单3-9中,我们给<code>#switcher h3</code>添加了一个<code>click</code>处理程序,在这里我们要尝试给<code>#switcher</code>添加这个处理程序,如代码清单3-11所示。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="string">'#switcher'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    $(<span class="string">'#switcher button'</span>).toggleClass(<span class="string">'hidden'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>这种改变会使样式转换器的整个区域都可以通过单击切换其可见性。但同时也造成了一个问题,即单击按钮会在修改内容区的样式之后折叠样式转换器。导致这个问题的原因就是<code>事件冒泡</code>,即事件首先被按钮处理,然后又沿着<code>DOM</code>树向上传递,直至到达<code>&lt;div id=&quot;switcher&quot;&gt;</code>激活事件处理程序并隐藏按钮。<br>要解决这个问题,必须访问<code>事件对象</code>。<strong>事件对象是一种<code>DOM</code>结构,它会在元素获得处理事件的机会时传递给被调用的事件处理程序</strong>。这个对象中包含着与事件有关的信息(例如事件发生时的鼠标指针位置),也提供了可以用来影响事件在<code>DOM</code>中传递进程的一些方法。<br>为了在处理程序中使用事件对象,需要为函数添加一个参数:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  $(<span class="string">'#switcher'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123; </span><br><span class="line">    $(<span class="string">'#switcher button'</span>).toggleClass(<span class="string">'hidden'</span>); </span><br><span class="line">  &#125;); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>注意,这里把事件对象命名为<code>event</code>,这主要是为了让大家一看就知道它是什么对象,不是必须这样命名的。就算你把它命名为<code>flapjacks</code>(煎饼),也没有任何问题。</p><h2 id="3-4-1-事件目标"><a href="#3-4-1-事件目标" class="headerlink" title="3.4.1 事件目标"></a>3.4.1 事件目标</h2><p>现在,事件处理程序中的变量<code>event</code>保存着事件对象。而<strong><code>event.target</code>属性保存着发生事件的目标元素</strong>。这个属性是<code>DOM API</code>中规定的,但是没有在某些旧版本的浏览器中实现。<code>jQuery</code>对这个事件对象进行了必要的扩展,从而在任何浏览器中都能够使用这个属性。<strong>通过<code>event.target</code>,可以确定<code>DOM</code>中首先接收到事件的元素</strong>(即实际被单击的元素)。而且,我们知道<strong><code>this</code>引用的是处理事件的<code>DOM</code>元素</strong>,所以可以编写出代码清单3-12。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="string">'#switcher'</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 只处理实际被点击的DOM元素</span></span><br><span class="line">    <span class="comment">// this表示DOM元素,包括实际被点击的DOM元素,及其祖先元素(id为switcher的为最顶层的祖先).</span></span><br><span class="line">    <span class="keyword">if</span> (event.target == <span class="keyword">this</span>) &#123;</span><br><span class="line">      $(<span class="string">'#switcher button'</span>).toggleClass(<span class="string">'hidden'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>此时的代码确保了被单击的元素是<code>&lt;div id=&quot;switcher&quot;&gt;</code>,而不是其他后代元素。现在,单击按钮不会再折叠样式转换器,而单击转换器背景区则会触发折叠操作。但是,单击标签(<code>&lt;h3&gt;</code>)同样什么也不会发生,因为它也是一个后代元素。实际上,我们可以不把检查代码放在这里,而是通过修改按钮的行为来达到目标。</p><h2 id="3-4-2-停止事件传播"><a href="#3-4-2-停止事件传播" class="headerlink" title="3.4.2 停止事件传播"></a>3.4.2 停止事件传播</h2><p><strong>事件对象还提供了一个<code>.stopPropagation()</code>方法,该方法可以完全阻止事件冒泡</strong>。与<code>.target</code>类似,这个方法也是一种基本的<code>DOM</code>特性,但在<code>IE8</code>及更早版本中则无法安全地使用。不过,只要我们通过<code>jQuery</code>来注册所有的事件处理程序,就可以放心地使用这个方法。<br>下面,我们会删除刚才添加的检查语句<code>event.target == this</code>,并在按钮的单击处理程序中添加一些代码,参见代码清单3-13。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 鼠标进出时调用</span></span><br><span class="line">  $(<span class="string">'#switcher h3'</span>).hover(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="keyword">this</span>).addClass(<span class="string">'hover'</span>);</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="keyword">this</span>).removeClass(<span class="string">'hover'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 背景的事件处理程序</span></span><br><span class="line">  $(<span class="string">'#switcher'</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    $(<span class="string">'#switcher button'</span>).toggleClass(<span class="string">'hidden'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="string">'#switcher-default'</span>).addClass(<span class="string">'selected'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按钮的点击事件处理程序</span></span><br><span class="line">  $(<span class="string">'#switcher button'</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 动态生成class属性</span></span><br><span class="line">    <span class="keyword">var</span> bodyClass = <span class="keyword">this</span>.id.split(<span class="string">'-'</span>)[<span class="number">1</span>];</span><br><span class="line">    $(<span class="string">'body'</span>).removeClass().addClass(bodyClass);</span><br><span class="line"></span><br><span class="line">    $(<span class="string">'#switcher button'</span>).removeClass(<span class="string">'selected'</span>);</span><br><span class="line">    $(<span class="keyword">this</span>).addClass(<span class="string">'selected'</span>);</span><br><span class="line">    <span class="comment">// 停止事件传播,该事件不会传播到祖先元素</span></span><br><span class="line">    event.stopPropagation();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>同以前一样,需要为用作单击处理程序的函数添加一个参数,以便访问事件对象。然后,通过调用<code>event.stopPropagation()</code>就可以避免其他所有<code>DOM</code>元素响应这个事件。这样一来,<strong>单击按钮的事件会被按钮处理,而且只会被按钮处理</strong>。单击样式转换器的其他地方则可以折叠和扩展整个区域。</p><h2 id="3-4-3-阻止默认操作"><a href="#3-4-3-阻止默认操作" class="headerlink" title="3.4.3 阻止默认操作"></a>3.4.3 阻止默认操作</h2><p>如果我们把单击事件处理程序注册到锚元素(<code>&lt;a&gt;</code>),而不是外层的<code>&lt;div&gt;</code>上,那么就要面对另外一个问题:当用户单击链接时,浏览器会加载一个新页面。这种行为与我们讨论的事件处理程序不是同一个概念,它是单击锚元素的默认操作。类似地,当用户在编辑完表单后按下回车键时,会触发表单的<code>submit</code>事件,在此事件发生后,表单提交才会真正发生。<br>即便在事件对象上调用<code>event.stopPropagation()</code>方法也不能禁止这种默认操作,因为默认操作不是在正常的事件传播流中发生的。在这种情况下,<code>event.preventDefault()</code>方法则可以在触发默认操作之前终止事件。</p><p>在事件的环境中完成了某些验证之后,通常会用到<code>event.preventDefault()</code>。例如,在表单提交期间,我们会对用户是否填写了必填字段进行检查,如果用户没有填写相应字段,那么就需要阻止默认操作。</p><p>事件传播和默认操作是相互独立的两套机制,在二者任何一方发生时,都可以终止另一方。如果想要同时停止事件传播和默认操作,可以在事件处理程序中返回<code>false</code>,这是对在事件对象上同时调用<code>.stopPropagation()</code>和<code>.preventDefault()</code>的一种简写方式。</p><h2 id="3-4-4-事件委托"><a href="#3-4-4-事件委托" class="headerlink" title="3.4.4 事件委托"></a>3.4.4 事件委托</h2><p>事件冒泡并不总是带来问题,也可以利用它为我们带来好处。<code>事件委托</code>就是利用冒泡的一项高级技术。通过<code>事件委托</code>,可以借助一个元素上的事件处理程序完成很多工作。<br>在我前面的例子中,只有3个<code>&lt;div class=&quot;button&quot;&gt;</code>元素注册了单击处理程序。假如我们想为更多元素注册处理程序怎么办?这种情况比我们想象的更常见。例如,有一个显示信息的大型表格,每一行都有一项需要注册单击处理程序。虽然不难通过隐式迭代来指定所有单击处理程序,但性能可能会很成问题,因为循环是由<code>jQuery</code>在内部完成的,而且要维护所有处理程序也需要占用很多内存。<br>为解决这个问题,<strong>可以只在<code>DOM</code>中的一个祖先元素上指定一个单击处理程序。由于事件会冒泡,未遭拦截的单击事件最终会到达这个祖先元素,而我们可以在此时再作出相应处理</strong>。<br>下面我们就以样式转换器为例(尽管其中的按钮数量还不至于使用这种方法),说明如何用这种技术。从代码清单3-12中可以看到,当发生单击事件时,<strong>可以使用<code>event.target</code>属性查鼠标指针下方是什么元素</strong>。下面是代码清单3-14。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="string">'#switcher h3'</span>).hover(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="keyword">this</span>).addClass(<span class="string">'hover'</span>);</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="keyword">this</span>).removeClass(<span class="string">'hover'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="string">'#switcher'</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 隐藏所有的按钮</span></span><br><span class="line">    $(<span class="string">'#switcher button'</span>).toggleClass(<span class="string">'hidden'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="string">'#switcher-default'</span>).addClass(<span class="string">'selected'</span>);</span><br><span class="line"></span><br><span class="line">  $(<span class="string">'#switcher'</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果触发这个事件的DOM元素时按钮的话</span></span><br><span class="line">    <span class="keyword">if</span> ($(event.target).is(<span class="string">'button'</span>)) &#123;</span><br><span class="line">      <span class="comment">// 根据该DOM元素(event.target)的id生成class属性值</span></span><br><span class="line">      <span class="keyword">var</span> bodyClass = event.target.id.split(<span class="string">'-'</span>)[<span class="number">1</span>];</span><br><span class="line">      <span class="comment">// 移除body元素上的所有class,然后再添加生成的class</span></span><br><span class="line">      $(<span class="string">'body'</span>).removeClass().addClass(bodyClass);</span><br><span class="line">      <span class="comment">// 所有按钮都不选中</span></span><br><span class="line">      $(<span class="string">'#switcher button'</span>).removeClass(<span class="string">'selected'</span>);</span><br><span class="line">      <span class="comment">// 选中当前的按钮</span></span><br><span class="line">      $(event.target).addClass(<span class="string">'selected'</span>);</span><br><span class="line">      <span class="comment">// 阻止事件冒泡</span></span><br><span class="line">      event.stopPropagation();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>这里使用了一个新方法,即<code>.is()</code>方法。这个方法接收一个选择符表达式(第2章介绍过) ,然后用选择符来测试当前的<code>jQuery</code>对象。如果集合中至少有一个元素与选择符匹配, <code>.is()</code>方法返回<code>true</code>。在这个例子中,<code>$(event.target).is(&#39;button&#39;)</code>测试被单击的元素是否包含<code>button</code>标签。如果是,则继续执行以前编写的那些代码——但有一个明显的不同,即此时的关键字<code>this</code>引用的是<code>&lt;div id=&quot;switcher&quot;&gt;</code>。换句话说,如果现在需要访问被单击的按钮,每次都必须通过<code>event.target</code>来引用。</p><h3 id="is-与-hasClass"><a href="#is-与-hasClass" class="headerlink" title="is()与`.hasClass()"></a>is()与`.hasClass()</h3><p>要测试元素是否包含某个类,也可以使用另一个简写方法<code>.hasClass()</code>,不过,<code>.is()</code>方法则更灵活一些,它可以测试任何选择符表达式。</p><p>然而,以上代码还有一个不期而至的连带效果。当按钮被单击时,转换器会折叠起来,就像没有使用<code>.stopPropagation()</code>之前看到的效果一样。用于切换转换器可见性的处理程序,现在被绑定到了按钮上面。因此,阻止事件冒泡并不会影响切换发生。要解决这个问题,可以去掉对<code>.stopPropagation()</code>的调用,然后添加另一个<code>.is()</code>测试。同样,随着把整个转换器<code>&lt;div&gt;</code>变得可以单击,还应该在用户鼠标悬停时切换<code>hover</code>类,如代码清单3-15所示。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 鼠标悬停事件</span></span><br><span class="line">  $(<span class="string">'#switcher'</span>).hover(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="keyword">this</span>).addClass(<span class="string">'hover'</span>);</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="keyword">this</span>).removeClass(<span class="string">'hover'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="string">'#switcher'</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果触发事件的DOM元素不是按钮的话</span></span><br><span class="line">    <span class="keyword">if</span> (!$(event.target).is(<span class="string">'button'</span>)) &#123;</span><br><span class="line">      <span class="comment">// 隐藏/显示这些按钮</span></span><br><span class="line">      $(<span class="string">'#switcher button'</span>).toggleClass(<span class="string">'hidden'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="string">'#switcher-default'</span>).addClass(<span class="string">'selected'</span>);</span><br><span class="line"></span><br><span class="line">  $(<span class="string">'#switcher'</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果触发点击事件的DOM元素是按钮的话</span></span><br><span class="line">    <span class="keyword">if</span> ($(event.target).is(<span class="string">'button'</span>)) &#123;</span><br><span class="line">      <span class="keyword">var</span> bodyClass = event.target.id.split(<span class="string">'-'</span>)[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">      $(<span class="string">'body'</span>).removeClass().addClass(bodyClass);</span><br><span class="line"></span><br><span class="line">      $(<span class="string">'#switcher button'</span>).removeClass(<span class="string">'selected'</span>);</span><br><span class="line">      $(event.target).addClass(<span class="string">'selected'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>虽然这个例子的代码显得稍微复杂了一点,但随着带有事件处理程序的元素数量增多,使用事件委托终究还是正确的技术。此外,通过组合两个<code>click</code>事件处理程序并使用基于<code>.is()</code>测试的<code>if-else</code>语句,可以减少重复的代码,参见代码清单3-16。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="string">'#switcher'</span>).hover(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="keyword">this</span>).addClass(<span class="string">'hover'</span>);</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="keyword">this</span>).removeClass(<span class="string">'hover'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="string">'#switcher-default'</span>).addClass(<span class="string">'selected'</span>);</span><br><span class="line"></span><br><span class="line">  $(<span class="string">'#switcher'</span>).on(<span class="string">'click'</span>, <span class="string">'button'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bodyClass = event.target.id.split(<span class="string">'-'</span>)[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    $(<span class="string">'body'</span>).removeClass().addClass(bodyClass);</span><br><span class="line"></span><br><span class="line">    $(<span class="string">'#switcher button'</span>).removeClass(<span class="string">'selected'</span>);</span><br><span class="line">    $(<span class="keyword">this</span>).addClass(<span class="string">'selected'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>以上代码仍然有进一步优化的余地,但目前这种情况已经是可以接受的了。不过,为了更深入地理解<code>jQuery</code>的事件处理,我们还要返回代码清单3-16,继续在那个版本上修改。</p><h2 id="3-4-5-使用内置的事件委托功能"><a href="#3-4-5-使用内置的事件委托功能" class="headerlink" title="3.4.5 使用内置的事件委托功能"></a>3.4.5 使用内置的事件委托功能</h2><p>由于事件委托可以解决很多问题,所以<code>jQuery</code>专门提供了一组方法来实现事件委托。前面讨论过的<code>.on</code>()方法可以接受相应参数实现事件委托,如代码清单3-17所示:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#switcher'</span>).on(<span class="string">'click'</span>, <span class="string">'button'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> bodyClass = event.target.id.split(<span class="string">'-'</span>)[<span class="number">1</span>]; </span><br><span class="line">  $(<span class="string">'body'</span>).removeClass().addClass(bodyClass); </span><br><span class="line">  $(<span class="string">'#switcher button'</span>).removeClass(<span class="string">'selected'</span>); </span><br><span class="line">  $(<span class="keyword">this</span>).addClass(<span class="string">'selected'</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>如果给<code>.on()</code>方法传入的第二个参数是一个<code>选择符表达式</code>,<code>jQuery</code>会把<code>click</code>事件处理程序绑定到<code>#switcher</code>对象,同时比较<code>event.target</code>和选择符表达式(这里的<code>&#39;button&#39;</code>)。</p><ul><li>如果<code>event.target</code>和选择符表达式匹配,<code>jQuery</code>会把<code>this</code>关键字映射到匹配的元素,</li><li>如果<code>event.target</code>和选择符表达式不匹配,则不会执行事件处理程序。</li></ul>]]></content>
      
      
      <categories>
          
          <category> jQuery基础教程 第4版 </category>
          
          <category> 第3章 事件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.3 事件传播</title>
      <link href="/ReadingNotes//21530484/"/>
      <url>/ReadingNotes//21530484/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/21530484/#3-3-事件传播" class="header_1">3.3 事件传播</a>&nbsp;<br><a href="/ReadingNotes/21530484/#3-3-1-事件的旅程" class="header_2">3.3.1 事件的旅程</a>&nbsp;<br><a href="/ReadingNotes/21530484/#3-3-2-事件冒泡的副作用" class="header_2">3.3.2 事件冒泡的副作用</a>&nbsp;<br><a href="/ReadingNotes/21530484/#避免冒泡问题" class="header_3">避免冒泡问题</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="3-3-事件传播"><a href="#3-3-事件传播" class="headerlink" title="3.3 事件传播"></a>3.3 事件传播</h1><p>在说明基于通常不可单击的页面元素处理单击事件的能力时,我们构思的界面中已经给出了一些提示——样式表切换器标签(即<code>&lt;h3&gt;</code>元素)实际上都是活动的,随时等待用户操作。为了改进界面,我们可以为按钮添加一种翻转状态,以便清楚地表明它们能与鼠标进行某种方式的交互:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.hover</span> &#123; </span><br><span class="line">  <span class="attribute">cursor</span>: pointer; </span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#afa</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>CSS</code>规范加入了一个名叫<code>:hover</code>的伪类选择符,这个选择符可以让样式表在用户鼠标指针悬停在某个元素上时,影响元素的外观。这个伪类选择符在某种程度上可以帮我们解决问题,但在这里,我们要介绍<code>jQuery</code>的<code>.hover</code>方法。这个方法可以让我们在鼠标指针进入元素和离开元素时,通过<code>JavaScript</code>来改变元素的样式——事实上是可以执行任意操作。</p><p>同前面介绍的简单事件方法不同,<code>.hover()</code>方法接受两个函数参数。</p><ul><li>第一个函数会在鼠标指针进入被选择的元素时执行,</li><li>第二个函数会在鼠标指针离开该元素时触发。</li></ul><p>我们可以在这些时候修改应用到按钮上的类,从而实现翻转效果,参见代码清单3-10。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="string">'#switcher h3'</span>).hover(</span><br><span class="line">    <span class="comment">//鼠标进入时触发</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      $(<span class="keyword">this</span>).addClass(<span class="string">'hover'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 鼠标离开时触发</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      $(<span class="keyword">this</span>).removeClass(<span class="string">'hover'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>这里,我们再次使用隐式迭代和事件上下文实现了简洁的代码。现在,当鼠标指针悬停在<code>&lt;h3&gt;</code>上时,我们都能看到如图3-6中所示的应用了类之后的效果。</p><p>而且,使用<code>.hover()</code>也意味着可以避免<code>JavaScript</code>中的事件传播(<code>event propagation</code>)导致的头痛问题。要理解事件传播的含义,首先必须搞清楚<code>JavaScript</code>如何决定由哪个元素来处理给定的事件。</p><h2 id="3-3-1-事件的旅程"><a href="#3-3-1-事件的旅程" class="headerlink" title="3.3.1 事件的旅程"></a>3.3.1 事件的旅程</h2><p>当页面上发生一个事件时,每个层次上的<code>DOM</code>元素都有机会处理这个事件。以下面的页面模型为例:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"foo"</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"bar"</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.example.com/"</span>&gt;</span> </span><br><span class="line">      The quick brown fox jumps over the lazy dog. </span><br><span class="line">    <span class="tag">&lt;/<span class="name">a</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span> </span><br><span class="line">    How razorback-jumping frogs can level six piqued gymnasts! </span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><br>当在浏览器中形象化地呈现这些由嵌套的代码构成的元素时,我们看到的效果如图3-7所示。</p><p>从逻辑上看,任何事件都可能会有多个元素负责响应。举例来说,如果单击了页面中的链接元素,那么<code>&lt;div&gt;</code>、<code>&lt;span&gt;</code>和<code>&lt;a&gt;</code>全都应该得到响应这次单击的机会。毕竟,这3个元素同时都处于用户鼠标指针之下。而<code>&lt;p&gt;</code>元素则与这次交互操作无关。<br><strong>允许多个元素响应单击事件的一种策略叫做<code>事件捕获</code></strong>①。<strong>在事件捕获的过程中,事件<code>首先会交给最外层的元素</code>,接着再交给更具体的元素</strong>。在这个例子中,意味着单击事件首先会传递给<code>&lt;div&gt;</code>,然后是<code>&lt;span&gt;</code>,最后是<code>&lt;a&gt;</code>,如图3-8所示。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/jQueryJiChuJiaoCheng4/chapter3/1.png" alt="这里有一张图片"><br>另一种相反的策略叫做<strong>事件冒泡</strong>。<strong>即当事件发生时,会首先发送给最具体的元素,在这个元素获得响应机会之后,事件会向上冒泡到更一般的元素</strong>。在我们的例子中,<code>&lt;a&gt;</code>会首先处理事件,然后按照顺序依次是<code>&lt;span&gt;</code>和<code>&lt;div&gt;</code>,如图3-9所示。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/jQueryJiChuJiaoCheng4/chapter3/2.png" alt="这里有一张图片"><br>毫不奇怪,不同的浏览器开发者最初采用的是不同的事件传播模型。因而,最终出台的<code>DOM</code>标准规定应该同时使用这两种策略:</p><ul><li>首先,事件要从一般元素到具体元素逐层捕获,</li><li>然后,事件再通过冒泡返回<code>DOM</code>树的顶层。</li></ul><p>而事件处理程序可以注册到这个过程中的任何一个阶段。<br>为了确保跨浏览器的一致性,而且也为了让人容易理解,<strong><code>jQuery</code>始终会在模型的冒泡阶段注册事件处理程序。因此,我们总是可以假定最具体的元素会首先获得响应事件的机会</strong>。</p><h2 id="3-3-2-事件冒泡的副作用"><a href="#3-3-2-事件冒泡的副作用" class="headerlink" title="3.3.2 事件冒泡的副作用"></a>3.3.2 事件冒泡的副作用</h2><p>事件冒泡可能会导致始料不及的行为,特别是在错误的元素响应<code>mouseover</code>或<code>mouseout</code>事件的情况下。<br>假设在我们的例子中,为<code>&lt;div&gt;</code>添加了一个<code>mouseout</code>事件处理程序。<br>当用户的鼠标指针退出这个<code>&lt;div&gt;</code>时,会按照预期运行<code>mouseout</code>处理程序。因为这个过程发生在顶层元素上,所以其他元素不会取得这个事件。<br>但是,当指针从<code>&lt;a&gt;</code>元素上离开时,<code>&lt;a&gt;</code>元素也会取得一个<code>mouseout</code>事件。然后,这个事件会向上冒泡到<code>&lt;span&gt;</code>和<code>&lt;div&gt;</code>,从而触发上述的事件处理程序。这种冒泡序列很可能不是我们所希望的。</p><h3 id="避免冒泡问题"><a href="#避免冒泡问题" class="headerlink" title="避免冒泡问题"></a>避免冒泡问题</h3><p>而<code>mouseenter</code>和<code>mouseleave</code>事件,无论是<strong>单独绑定</strong>,还是<strong>在<code>.hover()</code>方法中组合绑定</strong>,<strong><code>都可以避免</code>这些冒泡问题</strong>。在使用它们处理事件的时候,可以不用担心某些非目标元素得到<code>mouseover</code>或<code>mouseout</code>事件导致的问题。<br>刚才介绍的<code>mouseout</code>的问题说明了限制事件作用域的必要性。虽然<code>.hover</code>()可以处理这种特殊情况,但在其他情况下,我们可能还需要从空间(阻止事件发送到某些元素)和时间(阻止事件在某些时间段发送)上限制某个事件。</p>]]></content>
      
      
      <categories>
          
          <category> jQuery基础教程 第4版 </category>
          
          <category> 第3章 事件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.2 处理简单的事件</title>
      <link href="/ReadingNotes//578fdd22/"/>
      <url>/ReadingNotes//578fdd22/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/578fdd22/#3-2-处理简单的事件" class="header_1">3.2 处理简单的事件</a>&nbsp;<br><a href="/ReadingNotes/578fdd22/#3-2-1-简单的样式转换器" class="header_2">3.2.1 简单的样式转换器</a>&nbsp;<br><a href="/ReadingNotes/578fdd22/#3-2-2-启用其他按钮" class="header_2">3.2.2 启用其他按钮</a>&nbsp;<br><a href="/ReadingNotes/578fdd22/#3-2-3-利用事件处理程序的上下文" class="header_2">3.2.3 利用事件处理程序的上下文</a>&nbsp;<br><a href="/ReadingNotes/578fdd22/#3-2-4-使用事件上下文进一步减少代码" class="header_2">3.2.4 使用事件上下文进一步减少代码</a>&nbsp;<br><a href="/ReadingNotes/578fdd22/#3-2-5-简写的事件" class="header_2">3.2.5 简写的事件</a>&nbsp;<br><a href="/ReadingNotes/578fdd22/#3-2-6-显示和隐藏高级特性" class="header_2">3.2.6 显示和隐藏高级特性</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="3-2-处理简单的事件"><a href="#3-2-处理简单的事件" class="headerlink" title="3.2 处理简单的事件"></a>3.2 处理简单的事件</h1><p>除了页面加载之外,我们也想在其他时刻完成某个任务。正如<code>JavaScript</code>可以让我们通过<code>&lt;body onload=&quot;&quot;&gt;</code>或<code>window.onload</code>来截获页面加载事件一样,它对用户发起的事件也提供了相似的”挂钩” (<code>hook</code>) 。例如,鼠标单击(<code>onclick</code>) 、表单被修改(<code>onchange</code>)以及窗口大小变化(<code>onresize</code>)等。在这些情况下,如果直接在<code>DOM</code>中为元素指定行为,那么这些挂钩也会与我们讨论的<code>onload</code>一样具有类似的缺点。为此,<code>jQuery</code>也为处理这些事件提供了一种改进的方式。</p><h2 id="3-2-1-简单的样式转换器"><a href="#3-2-1-简单的样式转换器" class="headerlink" title="3.2.1 简单的样式转换器"></a>3.2.1 简单的样式转换器</h2><p>为了说明某些事件处理技术,我们假设希望某个页面能够基于用户的输入呈现出不同的样式。也就是说,允许用户通过单击按钮来切换视图,包括正常视图、将文本限制在窄列中的视图和适合打印的大字内容区视图。</p><p>用于样式转换器的<code>HTML</code>标记如下所示:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"switcher"</span> <span class="attr">class</span>=<span class="string">"switcher"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Style Switcher<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"switcher-default"</span>&gt;</span></span><br><span class="line">    Default</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"switcher-narrow"</span>&gt;</span></span><br><span class="line">    Narrow Column</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"switcher-large"</span>&gt;</span></span><br><span class="line">    Large Print</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><br>在与页面中其他<code>HTML</code>标记和基本的<code>CSS</code>组合以后,我们可以看到如图3-1所示的页面外观。</p><p>首先,我们来编写<code>Large Print</code>按钮的功能。此时,需要一点<code>CSS</code>代码来实现页面的替换视图:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span><span class="selector-class">.large</span> <span class="selector-class">.chapter</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.5em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>然后,我们的目标就是为<code>&lt;body&gt;</code>标签应用<code>large</code>类。这样会导致样式表对页面进行重新格式化。按照第2章介绍的知识,添加类的语句如下所示:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'body'</span>).addClass(<span class="string">'large'</span>);</span><br></pre></td></tr></table></figure><br>但是,我们希望这条语句在用户单击按钮时执行(而不是像我们到目前为止看到的那样在页面加载后执行)。为此,我们需要引入<code>.on()</code>方法。通过这个方法,可以指定任何<code>DOM</code>事件,并为该事件添加一种行为。此时,事件是<code>click</code>,而行为则是由上面的一行代码构成的函数,参见代码清单3-1。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 选择id为switcher-large的元素,注册点击事件处理程序</span></span><br><span class="line">  $(<span class="string">'#switcher-large'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 为body元素添加large类</span></span><br><span class="line">    $(<span class="string">'body'</span>).addClass(<span class="string">'large'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>现在,当单击<code>Large Print</code>按钮时,就会运行函数中的代码,而页面的外观将如图3-2所示。</p><p>这里的全部操作就是绑定了一个事件。我们前面介绍的<code>.ready()</code>方法的优点在此也同样适用。多次调用<code>.on()</code>也没有任何问题,即可以按需为同一个事件追加更多的行为。</p><h2 id="3-2-2-启用其他按钮"><a href="#3-2-2-启用其他按钮" class="headerlink" title="3.2.2 启用其他按钮"></a>3.2.2 启用其他按钮</h2><p>现在,<code>Large Print</code>按钮开始生效了。接下来,我们要以类似的方式处理其他两个按钮(<code>Default</code>和<code>Narrow</code>) ,让它们也都执行各自的任务。这个过程很简单,即分别使用<code>.on()</code>为它们添加一个单击处理程序,同时视情况移除或添加类。完成之后的代码如代码清单3-2所示。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 当点击id为switcher-default的元素(按钮)时</span></span><br><span class="line">  $(<span class="string">'#switcher-default'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 移除 body元素 上的narrow和large类</span></span><br><span class="line">    $(<span class="string">'body'</span>).removeClass(<span class="string">'narrow'</span>);</span><br><span class="line">    $(<span class="string">'body'</span>).removeClass(<span class="string">'large'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 当点击id为switcher-narrow的按钮时</span></span><br><span class="line">  $(<span class="string">'#switcher-narrow'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 移除 body元素 上的large类</span></span><br><span class="line">    $(<span class="string">'body'</span>).removeClass(<span class="string">'large'</span>);</span><br><span class="line">    <span class="comment">// 给 body元素 添加narrow类</span></span><br><span class="line">    $(<span class="string">'body'</span>).addClass(<span class="string">'narrow'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 当点击id为switcher-large的按钮时</span></span><br><span class="line">  $(<span class="string">'#switcher-large'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 移除 body元素 上的narrow类</span></span><br><span class="line">    $(<span class="string">'body'</span>).removeClass(<span class="string">'narrow'</span>);</span><br><span class="line">    <span class="comment">// 给 body元素 添加large类</span></span><br><span class="line">    $(<span class="string">'body'</span>).addClass(<span class="string">'large'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>以下是配套的<code>narrow</code>类的<code>CSS</code>规则:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span><span class="selector-class">.narrow</span> <span class="selector-class">.chapter</span> &#123; </span><br><span class="line">  <span class="attribute">width</span>: <span class="number">250px</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>现在,如果单击<code>Narrow Column</code>按钮,随着相应的<code>CSS</code>生效,文本会相应变化,如图3-3所示。<br>单击<code>Default</code>按钮将从<code>&lt;body</code>&gt;标签中同时移除两个类,让页面恢复为初始状态。</p><h2 id="3-2-3-利用事件处理程序的上下文"><a href="#3-2-3-利用事件处理程序的上下文" class="headerlink" title="3.2.3 利用事件处理程序的上下文"></a>3.2.3 利用事件处理程序的上下文</h2><p>虽然样式转换器的功能很正常,但我们并没有就哪个按钮处于当前使用状态对用户给出反馈。为此,我们的方法是在按钮被单击时,为它应用<code>selected</code>类,同时从其他按钮上移除这个类。<code>selected</code>类只是为按钮文本添加了粗体样式:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.selected</span> &#123; </span><br><span class="line">  <span class="attribute">font-weight</span>: bold; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>为了实现类的变换,可以按照前面的做法,通过<code>ID</code>来引用每个按钮,然后再视情况为它们应用或移除类。不过,这一次我们要探索一种更优雅也更具扩展性的解决方案,这个方案利用了事件处理程序运行的上下文。<br><strong>当触发任何事件处理程序时,关键字<code>this</code>引用的都是携带相应行为的<code>DOM</code>元素</strong>。前面我们谈到过,<code>$()</code>函数可以将<code>DOM</code>元素作为参数,而<code>this</code>关键字是实现这个功能的关键①。通过在事件处理程序中使用<code>$(this)</code>,可以为相应的元素创建<code>jQuery</code>对象,然后就如同使用<code>CSS</code>选择符找到该元素一样对它进行操作。<br>知道了这些之后,我们可以编写出下面的代码:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="keyword">this</span>).addClass(<span class="string">'selected'</span>);</span><br></pre></td></tr></table></figure><br>把这行代码放到那3个事件处理程序中,就可以在按钮被单击时为按钮添加<code>selected</code>类。要从其他按钮中移除这个类,可以利用<code>jQuery</code>的隐式迭代特性,并编写如下代码:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#switcher button'</span>).removeClass(<span class="string">'selected'</span>);</span><br></pre></td></tr></table></figure><br>这行代码会移除样式转换器中每个按钮的<code>selected</code>类。<br>我们还应该在文档就绪时把这个类添加到<code>Default</code>按钮上。因此,按照正确的次序放置它们,就可以得到代码清单3-3。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//选择id为switcher-default的DOM元素(按钮)</span></span><br><span class="line">  $(<span class="string">'#switcher-default'</span>)</span><br><span class="line">    <span class="comment">// 给按钮按钮添加selected类</span></span><br><span class="line">    .addClass(<span class="string">'selected'</span>)</span><br><span class="line">    <span class="comment">// 当点击该按钮时</span></span><br><span class="line">    .on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 移除 body元素 上的narrow类</span></span><br><span class="line">      $(<span class="string">'body'</span>).removeClass(<span class="string">'narrow'</span>);</span><br><span class="line">      <span class="comment">// 移除 body元素 上的large类</span></span><br><span class="line">      $(<span class="string">'body'</span>).removeClass(<span class="string">'large'</span>);</span><br><span class="line">      <span class="comment">// 移除 所有按钮 上的selected类</span></span><br><span class="line">      $(<span class="string">'#switcher button'</span>).removeClass(<span class="string">'selected'</span>);</span><br><span class="line">      <span class="comment">// 给 当前按钮 添加selected类</span></span><br><span class="line">      $(<span class="keyword">this</span>).addClass(<span class="string">'selected'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="comment">// 当点击id为switcher-narrow的DOM元素(按钮)时</span></span><br><span class="line">  $(<span class="string">'#switcher-narrow'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 移除 body元素 上的large类</span></span><br><span class="line">    $(<span class="string">'body'</span>).removeClass(<span class="string">'large'</span>);</span><br><span class="line">    <span class="comment">// 给 body元素 添加narrow类</span></span><br><span class="line">    $(<span class="string">'body'</span>).addClass(<span class="string">'narrow'</span>);</span><br><span class="line">    <span class="comment">// 移除 所有按钮 上的selected类</span></span><br><span class="line">    $(<span class="string">'#switcher button'</span>).removeClass(<span class="string">'selected'</span>);</span><br><span class="line">    <span class="comment">// 给 当前按钮 添加selected类</span></span><br><span class="line">    $(<span class="keyword">this</span>).addClass(<span class="string">'selected'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 当点击id为switcher-large的DOM元素(按钮)时</span></span><br><span class="line">  $(<span class="string">'#switcher-large'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 移除 body元素 上的narrow类</span></span><br><span class="line">    $(<span class="string">'body'</span>).removeClass(<span class="string">'narrow'</span>);</span><br><span class="line">    <span class="comment">// 给 body元素 添加large类</span></span><br><span class="line">    $(<span class="string">'body'</span>).addClass(<span class="string">'large'</span>);</span><br><span class="line">    <span class="comment">// 移除 所有按钮 上的selected类</span></span><br><span class="line">    $(<span class="string">'#switcher button'</span>).removeClass(<span class="string">'selected'</span>);</span><br><span class="line">    <span class="comment">// 给 当前按钮 添加selected类</span></span><br><span class="line">    $(<span class="keyword">this</span>).addClass(<span class="string">'selected'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>这样,样式转换器就会对用户给出适当的反馈了。<br>利用处理程序的上下文将语句通用化,可以使代码更高效。我们可以把负责突出显示的代码提取到一个单独的处理程序中,因为针对3个按钮的突出显示代码都一样,结果如代码清单3-4所示。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="string">'#switcher-default'</span>)</span><br><span class="line">    <span class="comment">// 给该按钮添加selected类</span></span><br><span class="line">    .addClass(<span class="string">'selected'</span>)</span><br><span class="line">    <span class="comment">// 点击该按钮时</span></span><br><span class="line">    .on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">//移除 body元素 上的narrow类,然后给 body元素 添加large类</span></span><br><span class="line">      $(<span class="string">'body'</span>).removeClass(<span class="string">'narrow'</span>).removeClass(<span class="string">'large'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 点击该按钮时</span></span><br><span class="line">  $(<span class="string">'#switcher-narrow'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 移除 body元素 上的large类,然后给 body元素 添加narrow类</span></span><br><span class="line">    $(<span class="string">'body'</span>).removeClass(<span class="string">'large'</span>).addClass(<span class="string">'narrow'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 点击该按钮时</span></span><br><span class="line">  $(<span class="string">'#switcher-large'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 移除 body元素 上的narrow类,然后给 body元素 添加large类</span></span><br><span class="line">    $(<span class="string">'body'</span>).removeClass(<span class="string">'narrow'</span>).addClass(<span class="string">'large'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 给所有按钮注册事件处理程序</span></span><br><span class="line">  $(<span class="string">'#switcher button'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 移除所有按钮上的selected类</span></span><br><span class="line">    $(<span class="string">'#switcher button'</span>).removeClass(<span class="string">'selected'</span>);</span><br><span class="line">    <span class="comment">// 给触发点击事件的 该按钮添加 select类</span></span><br><span class="line">    $(<span class="keyword">this</span>).addClass(<span class="string">'selected'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>这一步优化利用了我们讨论过的3种<code>jQuery</code>特性。</p><ul><li>第一,在通过对<code>.on()</code>的一次调用为每个按钮都绑定相同的单击事件处理程序时,<strong>隐式迭代机制</strong>再次发挥了作用。</li><li>第二,<strong>行为队列机制</strong>让我们在同一个单击事件上绑定了两个函数,而且第二个函数不会覆盖第一个函数。</li><li>最后,我们使用<code>jQuery</code>的<strong>连缀</strong>能力将每次添加和移除类的操作压缩到了一行代码中。</li></ul><h2 id="3-2-4-使用事件上下文进一步减少代码"><a href="#3-2-4-使用事件上下文进一步减少代码" class="headerlink" title="3.2.4 使用事件上下文进一步减少代码"></a>3.2.4 使用事件上下文进一步减少代码</h2><p>我们刚才的代码优化实际上是在做<strong>重构——修改已有代码,以更加高效和简洁的方式实现相同任务</strong>。 为寻找进一步重构的机会,下面再看一看绑定到每个按钮的行为。其中, <code>.removeClass()</code>方法的参数是可选的,即当省略参数时,该方法会移除元素中所有的类。利用这一点,可以把代码再改进得更简单一些,参见代码清单3-5。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$(document).ready(function () &#123;</span><br><span class="line">  <span class="comment">// 默认选中</span></span><br><span class="line">  $(<span class="string">'#switcher-default'</span>).addClass(<span class="string">'selected'</span>).on(<span class="string">'click'</span>, function () &#123;</span><br><span class="line">    <span class="comment">// 当点击该按钮时,移除body元素上的所有类</span></span><br><span class="line">    $(<span class="string">'body'</span>).removeClass();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  $(<span class="string">'#switcher-narrow'</span>).on(<span class="string">'click'</span>, function () &#123;</span><br><span class="line">    <span class="comment">// 移除body元素上的所有类,然后再给body元素添加narrow类</span></span><br><span class="line">    $(<span class="string">'body'</span>).removeClass().addClass(<span class="string">'narrow'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  $(<span class="string">'#switcher-large'</span>).on(<span class="string">'click'</span>, function () &#123;</span><br><span class="line">    <span class="comment">// 移除body元素上的所有类,然后再给body元素添加large类</span></span><br><span class="line">    $(<span class="string">'body'</span>).removeClass().addClass(<span class="string">'large'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  $(<span class="string">'#switcher button'</span>).on(<span class="string">'click'</span>, function () &#123;</span><br><span class="line">    <span class="comment">// 移除 所有按钮 上的selected类</span></span><br><span class="line">    $(<span class="string">'#switcher button'</span>).removeClass(<span class="string">'selected'</span>);</span><br><span class="line">    <span class="comment">// 给 触发该事件的按钮 添加select类</span></span><br><span class="line">    $(<span class="keyword">this</span>).addClass(<span class="string">'selected'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>注意,为了适应更通用的移除类的操作,我们对操作顺序作了小小的调整——先执行<code>.removeClass()</code>,以便它不会撤销几乎同时执行的<code>.addClass()</code>。<br>此时,在每个按钮的处理程序中仍然会执行某些相同的代码。这些代码也可以轻而易举地提取到通用的按钮单击处理程序中,如代码清单3-6所示。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DOM加载完毕后执行</span></span><br><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 给id为switcher-default的元素添加 selected类</span></span><br><span class="line">  $(<span class="string">'#switcher-default'</span>).addClass(<span class="string">'selected'</span>);</span><br><span class="line">  <span class="comment">// 监听所有按钮的点击事件</span></span><br><span class="line">  $(<span class="string">'#switcher button'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 移除 body元素 上的所有类</span></span><br><span class="line">    $(<span class="string">'body'</span>).removeClass();</span><br><span class="line">    <span class="comment">// 移除 所有按钮 上的selected类</span></span><br><span class="line">    $(<span class="string">'#switcher button'</span>).removeClass(<span class="string">'selected'</span>);</span><br><span class="line">    <span class="comment">// 触发点击事件的这个按钮 添加selected类</span></span><br><span class="line">    $(<span class="keyword">this</span>).addClass(<span class="string">'selected'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 当点击id为switcher-narrow的元素(按钮)时</span></span><br><span class="line">  $(<span class="string">'#switcher-narrow'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 给 body元素 添加narrow类</span></span><br><span class="line">    $(<span class="string">'body'</span>).addClass(<span class="string">'narrow'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 当点击id为switcher-large的元素(按钮)时</span></span><br><span class="line">  $(<span class="string">'#switcher-large'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 给 body元素 添加large类</span></span><br><span class="line">    $(<span class="string">'body'</span>).addClass(<span class="string">'large'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>这里要注意的是,必须把通用的处理程序转移到特殊的处理程序上方,因为<code>.removeClass()</code>需要先于<code>.addClass()</code>执行。而之所以能够做到这一点,是因为<strong><code>jQuery</code>总是按照我们注册的顺序来触发事件处理程序</strong>。<br>最后,可以通过再次利用事件的执行上下文来完全消除特殊的处理程序。因为<strong>上下文关键字<code>this</code>引用的是<code>DOM</code>元素</strong>,而不是<code>jQuery</code>对象,所以可以使用原生的<code>DOM</code>属性来确定被单击元素的<code>ID</code>。因而,就可以对所有按钮都绑定相同的处理程序,然后在这个处理程序内部针对按钮执行不同的操作,参见代码清单3-7。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当DOM加载完毕是执行</span></span><br><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 默认选中id为switcher-default的按钮</span></span><br><span class="line">  $(<span class="string">'#switcher-default'</span>).addClass(<span class="string">'selected'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 监听所有按钮的点击事件</span></span><br><span class="line">  $(<span class="string">'#switcher button'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// this.id将获取到按钮的id属性,值为:switcher-default,switcher-narrow,switcher-large</span></span><br><span class="line">    <span class="comment">// this.id.split('-')将生成一个数组,</span></span><br><span class="line">    <span class="comment">// 数组的第1个元素(this.id.split('-')[0])为switcher</span></span><br><span class="line">    <span class="comment">// 数组的第2个元素(this.id.split('-')[1])为default,narrow,large这三种可能</span></span><br><span class="line">    <span class="keyword">var</span> bodyClass = <span class="keyword">this</span>.id.split(<span class="string">'-'</span>)[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 移除 body元素上的所有class,然后添加根据当前id动态生成的class    </span></span><br><span class="line">    $(<span class="string">'body'</span>).removeClass().addClass(bodyClass);</span><br><span class="line">    <span class="comment">// 移除所有按钮上的selected类</span></span><br><span class="line">    $(<span class="string">'#switcher button'</span>).removeClass(<span class="string">'selected'</span>);</span><br><span class="line">    <span class="comment">// 给当前按钮添加selected类</span></span><br><span class="line">    $(<span class="keyword">this</span>).addClass(<span class="string">'selected'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>这里<code>bodyClass</code>变量的值根据按钮的<code>ID</code>属性的值来动态生成,根据单击的按钮不同,<code>bodyClass</code>变量的值可能是<code>default</code>、<code>narrow</code>或<code>large</code>。这里与前面做法的不同之处在于,我们会在用户单击<code>ID</code>为<code>switcher-default</code>的按钮时,程序根据<code>ID</code>属性值<code>switcher-default</code>,得到<code>default</code>类,然后给<code>&lt;body&gt;</code>添加<code>default</code>类。虽然在这儿添加这个类也用不着,但与因此降低的复杂性相比,仅仅添加一个用不上的类名还是很划算的。</p><h2 id="3-2-5-简写的事件"><a href="#3-2-5-简写的事件" class="headerlink" title="3.2.5 简写的事件"></a>3.2.5 简写的事件</h2><p>鉴于为某个事件(例如简单的单击事件)绑定处理程序极为常用,<code>jQuery</code>提供了一种简化事件操作的方式——简写事件方法,简写事件方法的原理与对应的<code>.on()</code>方法调用相同,可以减少一定的代码输入量。<br>例如,不使用<code>.on()</code>方法而使用<code>.click()</code>方法可以将前面的样式转换器程序重写为如代码清单3-8所示。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DOM加载结束时调用</span></span><br><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 一开始默认选中</span></span><br><span class="line">  $(<span class="string">'#switcher-default'</span>).addClass(<span class="string">'selected'</span>);</span><br><span class="line"></span><br><span class="line">  $(<span class="string">'#switcher button'</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 根据id属性值生成class属性值</span></span><br><span class="line">    <span class="keyword">var</span> bodyClass = <span class="keyword">this</span>.id.split(<span class="string">'-'</span>)[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// body元素删除所有class,然后添加生成的class</span></span><br><span class="line">    $(<span class="string">'body'</span>).removeClass().addClass(bodyClass);</span><br><span class="line">    <span class="comment">// 所有按钮先移除掉selected类</span></span><br><span class="line">    $(<span class="string">'#switcher button'</span>).removeClass(<span class="string">'selected'</span>);</span><br><span class="line">    <span class="comment">// 给触发事件的按钮添加selected类</span></span><br><span class="line">    $(<span class="keyword">this</span>).addClass(<span class="string">'selected'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>其他<code>blur</code>、<code>keydown</code>和<code>scroll</code>等标准的<code>DOM</code>事件,也存在类似前面这样的简写事件。这些简写的事件方法能够把一个事件处理程序绑定到同名事件上面。</p><h2 id="3-2-6-显示和隐藏高级特性"><a href="#3-2-6-显示和隐藏高级特性" class="headerlink" title="3.2.6 显示和隐藏高级特性"></a>3.2.6 显示和隐藏高级特性</h2><p>假设我们想在不需要时隐藏样式转换器。<strong>隐藏高级特性</strong>的一种便捷方式,就是使它们可以折叠。因此,我们要实现的效果是:</p><ul><li>在标签上单击时,可以隐藏所有按钮,最后只剩一个标签;</li><li>而再次单击标签时,则会恢复这些按钮。</li></ul><blockquote><p>这里所谓的高级特性就是指<strong>为页面提供样式切换能力的样式转换器</strong>。 </p></blockquote><p>为了隐藏按钮,我们还需要另外一个类:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.hidden</span> &#123; </span><br><span class="line">  <span class="attribute">display</span>: none; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>为实现这个功能,可以把当前的按钮状态保存在一个变量中,每当标签被单击时,通过检查这个变量的值就能知道应该向这些按钮中添加,还是要从这些按钮中移除<code>.hidden</code>类。<br>不过,<code>jQuery</code>也为我们提供了一个简便的<code>toggleClass()</code>方法,该方法能够根据相应的类是否存在而添加或删除类,参见代码清单3-9。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="string">'#switcher h3'</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果这些按钮中存在hidden类那就移除hidden类</span></span><br><span class="line">    <span class="comment">// 如果这些按钮不存在hidden类就添加hidden类</span></span><br><span class="line">    $(<span class="string">'#switcher button'</span>).toggleClass(<span class="string">'hidden'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 选中默认按钮</span></span><br><span class="line">  $(<span class="string">'#switcher-default'</span>).addClass(<span class="string">'selected'</span>);</span><br><span class="line">  <span class="comment">// 按钮点击事件处理程序</span></span><br><span class="line">  $(<span class="string">'#switcher button'</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 根据id属性值的生成class属性值</span></span><br><span class="line">    <span class="keyword">var</span> bodyClass = <span class="keyword">this</span>.id.split(<span class="string">'-'</span>)[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 移除body元素上的所有class属性,然后添加生成class属性</span></span><br><span class="line">    $(<span class="string">'body'</span>).removeClass().addClass(bodyClass);</span><br><span class="line">    <span class="comment">// 移除所有按钮上的值为selected的calss属性.</span></span><br><span class="line">    $(<span class="string">'#switcher button'</span>).removeClass(<span class="string">'selected'</span>);</span><br><span class="line">    <span class="comment">// 触发事件的当前按钮添加selected类</span></span><br><span class="line">    $(<span class="keyword">this</span>).addClass(<span class="string">'selected'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>在第一次单击后,所有按钮都会隐藏起来,如图3-4所示。<br>而第二次单击则又恢复了它们的可见性,如图3-5所示。</p><p>同样,这里我们依靠的仍然是<code>jQuery</code>的<strong>隐式迭代能力</strong>,即一次就能隐藏所有按钮,而不需要使用包装元素(即不需要在这3个按钮外部再添加额外的标签如:<code>&lt;div&gt;</code> 。如果没有<strong>隐式迭代机制</strong>,那么想一次隐藏3个按钮,一种常见的方法就是隐藏包含这3个按钮的包装元素)。</p>]]></content>
      
      
      <categories>
          
          <category> jQuery基础教程 第4版 </category>
          
          <category> 第3章 事件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.1 在页面加载后执行任务</title>
      <link href="/ReadingNotes//f49e94ad/"/>
      <url>/ReadingNotes//f49e94ad/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/f49e94ad/#3-1-在页面加载后执行任务" class="header_1">3.1 在页面加载后执行任务</a>&nbsp;<br><a href="/ReadingNotes/f49e94ad/#3-1-1-代码执行的时机选择" class="header_2">3.1.1 代码执行的时机选择</a>&nbsp;<br><a href="/ReadingNotes/f49e94ad/#window-onload时间和$-document-ready-的区别" class="header_2">window.onload时间和$(document).ready()的区别</a>&nbsp;<br><a href="/ReadingNotes/f49e94ad/#加载样式与执行代码" class="header_2">加载样式与执行代码</a>&nbsp;<br><a href="/ReadingNotes/f49e94ad/#什么是加载完成" class="header_2">什么是加载完成</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="3-1-在页面加载后执行任务"><a href="#3-1-在页面加载后执行任务" class="headerlink" title="3.1 在页面加载后执行任务"></a>3.1 在页面加载后执行任务</h1><p>我们已经看到如何让<code>jQuery</code>响应网页的加载事件,<code>$(document).ready()</code>事件处理程序可以用来触发函数中的代码,但对这个过程还有待深入分析。</p><h2 id="3-1-1-代码执行的时机选择"><a href="#3-1-1-代码执行的时机选择" class="headerlink" title="3.1.1 代码执行的时机选择"></a>3.1.1 代码执行的时机选择</h2><p>在第1章中,我们知道了<code>$(document).ready()</code>是<code>jQuery</code>基于页面加载执行任务的一种主要方式。但这并不是唯一的方式,原生的<code>window.onload</code>事件也可以实现相同的效果。虽然这两个方法具有类似的效果,但是,它们在触发操作的时间上存在着微妙的差异,这种差异只有在加载的资源多到一定程度时才会体现出来。</p><h2 id="window-onload时间和-document-ready-的区别"><a href="#window-onload时间和-document-ready-的区别" class="headerlink" title="window.onload时间和$(document).ready()的区别"></a>window.onload时间和$(document).ready()的区别</h2><p><strong>当文档完全下载到浏览器中时,会触发<code>window.onload</code>事件</strong>。这意味着页面上的全部元素对<code>JavaScript</code>而言都是可以操作的,这种情况对编写功能性的代码非常有利,因为无需考虑加载的次序。<br>另一方面,<strong>通过<code>$(document).ready()</code>注册的事件处理程序,则会在<code>DOM</code>完全就绪并可以使用时调用</strong>。虽然这也意味着所有元素对脚本而言都是可以访问的,但是,<strong>却不意味着所有关联的文件都已经下载完毕</strong>。换句话说,当<code>HTML</code>下载完成并解析为<code>DOM</code>树之后,代码就可以运行。</p><h2 id="加载样式与执行代码"><a href="#加载样式与执行代码" class="headerlink" title="加载样式与执行代码"></a>加载样式与执行代码</h2><p>为了保证<code>JavaScript</code>代码执行以前页面已经应用了样式,最好是在<code>&lt;head&gt;</code>元素中把<code>&lt;link rel=&quot;stylesheet&quot;&gt;</code>标签和<code>&lt;style&gt;</code>标签放在<code>&lt;script&gt;</code>标签前面。</p><p>举一个例子,假设有一个表现图库的页面,这种页面中可能会包含许多大型图像,我们可以通过<code>jQuery</code>隐藏、显示、移动或以其他方式操纵这些图像。如果我们通过<code>onload</code>事件设置界面,那么用户在能够使用这个页面之前,必须要等到每一幅图像都下载完成。更糟糕的是,如果行为尚未添加给那些具有默认行为的元素(例如链接) , 那么用户的交互可能会导致意想不到的结果。然而,当我们使用<code>$(document).ready()</code>进行设置时,这个界面就会更早地准备好可用的正确行为。</p><h2 id="什么是加载完成"><a href="#什么是加载完成" class="headerlink" title="什么是加载完成"></a>什么是加载完成</h2><p>一般来说, 使用<code>$(document).ready()</code>要优于使用<code>onload</code>事件处理程序,但必须要明确的一点是,因为支持文件可能还没有加载完成,所以类似图像的高度和宽度这样的属性此时则不一定会有效。如果需要访问这些属性,可能就得选择实现一个<code>onload</code>事件处理程序(或者是使用<code>jQuery</code>为<code>load</code>事件设置处理程序)。这两种机制能够和平共存。</p>]]></content>
      
      
      <categories>
          
          <category> jQuery基础教程 第4版 </category>
          
          <category> 第3章 事件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第3章 事件</title>
      <link href="/ReadingNotes//4e1f05d5/"/>
      <url>/ReadingNotes//4e1f05d5/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/4e1f05d5/#第3章-事件" class="header_1">第3章 事件</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="第3章-事件"><a href="#第3章-事件" class="headerlink" title="第3章 事件"></a>第3章 事件</h1><p><code>JavaScript</code>内置了一些对用户的交互和其他事件给予响应的方式。为了使页面具有动态性和响应性,就需要利用这种能力,以便能够适时地应用我们学过的<code>jQuery</code>技术和本书后面讨论的一些技巧。虽然使用普通的<code>JavaScript</code>也可以做到这一点,但<code>jQuery</code>增强并扩展了基本的事件处理机制。它不仅提供了更加优雅的事件处理语法,而且也极大地增强了事件处理机制。<br>本章将学习以下内容:</p><ul><li>在页面就绪时执行<code>JavaScript</code>代码;</li><li>处理用户事件,比如鼠标单击和按下键盘上的键;</li><li>文档中的事件流,以及如何操纵事件流;</li><li>模拟用户发起的事件。</li></ul>]]></content>
      
      
      <categories>
          
          <category> jQuery基础教程 第4版 </category>
          
          <category> 第3章 事件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2.8 小结</title>
      <link href="/ReadingNotes//7dc445f6/"/>
      <url>/ReadingNotes//7dc445f6/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/7dc445f6/#2-8-小结" class="header_1">2.8 小结</a>&nbsp;<br><a href="/ReadingNotes/7dc445f6/#延伸阅读" class="header_2">延伸阅读</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="2-8-小结"><a href="#2-8-小结" class="headerlink" title="2.8 小结"></a>2.8 小结</h1><p>通过本章介绍的技术,读者应该掌握了:</p><ul><li>如何使用<code>CSS</code>选择符以不同方式在页面中选择元素集合,</li><li>如何为嵌套列表中的顶级和非顶级项分别添加样式,</li><li>如何使用属性选择符为不同类型的链接应用不同的样式,</li><li>如何使用<code>jQuery</code>自定义的选择符:<code>odd</code>和:<code>even</code>,或高级的<code>CSS</code>选择符:<code>nth-child()</code>为表格添加条纹效果,</li><li>如何使用连缀的<code>jQuery</code>方法突出显示某个表格单元中的文本。</li></ul><p>到现在为止,我们使用了<code>$(document).ready()</code>事件为一组匹配的元素添加类。在下一章中,我们将探索基于用户发起的事件来添加类的技术。</p><h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><p>要了解有关选择符与遍历方法的完整介绍,请参考第9章或本书附录C,也可以参考<a href="http://api.jquery.com/" target="_blank" rel="noopener">jQuery官方文档</a>。 </p>]]></content>
      
      
      <categories>
          
          <category> jQuery基础教程 第4版 </category>
          
          <category> 第2章 选择元素 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2.7 访问DOM元素</title>
      <link href="/ReadingNotes//e9bef1a8/"/>
      <url>/ReadingNotes//e9bef1a8/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/e9bef1a8/#2-7-访问DOM元素" class="header_1">2.7 访问DOM元素</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="2-7-访问DOM元素"><a href="#2-7-访问DOM元素" class="headerlink" title="2.7 访问DOM元素"></a>2.7 访问DOM元素</h1><p>所有选择符表达式和多数<code>jQuery</code>方法都返回一个<code>jQuery</code>对象,而这通常都是我们所希望的,因为<code>jQuery</code>对象能够提供隐式迭代和连缀能力。<br>尽管如此,我们仍然有可能需要在代码中直接访问<code>DOM</code>元素。例如,可能需要为另一个<code>JavaScript</code>库提供一组元素的结果集合。或者可能不得不访问某个元素的标签名——通过<code>DOM</code>元素的属性。对于这些少见但合理的情形,<code>jQuery</code>提供了<code>.get()</code>方法。要访问<code>jQuery</code>对象引用的第一个<code>DOM</code>元素,可以使用<code>.get(0)</code>。因而,如果想知道带有<code>id=&quot;my-element&quot;</code>属性的元素的标签名,应该使用如下代码:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myTag = $(<span class="string">'#my-element'</span>).get(<span class="number">0</span>).tagName;</span><br></pre></td></tr></table></figure><br>为了进一步简化这些代码,<code>jQuery</code>还为<code>.get()</code>方法提供了一种简写方式。比如,可以将<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myTag = $(<span class="string">'#my-element'</span>)[<span class="number">0</span>].tagName;</span><br></pre></td></tr></table></figure><br>也就是说,可以<strong>在选择符后面直接使用方括号</strong>。显然,这种语法与访问<code>DOM</code>元素数组很相似,而使用方括号就好像剥掉<code>jQuery</code>的包装并直接露出节点列表,而方括号中的索引(这里的<code>0</code>)则相当于从中取出了原本的<code>DOM</code>元素。</p>]]></content>
      
      
      <categories>
          
          <category> jQuery基础教程 第4版 </category>
          
          <category> 第2章 选择元素 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2.6 DOM遍历方法</title>
      <link href="/ReadingNotes//4a5e2389/"/>
      <url>/ReadingNotes//4a5e2389/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/4a5e2389/#2-6-DOM遍历方法" class="header_1">2.6 DOM遍历方法</a>&nbsp;<br><a href="/ReadingNotes/4a5e2389/#2-6-1-为特定单元格添加样式" class="header_2">2.6.1 为特定单元格添加样式</a>&nbsp;<br><a href="/ReadingNotes/4a5e2389/#2-6-2-连缀" class="header_2">2.6.2 连缀</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="2-6-DOM遍历方法"><a href="#2-6-DOM遍历方法" class="headerlink" title="2.6 DOM遍历方法"></a>2.6 DOM遍历方法</h1><p>利用前面介绍的<code>jQuery</code>选择符取得一组元素,就像是我们在<code>DOM</code>树中纵横遍历再经过筛选得到的结果一样。很多情况下,取得某个元素的父元素或者祖先元素都是基本的操作,而这正是<code>jQuery</code>的<code>DOM</code>遍历方法的用武之地。有了这些方法,我们可以轻而易举地在<code>DOM</code>树中上下左右地自由漫步。<br>其中一些方法与选择符表达式有异曲同工之妙。例如,这行用于添加<code>alt</code>类的代码:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'tr:even'</span>).addClass(<span class="string">'alt'</span>);</span><br></pre></td></tr></table></figure><br>可以通过<code>.filter()</code>方法重写成下面这样:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'tr'</span>).filter(<span class="string">':even'</span>).addClass(<span class="string">'alt'</span>);</span><br></pre></td></tr></table></figure><br>而且,这两种取得元素的方式在很大程度上可以互补。同样, <code>.filter()</code>的功能也十分强大,因为它可以接受函数参数。通过传入的函数,可以执行复杂的测试,以决定相应元素是否应该保留在匹配的集合中。例如,假设我们要为所有外部链接添加一个类。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-class">.external</span> &#123; </span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#fff</span> <span class="built_in">url</span>(images/external.png) no-repeat <span class="number">100%</span> <span class="number">2px</span>; </span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">16px</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>jQuery</code>中没有针对这种需求的选择符。如果没有筛选函数,就必须显式地遍历每个元素,对它们单独进行测试。但是,有了下面的筛选函数,就仍然可以利用<code>jQuery</code>的隐式迭代能力,保持代码的简洁,如代码清单2-9所示。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'a'</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.hostname &amp;&amp; <span class="keyword">this</span>.hostname != location.hostname; </span><br><span class="line">&#125;).addClass(<span class="string">'external'</span>);</span><br></pre></td></tr></table></figure><br>第二行代码可以筛选出符合下面两个条件的<code>&lt;a&gt;</code>元素。<br>必须包含一个带有域名(<code>this.hostname</code>)的<code>href</code>属性。这个测试可以排除<code>mailto</code>及类似链接。<br>链接指向的域名(还是<code>this.hostname</code>)必须不等于(<code>!=</code>)页面当前所在域的名称(<code>location.hostname</code>)。</p><p>更准确地说,<code>.filter()</code>方法会迭代所有匹配的元素,对每个元素都调用传入的函数并测试函数的返回值。如果函数返回<code>false</code>,则从匹配集合中删除相应元素;如果返回<code>true</code>,则保留相应元素。<br>有了这些代码,<code>Henry V</code>就被标记为外链了,如图2-12所示。<br>下面,我们再通过前面添加了条纹效果的表格,来演示一些遍历方法的其他用途。</p><h2 id="2-6-1-为特定单元格添加样式"><a href="#2-6-1-为特定单元格添加样式" class="headerlink" title="2.6.1 为特定单元格添加样式"></a>2.6.1 为特定单元格添加样式</h2><p>此前,我们已经为所有包含文本<code>Henry</code>的单元格添加了<code>highlight</code>类。如果想改为给每个包含<code>Henry</code>的单元格的下一个单元格添加样式,可以将已经编写好的选择符作为起点,然后连缀一个<code>.next()</code>方法即可,参见代码清单2-10。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  $(<span class="string">'td:contains(Henry)'</span>).next().addClass(<span class="string">'highlight'</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>表格现在的效果如图2-13所示。</p><p>图2-13</p><p><code>.next()</code>方法只选择下一个最接近的同辈元素。要想突出显示<code>Henry</code>所在单元格后面的全部单元格,可以使用<code>.nextAll()</code>方法,如代码清单2-11所示。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  $(<span class="string">'td:contains(Henry)'</span>).nextAll().addClass(<span class="string">'highlight'</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>因为包含<code>Henry</code>的单元格位于表格的第一列,因此以上代码会导致相应行中的其他单元格突出显示,如图2-14所示。</p><p>有读者可能已经猜到了,<code>.next()</code>和<code>.nextAll()</code>方法分别有一个对应方法,即<code>.prev()</code>和<code>.prevAll()</code>。此外,<code>.siblings()</code>能够选择处于相同<code>DOM</code>层次的所有其他元素,无论这些元素处于当前元素之前还是之后。<br>要在这些单元格中再包含原来的单元格(即包含<code>Henry</code>的那个单元格),可以添加<code>.addBack()</code>方法,参见代码清单2-12。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  $(<span class="string">'td:contains(Henry)'</span>).nextAll().addBack() </span><br><span class="line">  .addClass(<span class="string">'highlight'</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>作了这个修改之后,相应行中的所有单元格就都会应用<code>highlight</code>类的样式了,如图2-15所示。<br>事实上,要选择同一组元素,可以采用的选择符和遍历方法的组合很多。 例如, 代码清单2-13就是选择所有包含<code>Henry</code>的单元格所在行的另一种方式。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  $(<span class="string">'td:contains(Henry)'</span>).parent().children() </span><br><span class="line">  .addClass(<span class="string">'highlight'</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>这种组合方式没有遍历同辈元素,而是通过<code>.parent()</code>方法在<code>DOM</code>中上溯一层到达<code>&lt;tr&gt;</code>,然后再通过<code>.children()</code>选择该行的所有单元格。</p><h2 id="2-6-2-连缀"><a href="#2-6-2-连缀" class="headerlink" title="2.6.2 连缀"></a>2.6.2 连缀</h2><p>刚刚介绍的遍历方法组合展示了<code>jQuery</code>的连缀能力。在<code>jQuery</code>中,可以通过一行代码取得多个元素集合并对这些元素集合执行多次操作。<code>jQuery</code>的这种连缀能力不仅有助于保持代码简洁,而且在替代组合重新指定选择符时,还有助于提升脚本性能。<br><strong>方法连缀的原理:</strong><br>几乎所有<code>jQuery</code>方法都会返回一个<code>jQuery</code>对象,因而可连缀调用多个<code>jQuery</code>方法。<br>在使用连缀时,为照顾到代码的可读性,还可以把一行代码分散到几行来写。例如,一组连缀的方法可以写成3行,参见代码清单2-14。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'td:contains(Henry)'</span>).parent().find(<span class="string">'td:eq(1)'</span>) </span><br><span class="line">    .addClass(<span class="string">'highlight'</span>).end().find(<span class="string">'td:eq(2)'</span>) </span><br><span class="line">                           .addClass(<span class="string">'highlight'</span>);</span><br></pre></td></tr></table></figure><br>甚至,也可以写成7行,参见代码清单2-15。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'td:contains(Henry)'</span>) <span class="comment">//取得包含Henry的所有单元格 </span></span><br><span class="line">  .parent() <span class="comment">//取得它的父元素 </span></span><br><span class="line">  .find(<span class="string">'td:eq(1)'</span>) <span class="comment">//在父元素中查找第2个单元格 </span></span><br><span class="line">  .addClass(<span class="string">'highlight'</span>) <span class="comment">//为该单元格添加hightlight类 </span></span><br><span class="line">  .end() <span class="comment">//恢复到包含Henry的单元格的父元素 </span></span><br><span class="line">  .find(<span class="string">'td:eq(2)'</span>) <span class="comment">//在父元素中查找第3个单元格 </span></span><br><span class="line">  .addClass(<span class="string">'highlight'</span>); <span class="comment">//为该单元格添加hightlight类</span></span><br></pre></td></tr></table></figure><br>不可否认,这个例子中展示的迂回曲折的<code>DOM</code>遍历过程几近荒谬。我们当然不建议读者使用如此复杂的连缀方式,因为还有更简单、更直接的方法。这个例子的用意只是演示一下连缀为我们带来的极大灵活性。<br>连缀就像是一口气说出一大段话——虽然效率很高,但对别人来说可能会难于理解。而将它分开放到多行并添加明确的注释,从长远来看则可以节省更多的时间。</p>]]></content>
      
      
      <categories>
          
          <category> jQuery基础教程 第4版 </category>
          
          <category> 第2章 选择元素 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2.5 自定义选择符</title>
      <link href="/ReadingNotes//f1bbb869/"/>
      <url>/ReadingNotes//f1bbb869/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/f1bbb869/#2-5-自定义选择符" class="header_1">2.5 自定义选择符</a>&nbsp;<br><a href="/ReadingNotes/f1bbb869/#2-5-1-每隔一行为表格添加样式" class="header_2">2.5.1 每隔一行为表格添加样式</a>&nbsp;<br><a href="/ReadingNotes/f1bbb869/#2-5-2-基于上下文内容选择元素" class="header_2">2.5.2 基于上下文内容选择元素</a>&nbsp;<br><a href="/ReadingNotes/f1bbb869/#2-5-3-基于表单的选择符" class="header_2">2.5.3 基于表单的选择符</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="2-5-自定义选择符"><a href="#2-5-自定义选择符" class="headerlink" title="2.5 自定义选择符"></a>2.5 自定义选择符</h1><p>除了各种<code>CSS</code>选择符之外,<code>jQuery</code>还添加了独有的完全不同的自定义选择符。这些自定义选择符进一步增强了已经十分强大的<code>CSS</code>选择符,为我们提供了在页面上选择元素的新手段。<br><strong>性能提示</strong><br>只要可能,<code>jQuery</code>就会使用浏览器原生的<code>DOM</code>选择符引擎去查找元素。但在使用自定义选择符的时候,就无法使用速度最快的原生方法了。因此,建议读者在能够使用原生方法的情况下,就不要频繁地使用自定义选择符,以确保性能。<br><code>jQuery</code>中的多数自定义选择符都可以让我们从已经找到的元素中选出一或多个元素。<br><strong>自定义选择符通常跟在一个<code>CSS</code>选择符后面,基于已经选择的元素集的位置来查找元素</strong>。自定义选择符的语法与<code>CSS</code>中的伪类选择符语法相同,即选择符以冒号(:)开头。例如,我们想要从带有<code>horizontal</code>类的<code>&lt;div&gt;</code>集合中选择第<code>2</code>项,那么应该使用下面的代码:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div.horizontal:eq(1)'</span>)</span><br></pre></td></tr></table></figure><br>注意,因为<code>JavaScript</code>数组采用从<code>0</code>开始的编号方式, 所以<code>eq(1)</code>取得的是集合中的第2个元素。而<code>CSS</code>则是从<code>1</code>开始的,因此<code>CSS</code>选择符<code>$(div:nth-child(1)&#39;)</code>取得的是作为其父元素第<code>1</code>个子元素的所有<code>div</code>元素。如果记不清哪个从<code>0</code>开始,哪个从<code>1</code>开始,可以参考<a href="http://api.jquery.com/category/selectors/" target="_blank" rel="noopener">jQuery API文档</a></p><h2 id="2-5-1-每隔一行为表格添加样式"><a href="#2-5-1-每隔一行为表格添加样式" class="headerlink" title="2.5.1 每隔一行为表格添加样式"></a>2.5.1 每隔一行为表格添加样式</h2><p><code>jQuery</code>库中的两个十分有用的自定义选择符是:<code>odd</code>和:<code>even</code>。下面,我们就来看一看如何通过这两个选择符为表格添加基本的条纹样式,针对下面的表格:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Shakespeare's Plays<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>As You Like It<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>Comedy<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>All's Well that Ends Well<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>Comedy<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>1601<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>Hamlet<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>Tragedy<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>1604<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>Macbeth<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>Tragedy<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>1606<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>Romeo and Juliet<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>Tragedy<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>1595<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>Henry IV, Part I<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>History<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>1596<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>Henry V<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>History<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>1599<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Shakespeare's Sonnets<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>The Fair Youth<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>1–126<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>The Dark Lady<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>127–152<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>The Rival Poet<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>78–86<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><br>在样式表中添加一点样式,表格的表头和单元格就清晰了许多。现在,这个表格有白色的背景,但行与行之间没有区别,如图2-8所示。</p><p>可以在样式表中为所有表格行添加一种样式,然后再为奇数行定义一个<code>alt</code>类。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">tr</span> &#123; </span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fff</span>;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-class">.alt</span> &#123; </span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ccc</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>最后编写<code>jQuery</code>代码,将这个类添加到表格中的奇数行(<code>&lt;tr&gt;</code>标签),如代码清单2-6所示。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  $(<span class="string">'tr:even'</span>).addClass(<span class="string">'alt'</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>等一等!为什么针对奇数行使用<code>:even</code>选择符呢?很简单,<code>:eq()</code>选择符、<code>:odd</code>和<code>:even</code>选择符都使用<code>JavaScript</code>内置从<code>0</code>开始的编号方式,因此,第一行的编号为<code>0</code>(偶数),第二行的编号为<code>1</code>(奇数) ,依此类推。知道这一点之后,我们希望上面那几行代码能够生成如图2-9所示的结果。<br>图2-9</p><p>不过,要注意的是,如果一个页面上存在另外一个表格,我们则真有可能会看到意料之外的结果。例如,因为<code>Plays</code>表格中的最后一行为”另一种”浅灰色背景,所以<code>Sonnets</code>表格的第一行的背景就会为白色。解决这个问题的一种方法是使用:<code>nth-child()</code>选择符。这个选择符相对于元素的父元素而非当前选择的所有元素来计算位置,它可以接受数值、<code>odd</code>或<code>even</code>作为参数,如代码清单2-7所示。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  $(<span class="string">'tr:nth-child(odd)'</span>).addClass(<span class="string">'alt'</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>值得一提的是,<strong><code>:nth-child()</code>是<code>jQuery</code>中唯一从<code>1</code>开始计数的选择符</strong>。要实现与图2-8所示相同的条纹交替效果,并且确保同一文档中的多个表格的效果一致,需要使用<code>odd</code>而不是<code>even</code>参数。替换了参数之后,两个表格出现了一致的条纹交替效果,如图2-10所示。</p><h2 id="2-5-2-基于上下文内容选择元素"><a href="#2-5-2-基于上下文内容选择元素" class="headerlink" title="2.5.2 基于上下文内容选择元素"></a>2.5.2 基于上下文内容选择元素</h2><p>下面,我们介绍最后一个自定义选择符。假设出于某种原因,我们希望突出显示提到任何一种<code>Henry</code>游戏的所有表格单元。为此,我们所要做的就是在样式表中添加一个声明了粗体和斜体文本的类:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.highlight&#123;</span><br><span class="line">    font-weight:bold;</span><br><span class="line">    font-style:italic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>然后向<code>jQuery</code>代码中添加一行代码,其中使用的是<code>:contains()</code>选择符,参见代码清单2-8。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  $(<span class="string">'tr:nth-child(odd)'</span>).addClass(<span class="string">'alt'</span>); </span><br><span class="line">  $(<span class="string">'td:contains(Henry)'</span>).addClass(<span class="string">'highlight'</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>这样,在可爱的条纹表格中,就能够看到突出显示的<code>Henry</code>游戏了,如图2-11所示。</p><p>必须注意,<code>:contains()</code>选择符区分大小写。换句话说,使用不带大写”H”的<code>$(&#39;td:contains(henry)&#39;)</code>,不会选择任何单元格。<br>诚然,不使用<code>jQuery</code>(或任何客户端编程语言)也可以通过其他方式实现这种行条纹和突出显示效果。然而,在内容由程序动态生成,而我们又无权改动<code>HTML</code>和服务器端代码的情况下,<code>jQuery</code>加上<code>CSS</code>对这种样式化操作提供了优秀的替换方案。</p><h2 id="2-5-3-基于表单的选择符"><a href="#2-5-3-基于表单的选择符" class="headerlink" title="2.5.3 基于表单的选择符"></a>2.5.3 基于表单的选择符</h2><p>自定义选择符并不局限于基于元素的位置选择元素。比如,在操作表单时,<code>jQuery</code>的自定义选择符以及后来补充的<code>CSS3</code>选择符同样可以简化选择元素的任务。表2-2列出了其中一些适用于表单的选择符。</p><center><strong>表2-2 表单选择符 </strong></center><div class="table-container"><table><thead><tr><th style="text-align:left">选择符</th><th style="text-align:left">匹配</th></tr></thead><tbody><tr><td style="text-align:left"><code>:input</code></td><td style="text-align:left">输入字段、文本区、选择列表和按钮元素</td></tr><tr><td style="text-align:left"><code>:button</code></td><td style="text-align:left">按钮元素或<code>type</code>属性值为<code>button</code>的输入元素</td></tr><tr><td style="text-align:left"><code>:enabled</code></td><td style="text-align:left">启用的表单元素</td></tr><tr><td style="text-align:left"><code>:disabled</code></td><td style="text-align:left">禁用的表单元素</td></tr><tr><td style="text-align:left"><code>:checked</code></td><td style="text-align:left">勾选的单选按钮或复选框</td></tr><tr><td style="text-align:left"><code>:selected</code></td><td style="text-align:left">选择的选项元素</td></tr></tbody></table></div><p>与其他选择符类似,组合使用表单选择符可以更有针对性。例如,使用<code>$(&#39;input[type=&quot;radio&quot;]:checked&#39;)</code>可以选择所有选中的单选按钮(而不是复选框) ,而使用<code>$(&#39;input[type=&quot;password&quot;],input[type=&quot;text&quot;]:disabled&#39;)</code>则可以选择所有密码输入字段和禁用的文本输入字段。可见,即便是使用自定义选择符,也可以按照基本的<code>CSS</code>语法来定义匹配的元素列表。</p>]]></content>
      
      
      <categories>
          
          <category> jQuery基础教程 第4版 </category>
          
          <category> 第2章 选择元素 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2.4 属性选择符</title>
      <link href="/ReadingNotes//2c49278/"/>
      <url>/ReadingNotes//2c49278/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/2c49278/#2-4-属性选择符" class="header_1">2.4 属性选择符</a>&nbsp;<br><a href="/ReadingNotes/2c49278/#为链接添加样式" class="header_2">为链接添加样式</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="2-4-属性选择符"><a href="#2-4-属性选择符" class="headerlink" title="2.4 属性选择符"></a>2.4 属性选择符</h1><p><strong>属性选择符</strong>是<code>CSS</code>选择符中特别有用的一类选择符。顾名思义,<strong>属性选择符通过<code>HTML</code>元素的属性选择元素</strong>,例如链接的<code>title</code>属性或图像的<code>alt</code>属性。例如,要选择带有<code>alt</code>属性的所有图像元素,可以使用以下代码:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'img[alt]'</span>)</span><br></pre></td></tr></table></figure></p><h2 id="为链接添加样式"><a href="#为链接添加样式" class="headerlink" title="为链接添加样式"></a>为链接添加样式</h2><p>属性选择符使用一种从正则表达式中借鉴来的通配符语法,</p><ul><li>以<code>^</code>表示值在字符串的开始,</li><li>以<code>$</code>表示值在字符串的结尾。</li><li>用星号<code>*</code>表示要匹配的值可以出现在字符串中的任意位置,</li><li>用叹号<code>!</code>表示对值取反。</li></ul><p>假设我们想以不同的文本颜色来显示不同类型的链接,那么首先要在样式表中定义如下样式:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123; </span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#00c</span>;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-tag">a</span><span class="selector-class">.mailto</span> &#123; </span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(images/email.png) no-repeat right top; </span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">18px</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-tag">a</span><span class="selector-class">.pdflink</span> &#123; </span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(images/pdf.png) no-repeat right top; </span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">18px</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-tag">a</span><span class="selector-class">.henrylink</span> &#123; </span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fff</span>; </span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">2px</span>; </span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>然后,可以使用<code>jQuery</code>为符合条件的链接添加3个类:<code>mailto</code>、<code>pdflink</code>和<code>henrylink</code>。</p><p>要为所有电子邮件链接添加类,需要构造一个选择符,用来寻找所有带<code>href</code>属性(<code>[href]</code>)且以<code>mailto</code>开头(<code>^=&quot;mailto:&quot;</code>])的锚元素(a)。结果如代码清单2-3所示。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  $(<span class="string">'a[href^="mailto:"]'</span>).addClass(<span class="string">'mailto'</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>因为我们在页面的样式表中定义了相应的规则,所以页面中所有<code>mailto:</code>链接的后面都会出现一个信封图标,如图2-5所示。</p><p>要为所有指向<code>PDF</code>文件的链接添加类,需要使用美元符号($)而不是脱字符号(^) 。这是因为我们要选择所有<code>href</code>属性以<code>.pdf</code>结尾的链接,如代码清单2-4所示。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  $(<span class="string">'a[href^="mailto:"]'</span>).addClass(<span class="string">'mailto'</span>); </span><br><span class="line">  $(<span class="string">'a[href$=".pdf"]'</span>).addClass(<span class="string">'pdflink'</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>因为有已经定义的样式表规则,新添加的<code>pdflink</code>类也会导致每个<code>PDF</code>文档链接后面出现<code>Adobe Acrobat</code>图标,如图2-6所示。</p><p>属性选择符也可以组合使用。例如,可以为<code>href</code>属性即以<code>http</code>开头且任意位置包含<code>henry</code>的所有链接添加一个<code>henrylink</code>类,如代码清单2-5所示。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="string">'#selected-plays &gt; li'</span>).addClass(<span class="string">'horizontal'</span>);</span><br><span class="line">  $(<span class="string">'#selected-plays li:not(.horizontal)'</span>).addClass(<span class="string">'sub-level'</span>);</span><br><span class="line"></span><br><span class="line">  $(<span class="string">'a[href^="mailto:"]'</span>).addClass(<span class="string">'mailto'</span>);</span><br><span class="line">  $(<span class="string">'a[href$=".pdf"]'</span>).addClass(<span class="string">'pdflink'</span>);</span><br><span class="line">  $(<span class="string">'a[href^="http"][href*="henry"]'</span>).addClass(<span class="string">'henrylink'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>在把这3个类应用到3种类型的链接之后,应该看到如图2-7所示的结果。</p><p>我们注意到,在这个屏幕截图中,<code>Hamlet</code>链接右侧有一个<code>PDF</code>图标,<code>email</code>链接旁边有一个信封图标,而<code>Henry V</code>链接则带有白色背景和黑色边框。</p>]]></content>
      
      
      <categories>
          
          <category> jQuery基础教程 第4版 </category>
          
          <category> 第2章 选择元素 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2.3 CSS选择符</title>
      <link href="/ReadingNotes//103cc50f/"/>
      <url>/ReadingNotes//103cc50f/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/103cc50f/#2-3-CSS选择符" class="header_1">2.3 CSS选择符</a>&nbsp;<br><a href="/ReadingNotes/103cc50f/#基于列表项的级别添加样式" class="header_2">基于列表项的级别添加样式</a>&nbsp;<br><a href="/ReadingNotes/103cc50f/#子元素组合符" class="header_3">子元素组合符</a>&nbsp;<br><a href="/ReadingNotes/103cc50f/#否定式伪类选择符" class="header_3">否定式伪类选择符</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="2-3-CSS选择符"><a href="#2-3-CSS选择符" class="headerlink" title="2.3 CSS选择符"></a>2.3 CSS选择符</h1><p><code>jQuery</code>支持<code>CSS规范1</code>到<code>CSS规范3</code>中的几乎所有选择符,具体内容可以参考<code>W3C</code> (<code>World Wide Web Consortium</code>,万维网联盟)<a href="http://www.w3.org/Style/CSS/specs" target="_blank" rel="noopener">网站</a>。这种对<code>CSS</code>选择符的支持,使得开发者在增强自己的网站时,不必为哪种浏览器不理解某种不太常用的选择符而担心,只要该浏览器启用了<code>JavaScript</code>就没有问题。<br><strong>渐进增强</strong><br>负责任的<code>jQuery</code>开发者应该在编写自己的程序时,始终坚持<code>渐进增强</code>(<code>progressive enhancement</code>)和<code>平稳退化</code>(<code>graceful degradation</code>)的理念,<strong>做到在<code>JavaScript</code>禁用时,页面仍然能够与启用<code>JavaScript</code>时一样准确地呈现</strong>,即使没有那么美观。贯穿本书,我们还将继续探讨这些理念。关于渐进增强的更多信息,请<a href="http://en.wikipedia.org/wiki/Progressive_enhancement" target="_blank" rel="noopener">参考</a>。<br>为了学习在<code>jQuery</code>中如何使用<code>CSS</code>选择符,我们选择了一个很多网站中都会有的<code>通常用于导航的结构——嵌套的无序列表</code>。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"selected-plays"</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Comedies </span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/asyoulikeit/"</span>&gt;</span>As You Like It<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>All's Well That Ends Well<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>A Midsummer Night's Dream<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>Twelfth Night<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Tragedies </span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"hamlet.pdf"</span>&gt;</span>Hamlet<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>Macbeth<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>Romeo and Juliet<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Histories </span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>Henry IV (<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"mailto:henryiv@king.co.uk"</span>&gt;</span>email<span class="tag">&lt;/<span class="name">a</span>&gt;</span>) </span><br><span class="line">         <span class="tag">&lt;<span class="name">ul</span>&gt;</span> </span><br><span class="line">           <span class="tag">&lt;<span class="name">li</span>&gt;</span>Part I<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">           <span class="tag">&lt;<span class="name">li</span>&gt;</span>Part II<span class="tag">&lt;/<span class="name">li</span>&gt;</span>  </span><br><span class="line">         <span class="tag">&lt;/<span class="name">ul</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.shakespeare.co.uk/henryv.htm"</span>&gt;</span>Henry V<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>Richard II<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><br>我们注意到,其中第一个<code>&lt;ul&gt;</code>的<code>ID</code>值为<code>selected-plays</code>,但<code>&lt;li&gt;</code>标签则全都没有与之关联的类。在没有应用任何样式的情况下,这个列表的外观如图2-2所示。</p><p>图2-2中的嵌套列表按照我们期望的方式显示——一组带符号的列表项垂直排列,并且每个列表都按照各自的级别进行了缩进。</p><h2 id="基于列表项的级别添加样式"><a href="#基于列表项的级别添加样式" class="headerlink" title="基于列表项的级别添加样式"></a>基于列表项的级别添加样式</h2><p>假设我们想让顶级的项(<code>Comedies</code>、<code>Tragedies</code>和<code>Histories</code>) ,而且只有顶级的项<code>水平排列</code>,那么可以先在样式表中定义一个<code>horizontal</code>类:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.horizontal</span> &#123; </span><br><span class="line">  <span class="attribute">float</span>: left; </span><br><span class="line">  <span class="attribute">list-style</span>: none; </span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">10px</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个<code>horizontal</code>类会将元素浮动到它后面元素的左侧,如果这个元素是一个列表项,那么会移除其项目符号,最后再为该元素的每一边各添加10像素的外边距。</p><h3 id="子元素组合符"><a href="#子元素组合符" class="headerlink" title="子元素组合符"></a>子元素组合符</h3><p>这里,我们没有直接在<code>HTML</code>中添加<code>horizontal</code>类,而只是将它动态地添加给位于顶级的列表项<code>Comedies</code>、<code>Tragedies</code>和<code>Histories</code>,以便示范<code>jQuery</code>中选择符的用法,如代码清单2-1所示。<br><strong>清单2-1:</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="string">'#selected-plays &gt; li'</span>).addClass(<span class="string">'horizontal'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>我们在第1章讨论过,当在<code>jQuery</code>代码中使用<code>$(document).ready()</code>时,位于其中的所有代码都会在<code>DOM</code>加载后立即执行。<br>第2行代码使用<code>子元素组合符</code>(<code>&gt;</code>)将<code>horizontal</code>类只添加到位于顶级的项中。实际上,位于<code>$()</code>函数中的选择符<code>#selected-plays&gt;li</code>的含义是,查找<code>ID</code>为<code>selected-plays</code>的元素(<code>#selected-plays</code>)的<code>子元素</code>(<code>&gt;</code>)中所有的列表项(<code>li</code>)。<br>随着这个类的应用,列表项应该水平对齐,而不是垂直对齐,如图2-3所示。</p><h3 id="否定式伪类选择符"><a href="#否定式伪类选择符" class="headerlink" title="否定式伪类选择符"></a>否定式伪类选择符</h3><p>要为其他项(非顶级的项)添加样式,有很多种方式。因为已经为顶级项添加了<code>horizontal</code>类,所以取得全部非顶级项的一种方式,就是使用<code>否定式伪类选择符</code>来识别没有<code>horizontal</code>类的所有列表项。注意代码清单2-2添加的第3行代码。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  $(<span class="string">'#selected-plays &gt; li'</span>).addClass(<span class="string">'horizontal'</span>); </span><br><span class="line">  $(<span class="string">'#selected-plays li:not(.horizontal)'</span>).addClass(<span class="string">'sub-level'</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>这一次取得的每个列表项(<code>&lt;li&gt;</code>):</p><ul><li>是<code>ID</code>为<code>selected-plays</code>的元素(<code>#selected-plays</code>)的后代元素。</li><li>没有<code>horizontal</code>类(<code>:not(.horizontal)</code>)。</li></ul><p>在为这些列表项添加了<code>sub-level</code>类之后,它们的背景颜色变为在样式表规则中定义的浅灰色。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.sub-level</span> &#123; </span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#ccc</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>此时的嵌套列表如图2-4所示。</p>]]></content>
      
      
      <categories>
          
          <category> jQuery基础教程 第4版 </category>
          
          <category> 第2章 选择元素 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2.2 使用$()函数</title>
      <link href="/ReadingNotes//3c919b9d/"/>
      <url>/ReadingNotes//3c919b9d/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/3c919b9d/#2-2-使用$-函数" class="header_1">2.2 使用$()函数</a>&nbsp;<br><a href="/ReadingNotes/3c919b9d/#让jQuery与其他JavaScript库协同工作" class="header_2">让jQuery与其他JavaScript库协同工作</a>&nbsp;<br><a href="/ReadingNotes/3c919b9d/#3种基本的选择符" class="header_2">3种基本的选择符</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="2-2-使用-函数"><a href="#2-2-使用-函数" class="headerlink" title="2.2 使用$()函数"></a>2.2 使用$()函数</h1><p>我们<strong>通过<code>jQuery</code>的各种选择符和方法取得的结果集合会被包装在<code>jQuery</code>对象中</strong>。通过<code>jQuery</code>对象实际地操作这些元素会非常简单。可以轻松地为<code>jQuery</code>对象绑定事件、添加漂亮的效果,也可以将多重修改或效果通过<code>jQuery</code>对象连缀到一起。<br>然而,<code>jQuery</code>对象与常规的<code>DOM</code>元素不同,而且也没有必要为实现某些任务给纯<code>DOM</code>元素或节点列表添加相同的方法和属性。在本章的最后一部分中,我们会介绍如何直接访问收集在<code>jQuery</code>对象中的<code>DOM</code>元素。<br>为了创建<code>jQuery</code>对象,就要使用<code>$()</code>函数。这个函数接受<code>CSS</code>选择符作为参数,充当一个工厂,返回包含页面中对应元素的<code>jQuery</code>对象。所有能在样式表中使用的选择符都可以传给这个函数,随后我们就可以对匹配的元素集合应用<code>jQuery</code>方法。</p><h2 id="让jQuery与其他JavaScript库协同工作"><a href="#让jQuery与其他JavaScript库协同工作" class="headerlink" title="让jQuery与其他JavaScript库协同工作"></a>让jQuery与其他JavaScript库协同工作</h2><p>在<code>jQuery</code>中, 美元符号<script type="math/tex">`只不过标识符`jQuery`的 "别名" 。 由于`$()`在`JavaScript`库中很常见,所以,如果在一个页面中使用了几个这样的库,那么就会导致冲突。在这种情况下,可以在我们自定义的`jQuery`代码中,通过将每个`</script>的实例替换成<code>jQuery</code>来避免这种冲突。第10章还会介绍这个问题的其他解决方案。</p><h2 id="3种基本的选择符"><a href="#3种基本的选择符" class="headerlink" title="3种基本的选择符"></a>3种基本的选择符</h2><p>有3种基本的选择符:<code>标签名</code>选择符、<code>ID</code>选择符和<code>类</code>选择符。这些选择符可以单独使用,也可以与其他选择符组合使用。表2-1展示了这3种基本的选择符。</p><center><strong>表2-1 基本的选择符 </strong></center><div class="table-container"><table><thead><tr><th style="text-align:left">选择符</th><th style="text-align:left"><code>CSS</code></th><th style="text-align:left"><code>jQuery</code></th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">标签名选择符</td><td style="text-align:left"><code>P{}</code></td><td style="text-align:left"><code>$(&#39;p&#39;)</code></td><td style="text-align:left">取得文档中所有的段落</td></tr><tr><td style="text-align:left"><code>ID</code>选择符</td><td style="text-align:left"><code>#some-id{}</code></td><td style="text-align:left"><code>$(&#39;#some-id&#39;)</code></td><td style="text-align:left">取得文档中<code>ID</code>为<code>some-id</code>的一个元素</td></tr><tr><td style="text-align:left">类选择符</td><td style="text-align:left"><code>.some-class{}</code></td><td style="text-align:left"><code>$(&#39;.some-class&#39;)</code></td><td style="text-align:left">取得文档中<code>类</code>为<code>some-class</code>的所有元素</td></tr></tbody></table></div><p>第1章曾经提到过,在将方法连缀到<code>$()</code>工厂函数后面时,包装在<code>jQuery</code>对象中的元素会被自动、隐式地循环遍历。换句话说,这样就避免了使用<code>for</code>循环之类的显式迭代(这种迭代在<code>DOM</code>脚本编程中非常常见)。</p>]]></content>
      
      
      <categories>
          
          <category> jQuery基础教程 第4版 </category>
          
          <category> 第2章 选择元素 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2.1 理解DOM</title>
      <link href="/ReadingNotes//ca28216e/"/>
      <url>/ReadingNotes//ca28216e/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/ca28216e/#2-1-理解DOM" class="header_1">2.1 理解DOM</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="2-1-理解DOM"><a href="#2-1-理解DOM" class="headerlink" title="2.1 理解DOM"></a>2.1 理解DOM</h1><p><code>jQuery</code>最强大的特性之一就是它能够简化在<code>DOM</code>中选择元素的任务。 <code>DOM</code> (<code>Document Object``Model</code>,文档对象模型)充当了<code>JavaScript</code>与网页之间的接口;它以对象网络而非纯文本的形式来表现<code>HTML</code>的源代码。<br><code>DOM</code>中的对象网络与家谱有几分类似。当我们提到网络中元素之间的关系时,会使用类似描述家庭关系的术语,比如父元素、子元素,等等。通过一个简单的例子,可以帮助我们理解文档各元素构成的树形结构:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>the title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is another paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is yet another paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><br>这里,<code>&lt;html&gt;</code>是其他所有元素的祖先元素,换句话说,其他所有元素都是<code>&lt;html&gt;</code>的后代元素。<code>&lt;head&gt;</code>和<code>&lt;body&gt;</code>元素是<code>&lt;html&gt;</code>的子元素(但并不是它唯一的子元素) 。因此除了作为<code>&lt;head&gt;</code>和<code>&lt;body&gt;</code>的祖先元素之外,<code>&lt;html&gt;</code>也是它们的父元素。 而<code>&lt;p&gt;</code>元素则是<code>&lt;div&gt;</code>的子元素(也是后代元素),是<code>&lt;body&gt;</code>和<code>&lt;html&gt;</code>的后代元素,是其他<code>&lt;p&gt;</code>元素的同辈元素。这些元素之间的关系从下面的图2-1中可以看得更清楚。<br>为了把<code>DOM</code>结构更形象地表现出来,可以使用很多工具,例如<code>Firefox</code>的<code>Firebug</code>插件、<code>Safari</code>和<code>Chrome</code>中的<code>Web Inspector</code>等。<br>有了这个元素树,就可以使用<code>jQuery</code>从中取得任何元素了。而我们用来取得元素的工具,就是<code>jQuery</code>选择符和遍历方法。</p>]]></content>
      
      
      <categories>
          
          <category> jQuery基础教程 第4版 </category>
          
          <category> 第2章 选择元素 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第2章 选择元素</title>
      <link href="/ReadingNotes//9e8a78ef/"/>
      <url>/ReadingNotes//9e8a78ef/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/9e8a78ef/#第2章-选择元素" class="header_1">第2章 选择元素</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="第2章-选择元素"><a href="#第2章-选择元素" class="headerlink" title="第2章 选择元素"></a>第2章 选择元素</h1><p><code>jQuery</code>利用了<strong><code>CSS</code>选择符</strong>的能力,让我们能够在<code>DOM</code>中快捷而轻松地获取元素或元素集合。本章将介绍如下内容:</p><ul><li>网页中元素的结构; </li><li>如何通过<code>CSS</code>选择符在页面中查找元素; </li><li>扩展<code>jQuery</code>标准的<code>CSS</code>选择符; </li><li>让选择页面元素更灵活的<code>DOM</code>遍历方法。 </li></ul>]]></content>
      
      
      <categories>
          
          <category> jQuery基础教程 第4版 </category>
          
          <category> 第2章 选择元素 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.4 纯JavaScript与jQuery</title>
      <link href="/ReadingNotes//677fb0da/"/>
      <url>/ReadingNotes//677fb0da/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/677fb0da/#1-4-纯JavaScript与jQuery" class="header_1">1.4 纯JavaScript与jQuery</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="1-4-纯JavaScript与jQuery"><a href="#1-4-纯JavaScript与jQuery" class="headerlink" title="1.4 纯JavaScript与jQuery"></a>1.4 纯JavaScript与jQuery</h1><p><code>jQuery</code>代码不仅写起来省事,读起来简单,而且也比纯<code>JavaScript</code>代码的执行速度更快。</p>]]></content>
      
      
      <categories>
          
          <category> jQuery基础教程 第4版 </category>
          
          <category> 第1章 jQuery入门 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.5 使用开发工具</title>
      <link href="/ReadingNotes//dfb87bf/"/>
      <url>/ReadingNotes//dfb87bf/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/dfb87bf/#1-5-使用开发工具" class="header_1">1.5 使用开发工具</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="1-5-使用开发工具"><a href="#1-5-使用开发工具" class="headerlink" title="1.5 使用开发工具"></a>1.5 使用开发工具</h1><p>通过上面代码的比较,我们知道<code>jQuery</code>代码与对应的纯<code>JavaScript</code>代码相比更短也更清楚。可是,这并不意味着我们写出的代码永远不会有<code>bug</code>,或者永远都能直观地理解页面中都发生了什么。如果能有一些标准的开发工具辅助,编写起<code>jQuery</code>代码来就会更轻松流畅。<br>现代浏览器中一般都内置了高质量的开发工具。我们可以从中选择自己觉得最方便的工具。下面列出了一些推荐工具:</p><ul><li><a href="https://developers.google.com/chrome-developer-tools/" target="_blank" rel="noopener">Chrome Developer Tools</a>;</li><li><a href="http://getfirebug.com" target="_blank" rel="noopener">Firefox插件Firebug</a>;<ul><li><code>Firebug</code>已停止继续开发,更新维护,现在可以下载<a href="https://www.mozilla.org/zh-CN/firefox/developer/" target="_blank" rel="noopener">Firefox Quantum:开发者版本</a>使用.</li></ul></li><li><a href="http://developer.apple.com/technologies/safari/developer-tools.html" target="_blank" rel="noopener">Safari Web Inspector</a>;</li><li><a href="http://www.opera.com/dragonfly/" target="_blank" rel="noopener">Opera Dragonfly</a></li><li><a href="http://msdn.microsoft.com/en-us/library/dd565628.aspx" target="_blank" rel="noopener">Internet Explorer Developer Tools</a>;</li></ul><p>上面列出来的这些工具都提供了类似的功能,比如:</p><ul><li>探测及修改<code>DOM</code>;</li><li>研究<code>CSS</code>及页面表现之间的关系;</li><li>通过特殊的方法方便地跟踪脚本执行;</li><li>暂停脚本运行及检查变量值。</li></ul><p>虽然这些功能在不同的工具中会有所变化,但大体上概念是相同的。本书中的某些示例需要用到这么一个工具,因此我们就以<code>Firebug</code>为例,不过使用其他浏览器的开发工具也没有什么问题。</p>]]></content>
      
      
      <categories>
          
          <category> jQuery基础教程 第4版 </category>
          
          <category> 第1章 jQuery入门 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.6 小结</title>
      <link href="/ReadingNotes//8379ecc7/"/>
      <url>/ReadingNotes//8379ecc7/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/8379ecc7/#1-6-小结" class="header_1">1.6 小结</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="1-6-小结"><a href="#1-6-小结" class="headerlink" title="1.6 小结"></a>1.6 小结</h1><p>本章,我们学习了怎样设置<code>jQuery</code>,以便在网页中通过<code>JavaScript</code>使用它;</p><ul><li>学习了使用<code>$()</code>工厂函数查找具有给定类的页面部分;</li><li>学习了调用<code>.addClass()</code>为页面的这些部分应用额外的样式;</li><li>还学习了调用<code>$(document).ready()</code>基于页面加载来执行代码。</li></ul><p>此外,我们也探讨了在编写、测试和调试<code>jQuery</code>代码时将会用到的开发工具。</p><p>经过对本章的学习,我们对开发者选择使用<code>JavaScript</code>框架,而不是从零开始编写代码(即使是最基本的任务)的原因有了一个概念。同时,也理解了<code>jQuery</code>作为一个框架,都有哪些值得称道的地方以及我们选择它而不是选别的框架的理由。我们也大体上知道了<code>jQuery</code>能够简化哪些任务。<br>本章中给出的示范如何使用<code>jQuery</code>的简单例子,在现实中并不是很有用。在下一章中,我们将在此基础上继续探索<code>jQuery</code>中<strong>高级的选择符使用方式</strong>,并介绍这一技术的实际应用。</p>]]></content>
      
      
      <categories>
          
          <category> jQuery基础教程 第4版 </category>
          
          <category> 第1章 jQuery入门 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.3 第一个jQuery驱动的页面</title>
      <link href="/ReadingNotes//a86b9418/"/>
      <url>/ReadingNotes//a86b9418/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/a86b9418/#1-3-第一个jQuery驱动的页面" class="header_1">1.3 第一个jQuery驱动的页面</a>&nbsp;<br><a href="/ReadingNotes/a86b9418/#1-3-1-下载jQuery" class="header_2">1.3.1 下载jQuery</a>&nbsp;<br><a href="/ReadingNotes/a86b9418/#1-3-2-本书使用jQuery的哪个版本" class="header_2">1.3.2 本书使用jQuery的哪个版本</a>&nbsp;<br><a href="/ReadingNotes/a86b9418/#1-3-3-在HTML文档中引入jQuery" class="header_2">1.3.3 在HTML文档中引入jQuery</a>&nbsp;<br><a href="/ReadingNotes/a86b9418/#下载示例代码" class="header_3">下载示例代码</a>&nbsp;<br><a href="/ReadingNotes/a86b9418/#1-3-4-编写jQuery代码" class="header_2">1.3.4 编写jQuery代码</a>&nbsp;<br><a href="/ReadingNotes/a86b9418/#1-查找诗歌文本" class="header_3">1. 查找诗歌文本</a>&nbsp;<br><a href="/ReadingNotes/a86b9418/#2-加入新类" class="header_3">2. 加入新类</a>&nbsp;<br><a href="/ReadingNotes/a86b9418/#3-执行代码" class="header_3">3. 执行代码</a>&nbsp;<br><a href="/ReadingNotes/a86b9418/#1-3-5-最终结果" class="header_3">1.3.5 最终结果</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="1-3-第一个jQuery驱动的页面"><a href="#1-3-第一个jQuery驱动的页面" class="headerlink" title="1.3 第一个jQuery驱动的页面"></a>1.3 第一个jQuery驱动的页面</h1><p>了解<code>jQuery</code>能够提供的丰富特性之后,我们可以来看一看这个库的实际应用了。为此,我们需要下载一个<code>jQuery</code>的副本。</p><h2 id="1-3-1-下载jQuery"><a href="#1-3-1-下载jQuery" class="headerlink" title="1.3.1 下载jQuery"></a>1.3.1 下载jQuery</h2><p><code>jQuery</code>不需要安装,要使用它只需该文件的一个副本,该副本可以放在外部站点上,也可以放在自己的服务器上。由于<code>JavaScript</code>是一种解释型语言,所以不必担心编译和构建。什么时候需要使用<code>jQuery</code>,只要在<code>HTML</code>文档中使用<code>&lt;script&gt;</code>元素把它导入进来即可。<br><code>jQuery</code><a href="http://jquery.com/" target="_blank" rel="noopener">官方网站</a>始终都包含该库最新的稳定版本,通过官网的首页就可以下载。官方网站在任何时候都会提供几种不同版本的<code>jQuery</code>库,但其中最适合我们的是该库最新的<strong>未压缩版(uncompressed)</strong>。而在正式发布的页面中,则可以使用压缩版(minified)。<br>随着<code>jQuery</code>的日益流行,很多公司都通过自己的<code>CDN</code>(<code>Content Delivery Networks</code>,内容分发网络)来托管其库文件,让开发人员能更方便地使用它。最典型的就是谷歌(<a href="https://developers.google.com/speed/libraries/devguide" target="_blank" rel="noopener">https://developers.google.com/speed/libraries/devguide</a>)和微软(<a href="http://www.asp.net/ajaxlibrary/cdn.ashx" target="_blank" rel="noopener">http://www.asp.net/ajaxlibrary/cdn.ashx</a>)和<code>jQuery</code>项目自己的服务器(<a href="http://code.jquery.com/" target="_blank" rel="noopener">http://code.jquery.com/</a>),<code>jQuery</code>库文件被放在了强劲、低延时的服务器上,这些服务器遍布全球各地,无论用户在哪个国家,都能以最快速度下载到<code>jQuery</code>。虽然托管在<code>CDN</code>上的文件由于分布式和缓存的原因有速度优势,但在实际开发中还是使用本地副本更方便一些。</p><h2 id="1-3-2-本书使用jQuery的哪个版本"><a href="#1-3-2-本书使用jQuery的哪个版本" class="headerlink" title="1.3.2 本书使用jQuery的哪个版本"></a>1.3.2 本书使用jQuery的哪个版本</h2><p>为了确保在现代浏览器中速度更快,代码更简洁,<code>jQuery</code>从2.0版开始不再支持<code>IE6</code>、<code>IE7</code>和<code>IE8</code>。<br>不过支持这些老版本浏览器也很重要。正因为如此,<code>jQuery</code>开发团队还会继续维护<code>jQuery 1.x</code>版。<br>如果项目中有针对<code>jQuery 1.9</code>之前的版本编写的代码,可以使用<a href="http://jquery.com/upgrade-guide/1.9/#jquery-migrate-plugin" target="_blank" rel="noopener">jQuery迁移插件</a>实现与<code>jQuery 1.10</code>兼容。</p><h2 id="1-3-3-在HTML文档中引入jQuery"><a href="#1-3-3-在HTML文档中引入jQuery" class="headerlink" title="1.3.3 在HTML文档中引入jQuery"></a>1.3.3 在HTML文档中引入jQuery</h2><h3 id="下载示例代码"><a href="#下载示例代码" class="headerlink" title="下载示例代码"></a>下载示例代码</h3><p>如同本书其他<code>HTML</code>、<code>CSS</code>以及<code>JavaScript</code>示例一样,上面的标记只是完整文档的一个片段。如果读者想试一试这些示例,可以从<a href="http://book.learningjquery.com/" target="_blank" rel="noopener">本书网站</a>下载随书代码.</p><p><strong>引用<code>jQuery</code>库文件的<code>&lt;script</code>&gt;标签,必须放在引用自定义脚本文件的<code>&lt;script</code>&gt;标签之前。否则,在我们编写的代码中将引用不到<code>jQuery</code>框架。</strong></p><h2 id="1-3-4-编写jQuery代码"><a href="#1-3-4-编写jQuery代码" class="headerlink" title="1.3.4 编写jQuery代码"></a>1.3.4 编写jQuery代码</h2><h3 id="1-查找诗歌文本"><a href="#1-查找诗歌文本" class="headerlink" title="1. 查找诗歌文本"></a>1. 查找诗歌文本</h3><p><code>jQuery</code>中基本的操作就是选择文档中的某一部分,这是通过<code>$()</code>函数来完成的。通常,<code>$()</code>函数需要一个字符串参数,该字符串参数中可以包含任何<strong><code>CSS</code>选择符表达式</strong>。在这个例子中,我们想要找到带有<code>poem-stanza</code>类的所有<code>&lt;div&gt;</code>元素,因此选择符非常简单。不过,在本书其他章中,我们还会介绍很多更复杂的选择符表达式。在第2章中,我们要讨论的就是查找文档部分的不同方式。<br>这里用到的<strong><code>$()</code>函数会返回一个新的<code>jQuery</code>对象实例</strong>,它是我们从现在开始就要打交道的基本的构建块。<strong><code>jQuery</code>对象中会封装零个或多个<code>DOM</code>元素,并允许我们以多种不同的方式与这些<code>DOM</code>元素进行交互</strong>。在这个例子中,我们希望修改页面中这些部分的外观,而为了完成这个任务,就需要改变应用到诗歌文本的类。</p><h3 id="2-加入新类"><a href="#2-加入新类" class="headerlink" title="2. 加入新类"></a>2. 加入新类</h3><p>1本例中,<strong><code>.addClass()</code>方法会将一个<code>CSS</code>类应用到我们选择的页面元素</strong>。<code>.addClass()</code>方法唯一的参数就是要添加的类名。 <code>.addClass()</code>方法及其反方法<code>.removeClass()</code>,为我们探索<code>jQuery</code>支持的各种选择符表达式提供了便利。现在,这个例子只是简单地添加了<code>highlight</code>类,而我们的样式表中为这个类定义的是带边框和灰色背景的斜体文本样式。<br>我们注意到,无需迭代操作就能为所有诗歌中的<code>节</code>添加这个类(所谓<code>节</code>就是类为<code>.poem-stanza</code>的文档部分.)。前面我们提到过,<strong><code>jQuery</code>在<code>.addClass()</code>等方法中使用了<code>隐式迭代机制</code>,因此<code>一次函数调用就可以完成对所有选择的文档部分的修改</code>。</strong></p><h3 id="3-执行代码"><a href="#3-执行代码" class="headerlink" title="3. 执行代码"></a>3. 执行代码</h3><p>综合起来,<code>$()</code>和<code>.addClass()</code>对我们修改诗歌中文本的外观已经够用了。但是,如果将这行代码单独插入文档的头部,不会有任何效果。<strong>通常,<code>JavaScript</code>代码在浏览器初次遇到它们时就会执行</strong>,<strong>而在浏览器处理头部时,<code>HTML</code>还不会呈现样式</strong>。因此,我们需要将代码延迟到<code>DOM</code>可用时再执行。<br>通过使用<code>$(document).ready()</code>方法, <code>jQuery</code>支持我们预定在<code>DOM</code>加载完毕后调用某个函数,而不必等待页面中的图像加载。尽管不使用<code>jQuery</code>,也可以做到这种预定,但<code>$(document).ready()</code>为我们提供了很好的跨浏览器解决方案,涉及如下功能:</p><ul><li>尽可能使用浏览器原生的<code>DOM</code>就绪实现,并以<code>window.onload</code>事件处理程序作为后备;</li><li>可以多次调用<code>$(document).ready()</code>并按照调用它们的顺序执行;</li><li>即便是在浏览器事件发生之后把函数传给<code>$(document).ready()</code>, 这些函数也会执行;</li><li>异步处理事件的预定,必要时脚本可以延迟执行;</li><li>通过重复检查一个几乎与<code>DOM</code>同时可用的方法,在较早版本的浏览器中模拟<code>DOM</code>就绪事件。</li></ul><p><code>$(document).ready()</code>方法的参数可以<code>函数名称</code>,如下面的代码所示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function addHighlightClass()  &#123; </span><br><span class="line">  $(&#39;div.poem-stanza&#39;).addClass(&#39;highlight&#39;); </span><br><span class="line">&#125; </span><br><span class="line">&#x2F;&#x2F; 使用函数的引用(函数名)作为参数</span><br><span class="line">$(document).ready(addHighlightClass);</span><br></pre></td></tr></table></figure><br>这个方法也可以接收一个<code>匿名函数</code>.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">  $(<span class="string">'div.poem-stanza'</span>).addClass(<span class="string">'highlight'</span>);  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>这种<code>匿名函数</code>的写作在<code>jQuery</code>中十分方便,<code>特别适合传递那些不会被重用的函数</code>。而且,与此同时创建的<code>闭包</code>也是一种非常高级和强大的工具。但是,假如处理不当的话,闭包也会给我们带来意想不到的后果以及内存占用问题。附录A详细介绍了闭包。</p><h3 id="1-3-5-最终结果"><a href="#1-3-5-最终结果" class="headerlink" title="1.3.5 最终结果"></a>1.3.5 最终结果</h3><p>在编写好<code>JavaScript</code>代码之后,现在的页面如下图:</p><p>由于<code>JavaScript</code>插入了<code>highlight</code>类,页面中的两节诗歌文本变成了斜体,带有了灰色背景,并且被包含在方框中;这些样式来源于<code>01.css</code>样式表。</p>]]></content>
      
      
      <categories>
          
          <category> jQuery基础教程 第4版 </category>
          
          <category> 第1章 jQuery入门 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.2 jQuery为什么如此出色</title>
      <link href="/ReadingNotes//959ec8ba/"/>
      <url>/ReadingNotes//959ec8ba/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/959ec8ba/#1-2-jQuery为什么如此出色" class="header_1">1.2 jQuery为什么如此出色</a>&nbsp;<br><a href="/ReadingNotes/959ec8ba/#jQuery策略" class="header_2">jQuery策略</a>&nbsp;<br><a href="/ReadingNotes/959ec8ba/#脚注说明" class="header_2">脚注说明</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="1-2-jQuery为什么如此出色"><a href="#1-2-jQuery为什么如此出色" class="headerlink" title="1.2 jQuery为什么如此出色"></a>1.2 jQuery为什么如此出色</h1><h2 id="jQuery策略"><a href="#jQuery策略" class="headerlink" title="jQuery策略"></a>jQuery策略</h2><p><code>jQuery</code>采用了如下策略。</p><ol><li><strong>利用<code>CSS</code>的优势</strong>。通过将查找页面元素的机制构建于<code>CSS</code>选择符之上,<code>jQuery</code>继承了简明清晰地表达文档结构的方式。由于进行专业<code>Web</code>开发的一个必要条件是掌握<code>CSS</code>语法,因而<code>jQuery</code>成为希望向页面中添加行为的设计者们的切入点。</li><li><strong>支持扩展</strong>。为了避免特性蠕变(<code>feature creep</code>)①,<code>jQuery</code>将特殊情况下使用的工具归入插件当中。创建新插件的方法很简单,而且拥有完备的文档说明,这促进了大量有创意且有实用价值的模块的开发。甚至在下载的基本<code>jQuery</code>库文件当中,多数特性在内部都是通过插件架构实现的。而且,如有必要,可以移除这些内部插件,从而生成更小的库文件.</li><li><strong>抽象浏览器不一致性</strong>。<code>Web</code>开发领域中一个令人遗憾的事实是,每种浏览器对颁布的标准都有自己的一套不太一致的实现方案。 任何<code>Web</code>应用程序中都会包含一个用于处理这些平台间特性差异的重要组成部分。虽然不断发展的浏览器前景,使得为某些高级特性提供浏览器中立的完美的基础代码(<code>code base</code>)变得不大可能,但<code>jQuery</code>添加一个抽象层来标准化常见的任务,从而有效地减少了代码量,同时,也极大地简化了这些任务。</li><li><strong>总是面向集合</strong>。当我们指示<code>jQuery</code>“找到带有<code>collapsible</code>类的全部元素,然后隐藏它们”时,不需要循环遍历每一个返回的元素。相反,<code>.hide</code>()之类的方法被设计成自动操作对象集合,而不是单独的对象。利用这种称作隐式迭代(<code>implicit iteration</code>)的技术,就可以抛弃那些臃肿的循环结构,从而大幅地减少代码量。</li><li><strong>将多重操作集于一行</strong>。为了避免过度使用临时变量或不必要的代码重复,<code>jQuery</code>在其多数方法中采用了一种称作连缀(<code>chaining</code>)②的编程模式。这种模式意味着基于一个对象进行的多数操作的结果,都会返回这个对象自身,以便为该对象应用下一次操作。</li></ol><p>这些策略不仅保证了<code>jQuery</code>包的小型化,也为我们使用这个库创建简洁的自定义代码提供了技术保障。<br><code>jQuery</code>库的适用性一方面要归因于其设计理念,另一方面则得益于围绕这个开源项目涌现出的活跃社区的促进作用。<code>jQuery</code>用户聚集到一起,不仅会讨论插件的开发,也会讨论如何增强核心库。用户和开发人员也对<code>jQuery</code>的官方文档给予了持续的帮助,该文档的地址为<a href="http://api.jquery.com" target="_blank" rel="noopener">http://api.jquery.com</a>。<br><code>jQuery</code>为<code>Web</code>开发人员提供了灵活且健壮的系统,而且它对所有人都是免费的。这个开源项目遵循<code>MIT License</code>发布,任何站点和专有的软件都可以自由使用它。如果项目需要,还可以基于<code>GNU Public License</code>重新发布它,以便与其他基于<code>GNU</code>许可的开源项目整合。</p><h2 id="脚注说明"><a href="#脚注说明" class="headerlink" title="脚注说明"></a>脚注说明</h2><p>① 术语<code>feature creep</code>(<strong>特性蠕变</strong>)也有人译为<strong>特性蔓延</strong>,指软件应用开发中过分强调新的功能以至于损害了其他的设计目标,例如简洁性、轻巧性、稳定性及错误出现率等。<br>② 术语<code>chaining</code>(<strong>连缀</strong>)也可译为<strong>链接</strong>,但为避免与人们耳熟能详的超链接混淆(如常见的”单击链接”等),所以才译为更贴切的连缀。</p>]]></content>
      
      
      <categories>
          
          <category> jQuery基础教程 第4版 </category>
          
          <category> 第1章 jQuery入门 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第1章 jQuery入门 1.1 jQuery能做什么</title>
      <link href="/ReadingNotes//938adc5f/"/>
      <url>/ReadingNotes//938adc5f/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/938adc5f/#第1章-jQuery入门" class="header_1">第1章 jQuery入门</a>&nbsp;<br><a href="/ReadingNotes/938adc5f/#1-1-jQuery能做什么" class="header_2">1.1 jQuery能做什么</a>&nbsp;<br><a href="/ReadingNotes/938adc5f/#小结" class="header_2">小结</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="第1章-jQuery入门"><a href="#第1章-jQuery入门" class="headerlink" title="第1章 jQuery入门"></a>第1章 jQuery入门</h1><p>本章将介绍如下内容:</p><ol><li><code>jQuery</code>的主要特点;</li><li>建立<code>jQuery</code>编码环境;</li><li>简单<code>jQuery</code>脚本示例;</li><li>选择<code>jQuery</code>而不是纯<code>JavaScript</code>的理由;</li><li>常用<code>JavaScript</code>开发工具.</li></ol><h2 id="1-1-jQuery能做什么"><a href="#1-1-jQuery能做什么" class="headerlink" title="1.1 jQuery能做什么"></a>1.1 jQuery能做什么</h2><ol><li><strong>取得文档中的元素</strong>。如果不使用<code>JavaScript</code>库,遍历<code>DOM(Document Object Model</code>,文档对象模型)树, 以及查找<code>HTML</code>文档结构中某个特殊的部分,必须编写很多行代码。 <code>jQuery</code>为准确地获取需要检查或操纵的文档元素,提供了可靠而富有效率的选择符机制。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div.content'</span>).find(<span class="string">'p'</span>);</span><br></pre></td></tr></table></figure></li><li><strong>修改页面的外观</strong>。<code>CSS</code>虽然为影响文档呈现的方式提供了一种强大的手段,但当所有浏览器不完全支持相同的标准时,单纯使用<code>CSS</code>就会显得力不从心。 <code>jQuery</code>可以弥补这一不足,它提供了跨浏览器的标准解决方案。而且,即使在页面已经呈现之后,<code>jQuery</code>仍然能够改变文档中某个部分的类或者个别的样式属性。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'ul &gt; li:first'</span>).addClass(<span class="string">'active'</span>);</span><br></pre></td></tr></table></figure></li><li><strong>改变文档的内容</strong>。jQuery能够影响的范围并不局限于简单的外观变化,使用少量的代码,jQuery就能改变文档的内容。可以改变文本、插入或翻转图像、列表重新排序,甚至对HTML文档的整个结构都能重写和扩充——所有这些只需一个简单易用的API。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#container'</span>).append(<span class="string">'&lt;a href="more.html"&gt;more&lt;/a&gt;'</span>);</span><br></pre></td></tr></table></figure></li><li><strong>响应用户的交互操作</strong>。即使是最强大和最精心设计的行为,如果我们无法控制它何时发生,那它也毫无用处。<code>jQuery</code>提供了截获形形色色的页面事件(比如用户单击某个链接)的适当方式,而不需要使用事件处理程序拆散<code>HTML</code>代码。此外,它的事件处理<code>API</code>也消除了经常困扰<code>Web</code>开发人员浏览器的不一致性。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'button.show-details'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="string">'div.details'</span>).show();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><strong>为页面添加动态效果</strong>。为了实现某种交互式行为,设计者也必须向用户提供视觉上的反馈。<code>jQuery</code>中内置的一批淡入、擦除之类的效果,以及制作新效果的工具包,为此提供了便利.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div.details'</span>).slideDown();</span><br></pre></td></tr></table></figure></li><li><strong>无需刷新页面从服务器获取信息</strong>。这种编程模式就是众所周知的<code>Ajax(Asynchronous JavaScript and XML</code>,异步<code>JavaScript</code>和<code>XML</code>),它是一系列在客户端和服务器之间传输数据的强大技术。<code>jQuery</code>通过消除这一过程中的浏览器特定的复杂性,使开发人员得以专注于服务器端的功能设计,从而得以创建出反应灵敏、功能丰富的网站。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div.details'</span>).load(<span class="string">'more.html #content'</span>);</span><br></pre></td></tr></table></figure></li><li><strong>简化常见的<code>JavaScript</code>任务</strong>。除了这些完全针对文档的特性之外,<code>jQuery</code>也改进了对基本的<code>JavaScript</code>数据结构的操作(例如迭代和数组操作等)。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$.each(obj, <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123; </span><br><span class="line">  total += value; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2>使用<code>jQuery</code>可以做如下事情:</li><li>取得文档中的元素</li><li>修改页面的外观</li><li>改变文档的内容</li><li>响应用户的交互操作</li><li>为页面添加动态效果</li><li>无需刷新页面从服务器获取信息</li><li>简化常见的<code>JavaScript</code>任务</li></ol>]]></content>
      
      
      <categories>
          
          <category> jQuery基础教程 第4版 </category>
          
          <category> 第1章 jQuery入门 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>jQuery基础教程 第4版 目录</title>
      <link href="/ReadingNotes//464b2333/"/>
      <url>/ReadingNotes//464b2333/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/464b2333/#第1章-jQuery入门-##" class="header_2">第1章 jQuery入门 ## </a>&nbsp;<br><a href="/ReadingNotes/464b2333/#第2章-选择元素-##" class="header_2">第2章 选择元素 ## </a>&nbsp;<br><a href="/ReadingNotes/464b2333/#第4章-样式与动画" class="header_2">第4章 样式与动画</a>&nbsp;<br><a href="/ReadingNotes/464b2333/#第5章-操作DOM" class="header_2">第5章 操作DOM</a>&nbsp;<br><a href="/ReadingNotes/464b2333/#第6章-通过Ajax发送数据" class="header_2">第6章 通过Ajax发送数据</a>&nbsp;<br><a href="/ReadingNotes/464b2333/#第7章-使用插件" class="header_2">第7章 使用插件</a>&nbsp;<br><a href="/ReadingNotes/464b2333/#第8章-开发插件" class="header_2">第8章 开发插件</a>&nbsp;<br><a href="/ReadingNotes/464b2333/#第9章-高级选择符与遍历" class="header_2">第9章 高级选择符与遍历</a>&nbsp;<br><a href="/ReadingNotes/464b2333/#第10章-高级事件处理" class="header_2">第10章 高级事件处理</a>&nbsp;<br><a href="/ReadingNotes/464b2333/#第11-章高级效果" class="header_2">第11 章高级效果</a>&nbsp;<br><a href="/ReadingNotes/464b2333/#第12章-高级DOM操作" class="header_2">第12章 高级DOM操作</a>&nbsp;<br><a href="/ReadingNotes/464b2333/#第13章-高级Ajax" class="header_2">第13章 高级Ajax</a>&nbsp;<br><a href="/ReadingNotes/464b2333/#附录A-JavaScript闭包" class="header_2">附录A JavaScript闭包</a>&nbsp;<br><a href="/ReadingNotes/464b2333/#附录B-使用QUnit测试JavaScript" class="header_2">附录B 使用QUnit测试JavaScript</a>&nbsp;<br><a href="/ReadingNotes/464b2333/#附录C-简明参考" class="header_2">附录C 简明参考</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="jQuery基础教程-第4版-目录"><a href="#jQuery基础教程-第4版-目录" class="headerlink" title="jQuery基础教程 第4版 目录"></a>jQuery基础教程 第4版 目录</h1><h2 id="第1章-jQuery入门"><a href="#第1章-jQuery入门" class="headerlink" title="第1章 jQuery入门"></a>第1章 jQuery入门</h2><ul><li>1.1 jQuery能做什么</li><li>1.2 jQuery为什么如此出色</li><li>1.3 第一个 jQuery驱动的页面<ul><li>1.3.1 下载 jQuery</li><li>1.3.2 本书使用 jQuery的哪个版本</li><li>1.3.3 在 HTML文档中引入 jQuery</li><li>1.3.4 编写 jQuery代码</li><li>1.3.5 最终结果</li></ul></li><li>1.4 纯 JavaScript与 jQuery</li><li>1.5 使用开发工具</li><li>1.6 小结</li></ul><h2 id="第2章-选择元素"><a href="#第2章-选择元素" class="headerlink" title="第2章 选择元素"></a>第2章 选择元素</h2><ul><li>2.1 理解DOM</li><li>2.2 使用$()函数</li><li>2.3 CSS选择符</li><li>2.4 属性选择符</li><li>2.5 自定义选择符<ul><li>2.5.1 每隔一行为表格添加样式</li><li>2.5.2 基于上下文内容选择元素</li><li>2.5.3 基于表单的选择符</li></ul></li><li>2.6 DOM遍历方法<ul><li>2.6.1 为特定单元格添加样式</li><li>2.6.2 连缀</li></ul></li><li>2.7 访问 DOM元素</li><li>2.8 小结</li><li>2.9 练习</li></ul><p>第3章 事件</p><ul><li>3.1 在页面加载后执行任务<ul><li>3.1.1 代码执行的时机选择</li><li>3.1.2 基于一个页面执行多个脚本</li><li>3.1.3 .ready()的简写形式</li><li>3.1.4 向.ready()回调函数中传入参数</li></ul></li><li>3.2 处理简单的事件<ul><li>3.2.1 简单的样式转换器</li><li>3.2.2 启用其他按钮</li><li>3.2.3 利用事件处理程序的上下文</li><li>3.2.4 使用事件上下文进一步减少代码</li><li>3.2.5 简写的事件</li><li>3.2.6 显示和隐藏高级特性</li></ul></li><li>3.3 事件传播<ul><li>3.3.1 事件的旅程</li><li>3.3.2 事件冒泡的副作用</li></ul></li><li>3.4 通过事件对象改变事件的旅程<ul><li>3.4.1 事件目标</li><li>3.4.2 停止事件传播</li><li>3.4.3 阻止默认操作</li><li>3.4.4 事件委托</li><li>3.4.5 使用内置的事件委托功能</li></ul></li><li>3.5 移除事件处理程序<ul><li>3.5.1 为事件处理程序添加命名空间</li><li>3.5.2 重新绑定事件</li></ul></li><li>3.6 模仿用户操作</li><li>3.7 小结</li><li>3.8 练习</li></ul><h2 id="第4章-样式与动画"><a href="#第4章-样式与动画" class="headerlink" title="第4章 样式与动画"></a>第4章 样式与动画</h2><ul><li>4.1 修改内联CSS<ul><li>4.1.1 设置计算的样式属性值</li><li>4.1.2 带厂商前缀的样式属性</li></ul></li><li>4.2 隐藏和显示元素</li><li>4.3 效果和时长<ul><li>4.3.1 指定显示速度</li><li>4.3.2 淡入和淡出</li><li>4.3.3 滑上和滑下</li><li>4.3.4 切换可见性</li></ul></li><li>4.4 创建自定义动画<ul><li>4.4.1 手工创建效果</li><li>4.4.2 一次给多个属性添加动画效果</li></ul></li><li>4.5 并发与排队效果<ul><li>4.5.1 处理一组元素</li><li>4.5.2 处理多组元素</li><li>4.5.3 简单概括</li></ul></li><li>4.6 小结</li><li>4.7 练习</li></ul><h2 id="第5章-操作DOM"><a href="#第5章-操作DOM" class="headerlink" title="第5章 操作DOM"></a>第5章 操作DOM</h2><ul><li>5.1 操作属性<ul><li>5.1.1 非类属性</li><li>5.1.2 DOM元素属性</li><li>5.1.3 表单控件的值</li></ul></li><li>5.2 DOM树操作<ul><li>5.2.1 重新认识$()函数</li><li>5.2.2 创建新元素</li><li>5.2.3 插入新元素</li><li>5.2.4 移动元素</li><li>5.2.5 包装元素</li><li>5.2.6 使用反向插入方法</li></ul></li><li>5.3 复制元素</li><li>5.4 内容setter和getter方法</li><li>5.5DOM操作方法的简单归纳</li><li>5.6 小结</li><li>5.7 练习</li></ul><h2 id="第6章-通过Ajax发送数据"><a href="#第6章-通过Ajax发送数据" class="headerlink" title="第6章 通过Ajax发送数据"></a>第6章 通过Ajax发送数据</h2><ul><li>6.1 基于请求加载数据<ul><li>6.1.1 追加HTML</li><li>6.1.2 操作JavaScript对象</li><li>6.1.3 加载XML文档</li></ul></li><li>6.2 选择数据格式</li><li>6.3 向服务器传递数据<ul><li>6.3.1 执行GET 请求</li><li>6.3.2 执行POST 请求</li><li>6.3.3 序列化表单</li></ul></li><li>6.4 为Ajax请求提供不同的内容</li><li>6.5 关注请求</li><li>6.6 错误处理</li><li>6.7 Ajax和事件</li><li>6.8 安全限制</li><li>6.9 其他工具<ul><li>6.9.1 低级Ajax方法</li><li>6.9.2 修改默认选项</li><li>6.9.3 部分加载HTML页面</li></ul></li><li>6.10 小结</li><li>6.11 练习</li></ul><h2 id="第7章-使用插件"><a href="#第7章-使用插件" class="headerlink" title="第7章 使用插件"></a>第7章 使用插件</h2><ul><li>7.1 查找插件和帮助</li><li>7.2 使用插件<ul><li>7.2.1 下载并包含Cycle插件</li><li>7.2.2 调用插件提供的方法</li><li>7.2.3 为插件方法指定参数</li><li>7.2.4 修改参数默认值</li></ul></li><li>7.3 其他形式的插件<ul><li>7.3.1 自定义选择符</li><li>7.3.2 全局函数插件</li></ul></li><li>7.4 jQuery UI插件库<ul><li>7.4.1 效果</li><li>7.4.2 交互组件</li><li>7.4.3 部件</li><li>7.4.4 jQuery UI主题卷轴</li></ul></li><li>7.5 jQuery Mobile插件库<ul><li>7.5.1 HTML5自定义数据属性</li><li>7.5.2 移动导航</li><li>7.5.3 一个文档支持多个页面</li><li>7.5.4 交互式元素</li><li>7.5.5 高级功能</li></ul></li><li>7.6 小结</li><li>7.7 练习</li></ul><h2 id="第8章-开发插件"><a href="#第8章-开发插件" class="headerlink" title="第8章 开发插件"></a>第8章 开发插件</h2><ul><li>8.1 在插件中使用$别名</li><li>8.2 添加新的全局函数</li><li>8.3 添加jQuery 对象方法<ul><li>8.3.1 对象方法的上下文</li><li>8.3.2 隐式迭代</li><li>8.3.3 方法连缀</li></ul></li><li>8.4 提供灵活的方法参数<ul><li>8.4.1 参数对象</li><li>8.4.2 默认参数值</li><li>8.4.3 回调函数</li><li>8.4.4 可定制的默认值</li></ul></li><li>8.5 使用jQueryUI部件工厂创建插件<ul><li>8.5.1 创建部件</li><li>8.5.2 销毁部件</li><li>8.5.3 启用和禁用部件</li><li>8.5.4 接受部件选项</li><li>8.5.5 添加子方法</li><li>8.5.6 触发部件事件</li></ul></li><li>8.6 插件设计建议</li><li>8.7 小结</li><li>8.8 练习</li></ul><h2 id="第9章-高级选择符与遍历"><a href="#第9章-高级选择符与遍历" class="headerlink" title="第9章 高级选择符与遍历"></a>第9章 高级选择符与遍历</h2><ul><li>9.1 深入选择与遍历<ul><li>9.1.1 动态筛选表格内容</li><li>9.1.2 为表格行添加条纹效果</li><li>9.1.3 组合筛选与条纹</li><li>9.1.4 更多选择符与遍历方法</li></ul></li><li>9.2 定制与优化选择符<ul><li>9.2.1 编写定制的选择符插件</li><li>9.2.2 选择符的性能问题</li></ul></li><li>9.3 DOM遍历背后的秘密<ul><li>9.3.1 jQuery对象属性</li><li>9.3.2 DOM元素栈</li><li>9.3.3 编写DOM遍历方法插件</li><li>9.3.4DOM遍历的性能问题</li></ul></li><li>9.4 小结</li><li>9.5 练习</li></ul><h2 id="第10章-高级事件处理"><a href="#第10章-高级事件处理" class="headerlink" title="第10章 高级事件处理"></a>第10章 高级事件处理</h2><ul><li>10.1 再谈事件<ul><li>10.1.1 追加数据页面</li><li>10.1.2 悬停时显示数据</li></ul></li><li>10.2 事件委托<ul><li>10.2.1 使用jQuery的委托方法</li><li>10.2.2 选择委托的作用域</li><li>10.2.3 早委托</li></ul></li><li>10.3 自定义事件<ul><li>10.3.1 无穷滚动</li><li>10.3.2 自定义事件参数</li></ul></li><li>10.4 节流事件</li><li>10.5 扩展事件</li><li>10.6 小结</li><li>10.7 练习</li></ul><h2 id="第11-章高级效果"><a href="#第11-章高级效果" class="headerlink" title="第11 章高级效果"></a>第11 章高级效果</h2><ul><li>11.1 再谈动画</li><li>11.2 观测及中断动画<ul><li>11.2.1 确定动画状态</li><li>11.2.2 中止运行的动画</li></ul></li><li>11.3 全局效果属性<ul><li>11.3.1 禁用所有效果</li><li>11.3.2 定义效果时长</li></ul></li><li>11.4 多属性缓动</li><li>11.5 使用延迟对象</li><li>11.6 精细地控制动画</li><li>11.7 小结</li><li>11.8 练习</li></ul><h2 id="第12章-高级DOM操作"><a href="#第12章-高级DOM操作" class="headerlink" title="第12章 高级DOM操作"></a>第12章 高级DOM操作</h2><ul><li>12.1 排序表格行<ul><li>12.1.1 服务器端排序</li><li>12.1.2 Ajax排序</li><li>12.1.3 JavaScript排序</li></ul></li><li>12.2 移动和插入元素<ul><li>12.2.1 为已有的文本添加链接</li><li>12.2.2 简单的JavaScript数组排序</li><li>12.2.3 对DOM元素排序</li></ul></li><li>12.3 在DOM元素中保存数据<ul><li>12.3.1 执行预先计算</li><li>12.3.2 存储非字符串数据</li><li>12.3.3 变换排序方向</li></ul></li><li>12.4 使用HTML5自定义数据属性</li><li>12.5 使用JSON排序和构建行<ul><li>12.5.1 修改JSON对象</li><li>12.5.2 按需重新构建内容</li></ul></li><li>12.6 高级属性操作<ul><li>12.6.1 简捷地创建元素</li><li>12.6.2 DOM创建挂钩</li></ul></li><li>12.7 小结</li><li>12.8 练习</li></ul><h2 id="第13章-高级Ajax"><a href="#第13章-高级Ajax" class="headerlink" title="第13章 高级Ajax"></a>第13章 高级Ajax</h2><ul><li>13.1 渐进增强与Ajax</li><li>13.2 处理Ajax错误</li><li>13.3 jqXHR 对象<ul><li>13.3.1 Ajax承诺</li><li>13.3.2 缓存响应</li></ul></li><li>13.4 截流Ajax请求</li><li>13.5 扩展Ajax功能<ul><li>13.5.1 数据类型转换器</li><li>13.5.2 Ajax预过滤器</li><li>13.5.3 替代传输方式</li></ul></li><li>13.6 小结</li><li>13.7 练习</li></ul><h2 id="附录A-JavaScript闭包"><a href="#附录A-JavaScript闭包" class="headerlink" title="附录A JavaScript闭包"></a>附录A JavaScript闭包</h2><ul><li>A.1 创建内部函数</li><li>A.1.1 在任何地方调用内部函数</li><li>A.1.2 理解变量作用域</li><li>A.2 处理闭包之间的交互</li><li>A.3 在jQuery中创建闭包<ul><li>A.3.1 $(document).ready()的参数</li><li>A.3.2 绑定事件处理程序</li><li>A.3.3 在循环中绑定处理程序</li><li>A.3.4 命名及匿名函数</li></ul></li><li>A.4 应对内存泄漏的风险<ul><li>A.4.1 避免意外的引用循环</li><li>A.4.2 控制DOM与JavaScript的循环</li></ul></li><li>A.5 小结</li></ul><h2 id="附录B-使用QUnit测试JavaScript"><a href="#附录B-使用QUnit测试JavaScript" class="headerlink" title="附录B 使用QUnit测试JavaScript"></a>附录B 使用QUnit测试JavaScript</h2><ul><li>B.1 下载QUnit</li><li>B.2 设置文档</li><li>B.3 组织测试</li><li>B.4 添加和运行测试</li><li>B.5 其他测试类型</li><li>B.6 最佳实践</li><li>B.7 小结</li></ul><h2 id="附录C-简明参考"><a href="#附录C-简明参考" class="headerlink" title="附录C 简明参考"></a>附录C 简明参考</h2><ul><li>C.1 选择符表达式<ul><li>C.1.1 简单的CSS选择符</li><li>C.1.2 在同辈元素间定位</li><li>C.1.3 在匹配的元素间定位</li><li>C.1.4 属性</li><li>C.1.5 表单</li><li>C.1.6 其他自定义选择符</li></ul></li><li>C.2 DOM遍历方法<ul><li>C.2.1 筛选元素</li><li>C.2.2 后代元素</li><li>C.2.3 同辈元素</li><li>C.2.4 祖先元素</li><li>C.2.5 集合操作</li><li>C.2.6 操作选中的元素</li></ul></li><li>C.3 事件方法<ul><li>C.3.1 绑定</li><li>C.3.2 简写绑定</li><li>C.3.3 触发事件</li><li>C.3.4 简写触发方法</li><li>C.3.5 实用方法</li></ul></li><li>C.4 效果方法<ul><li>C.4.1 预定义效果</li><li>C.4.2 自定义动画</li><li>C.4.3 队列操作</li></ul></li><li>C.5 DOM操作方法<ul><li>C.5.1 特性与属性</li><li>C.5.2 内容</li><li>C.5.3 CSS</li><li>C.5.4 尺寸</li><li>C.5.5 插入</li><li>C.5.6 替换</li><li>C.5.7 删除</li><li>C.5.8 复制</li><li>C.5.9 数据</li></ul></li><li>C.6 Ajax方法<ul><li>C.6.1 发送请求</li><li>C.6.2 监视请求</li><li>C.6.3 配置</li><li>C.6.4 实用方法</li></ul></li><li>C.7 延迟方法<ul><li>C.7.1 创建对象</li><li>C.7.2 延迟对象的方法</li><li>C.7.3 承诺对象的方法</li></ul></li><li>C.8 其他方法<ul><li>C.8.1 jQuery对象的属性</li><li>C.8.2 数组和对象</li><li>C.8.3 对象内省</li><li>C.8.4 其他</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> jQuery基础教程 第4版 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>jQuery基础教程 第4版 内容提要</title>
      <link href="/ReadingNotes//c27a32d7/"/>
      <url>/ReadingNotes//c27a32d7/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/c27a32d7/#内容提要" class="header_1">内容提要</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><p><iframe height="36" width="260" src="https://www.ximalaya.com/thirdparty/player/sound/player.html?id=193882547&type=red" frameborder=0 allowfullscreen></iframe></p><h1 id="内容提要"><a href="#内容提要" class="headerlink" title="内容提要"></a>内容提要</h1><ul><li>本书是<code>jQuery</code>经典技术教程的最新升级版,涵盖<code>jQuery 1.10.x</code>和<code>jQuery 2.0.x</code>。</li><li>本书前6章以通俗易懂的方式讲解了<code>jQuery</code>的核心组件,包括<code>jQuery</code>的选择符、事件、动画、<code>DOM</code>操作、<code>Ajax</code>支持等。</li><li>第7章和第8章介绍了<code>jQuery UI</code>、<code>jQuery Mobile</code>及利用<code>jQuery</code>强大的扩展能力开发自定义插件。</li><li>随后的几章更加深入地探讨了<code>jQuery</code>的各种特性及一些高级技术。</li><li>附录A特别讲解了<code>JavaScript</code>中闭包的概念,以及如何在<code>jQuery</code>中有效地使用闭包。</li><li>附录B讲解了使用<code>QUnit</code>测试<code>JavaScript</code>代码的必备知识。</li><li>附录C给出了<code>jQuery API</code>的快速参考。</li></ul>]]></content>
      
      
      <categories>
          
          <category> jQuery基础教程 第4版 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第1章 MySQL架构与历史</title>
      <link href="/ReadingNotes//3701e29b/"/>
      <url>/ReadingNotes//3701e29b/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/3701e29b/#第1章" class="header_2">第1章</a>&nbsp;<br><a href="/ReadingNotes/3701e29b/#1-1-MySQL逻辑架构" class="header_2">1.1 MySQL逻辑架构</a>&nbsp;<br><a href="/ReadingNotes/3701e29b/#1-1-1连接管理与安全性" class="header_3">1.1.1连接管理与安全性</a>&nbsp;<br><a href="/ReadingNotes/3701e29b/#1-1-2优化与执行" class="header_3">1.1.2优化与执行</a>&nbsp;<br><a href="/ReadingNotes/3701e29b/#1-2-1读写锁" class="header_3">1.2.1读写锁</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h2 id="第1章"><a href="#第1章" class="headerlink" title="第1章"></a>第1章</h2><p><code>MySQL</code>架构与历史和其他数据库系统相比，<code>MySQL</code>有点与众不同，它的架构可以在多种不同场景中应用并发挥好的作用，但同时也会带来一点选择上的困难。<code>MySQL</code>并不完美，却足够灵活，能够适应高要求的环境，例如<code>Web</code>类应用。同时，<code>MySQL</code>既可以嵌入到应用程序中，也可以支持数据仓库、内容索引和部署软件、高可用的冗余系统、在线事务处理系统（<code>OLTP</code>）等各种应用类型。为了充分发挥<code>MySQL</code>的性能并顺利地使用，就必须理解其设计。<code>MySQL</code>的灵活性体现在很多方面。例如，你可以通过配置使它在不同的硬件上都运行得很好，也可以支持多种不同的数据类型。 但是， <strong>MySQL 最重要、 最与众不同的特性是它的存储引擎架构</strong>， 这种架构的设计将查询处理（ <code>Query Processing</code>） 及其他系统任务（ <code>Server Task</code>） 和数据的存储/ 提取相分离。 这种处理和存储分离的设计可以在使用时根据性能、 特性， 以及其他需求来选择数据存储的方式。<br>本章概要地描述了 <strong><code>MySQL</code> 的服务器架构</strong>、 <strong>各种存储引擎之间的主要区别</strong>， 以及这些区别的重要性。 另外也会回顾一下 <code>MySQL</code> 的历史背景和基准测试， 并试图通过简化细节和演示案例来讨论<code>MySQL</code>的原理。 这些讨论无论是对数据库一无所知的新手， 还是熟知其他数据库的专家， 都不无裨益。</p><h2 id="1-1-MySQL逻辑架构"><a href="#1-1-MySQL逻辑架构" class="headerlink" title="1.1 MySQL逻辑架构"></a>1.1 MySQL逻辑架构</h2><p>如果能在头脑中构建出一幅MySQL各组件之间如何协同工作的架构图，就会有助于深入理解MySQL服务器。图1-1展示了MySQL的逻辑架构图。</p><p>最上层的服务并不是MySQL所独有的，大多数基于网络的客户端/服务器的工具或者服务都有类似的架构。比如连接处理、授权认证、安全等等。<br>第二层架构是MySQL比较有意思的部分。<strong>大多数MySQL的核心服务功能都在这一层</strong>，包括查询解析、分析、优化、缓存以及所有的内置函数（例如，日期、时间、数学和加密函数），所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。</p><p>第三层包含了存储引擎。<strong>存储引擎负责MySQL中数据的存储和提取</strong>。和GNU/Linux下的各种文件系统一样，每个存储引擎都有它的优势和劣势。服务器通过API与存储引擎进行通信。这些接口屏蔽了不同存储引擎之间的差异，使得这些差异对上层的查询过程透明。存储引擎API包含几十个底层函数，用于执行诸如“开始一个事务”或者“根据主键提取一行记录”等操作。但存储引擎不会去解析SQL(1)，<strong>不同存储引擎之间也不会相互通信，而只是简单地响应上层服务器的请求</strong>。</p><h3 id="1-1-1连接管理与安全性"><a href="#1-1-1连接管理与安全性" class="headerlink" title="1.1.1连接管理与安全性"></a>1.1.1连接管理与安全性</h3><p>每个客户端连接都会在服务器进程中拥有一个线程，这个连接的查询只会在这个单独的线程中执行，该线程只能轮流在某个CPU核心或者CPU中运行。服务器会负责缓存线程，因此<strong>不需要为每一个新建的连接创建或者销毁线程</strong>(2)。</p><p>当客户端（应用）连接到<code>MySQL</code>服务器时，服务器需要对其进行认证。认证基于用户名、原始主机信息和密码。如果使用了安全套接字（<code>SSL</code>）的方式连接，还可以使用X<code>.509</code>证书认证。一旦客户端连接成功，服务器会继续验证该客户端是否具有执行某个特定查询的权限（例如，是否允许客户端对<code>world</code>数据库的<code>Country</code>表执行<code>SELECT</code>语句）。</p><h3 id="1-1-2优化与执行"><a href="#1-1-2优化与执行" class="headerlink" title="1.1.2优化与执行"></a>1.1.2优化与执行</h3><p><code>MySQL</code>会解析查询，并创建内部数据结构（解析树），然后对其进行各种优化，包括重写查询、决定表的读取顺序，以及选择合适的索引等。用户可以通过特殊的关键字提示（<code>hint</code>）优化器，影响它的决策过程。也可以请求优化器解释（<code>explain</code>）优化过程的各个因素，使用户可以知道服务器是如何进行优化决策的，并提供一个参考基准，便于用户重构查询和<code>schema</code>、修改相关配置，使应用尽可能高效运行。第6章我们将讨论更多优化器的细节。<br>优化器并不关心表使用的是什么存储引擎，但存储引擎对于优化查询是有影响的。优化器会请求存储引擎提供容量或某个具体操作的开销信息，以及表数据的统计信息等。例如，某些存储引擎的某种索引，可能对一些特定的查询有优化。关于索引与<code>schema</code>的优化，请参见第4章和第5章。<br>对于SELECT语句，在解析查询之前，服务器会先检查查询缓存（<code>Query Cache</code>），如果能够在其中找到对应的查询，服务器就不必再执行查询解析、优化和执行的整个过程，而是直接返回查询缓存中的结果集。第7章详细讨论了相关内容。<br>以Unix系统的<code>email box</code>为例，典型的<code>mbox</code>文件格式是非常简单的。一个<code>mbox</code>邮箱中的所有邮件都串行在一起，彼此首尾相连。这种格式对于读取和分析邮件信息非常友好，同时投递邮件也很容易，只要在文件末尾附加新的邮件内容即可。<br>但如果两个进程在同一时刻对同一个邮箱投递邮件，会发生什么情况？显然，邮箱的数据会被破坏，两封邮件的内容会交叉地附加在邮箱文件的末尾。设计良好的邮箱投递系统会通过锁（<code>lock</code>）来防止数据损坏。如果客户试图投递邮件，而邮箱已经被其他客户锁住，那就必须等待，直到锁释放才能进行投递。<br>这种锁的方案在实际应用环境中虽然工作良好，但并不支持并发处理。因为在任意一个时刻，只有一个进程可以修改邮箱的数据，这在大容量的邮箱系统中是个问题。</p><h3 id="1-2-1读写锁"><a href="#1-2-1读写锁" class="headerlink" title="1.2.1读写锁"></a>1.2.1读写锁</h3><p>从邮箱中读取数据没有这样的麻烦，即使同一时刻多个用户并发读取也不会有什么问题。因为读取不会修改数据，所以不会出错。但如果某个客户正在读取邮箱，同时另外一个用户试图删除编号为25的邮件，会产生什么结果？结论是不确定，读的客户可能会报错退出，也可能读取到不一致的邮箱数据。所以，为安全起见，即使是读取邮箱也需要特别注意。<br>如果把上述的邮箱当成数据库中的一张表，把邮件当成表中的一行记录，就很容易看出，同样的问题依然存在。从很多方面来说，邮箱就是一张简单的数据库表。修改数据库表中的记录，和删除或者修改邮箱中的邮件信息，十分类似。<br>解决这类经典问题的方法就是并发控制，其实非常简单。<strong>在处理并发读或者写时，可以通过实现一个由两种类型的锁组成的锁系统来解决问题</strong>。这两种类型的锁通常被称为共享锁（<code>shared lock</code>）和排他锁（<code>exclusive lock</code>），也叫读锁（<code>read lock</code>）和写锁（<code>write lock</code>）。<br>这里先不讨论锁的具体实现，描述一下锁的概念如下：读锁是共享的，或者说是相互不阻塞的。多个客户在同一时刻可以同时读取同一个资源，而互不干扰。写锁则是排他的，也就是说一个写锁会阻塞其他的写锁和读锁，这是出于安全策略的考虑，只有这样，才能确保在给定的时间里，只有一个用户能执行写入，并防止其他用户读取正在写入的同一资源。在实际的数据库系统中，每时每刻都在发生锁定，当某个用户在修改某一部分数据时，MySQL会通过锁定防止其他用户读取同一数据。大多数时候，MySQL锁的内部管理都是透明的。</p>]]></content>
      
      
      <categories>
          
          <category> 高性能MySQL </category>
          
          <category> 第1章 MySQL架构与历史 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2.9 模型视图控制器(mvc)</title>
      <link href="/ReadingNotes//4a06c578/"/>
      <url>/ReadingNotes//4a06c578/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/4a06c578/#2-9-模型视图控制器-mvc" class="header_2">2.9 模型视图控制器(mvc)</a>&nbsp;<br><a href="/ReadingNotes/4a06c578/#控制器" class="header_3">控制器</a>&nbsp;<br><a href="/ReadingNotes/4a06c578/#模型" class="header_3">模型</a>&nbsp;<br><a href="/ReadingNotes/4a06c578/#视图" class="header_3">视图</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h2 id="2-9-模型视图控制器-mvc"><a href="#2-9-模型视图控制器-mvc" class="headerlink" title="2.9 模型视图控制器(mvc)"></a>2.9 模型视图控制器(mvc)</h2><p><strong>模型-视图-控制器(MVC)就是把业务逻辑从servlet中抽出来,把它放在一个“模型”中,所谓模型就是一个可重用的普通Java类。模型是业务数据(如:购物车的状态)和处理该数据的方法(规则)的组合。</strong></p><h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><p>控制器从请求获得用户输入,并明确这些输入对模型有什么影响。<br>告诉模型自行更新,且让视图(JSP)能得到新的模型状态。</p><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>模型包含具体的业务逻辑和状态。换句话说模型知道用什么规则来得到和更新状态。</p><p>购物车的内容(和处理购物车内容的规则)就属于MVC中的模型。<br>系统中只有这部分与数据库通信(不过它可能会使用另一个对象完成具体的数据库通信,但这种模式以后再讲)。</p><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>视图表示方面。它从控制器得到模型的状态(不过不是直接得到;控制器会把模型数据放在视图能找到的一个地方)。另外视图还要获得用户输入,并交给控制器。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/HeadFirstServletsAndJSP/Di2Zhang/mvc.png" alt="这里有一张图片"></p>]]></content>
      
      
      <categories>
          
          <category> Head frist Servlet and JSP </category>
          
          <category> 第2章 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2.8 部署描述文件的作用</title>
      <link href="/ReadingNotes//25674e82/"/>
      <url>/ReadingNotes//25674e82/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/25674e82/#2-8-部署描述文件的作用和优点" class="header_2">2.8 部署描述文件的作用和优点</a>&nbsp;<br><a href="/ReadingNotes/25674e82/#部署描述文件的优点" class="header_3">部署描述文件的优点</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h2 id="2-8-部署描述文件的作用和优点"><a href="#2-8-部署描述文件的作用和优点" class="headerlink" title="2.8 部署描述文件的作用和优点"></a>2.8 部署描述文件的作用和优点</h2><p><strong>利用部署描述文件,你能采用一种声明方式修改应用,而无需修改源代码</strong>!这意味着,就算你不是Java程序员,也可以定制 Java Web应用,而且不用中断你快乐的热带旅行,你不必中途赶回来修改代码。</p><p><strong>部署描述文件(DD)提供了一种“声明”机制来定制Web应用而无需修改源代码!</strong></p><h3 id="部署描述文件的优点"><a href="#部署描述文件的优点" class="headerlink" title="部署描述文件的优点"></a>部署描述文件的优点</h3><ul><li>可以尽量少改动已经测试过的源代码。</li><li>即使你手上并没有源代码,也可以对应用的功能进行调整。</li><li>不用重新编译和测试任何代码,也可以让你的应用适应不同的资源(如数据库)。</li><li>可以更容易地维护动态安全信息,如访问控制列表和安全角色。</li><li>非程序员也可以修改和部署你的Web应用,而你可以留出精力,做更有意思的事情。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Head frist Servlet and JSP </category>
          
          <category> 第2章 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2.5 一个servlet可以有3个名字</title>
      <link href="/ReadingNotes//30260129/"/>
      <url>/ReadingNotes//30260129/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/30260129/#2-5-一个servlet可以有3个名字" class="header_2">2.5 一个servlet可以有3个名字</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h2 id="2-5-一个servlet可以有3个名字"><a href="#2-5-一个servlet可以有3个名字" class="headerlink" title="2.5 一个servlet可以有3个名字"></a>2.5 一个servlet可以有3个名字</h2><ul><li><ol><li>客户可看到的名字,<code>客户</code>可以看到一个 servlet在HTML中对应的URL,但是客户是不知道这个servlet是如何映射到服务器上的目录和文件的。公共URL名只是一个虚构的名字,是完全为客户提供的。</li></ol></li><li><ol><li>部署人员使用的名字,<code>部署人员</code>可以创造一个内部名,这个内部名只有他自己以及实际操作环境中的其他人知道。同样地,这也是一个虚构的名字,只用于部署 servlet。这个内部名不必与客户使用的公共URL名一致,也不必与 servlet类的实际文件和路径名一样。</li></ol></li><li><ol><li>开发人员使用的名字,<code>开发人员</code>的 servlet类有一个<strong>完全限定名</strong>,其中包括类名和包名。servlet类文件有一个实际的路径和文件名,这取决于服务器上包目录结构所在的位置。</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Head frist Servlet and JSP </category>
          
          <category> 第2章 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2.6 servlet名的映射的必要性</title>
      <link href="/ReadingNotes//9606279e/"/>
      <url>/ReadingNotes//9606279e/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/9606279e/#2-6-servlet名的映射的必要性" class="header_2">2.6 servlet名的映射的必要性</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h2 id="2-6-servlet名的映射的必要性"><a href="#2-6-servlet名的映射的必要性" class="headerlink" title="2.6 servlet名的映射的必要性"></a>2.6 servlet名的映射的必要性</h2><p><strong>建立 servlet名的映射,这有助于改善应用的灵活性和安全性</strong><br>如果你把真实的路径和文件名通过硬编码写到了所有使用这个 servlet的JSP和其他HTML页面中,这样做是没有问题的。但是假设你现在想要重新组织你的应用,可能要把某些东西移到不同的目录结构下,此时,事情就变得很麻烦。</p><ul><li>因为这样你要让每一个使用这个servlet的人都知道你移动了目录结构,并确保他们都能正确的使用这个新的目录结构。</li><li><strong>通过映射servlet名</strong>,而不是把真实的文件和路径名写入代码,这样就能提供很大的灵活性,<strong>使你能轻松地移动文件,而不用担心遭遇维护噩梦</strong>,否则,就需要跟踪客户代码中哪里引用了servlet文件原先的位置,并相应地进行修改,这种手动修改的工作量是非常巨大的。</li><li><strong>安全性方面</strong>,如果客户对你的服务器上的目录结构了如指掌,他们就可能绕过你的应用搞事情?因为最终用户可以看到真实的路径,他们就可以在浏览器中键入这个路径直接访问。比如他们可以直接访问servlet,而不经过适当的页面或表单验证。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Head frist Servlet and JSP </category>
          
          <category> 第2章 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2.7 使用部署描述文件将URL映射到servlet</title>
      <link href="/ReadingNotes//8efd2104/"/>
      <url>/ReadingNotes//8efd2104/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/8efd2104/#2-7-使用部署描述文件将URL映射到servlet" class="header_2">2.7 使用部署描述文件将URL映射到servlet</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h2 id="2-7-使用部署描述文件将URL映射到servlet"><a href="#2-7-使用部署描述文件将URL映射到servlet" class="headerlink" title="2.7 使用部署描述文件将URL映射到servlet"></a>2.7 使用部署描述文件将URL映射到servlet</h2><p>将 servlet部署到web容器时,会创建一个相当简单的XML文档,这称为<strong>部署描述文件</strong>(DD)。<strong>部署描述文件会告诉容器如何运行你的 servlet和JSP</strong>。尽管使用部署描述文件不只是为了映射servlet名,但最起码要知道,可以使用下面介绍的两个XML元素把URL映射到 servlet,其中一个XML元素将客户知道的公共URL名映射到你自己的内部名,另一个XML元素把你自己的内部名映射到一个完全限定类名。用于URL映射的两个部署描述文件元素如下:</p><ol><li><strong><code>&lt;servlet&gt;</code> 元素 可以将内部名映射到完全限定类名</strong></li><li><strong><code>&lt;servlet-mapping&gt;</code> 元素 可以将内部名映射到公共URL名</strong></li></ol><p>先来介绍servlet元素<br><code>&lt;servlet&gt;</code>元素告诉容器哪些类文件属于一个特定Web应用。</p><p><code>&lt;servlet&gt;</code>元素的<code>&lt;servlet-class&gt;</code>子元素中设置的是类的完全限定名,注意,这个限定名并不带<code>.class</code>后缀。<br><code>&lt;servlet&gt;</code>元素的<code>&lt;servlet-name&gt;</code>子元素用于把一个<code>&lt;servlet&gt;</code>元素绑定到一个特定的<code>&lt;servlet-mapping&gt;</code>元素。最终用户绝对看不到<code>&lt;servlet-name&gt;</code>子元素中设置的这个名字,这个名字只在这个部署描述文件的其他部分中使用,称之为内部名,<strong>这个内部名现在对应的是类的完全限定名</strong>.</p><p>现在来介绍<code>&lt;servlet-mapping&gt;</code>元素.<br><code>&lt;servlet-mapping&gt;</code>元素的<code>&lt;url-pattern&gt;</code>子元素中设置的是URL。<br><code>&lt;servlet-mapping&gt;</code>元素的<code>&lt;servlet-name&gt;</code>子元素与<code>&lt;servlet&gt;</code>元素中的<code>&lt;servlet-name&gt;</code>子元素一样,设置的都是一个内部名。只不过<strong>现在这个内部名对应的是<code>&lt;url-pattern&gt;</code>子元素中的URL.</strong></p><p>所以你可以看到<strong>通过内部名这个桥梁,我们就可以将客户可见的URL,映射到类的完全限定名.</strong></p>]]></content>
      
      
      <categories>
          
          <category> Head frist Servlet and JSP </category>
          
          <category> 第2章 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2.4 servlet何以成为一个servelet</title>
      <link href="/ReadingNotes//dbab97fa/"/>
      <url>/ReadingNotes//dbab97fa/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/dbab97fa/#2-4-servlet何以成为一个servelet" class="header_2">2-4 servlet何以成为一个servelet</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h2 id="2-4-servlet何以成为一个servelet"><a href="#2-4-servlet何以成为一个servelet" class="headerlink" title="2-4 servlet何以成为一个servelet"></a>2-4 servlet何以成为一个servelet</h2><p><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/HeadFirstServletsAndJSP/Di2Zhang/1.png" alt="这里有一张图片"></p><ul><li>99.9999%的servlet都是HttpServlet的子类。</li><li>在实际中,99.9%的servlet都会覆盖doGet()或doPost()方法。</li><li>注意，servlet没有main()方法。servlet的生命周期方法，如doGet()方法由容器调用。</li><li>servlet从doGet()方法的参数列表中拿到容器创建的请求和响应对象的引用。</li><li>在 servlet从容器得到的响应对象中,可以拿到一个 PrintWriter类的对象,使用这个PrintWriter类的对象能够将HTML文本输出到响应对象中,除了PrintWriter以外,还可以输出其他内容,比如输出图片而不是HTML文本.</li></ul>]]></content>
      
      
      <categories>
          
          <category> Head frist Servlet and JSP </category>
          
          <category> 第2章 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2.3 容器如何处理请求</title>
      <link href="/ReadingNotes//91b20960/"/>
      <url>/ReadingNotes//91b20960/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/91b20960/#容器如何处理请求" class="header_2">容器如何处理请求</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h2 id="容器如何处理请求"><a href="#容器如何处理请求" class="headerlink" title="容器如何处理请求"></a>容器如何处理请求</h2><ul><li>当用户点击一个链接,这个链接的URL指向一个 servlet而不是静态页面时。</li><li>容器可以看出来这个请求要的是一个servlet,所以容器仓建两个对象:<ul><li>一个是HttpServletResponse</li><li>另一个是HttpServletRequest</li></ul></li><li>然后容器根据请求中的URL找到正确的 servlet,为这个请求创建或分配一个线程,并把请求和响应对象传递给这个servlet线程。</li><li>接着容器调用 servlet的 service()方法。根据请求的不同类型, service()方法会调用doGet()或 doPost()方法。对于这个示例,假设请求是一个 HTTP GET请求,则调用的是doGet()方法。</li><li>然后doGet()方法生成动态页面并把这个页面“填入”响应对象。要记住,容器还有响应对象的一个引用!</li><li>最后线程结束,容器把响应对象转换为一个HTTP响应,把它发回给客户,然后删除请求和响应对象。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Head frist Servlet and JSP </category>
          
          <category> 第2章 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2.1 什么是容器</title>
      <link href="/ReadingNotes//81d8e841/"/>
      <url>/ReadingNotes//81d8e841/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/81d8e841/#什么是容器" class="header_2">什么是容器</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h2 id="什么是容器"><a href="#什么是容器" class="headerlink" title="什么是容器"></a>什么是容器</h2><p><strong>Servlet没有main()方法。它们受控于另一个Java应用,这个Java应用称为容器。</strong><br>Tomcat就是这样一个容器。如果web服务器应用(如 Apache)得到一个指向某 servlet的请求,此时<strong>服务器不是把这个请求交给 servlet本身,而是交给部署该 servlet的容器</strong>。要由容器向servlet提供HTTP请求和响应,而且要由容器调用servlet的方法,如 doPost()或 doGet()方法等。</p>]]></content>
      
      
      <categories>
          
          <category> Head frist Servlet and JSP </category>
          
          <category> 第2章 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2.2 容器能提供什么</title>
      <link href="/ReadingNotes//e07c2ce7/"/>
      <url>/ReadingNotes//e07c2ce7/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/e07c2ce7/#容器能提供什么" class="header_2">容器能提供什么</a>&nbsp;<br><a href="/ReadingNotes/e07c2ce7/#1-通信支持" class="header_3">1 通信支持</a>&nbsp;<br><a href="/ReadingNotes/e07c2ce7/#2-生命周期管理" class="header_3">2 生命周期管理</a>&nbsp;<br><a href="/ReadingNotes/e07c2ce7/#3-多线程支持" class="header_3">3 多线程支持</a>&nbsp;<br><a href="/ReadingNotes/e07c2ce7/#4-声明方式实现安全" class="header_4">4 声明方式实现安全</a>&nbsp;<br><a href="/ReadingNotes/e07c2ce7/#5-JSP支持" class="header_4">5 JSP支持</a>&nbsp;<br><a href="/ReadingNotes/e07c2ce7/#总结" class="header_3">总结</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h2 id="容器能提供什么"><a href="#容器能提供什么" class="headerlink" title="容器能提供什么"></a>容器能提供什么</h2><h3 id="1-通信支持"><a href="#1-通信支持" class="headerlink" title="1 通信支持"></a>1 通信支持</h3><p>利用容器提供的方法,你能轻松地让 servlet与Web服务器对话。无需自己建立ServerSocket、无需自己监听端口,无需自己创建流等。你要考虑的只是如何在 servlet中实现业务逻辑,例如接受在线商店的一个订单。</p><h3 id="2-生命周期管理"><a href="#2-生命周期管理" class="headerlink" title="2 生命周期管理"></a>2 生命周期管理</h3><p>容器控制着servlet生死。它会负责加载类、实例化和初始化 servlet、调用 servlet方法,并使servlet实例能够被垃圾回收。有了容器的控制,你就不用太多地考虑资源管理了。</p><h3 id="3-多线程支持"><a href="#3-多线程支持" class="headerlink" title="3 多线程支持"></a>3 多线程支持</h3><p>容器会自动地为接收到的每个servlet请求创建一个新的Java线程。针对客户的请求,如果 servlet已经运行完相应的HTTP服务方法,这个线程就会结束,也就是会死掉。由服务器创建和管理多个线程来处理多个请求,这样能让你少做很多工作。</p><h4 id="4-声明方式实现安全"><a href="#4-声明方式实现安全" class="headerlink" title="4 声明方式实现安全"></a>4 声明方式实现安全</h4><p>利用容器,可以使用XML部署描述文件来配置(和修改)安全性,而不必将其硬编码写到servlet类代码或其他类代码中。这样你不用去改你的Java源文件,也不用重新编译,你就能管理和修改安全性配置</p><h4 id="5-JSP支持"><a href="#5-JSP支持" class="headerlink" title="5 JSP支持"></a>5 JSP支持</h4><p>容器负责把JSP代码翻译成真正的Java.</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>多亏有了容器,你可以更专注于自己的业务逻辑,而不用考虑为线程管理、安全性和网络通信编写代码.<br>你能把精力都用来建立一个超级在线商店,而把底层的服务,比如安全和JSP处理等交给容器负责。</p>]]></content>
      
      
      <categories>
          
          <category> Head frist Servlet and JSP </category>
          
          <category> 第2章 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java网络编程 URLEncoder只编码URL中的中文,空格编码为百分之20</title>
      <link href="/ReadingNotes//7865fbca/"/>
      <url>/ReadingNotes//7865fbca/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/7865fbca/#需求" class="header_2">需求</a>&nbsp;<br><a href="/ReadingNotes/7865fbca/#只编码URL里的中文" class="header_2">只编码URL里的中文</a>&nbsp;<br><a href="/ReadingNotes/7865fbca/#同时编码中文和空格" class="header_2">同时编码中文和空格</a>&nbsp;<br><a href="/ReadingNotes/7865fbca/#方案1：先把空格编码成加号，然后用%20替换" class="header_3">方案1：先把空格编码成加号，然后用%20替换</a>&nbsp;<br><a href="/ReadingNotes/7865fbca/#方案2：只编码中文-直接用%20替换空格" class="header_3">方案2：只编码中文,直接用%20替换空格</a>&nbsp;<br><a href="/ReadingNotes/7865fbca/#完整代码" class="header_2">完整代码</a>&nbsp;<br><a href="/ReadingNotes/7865fbca/#参考链接" class="header_2">参考链接</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>把下面的带中文的URL：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.lansheng.net.cn&#x2F;2018&#x2F;10&#x2F;30&#x2F;Java&#x2F;Java IO流&#x2F;Java IO流 使用RandomAccessFile快速读写文本文件最后一行&#x2F;</span><br></pre></td></tr></table></figure><br>编码成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.lansheng.net.cn&#x2F;2018&#x2F;10&#x2F;30&#x2F;Java&#x2F;Java%20IO%E6%B5%81&#x2F;Java%20IO%E6%B5%81%20%E4%BD%BF%E7%94%A8RandomAccessFile%E5%BF%AB%E9%80%9F%E8%AF%BB%E5%86%99%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E6%9C%80%E5%90%8E%E4%B8%80%E8%A1%8C&#x2F;</span><br></pre></td></tr></table></figure></p><h2 id="只编码URL里的中文"><a href="#只编码URL里的中文" class="headerlink" title="只编码URL里的中文"></a>只编码URL里的中文</h2><p>java中，默认的URLEcoder.encode()方法对URL进行编码的时候，会把特殊字符<code>:</code>,<code>.</code>,<code>空格</code>等都进行编码,这与我从浏览器中复制粘贴出来的显然不一样。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"https://www.lansheng.net.cn/2018/10/30/Java/Java IO流/Java IO流 使用RandomAccessFile快速读写文本文件最后一行/"</span>;</span><br><span class="line">System.out.println(URLEncoder.encode(str,<span class="string">"utf-8"</span>));</span><br></pre></td></tr></table></figure><br>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https%3A%2F%2Fwww.lansheng.net.cn%2F2018%2F10%2F30%2FJava%2FJava+IO%E6%B5%81%2FJava+IO%E6%B5%81+%E4%BD%BF%E7%94%A8RandomAccessFile%E5%BF%AB%E9%80%9F%E8%AF%BB%E5%86%99%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E6%9C%80%E5%90%8E%E4%B8%80%E8%A1%8C%2F</span><br></pre></td></tr></table></figure><br>可以看到默认的URLEncoder.encode(str,”utf-8”)方法，把<code>:</code>编码成<code>%3A</code>,<code>/</code>编码成<code>%2F</code>并不需要编码那么多，只需要编码中文即可,这里来使用正则表达式对中文进行编码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encode</span><span class="params">(String str, String charset)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> UnsupportedEncodingException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//匹配中文和空格的正则表达式</span></span><br><span class="line">    String zhPattern = <span class="string">"[\u4e00-\u9fa5]+"</span>;</span><br><span class="line">    Pattern p = Pattern.compile(zhPattern);</span><br><span class="line">    Matcher m = p.matcher(str);</span><br><span class="line">    StringBuffer b = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">while</span> (m.find())</span><br><span class="line">    &#123;</span><br><span class="line">        m.appendReplacement(b, URLEncoder.encode(m.group(<span class="number">0</span>), charset));</span><br><span class="line">    &#125;</span><br><span class="line">    m.appendTail(b);</span><br><span class="line">    <span class="keyword">return</span> b.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.lansheng.net.cn&#x2F;2018&#x2F;10&#x2F;30&#x2F;Java&#x2F;Java IO%E6%B5%81&#x2F;Java IO%E6%B5%81 %E4%BD%BF%E7%94%A8RandomAccessFile%E5%BF%AB%E9%80%9F%E8%AF%BB%E5%86%99%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E6%9C%80%E5%90%8E%E4%B8%80%E8%A1%8C&#x2F;</span><br></pre></td></tr></table></figure><br>这里可以看到，空格没有被编码。</p><h2 id="同时编码中文和空格"><a href="#同时编码中文和空格" class="headerlink" title="同时编码中文和空格"></a>同时编码中文和空格</h2><p>这里有两个方案，方案1：在正则表达式中匹配空格，也就是把正则表达式改成<code>[\u4e00-\u9fa5 ]</code>这样空格就会被编码了。</p><h3 id="方案1：先把空格编码成加号，然后用-20替换"><a href="#方案1：先把空格编码成加号，然后用-20替换" class="headerlink" title="方案1：先把空格编码成加号，然后用%20替换"></a>方案1：先把空格编码成加号，然后用%20替换</h3><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.lansheng.net.cn&#x2F;2018&#x2F;10&#x2F;30&#x2F;Java&#x2F;Java+IO%E6%B5%81&#x2F;Java+IO%E6%B5%81+%E4%BD%BF%E7%94%A8RandomAccessFile%E5%BF%AB%E9%80%9F%E8%AF%BB%E5%86%99%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E6%9C%80%E5%90%8E%E4%B8%80%E8%A1%8C&#x2F;</span><br></pre></td></tr></table></figure><br>可以看到这里空格被编码为加号<code>+</code>,但是，不幸的是，我复制到浏览器中，还是打不开我的这篇文章。：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/Java/javaw%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/api/Ecoder/404.png" alt=""><br>解决方案，使用正则表达式把加号+，替换为<code>%20</code>即可：<br>只对中文和空格进行编码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 只对中文和空格进行编码。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment"> *            被替换的字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> charset</span></span><br><span class="line"><span class="comment"> *            字符集</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 替换好的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> UnsupportedEncodingException</span></span><br><span class="line"><span class="comment"> *             不支持的字符集</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encodeSpaceChinese</span><span class="params">(String str, String charset)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> UnsupportedEncodingException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//匹配中文和空格的正则表达式</span></span><br><span class="line">    String zhPattern = <span class="string">"[\u4e00-\u9fa5 ]+"</span>;</span><br><span class="line">    Pattern p = Pattern.compile(zhPattern);</span><br><span class="line">    Matcher m = p.matcher(str);</span><br><span class="line">    StringBuffer b = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">while</span> (m.find())</span><br><span class="line">    &#123;</span><br><span class="line">        m.appendReplacement(b, URLEncoder.encode(m.group(<span class="number">0</span>), charset));</span><br><span class="line">    &#125;</span><br><span class="line">    m.appendTail(b);</span><br><span class="line">    <span class="keyword">return</span> b.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>main方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"https://www.lansheng.net.cn/2018/10/30/Java/Java IO流/Java IO流 使用RandomAccessFile快速读写文本文件最后一行/"</span>;</span><br><span class="line">String url=encodeSpaceChinese(str, <span class="string">"UTF-8"</span>);</span><br><span class="line">System.out.println(url);</span><br><span class="line">url=url.replaceAll(<span class="string">"\\+"</span>, <span class="string">"%20"</span>);</span><br><span class="line">System.out.println(url);</span><br></pre></td></tr></table></figure><br>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.lansheng.net.cn&#x2F;2018&#x2F;10&#x2F;30&#x2F;Java&#x2F;Java+IO%E6%B5%81&#x2F;Java+IO%E6%B5%81+%E4%BD%BF%E7%94%A8RandomAccessFile%E5%BF%AB%E9%80%9F%E8%AF%BB%E5%86%99%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E6%9C%80%E5%90%8E%E4%B8%80%E8%A1%8C&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;www.lansheng.net.cn&#x2F;2018&#x2F;10&#x2F;30&#x2F;Java&#x2F;Java%20IO%E6%B5%81&#x2F;Java%20IO%E6%B5%81%20%E4%BD%BF%E7%94%A8RandomAccessFile%E5%BF%AB%E9%80%9F%E8%AF%BB%E5%86%99%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E6%9C%80%E5%90%8E%E4%B8%80%E8%A1%8C&#x2F;</span><br></pre></td></tr></table></figure><br>这样就可以成功打来我的这篇文章了：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/Java/javaw%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/api/Ecoder/yes.png" alt=""><br>因为这与我从浏览器中复制粘贴的地址格式已经完全一样了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.lansheng.net.cn&#x2F;2018&#x2F;10&#x2F;30&#x2F;Java&#x2F;Java%20IO%E6%B5%81&#x2F;Java%20IO%E6%B5%81%20%E4%BD%BF%E7%94%A8RandomAccessFile%E5%BF%AB%E9%80%9F%E8%AF%BB%E5%86%99%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E6%9C%80%E5%90%8E%E4%B8%80%E8%A1%8C&#x2F;</span><br></pre></td></tr></table></figure></p><h3 id="方案2：只编码中文-直接用-20替换空格"><a href="#方案2：只编码中文-直接用-20替换空格" class="headerlink" title="方案2：只编码中文,直接用%20替换空格"></a>方案2：只编码中文,直接用%20替换空格</h3><p>这里钻了个空子：我可以直接编码中文，然后把没有编码的空格<code>`直接替换为</code>%20`。这样少了一步操作。<br>只对中文进行编码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encodeChinese</span><span class="params">(String str, String charset)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> UnsupportedEncodingException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//匹配中文和空格的正则表达式</span></span><br><span class="line">    String zhPattern = <span class="string">"[\u4e00-\u9fa5]+"</span>;</span><br><span class="line">    Pattern p = Pattern.compile(zhPattern);</span><br><span class="line">    Matcher m = p.matcher(str);</span><br><span class="line">    StringBuffer b = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">while</span> (m.find())</span><br><span class="line">    &#123;</span><br><span class="line">        m.appendReplacement(b, URLEncoder.encode(m.group(<span class="number">0</span>), charset));</span><br><span class="line">    &#125;</span><br><span class="line">    m.appendTail(b);</span><br><span class="line">    <span class="keyword">return</span> b.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>main方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"https://www.lansheng.net.cn/2018/10/30/Java/Java IO流/Java IO流 使用RandomAccessFile快速读写文本文件最后一行/"</span>;</span><br><span class="line">String url=encodeChinese(str, <span class="string">"UTF-8"</span>);</span><br><span class="line">System.out.println(url);</span><br><span class="line">url=url.replaceAll(<span class="string">" "</span>, <span class="string">"%20"</span>);</span><br><span class="line">System.out.println(url);</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.lansheng.net.cn&#x2F;2018&#x2F;10&#x2F;30&#x2F;Java&#x2F;Java IO%E6%B5%81&#x2F;Java IO%E6%B5%81 %E4%BD%BF%E7%94%A8RandomAccessFile%E5%BF%AB%E9%80%9F%E8%AF%BB%E5%86%99%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E6%9C%80%E5%90%8E%E4%B8%80%E8%A1%8C&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;www.lansheng.net.cn&#x2F;2018&#x2F;10&#x2F;30&#x2F;Java&#x2F;Java%20IO%E6%B5%81&#x2F;Java%20IO%E6%B5%81%20%E4%BD%BF%E7%94%A8RandomAccessFile%E5%BF%AB%E9%80%9F%E8%AF%BB%E5%86%99%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E6%9C%80%E5%90%8E%E4%B8%80%E8%A1%8C&#x2F;</span><br></pre></td></tr></table></figure><br>当然这两个方法基本差不多，我这里就简单记录一下两种可能，个人习惯用第二中方法。</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> url.encoder.hz;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.net.URLEncoder;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 正则替换字符串里面的汉字部分。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">URLEncoderCH</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String str = <span class="string">"https://www.lansheng.net.cn/2018/10/30/Java/Java IO流/Java IO流 使用RandomAccessFile快速读写文本文件最后一行/"</span>;</span><br><span class="line"><span class="comment">//        把URL中表示空格的+替换成%20,因为有些应用不认+表示的空格，只认%20</span></span><br><span class="line">        String url = URLEncode(str);</span><br><span class="line">        System.out.println(url);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**编码为浏览器可以直接访问的URL。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnsupportedEncodingException  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">URLEncode</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> UnsupportedEncodingException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String url=encodeChinese(str, <span class="string">"UTF-8"</span>);</span><br><span class="line">        System.out.println(url);</span><br><span class="line">        url=url.replaceAll(<span class="string">" "</span>, <span class="string">"%20"</span>);</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 只对中文进行编码。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment">     *            被替换的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> charset</span></span><br><span class="line"><span class="comment">     *            字符集</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 替换好的</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnsupportedEncodingException</span></span><br><span class="line"><span class="comment">     *             不支持的字符集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encodeChinese</span><span class="params">(String str, String charset)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> UnsupportedEncodingException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//匹配中文和空格的正则表达式</span></span><br><span class="line">        String zhPattern = <span class="string">"[\u4e00-\u9fa5]+"</span>;</span><br><span class="line">        Pattern p = Pattern.compile(zhPattern);</span><br><span class="line">        Matcher m = p.matcher(str);</span><br><span class="line">        StringBuffer b = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">while</span> (m.find())</span><br><span class="line">        &#123;</span><br><span class="line">            m.appendReplacement(b, URLEncoder.encode(m.group(<span class="number">0</span>), charset));</span><br><span class="line">        &#125;</span><br><span class="line">        m.appendTail(b);</span><br><span class="line">        <span class="keyword">return</span> b.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 只对中文和空格进行编码。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment">     *            被替换的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> charset</span></span><br><span class="line"><span class="comment">     *            字符集</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 替换好的</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnsupportedEncodingException</span></span><br><span class="line"><span class="comment">     *             不支持的字符集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encodeSpaceChinese</span><span class="params">(String str, String charset)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> UnsupportedEncodingException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//匹配中文和空格的正则表达式</span></span><br><span class="line">        String zhPattern = <span class="string">"[\u4e00-\u9fa5 ]+"</span>;</span><br><span class="line">        Pattern p = Pattern.compile(zhPattern);</span><br><span class="line">        Matcher m = p.matcher(str);</span><br><span class="line">        StringBuffer b = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">while</span> (m.find())</span><br><span class="line">        &#123;</span><br><span class="line">            m.appendReplacement(b, URLEncoder.encode(m.group(<span class="number">0</span>), charset));</span><br><span class="line">        &#125;</span><br><span class="line">        m.appendTail(b);</span><br><span class="line">        <span class="keyword">return</span> b.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>URLEncoder的只编码中文字符的类：<a href="https://blog.csdn.net/a332324956/article/details/18991243" target="_blank" rel="noopener">https://blog.csdn.net/a332324956/article/details/18991243</a><br>URL中关于空格的编码转换成＋或转换成％20的问题：<a href="https://www.jianshu.com/p/4a7eb969235d" target="_blank" rel="noopener">https://www.jianshu.com/p/4a7eb969235d</a></p><blockquote><p>原文链接: <a href="https://www.lansheng.net.cn/blog/7865fbca/" target="_blank" rel="noopener">Java网络编程 URLEncoder只编码URL中的中文,空格编码为百分之20</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java 网络编程 </category>
          
          <category> API </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DatagramSocket类</title>
      <link href="/ReadingNotes//c1fee13e/"/>
      <url>/ReadingNotes//c1fee13e/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/c1fee13e/#成员方法" class="header_2">成员方法</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><div class="table-container"><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>DatagramSocket()</code></td><td style="text-align:left">构造数据报套接字并将其绑定到本地主机上任何可用的端口。</td></tr><tr><td style="text-align:left"><code>DatagramSocket(int port)</code></td><td style="text-align:left">创建数据报套接字并将其绑定到本地主机上的指定端口。</td></tr><tr><td style="text-align:left"><code>DatagramSocket(int port, InetAddress laddr)</code></td><td style="text-align:left">创建数据报套接字，将其绑定到指定的IP地址</td></tr><tr><td style="text-align:left"><code>DatagramSocket(SocketAddress bindaddr)</code></td><td style="text-align:left">创建数据报套接字，将其绑定到指定的本地套接字地址。</td></tr><tr><td style="text-align:left"><code>protected  DatagramSocket(DatagramSocketImpl impl)</code></td><td style="text-align:left">创建带有指定 DatagramSocketImpl 的未绑定数据报套接字。</td></tr></tbody></table></div><h2 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h2><div class="table-container"><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>void bind(SocketAddress addr)</code></td><td style="text-align:left">将此 DatagramSocket 绑定到特定的地址和端口。</td></tr><tr><td style="text-align:left"><code>void close()</code></td><td style="text-align:left">关闭此数据报套接字。</td></tr><tr><td style="text-align:left"><code>void connect(InetAddress address, int port)</code></td><td style="text-align:left">将套接字连接到此套接字的远程地址。</td></tr><tr><td style="text-align:left"><code>void connect(SocketAddress addr)</code></td><td style="text-align:left">将此套接字连接到远程套接字地址（IP 地址 + 端口号）。</td></tr><tr><td style="text-align:left"><code>void disconnect()</code></td><td style="text-align:left">断开套接字的连接。</td></tr><tr><td style="text-align:left"><code>boolean getBroadcast()</code></td><td style="text-align:left">检测是否启用了 SO_BROADCAST。</td></tr><tr><td style="text-align:left"><code>DatagramChannel getChannel()</code></td><td style="text-align:left">返回与此数据报套接字关联的唯一 DatagramChannel 对象（如果有）。</td></tr><tr><td style="text-align:left"><code>InetAddress getInetAddress()</code></td><td style="text-align:left">返回此套接字连接的地址。</td></tr><tr><td style="text-align:left"><code>InetAddress getLocalAddress()</code></td><td style="text-align:left">获取套接字绑定的本地地址。</td></tr><tr><td style="text-align:left"><code>int getLocalPort()</code></td><td style="text-align:left">返回此套接字绑定的本地主机上的端口号。</td></tr><tr><td style="text-align:left"><code>SocketAddress getLocalSocketAddress()</code></td><td style="text-align:left">返回此套接字绑定的端点的地址，如果尚未绑定则返回 null。</td></tr><tr><td style="text-align:left"><code>int getPort()</code></td><td style="text-align:left">返回此套接字的端口。</td></tr><tr><td style="text-align:left"><code>int getReceiveBufferSize()</code></td><td style="text-align:left">获取此 DatagramSocket 的 SO_RCVBUF 选项的值，该值是平台在 DatagramSocket 上输入时使用的缓冲区大小。</td></tr><tr><td style="text-align:left"><code>SocketAddress getRemoteSocketAddress()</code></td><td style="text-align:left">返回此套接字连接的端点的地址，如果未连接则返回 null。</td></tr><tr><td style="text-align:left"><code>boolean getReuseAddress()</code></td><td style="text-align:left">检测是否启用了 SO_REUSEADDR。</td></tr><tr><td style="text-align:left"><code>int getSendBufferSize()</code></td><td style="text-align:left">获取此 DatagramSocket 的 SO_SNDBUF 选项的值，该值是平台在 DatagramSocket 上输出时使用的缓冲区大小。</td></tr><tr><td style="text-align:left"><code>int getSoTimeout()</code></td><td style="text-align:left">获取 SO_TIMEOUT 的设置。</td></tr><tr><td style="text-align:left"><code>int getTrafficClass()</code></td><td style="text-align:left">为从此 DatagramSocket 上发送的包获取 IP 数据报头中的流量类别或服务类型。</td></tr><tr><td style="text-align:left"><code>boolean isBound()</code></td><td style="text-align:left">返回套接字的绑定状态。</td></tr><tr><td style="text-align:left"><code>boolean isClosed()</code></td><td style="text-align:left">返回是否关闭了套接字。</td></tr><tr><td style="text-align:left"><code>boolean isConnected()</code></td><td style="text-align:left">返回套接字的连接状态。</td></tr><tr><td style="text-align:left"><code>void receive(DatagramPacket p)</code></td><td style="text-align:left">从此套接字接收数据报包。</td></tr><tr><td style="text-align:left"><code>void send(DatagramPacket p)</code></td><td style="text-align:left">从此套接字发送数据报包。</td></tr><tr><td style="text-align:left"><code>void setBroadcast(boolean on)</code></td><td style="text-align:left">启用/禁用 SO_BROADCAST。</td></tr><tr><td style="text-align:left"><code>static void setDatagramSocketImplFactory(DatagramSocketImplFactory fac)</code></td><td style="text-align:left">为应用程序设置数据报套接字实现工厂。</td></tr><tr><td style="text-align:left"><code>void setReceiveBufferSize(int size)</code></td><td style="text-align:left">将此 DatagramSocket 的 SO_RCVBUF 选项设置为指定的值。</td></tr><tr><td style="text-align:left"><code>void setReuseAddress(boolean on)</code></td><td style="text-align:left">启用/禁用 SO_REUSEADDR 套接字选项。</td></tr><tr><td style="text-align:left"><code>void setSendBufferSize(int size)</code></td><td style="text-align:left">将此 DatagramSocket 的 SO_SNDBUF 选项设置为指定的值。</td></tr><tr><td style="text-align:left"><code>void setSoTimeout(int timeout)</code></td><td style="text-align:left">启用/禁用带有指定超时值的 SO_TIMEOUT，以毫秒为单位。</td></tr><tr><td style="text-align:left"><code>void setTrafficClass(int tc)</code></td><td style="text-align:left">为从此 DatagramSocket 上发送的数据报在 IP 数据报头中设置流量类别 (traffic class) 或服务类型八位组 (type-of-service octet)。</td></tr></tbody></table></div><blockquote><p>原文链接: <a href="https://www.lansheng.net.cn/blog/c1fee13e/" target="_blank" rel="noopener">DatagramSocket类</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java 网络编程 </category>
          
          <category> API </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>7网络协议</title>
      <link href="/ReadingNotes//12786bb5/"/>
      <url>/ReadingNotes//12786bb5/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/12786bb5/#实例" class="header_2">实例</a>&nbsp;<br><a href="/ReadingNotes/12786bb5/#客户端发送给服务器的数据格式" class="header_3">客户端发送给服务器的数据格式</a>&nbsp;<br><a href="/ReadingNotes/12786bb5/#服务器反馈的数据格式" class="header_3">服务器反馈的数据格式</a>&nbsp;<br><a href="/ReadingNotes/12786bb5/#常见协议" class="header_2">常见协议</a>&nbsp;<br><a href="/ReadingNotes/12786bb5/#小结" class="header_2">小结</a>&nbsp;<br><a href="/ReadingNotes/12786bb5/#网络编程示例" class="header_2">网络编程示例</a>&nbsp;<br><a href="/ReadingNotes/12786bb5/#质数判别示例" class="header_2">质数判别示例</a>&nbsp;<br><a href="/ReadingNotes/12786bb5/#客户端程序功能：" class="header_3">客户端程序功能：</a>&nbsp;<br><a href="/ReadingNotes/12786bb5/#服务器端程序功能：" class="header_3">服务器端程序功能：</a>&nbsp;<br><a href="/ReadingNotes/12786bb5/#客户端发送协议格式：" class="header_3">客户端发送协议格式：</a>&nbsp;<br><a href="/ReadingNotes/12786bb5/#服务器端发送协议格式：" class="header_3">服务器端发送协议格式：</a>&nbsp;<br><a href="/ReadingNotes/12786bb5/#以TCP方式实现" class="header_3">以TCP方式实现</a>&nbsp;<br><a href="/ReadingNotes/12786bb5/#客户端程序" class="header_4">客户端程序</a>&nbsp;<br><a href="/ReadingNotes/12786bb5/#服务器端实现" class="header_3">服务器端实现</a>&nbsp;<br><a href="/ReadingNotes/12786bb5/#服务器逻辑线程" class="header_3">服务器逻辑线程</a>&nbsp;<br><a href="/ReadingNotes/12786bb5/#运行结果如下" class="header_3">运行结果如下</a>&nbsp;<br><a href="/ReadingNotes/12786bb5/#猜数字小游戏" class="header_2">猜数字小游戏</a>&nbsp;<br><a href="/ReadingNotes/12786bb5/#客户端程序功能列表：" class="header_3">客户端程序功能列表：</a>&nbsp;<br><a href="/ReadingNotes/12786bb5/#服务器端程序功能列表：" class="header_3">服务器端程序功能列表：</a>&nbsp;<br><a href="/ReadingNotes/12786bb5/#其中客户端程序协议格式如下：" class="header_3">其中客户端程序协议格式如下：</a>&nbsp;<br><a href="/ReadingNotes/12786bb5/#其中服务器端程序协议格式如下：" class="header_3">其中服务器端程序协议格式如下：</a>&nbsp;<br><a href="/ReadingNotes/12786bb5/#客户端程序实现代码如下：" class="header_3">客户端程序实现代码如下：</a>&nbsp;<br><a href="/ReadingNotes/12786bb5/#服务器控制程序" class="header_3">服务器控制程序</a>&nbsp;<br><a href="/ReadingNotes/12786bb5/#逻辑线程" class="header_3">逻辑线程</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><p>参考：<a href="http://www.cnblogs.com/springcsc/archive/2009/12/03/1616413.html" target="_blank" rel="noopener">http://www.cnblogs.com/springcsc/archive/2009/12/03/1616413.html</a><br>对于需要从事网络编程的程序员来说，网络协议是一个需要深刻理解的概念。那么什么是网络协议呢？</p><p><strong>网络协议是指对于网络中传输的数据格式的规定。</strong>对于网络编程初学者来说，没有必要深入了解TCP/IP协议簇，所以对于初学者来说去读大部头的《TCP/IP协议》也不是一件很合适的事情，因为深入了解TCP/IP协议是网络编程提高阶段，也是深入网络编程底层时才需要做的事情。<br>对于一般的网络编程来说，更多的是关心网络上传输的逻辑数据内容，也就是更多的是应用层上的网络协议，所以后续的内容均以实际应用的数据为基础来介绍网络协议的概念。</p><p>那么什么是网络协议呢，下面看一个简单的例子。春节晚会上“小沈阳”和赵本山合作的小品《不差钱》中，小沈阳和赵本山之间就设计了一个协议，协议的内容为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果点的菜价钱比较贵是，就说没有。</span><br></pre></td></tr></table></figure><br>按照该协议的规定，就有了下面的对话：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">赵本山：<span class="number">4</span>斤的龙虾</span><br><span class="line">小沈阳：(经过判断，得出价格比较高)，没有</span><br><span class="line">赵本山：鲍鱼</span><br><span class="line">小沈阳：(经过判断，得出价格比较高)，没有</span><br></pre></td></tr></table></figure><br>这就是一种双方达成的一种协议约定，其实这种约定的实质和网络协议的实质是一样的。<strong>网络协议的实质也是客户端程序和服务器端程序对于数据的一种约定，只是由于以计算机为基础，所以更多的是使用数字来代表内容，这样就显得比较抽象一些。</strong></p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>下 面再举一个简单的例子，介绍一些基础的网络协议设计的知识。例如需要设计一个简单的网络程序：网络计算器。也就是在客户端输入需要计算的数字和运算符，在 服务器端实现计算，并将计算的结果反馈给客户端。在这个例子中，就需要约定两个数据格式：<strong>客户端发送给服务器端的数据格式，以及服务器端反馈给客户端的数 据格式。</strong></p><h3 id="客户端发送给服务器的数据格式"><a href="#客户端发送给服务器的数据格式" class="headerlink" title="客户端发送给服务器的数据格式"></a>客户端发送给服务器的数据格式</h3><p>可能你觉得这个比较简单，例如客户端输入的数字依次是<code>12</code>和<code>432</code>，输入的运算符是加号，可能最容易想到的数据格式是形成字符串“<code>12+432</code>”，这样格式的确比较容易阅读，但是服务器端在进行计算时，逻辑就比较麻烦，因为需要首先拆分该字符串，然后才能进行计算，所以可用的数据格式就有了一下几种：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">“<span class="number">12</span>，<span class="number">432</span>，+”     格式为：第一个数字，第二个数字，运算符</span><br><span class="line">“<span class="number">12</span>，+，<span class="number">432</span>”     格式为：第一个数字，运算符，第二个数字</span><br></pre></td></tr></table></figure><br>其实以上两种数据格式很接近，比较容易阅读，在服务器端收到该数据格式以后，使用“<code>，</code>”为分隔符分割字符串即可。</p><p>假设对于运算符再进行一次约定，例如约定数字<code>0</code>代表加法<code>+</code>，<code>1</code>代表减法<code>-</code>，2代表乘法<code>*</code>，3代表除法<code>/</code>，整体格式遵循以上第一种格式，则上面的数字生产的协议数据为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“<span class="number">12</span>，<span class="number">432</span>，<span class="number">0</span>”</span><br></pre></td></tr></table></figure><br>这就是一种基本的发送的协议约定了。</p><h3 id="服务器反馈的数据格式"><a href="#服务器反馈的数据格式" class="headerlink" title="服务器反馈的数据格式"></a>服务器反馈的数据格式</h3><p>另 外一个需要设计的协议格式就是服务器端反馈的数据格式，其实服务器端主要反馈计算结果，但是在实际接受数据时，有可能存在格式错误的情况，这样就需要简单 的设计一下服务器端反馈的数据格式了。例如规定，如果发送的数据格式正确，则反馈结果，否则反馈字符串“错误”。这样就有了以下的数据格式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">客户端：“<span class="number">1</span>,<span class="number">111</span>,<span class="number">1</span>”     服务器端：”-<span class="number">110</span>”</span><br><span class="line">客户端：“<span class="number">123</span>,<span class="number">23</span>,<span class="number">0</span>”    服务器端：“<span class="number">146</span>”</span><br><span class="line">客户端：“<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>”       服务器端：“错误”</span><br></pre></td></tr></table></figure><br>这样就设计出了一种最最基本的网络协议格式，从该示例中可以看出，<strong>网络协议就是一种格式上的约定，可以根据逻辑的需要约定出各种数据格式</strong>，在进行设计时一般遵循“简单、通用、容易解析”的原则进行。</p><p>而对于复杂的网络程序来说，需要传输的数据种类和数据量都比较大，这样只需要依次设计出每种情况下的数据格式即可，例如QQ程序，在该程序中需要进行传输的网络数据种类很多，那么在设计时就可以遵循：登录格式、注册格式、发送消息格式等等，一一进行设计即可。所以对于复杂的网络程序来说，只是增加了更多的命令格式，在实际设计时的工作量增加不是太大。</p><p>不管怎么说，在网络编程中，<strong>对于同一个网络程序来说，一般都会涉及到两个网络协议格式：客户端发送数据格式和服务器端反馈数据格式</strong>，在实际设计时，需要一一对应。这就是最基本的网络协议的知识。</p><p>网络协议设计完成以后，在进行网络编程时，就需要根据设计好的协议格式，在程序中进行对应的编码了，客户端程序和服务器端程序需要进行协议处理的代码分别如下。</p><p>客户端程序需要完成的处理为：</p><ul><li>客户端发送协议格式的生成</li><li>服务器端反馈数据格式的解析</li></ul><p>服务器端程序需要完成的处理为：</p><ul><li>服务器端反馈协议格式的生成</li><li>客户端发送协议格式的解析</li></ul><p>这里的<strong>生成是指将计算好的数据，转换成规定的数据格式</strong>，这里的<strong>解析指，从反馈的数据格式中拆分出需要的数据。</strong>在进行对应的代码编写时，严格遵循协议约定即可。</p><p>所以，对于程序员来说，在进行网络程序编写时，需要首先根据逻辑的需要设计网络协议格式，然后遵循协议格式约定进行协议生成和解析代码的编写，最后使用网络编程技术实现整个网络编程的功能。</p><p>由于各种网络程序使用不同的协议格式，所以不同网络程序的客户端之间无法通用。</p><h2 id="常见协议"><a href="#常见协议" class="headerlink" title="常见协议"></a>常见协议</h2><p>而对于常见协议的格式，例如</p><ul><li><code>HTTP(Hyper Text Transfer Protocol</code>，超文本传输协议)、</li><li><code>FTP(File Transfer Protocol</code>，文件传输协议)，</li><li><code>SMTP(Simple Mail Transfer Protocol</code>，简单邮件传输协议)等等，</li></ul><p>都有通用的规定，具体可以查阅相关的<code>RFC</code>文档。</p><p>最后，对于一种网络程序来说，网络协议格式是该程序最核心的技术秘密，因为一旦协议格式泄漏，则任何一个人都可以根据该格式进行客户端的编写，这样将影响服务器端的实现，也容易出现一些其它的影响。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>关于网络编程基本的技术就介绍这么多，该部分介绍了网络编程的基础知识，以及Java语言对于网络编程的支持，网络编程的步骤等，并详细介绍了TCP方式网络编程和UDP方式网络编程在Java语言中的实现。</p><p>网络协议也是网络程序的核心，所以在实际开始进行网络编程时，设计一个良好的协议格式也是必须进行的工作。</p><h2 id="网络编程示例"><a href="#网络编程示例" class="headerlink" title="网络编程示例"></a>网络编程示例</h2><p>“实践出真知”，所以在进行技术学习时，还是需要进行很多的练习，才可以体会技术的奥妙，下面通过两个简单的示例，演示网络编程的实际使用。</p><h2 id="质数判别示例"><a href="#质数判别示例" class="headerlink" title="质数判别示例"></a>质数判别示例</h2><p>该示例实现的功能是质数判断，<strong>程序实现的功能为客户端程序接收用户输入的数字，然后将用户输入的内容发送给服务器端，服务器端判断客户端发送的数字是否是质数，并将判断的结果反馈给客户端，客户端根据服务器端的反馈显示判断结果。</strong></p><p><strong>质数的规则是</strong>：<strong>最小的质数是2，只能被1和自身整除的<code>自然数</code>。当用户输入小于2的数字，以及输入的内容不是自然数时，都属于非法输入。</strong></p><p>网络程序的功能都分为客户端程序和服务器端程序实现，下面先描述一下每个程序分别实现的功能：</p><h3 id="客户端程序功能："><a href="#客户端程序功能：" class="headerlink" title="客户端程序功能："></a>客户端程序功能：</h3><ul><li>接收用户控制台输入</li><li>判断输入内容是否合法</li><li>按照协议格式生成发送数据</li><li>发送数据</li><li>接收服务器端反馈</li><li>解析服务器端反馈信息，并输出</li></ul><h3 id="服务器端程序功能："><a href="#服务器端程序功能：" class="headerlink" title="服务器端程序功能："></a>服务器端程序功能：</h3><ul><li>接收客户端发送数据</li><li>按照协议格式解析数据</li><li>判断数字是否是质数</li><li>根据判断结果，生成协议数据</li><li>将数据反馈给客户端</li></ul><p>分解好了网络程序的功能以后，就可以设计网络协议格式了，如果该程序的功能比较简单，所以设计出的协议格式也不复杂。</p><h3 id="客户端发送协议格式："><a href="#客户端发送协议格式：" class="headerlink" title="客户端发送协议格式："></a>客户端发送协议格式：</h3><ul><li>将用户输入的数字转换为字符串，再将字符串转换为byte数组即可。</li><li>例如用户输入16，则转换为字符串“16”，使用getBytes转换为byte数组。</li><li>客户端发送“quit”字符串代表结束连接<h3 id="服务器端发送协议格式："><a href="#服务器端发送协议格式：" class="headerlink" title="服务器端发送协议格式："></a>服务器端发送协议格式：</h3></li><li>反馈数据长度为1个字节。数字0代表是质数，1代表不是质数，2代表协议格式错误。</li><li>例如客户端发送数字12，则反馈1，发送13则反馈0，发送0则反馈2。</li></ul><p>功能设计完成以后，就可以分别进行客户端和服务器端程序的编写了，在编写完成以后联合起来进行调试即可。</p><p>下面分别以TCP方式和UDP方式实现该程序，注意其实现上的差异。不管使用哪种方式实现，客户端都可以多次输入数据进行判断。对于UDP方式来说，不需要向服务器端发送quit字符串。</p><h3 id="以TCP方式实现"><a href="#以TCP方式实现" class="headerlink" title="以TCP方式实现"></a>以TCP方式实现</h3><h4 id="客户端程序"><a href="#客户端程序" class="headerlink" title="客户端程序"></a>客户端程序</h4><p>以TCP方式实现的客户端程序代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> example1;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 以TCP方式实现的质数判断客户端程序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPPrimeClient</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> BufferedReader br;</span><br><span class="line">    <span class="keyword">static</span> Socket socket;</span><br><span class="line">    <span class="keyword">static</span> InputStream is;</span><br><span class="line">    <span class="keyword">static</span> OutputStream os;</span><br><span class="line">    <span class="comment">/**服务器IP*/</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> String HOST = <span class="string">"127.0.0.1"</span>;</span><br><span class="line">    <span class="comment">/**服务器端端口*/</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> PORT = <span class="number">10005</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        init(); <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"请输入数字："</span>);</span><br><span class="line">            String input = readInput(); <span class="comment">//读取输入</span></span><br><span class="line">            <span class="keyword">if</span>(isQuit(input))</span><br><span class="line">            &#123; <span class="comment">//判读是否结束</span></span><br><span class="line">                <span class="keyword">byte</span>[] b = <span class="string">"quit"</span>.getBytes();</span><br><span class="line">                send(b);</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">//结束程序</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(checkInput(input))</span><br><span class="line">            &#123; <span class="comment">//校验合法</span></span><br><span class="line">                <span class="comment">//发送数据</span></span><br><span class="line">                send(input.getBytes());</span><br><span class="line">                <span class="comment">//接收数据</span></span><br><span class="line">                <span class="keyword">byte</span>[] data = receive();</span><br><span class="line">                <span class="comment">//解析反馈数据</span></span><br><span class="line">                parse(data);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"输入不合法，请重新输入！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        close(); <span class="comment">//关闭流和连接</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 初始化</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            br = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">            <span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">            socket = <span class="keyword">new</span> Socket(HOST,PORT);</span><br><span class="line">            is = socket.getInputStream();</span><br><span class="line">            os = socket.getOutputStream();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 读取客户端输入</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">readInput</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> br.readLine();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 判断是否输入quit</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> input 输入内容</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> true代表结束，false代表不结束</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isQuit</span><span class="params">(String input)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(input == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">"quit"</span>.equalsIgnoreCase(input))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 校验输入</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> input 用户输入内容</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> true代表输入符合要求，false代表不符合</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkInput</span><span class="params">(String input)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(input == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> n = Integer.parseInt(input);</span><br><span class="line">            <span class="keyword">if</span>(n &gt;= <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//输入不是整数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 向服务器端发送数据</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> data 数据内容</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(<span class="keyword">byte</span>[] data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            os.write(data);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 接收服务器端反馈</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 反馈数据</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] receive()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> n = is.read(b);</span><br><span class="line">            <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[n];</span><br><span class="line">            <span class="comment">//复制有效数据</span></span><br><span class="line">            System.arraycopy(b, <span class="number">0</span>, data, <span class="number">0</span>, n);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;&#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 解析协议数据</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> data 协议数据</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">(<span class="keyword">byte</span>[] data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"服务器端反馈数据不正确！"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span> value = data[<span class="number">0</span>]; <span class="comment">//取第一个byte</span></span><br><span class="line">        <span class="comment">//按照协议格式解析</span></span><br><span class="line">        <span class="keyword">switch</span>(value)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            System.out.println(<span class="string">"质数"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            System.out.println(<span class="string">"不是质数"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            System.out.println(<span class="string">"协议格式错误"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 关闭流和连接</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            br.close();</span><br><span class="line">            is.close();</span><br><span class="line">            os.close();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该代码中，将程序的功能使用方法进行组织，使得结构比较清晰，核心的逻辑流程在main方法中实现。</p><h3 id="服务器端实现"><a href="#服务器端实现" class="headerlink" title="服务器端实现"></a>服务器端实现</h3><p>以TCP方式实现的服务器端的代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> example1;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 以TCP方式实现的质数判别服务器端</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPPrimeServer</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">10005</span>;</span><br><span class="line">        ServerSocket ss = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            ss = <span class="keyword">new</span> ServerSocket(PORT);</span><br><span class="line">            System.out.println(<span class="string">"服务器端已启动："</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Socket s = ss.accept();</span><br><span class="line">                <span class="keyword">new</span> PrimeLogicThread(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;&#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                ss.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e2) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="服务器逻辑线程"><a href="#服务器逻辑线程" class="headerlink" title="服务器逻辑线程"></a>服务器逻辑线程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line">package example1;</span><br><span class="line">import java.io.*;</span><br><span class="line">import java.net.*;</span><br><span class="line">&#x2F;**</span><br><span class="line">* 实现质数判别逻辑的线程</span><br><span class="line">*&#x2F;</span><br><span class="line">public class PrimeLogicThread extends Thread </span><br><span class="line">&#123;</span><br><span class="line">    Socket socket;</span><br><span class="line">    InputStream is;</span><br><span class="line">    OutputStream os;</span><br><span class="line">    public PrimeLogicThread(Socket socket)</span><br><span class="line">    &#123;</span><br><span class="line">        this.socket &#x3D; socket;</span><br><span class="line">        init();</span><br><span class="line">        start();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">    * 初始化</span><br><span class="line">    *&#x2F;</span><br><span class="line">    private void init()</span><br><span class="line">    &#123;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            is &#x3D; socket.getInputStream();</span><br><span class="line">            os &#x3D; socket.getOutputStream();</span><br><span class="line">        &#125;catch(Exception e)&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void run()</span><br><span class="line">    &#123;</span><br><span class="line">        while(true)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;接收客户端反馈</span><br><span class="line">            byte[] data &#x3D; receive();</span><br><span class="line">            &#x2F;&#x2F;判断是否是退出</span><br><span class="line">            if(isQuit(data))</span><br><span class="line">            &#123;</span><br><span class="line">                break; &#x2F;&#x2F;结束循环</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;逻辑处理</span><br><span class="line">            byte[] b &#x3D; logic(data);</span><br><span class="line">            &#x2F;&#x2F;反馈数据</span><br><span class="line">            send(b);</span><br><span class="line">        &#125;</span><br><span class="line">        close();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">    * 接收客户端数据</span><br><span class="line">    * @return 客户端发送的数据</span><br><span class="line">    *&#x2F;</span><br><span class="line">    private byte[] receive()</span><br><span class="line">    &#123;</span><br><span class="line">        byte[] b &#x3D; new byte[1024];</span><br><span class="line">        try </span><br><span class="line">        &#123;</span><br><span class="line">            int n &#x3D; is.read(b);</span><br><span class="line">            byte[] data &#x3D; new byte[n];</span><br><span class="line">            &#x2F;&#x2F;复制有效数据</span><br><span class="line">            System.arraycopy(b, 0, data, 0, n);</span><br><span class="line">            return data;</span><br><span class="line">        &#125; catch (Exception e)&#123;&#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">    * 向客户端发送数据</span><br><span class="line">    * @param data 数据内容</span><br><span class="line">    *&#x2F;</span><br><span class="line">    private void send(byte[] data)</span><br><span class="line">    &#123;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            os.write(data);</span><br><span class="line">        &#125;catch(Exception e)&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">    * 判断是否是quit</span><br><span class="line">    * @return 是返回true，否则返回false</span><br><span class="line">    *&#x2F;</span><br><span class="line">    private boolean isQuit(byte[] data)</span><br><span class="line">    &#123;</span><br><span class="line">        if(data &#x3D;&#x3D; null)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            String s &#x3D; new String(data);</span><br><span class="line">            if(s.equalsIgnoreCase(&quot;quit&quot;))</span><br><span class="line">            &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private byte[] logic(byte[] data)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;反馈数组</span><br><span class="line">        byte[] b &#x3D; new byte[1];</span><br><span class="line">        &#x2F;&#x2F;校验参数</span><br><span class="line">        if(data &#x3D;&#x3D; null)</span><br><span class="line">        &#123;</span><br><span class="line">            b[0] &#x3D; 2;</span><br><span class="line">            return b;</span><br><span class="line">        &#125;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;转换为数字</span><br><span class="line">            String s &#x3D; new String(data);</span><br><span class="line">            int n &#x3D; Integer.parseInt(s);</span><br><span class="line">            &#x2F;&#x2F;判断是否是质数</span><br><span class="line">            if(n &gt;&#x3D; 2)</span><br><span class="line">            &#123;</span><br><span class="line">                boolean flag &#x3D; isPrime(n);</span><br><span class="line">                if(flag)</span><br><span class="line">                &#123;</span><br><span class="line">                    b[0] &#x3D; 0;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    b[0] &#x3D; 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                b[0] &#x3D; 2; &#x2F;&#x2F;格式错误</span><br><span class="line">                System.out.println(n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            b[0] &#x3D; 2;</span><br><span class="line">        &#125;</span><br><span class="line">        return b;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">    *</span><br><span class="line">    * @param n</span><br><span class="line">    * @return</span><br><span class="line">    *&#x2F;</span><br><span class="line">    private boolean isPrime(int n)</span><br><span class="line">    &#123;</span><br><span class="line">        boolean b &#x3D; true;</span><br><span class="line">        for(int i &#x3D; 2;i &lt;&#x3D; Math.sqrt(n);i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(n % i &#x3D;&#x3D; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                b &#x3D; false;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return b;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">    * 关闭连接</span><br><span class="line">    *&#x2F;</span><br><span class="line">    private void close()</span><br><span class="line">    &#123;</span><br><span class="line">        try </span><br><span class="line">        &#123;</span><br><span class="line">            is.close();</span><br><span class="line">            os.close();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; catch (Exception e)&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本示例使用的服务器端的结构和前面示例中的结构一致，只是逻辑线程的实现相对来说要复杂一些，在线程类中的logic方法中实现了服务器端逻辑，根据客户端发送过来的数据，判断是否是质数，然后根据判断结果按照协议格式要求，生成客户端反馈数据，实现服务器端要求的功能。</p><h3 id="运行结果如下"><a href="#运行结果如下" class="headerlink" title="运行结果如下"></a>运行结果如下</h3><p><img src="https://i.imgur.com/FPsEGIo.png" alt="运行结果"></p><h2 id="猜数字小游戏"><a href="#猜数字小游戏" class="headerlink" title="猜数字小游戏"></a>猜数字小游戏</h2><p>下面这个示例是一个猜数字的控制台小游戏。该游戏的规则是：<strong>当客户端第一次连接到服务器端时，服务器端生产一个【0，50】之间的随机数字，然后客户端输入数字来猜该数字，每次客户端输入数字以后，发送给服务器端，服务器端判断该客户端发送的数字和随机数字的关系，并反馈比较结果，客户端总共有5次猜的机会，猜中时提示猜中，当输入”quit”时结束程序。</strong></p><p>和前面的示例类似，在进行网络程序开发时，首先需要分解一下功能的实现，觉得功能是在客户端程序中实现还是在服务器端程序中实现。区分的规则一般是：</p><ul><li>客户端 程序实现接收用户输入等界面功能，并实现一些基础的校验降低服务器端的压力，</li><li>而将程序核心的逻辑以及数据存储等功能放在服务器端进行实现。<br>遵循该原则划分 的客户端和服务器端功能如下所示。</li></ul><h3 id="客户端程序功能列表："><a href="#客户端程序功能列表：" class="headerlink" title="客户端程序功能列表："></a>客户端程序功能列表：</h3><ul><li>接收用户控制台输入</li><li>判断输入内容是否合法</li><li>按照协议格式发送数据</li><li>根据服务器端的反馈给出相应提示</li></ul><h3 id="服务器端程序功能列表："><a href="#服务器端程序功能列表：" class="headerlink" title="服务器端程序功能列表："></a>服务器端程序功能列表：</h3><ul><li>接收客户端发送数据</li><li>按照协议格式解析数据</li><li>判断发送过来的数字和随机数字的关系</li><li>根据判断结果生产协议数据</li><li>将生产的数据反馈给客户端</li></ul><p>在该示例中，实际使用的网络命令也只有两条，所以显得协议的格式比较简单。</p><h3 id="其中客户端程序协议格式如下："><a href="#其中客户端程序协议格式如下：" class="headerlink" title="其中客户端程序协议格式如下："></a>其中客户端程序协议格式如下：</h3><ul><li>将用户输入的数字转换为字符串，然后转换为byte数组</li><li>发送“quit”字符串代表退出<h3 id="其中服务器端程序协议格式如下："><a href="#其中服务器端程序协议格式如下：" class="headerlink" title="其中服务器端程序协议格式如下："></a>其中服务器端程序协议格式如下：</h3><code>反馈长度为1个字节，数字0代表相等(猜中)，1代表大了，2代表小了，其它数字代表错误。</code></li></ul><p>实现该程序的代码比较多，下面分为客户端程序实现和服务器端程序实现分别进行列举。</p><h3 id="客户端程序实现代码如下："><a href="#客户端程序实现代码如下：" class="headerlink" title="客户端程序实现代码如下："></a>客户端程序实现代码如下：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">package guess;</span><br><span class="line"></span><br><span class="line">import java.net.*;</span><br><span class="line">import java.io.*;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 猜数字客户端</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class TCPClient</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Socket socket &#x3D; null;</span><br><span class="line">        OutputStream os &#x3D; null;</span><br><span class="line">        InputStream is &#x3D; null;</span><br><span class="line">        BufferedReader br &#x3D; null;</span><br><span class="line">        byte[] data &#x3D; new byte[2];</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F; 建立连接</span><br><span class="line">            socket &#x3D; new Socket(&quot;127.0.0.1&quot;, 10001);</span><br><span class="line">            &#x2F;&#x2F; 发送数据</span><br><span class="line">            os &#x3D; socket.getOutputStream();</span><br><span class="line">            &#x2F;&#x2F; 读取反馈数据</span><br><span class="line">            is &#x3D; socket.getInputStream();</span><br><span class="line">            &#x2F;&#x2F; 键盘输入流</span><br><span class="line">            br &#x3D; new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">            &#x2F;&#x2F; 多次输入</span><br><span class="line">            while (true)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(&quot;请输入数字：&quot;);</span><br><span class="line">                &#x2F;&#x2F; 接收输入</span><br><span class="line">                String s &#x3D; br.readLine();</span><br><span class="line">                &#x2F;&#x2F; 结束条件</span><br><span class="line">                if (s.equals(&quot;quit&quot;))</span><br><span class="line">                &#123;</span><br><span class="line">                    os.write(&quot;quit&quot;.getBytes());</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 校验输入是否合法</span><br><span class="line">                boolean b &#x3D; true;</span><br><span class="line">                try</span><br><span class="line">                &#123;</span><br><span class="line">                    Integer.parseInt(s);</span><br><span class="line">                &#125; catch (Exception e)</span><br><span class="line">                &#123;</span><br><span class="line">                    b &#x3D; false;</span><br><span class="line">                &#125;</span><br><span class="line">                if (b)</span><br><span class="line">                &#123; &#x2F;&#x2F; 输入合法</span><br><span class="line">                    &#x2F;&#x2F; 发送数据</span><br><span class="line">                    os.write(s.getBytes());</span><br><span class="line">                    &#x2F;&#x2F; 接收反馈</span><br><span class="line">                    is.read(data);</span><br><span class="line">                    &#x2F;&#x2F; 判断</span><br><span class="line">                    switch (data[0])</span><br><span class="line">                    &#123;</span><br><span class="line">                        case 0 :</span><br><span class="line">                            System.out.println(&quot;相等！祝贺你！&quot;);</span><br><span class="line">                            break;</span><br><span class="line">                        case 1 :</span><br><span class="line">                            System.out.println(&quot;大了！&quot;);</span><br><span class="line">                            break;</span><br><span class="line">                        case 2 :</span><br><span class="line">                            System.out.println(&quot;小了！&quot;);</span><br><span class="line">                            break;</span><br><span class="line">                        default :</span><br><span class="line">                            System.out.println(&quot;其它错误！&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F; 提示猜的次数</span><br><span class="line">                    System.out.println(&quot;你已经猜了&quot; + data[1] + &quot;次！&quot;);</span><br><span class="line">                    &#x2F;&#x2F; 判断次数是否达到5次</span><br><span class="line">                    if (data[1] &gt;&#x3D; 5)</span><br><span class="line">                    &#123;</span><br><span class="line">                        System.out.println(&quot;你挂了！&quot;);</span><br><span class="line">                        &#x2F;&#x2F; 给服务器端线程关闭的机会</span><br><span class="line">                        os.write(&quot;quit&quot;.getBytes());</span><br><span class="line">                        &#x2F;&#x2F; 结束客户端程序</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else</span><br><span class="line">                &#123; &#x2F;&#x2F; 输入错误</span><br><span class="line">                    System.out.println(&quot;输入错误！&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally</span><br><span class="line">        &#123;</span><br><span class="line">            try</span><br><span class="line">            &#123;</span><br><span class="line">                &#x2F;&#x2F; 关闭连接</span><br><span class="line">                br.close();</span><br><span class="line">                is.close();</span><br><span class="line">                os.close();</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; catch (Exception e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该示例中，首先建立一个到<code>IP</code>地址为<code>127.0.0.1</code>的端口为<code>10001</code>的连接，然后进行各个流的初始化工作，将逻辑控制的代码放入在一个<code>while</code>循环中，这样可以在客户端多次进行输入。在循环内部，首先判断用户输入的是否为<code>quit</code>字符串，如果是则结束程序，如果输入不是<code>quit</code>，则首先校验输入的是否是数字，如果不是数字则直接输出“输入错误！”并继续接收用户输入，如果是数字则发送给服务器端，并根据服务器端的反馈显示相应的提示信息。最后关闭流和连接，结束客户端程序。</p><p>服务器端程序的实现还是分为服务器控制程序和逻辑线程，实现的代码分别如下：</p><h3 id="服务器控制程序"><a href="#服务器控制程序" class="headerlink" title="服务器控制程序"></a>服务器控制程序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> guess;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* TCP连接方式的服务器端</span></span><br><span class="line"><span class="comment">* 实现功能：接收客户端的数据，判断数字关系</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPServer</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//监听端口</span></span><br><span class="line">            ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">10001</span>);</span><br><span class="line">            System.out.println(<span class="string">"服务器已启动："</span>);</span><br><span class="line">            <span class="comment">//逻辑处理</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//获得连接</span></span><br><span class="line">                Socket s = ss.accept();</span><br><span class="line">                <span class="comment">//启动线程处理</span></span><br><span class="line">                <span class="keyword">new</span> LogicThread(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="逻辑线程"><a href="#逻辑线程" class="headerlink" title="逻辑线程"></a>逻辑线程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">package guess;</span><br><span class="line">import java.net.*;</span><br><span class="line">import java.io.*;</span><br><span class="line">import java.util.*;</span><br><span class="line">&#x2F;**</span><br><span class="line">* 逻辑处理线程</span><br><span class="line">*&#x2F;</span><br><span class="line">public class LogicThread extends Thread </span><br><span class="line">&#123;</span><br><span class="line">    Socket s;</span><br><span class="line">    static Random r &#x3D; new Random();</span><br><span class="line">    public LogicThread(Socket s)</span><br><span class="line">    &#123;</span><br><span class="line">        this.s &#x3D; s;</span><br><span class="line">        start(); &#x2F;&#x2F;启动线程</span><br><span class="line">    &#125;</span><br><span class="line">    public void run()</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;生成一个[0，50]的随机数</span><br><span class="line">        int randomNumber &#x3D; Math.abs(r.nextInt() % 51);</span><br><span class="line">        &#x2F;&#x2F;用户猜的次数</span><br><span class="line">        int guessNumber &#x3D; 0;</span><br><span class="line">        InputStream is &#x3D; null;</span><br><span class="line">        OutputStream os &#x3D; null;</span><br><span class="line">        byte[] data &#x3D; new byte[2];</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;获得输入流</span><br><span class="line">            is &#x3D; s.getInputStream();</span><br><span class="line">            &#x2F;&#x2F;获得输出流</span><br><span class="line">            os &#x3D; s.getOutputStream();</span><br><span class="line">            while(true)</span><br><span class="line">            &#123; &#x2F;&#x2F;多次处理</span><br><span class="line">                &#x2F;&#x2F;读取客户端发送的数据</span><br><span class="line">                byte[] b &#x3D; new byte[1024];</span><br><span class="line">                int n &#x3D; is.read(b);</span><br><span class="line">                String send &#x3D; new String(b,0,n);</span><br><span class="line">                &#x2F;&#x2F;结束判别</span><br><span class="line">                if(send.equals(&quot;quit&quot;))</span><br><span class="line">                &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;解析、判断</span><br><span class="line">                try</span><br><span class="line">                &#123;</span><br><span class="line">                    int num &#x3D; Integer.parseInt(send);</span><br><span class="line">                    &#x2F;&#x2F;处理</span><br><span class="line">                    guessNumber++; &#x2F;&#x2F;猜的次数增加1</span><br><span class="line">                    data[1] &#x3D; (byte)guessNumber;</span><br><span class="line">                    &#x2F;&#x2F;判断</span><br><span class="line">                    if(num &gt; randomNumber)</span><br><span class="line">                    &#123;</span><br><span class="line">                        data[0] &#x3D; 1;</span><br><span class="line">                    &#125;else if(num &lt; randomNumber)&#123;</span><br><span class="line">                        data[0] &#x3D; 2;</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        data[0] &#x3D; 0;</span><br><span class="line">                        &#x2F;&#x2F;如果猜对</span><br><span class="line">                        guessNumber &#x3D; 0; &#x2F;&#x2F;清零</span><br><span class="line">                        randomNumber &#x3D; Math.abs(r.nextInt() % 51);</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F;反馈给客户端</span><br><span class="line">                    os.write(data);</span><br><span class="line">                &#125;catch(Exception e)&#123; &#x2F;&#x2F;数据格式错误</span><br><span class="line">                    data[0] &#x3D; 3;</span><br><span class="line">                    data[1] &#x3D; (byte)guessNumber;</span><br><span class="line">                    os.write(data); &#x2F;&#x2F;发送错误标识</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                os.flush();   &#x2F;&#x2F;强制发送</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            try</span><br><span class="line">            &#123;</span><br><span class="line">                is.close();</span><br><span class="line">                os.close();</span><br><span class="line">                s.close();</span><br><span class="line">            &#125;catch(Exception e)&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>原文链接: <a href="https://www.lansheng.net.cn/blog/12786bb5/" target="_blank" rel="noopener">7网络协议</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java 网络编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>UDP网络编程</title>
      <link href="/ReadingNotes//b6cecc51/"/>
      <url>/ReadingNotes//b6cecc51/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/b6cecc51/#Java-UDP网络编程相关类" class="header_2">Java UDP网络编程相关类</a>&nbsp;<br><a href="/ReadingNotes/b6cecc51/#DatagramSocket类" class="header_3">DatagramSocket类</a>&nbsp;<br><a href="/ReadingNotes/b6cecc51/#-DatagramPacket-类" class="header_3">`DatagramPacket`类</a>&nbsp;<br><a href="/ReadingNotes/b6cecc51/#UDP客户端编程步骤" class="header_2">UDP客户端编程步骤</a>&nbsp;<br><a href="/ReadingNotes/b6cecc51/#建立连接" class="header_3">建立连接</a>&nbsp;<br><a href="/ReadingNotes/b6cecc51/#发送数据" class="header_3">发送数据</a>&nbsp;<br><a href="/ReadingNotes/b6cecc51/#客户端接收数据" class="header_3">客户端接收数据</a>&nbsp;<br><a href="/ReadingNotes/b6cecc51/#关闭" class="header_3">关闭</a>&nbsp;<br><a href="/ReadingNotes/b6cecc51/#UDP服务端网络编程" class="header_2">UDP服务端网络编程</a>&nbsp;<br><a href="/ReadingNotes/b6cecc51/#第一步监听窗口，建立连接" class="header_3">第一步监听窗口，建立连接</a>&nbsp;<br><a href="/ReadingNotes/b6cecc51/#第二步：接收客户端的数据" class="header_3">第二步：接收客户端的数据</a>&nbsp;<br><a href="/ReadingNotes/b6cecc51/#第三步：处理接收的数据，给出响应" class="header_3">第三步：处理接收的数据，给出响应</a>&nbsp;<br><a href="/ReadingNotes/b6cecc51/#实例" class="header_2">实例</a>&nbsp;<br><a href="/ReadingNotes/b6cecc51/#多次发送多次接收" class="header_2">多次发送多次接收</a>&nbsp;<br><a href="/ReadingNotes/b6cecc51/#情况：得不到服务器的响应，一直阻塞" class="header_3">情况：得不到服务器的响应，一直阻塞</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><p>参考：<a href="https://blog.csdn.net/sihai12345/article/details/79334299" target="_blank" rel="noopener">https://blog.csdn.net/sihai12345/article/details/79334299</a></p><p>网络通讯的方式除了<code>TCP</code>方式以外，还有一种实现的方式就是<code>UDP</code>方式。<code>UDP(User Datagram Protocol)</code>，中文意思是<strong>用户数据报协议</strong>，方式类似于发短信息，是一种物美价廉的通讯方式，使用<strong>该种方式无需建立专用的虚拟连接</strong>，由于无需建立专用的连接，所以<strong>对于服务器的压力要比<code>TCP</code>小很多</strong>，所以也是一种常见的网络编程方式。但是使用<strong>该种方式最大的不足是传输不可靠</strong>，当然也不是说经常丢失，就像大家发短信息一样，理论上存在收不到的可能，这种可能性可能是<code>1%</code>，反正比较小，但是由于这种可能的存在，所以平时我们都觉得重要的事情还是打个电话吧(类似<code>TCP</code>方式)，一般的事情才发短信息(类似<code>UDP</code>方式)。网络编程中也是这样，<strong>必须要求可靠传输的信息一般使用<code>TCP</code>方式实现，一般的数据才使用<code>UDP</code>方式实现。</strong></p><p><code>UDP</code>方式的网络编程也在<code>Java</code>语言中获得了良好的支持，由于其在传输数据的过程中不需要建立专用的连接等特点，所以在<code>Java API</code>中设计的实现结构和<code>TCP</code>方式不太一样。当然，需要使用的类还是包含在<code>java.net</code>包中。</p><h2 id="Java-UDP网络编程相关类"><a href="#Java-UDP网络编程相关类" class="headerlink" title="Java UDP网络编程相关类"></a>Java UDP网络编程相关类</h2><p>在<code>Java API</code>中，实现<code>UDP</code>方式的编程，包含<code>客户端网络编程</code>和<code>服务器端网络编程</code>，主要由两个类实现，分别是：</p><h3 id="DatagramSocket类"><a href="#DatagramSocket类" class="headerlink" title="DatagramSocket类"></a>DatagramSocket类</h3><p><code>DatagramSocket</code>类实现“<strong>网络连接</strong>”，包括客户端网络连接和服务器端网络连接。虽然UDP方式的网络通讯不需要建立专用的网络连接，但是毕竟还是需要发送和接收数据，<strong><code>DatagramSocket</code>实现的就是发送数据时的发射器，以及接收数据时的监听器的角色。</strong>类比于TCP中的网络连接，该类既可以用于实现客户端连接，也可以用于实现服务器端连接。</p><h3 id="DatagramPacket类"><a href="#DatagramPacket类" class="headerlink" title="DatagramPacket类"></a><code>DatagramPacket</code>类</h3><p><strong><code>DatagramPacket</code>类实现对于网络中传输的数据封装</strong>，也就是说，<strong>该类的对象代表网络中交换的<code>数据</code></strong>。<br><strong>在<code>UDP</code>方式的网络编程中，无论是需要发送的数据还是需要接收的数据，都必须被处理成<code>DatagramPacket</code>类型的对象</strong>，该对象中包含<code>发送到的地址</code>、<code>发送到的端口号</code>以及<code>发送的内容</code>等。其实<code>DatagramPacket</code>类的作用类似于现实中的信件，在信件中包含信件发送到的地址以及接收人，还有发送的内容等，邮局只需要按照地址传递即可。在接收数据时，接收到的数据也必须被处理成<code>DatagramPacket</code>类型的对象，在该对象中包含发送方的地址、端口号等信息，也包含数据的内容。和<code>TCP</code>方式的网络传输相比，<strong><code>IO</code>编程在<code>UDP</code>方式的网络编程中变得不是必须的内容</strong>，结构也要比<code>TCP</code>方式的网络编程简单一些。</p><p>下面介绍一下UDP方式的网络编程中，客户端和服务器端的实现步骤，以及通过基础的示例演示UDP方式的网络编程在Java语言中的实现方式。</p><p>UDP方式的网络编程，编程的步骤和TCP方式类似，只是使用的类和方法存在比较大的区别，下面首先介绍一下UDP方式的网络编程客户端实现过程。</p><h2 id="UDP客户端编程步骤"><a href="#UDP客户端编程步骤" class="headerlink" title="UDP客户端编程步骤"></a>UDP客户端编程步骤</h2><p>UDP客户端编程涉及的步骤也是4个部分：<strong>建立连接</strong>、<strong>发送数据</strong>、<strong>接收数据</strong>和<strong>关闭连接</strong>。</p><h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><p>首先介绍UDP方式的网络编程中建立连接的实现。其中<strong>UDP方式的建立连接和TCP方式不同，只需要建立一个连接对象即可，不需要指定服务器的IP和端口号码</strong>。实现的代码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DatagramSocket ds &#x3D; new DatagramSocket();</span><br></pre></td></tr></table></figure><br>这样就建立了一个客户端连接，<strong>该客户端连接使用系统随机分配的一个本地计算机的未用端口号</strong>。在该连接中，不指定服务器端的IP和端口，所以UDP方式的网络连接更像一个发射器，而不是一个具体的连接。<br>当然，可以通过制定连接使用的端口号来创建客户端连接。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DatagramSocket ds &#x3D; new DatagramSocket(5000);</span><br></pre></td></tr></table></figure><br>这样就是使用本地计算机的<code>5000</code>号端口建立了一个连接。<strong>一般在建立客户端连接时没有必要指定端口号码。</strong></p><h3 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h3><p>接着，介绍一下UDP客户端编程中发送数据的实现。<strong>在UDP方式的网络编程中，IO技术不是必须的</strong>，<strong>发送数据步骤：</strong></p><ul><li>需要将需要发送的数据内容首先转换为<code>byte</code>数组，</li><li>然后将<code>数据内容</code>、<code>服务器IP</code>和<code>服务器端口号</code>一起构造成一个<code>DatagramPacket</code>类型的对象，这样数据的准备就完成了，</li><li>发送时调用网络连接对象中的send方法发送该对象即可。</li></ul><p>例如将字符串“<code>Hello</code>”发送到IP是<code>127.0.0.1</code>，端口号是<code>10001</code>的服务器，则实现发送数据的代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String s = “Hello”;</span><br><span class="line">String host = “<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>”;</span><br><span class="line"><span class="keyword">int</span> port = <span class="number">10001</span>;</span><br><span class="line"><span class="comment">//将发送的内容转换为byte数组</span></span><br><span class="line"><span class="keyword">byte</span>[] byteToSend = s.getBytes();</span><br><span class="line"><span class="comment">//将服务器IP转换为InetAddress对象</span></span><br><span class="line">InetAddress serverIP = InetAddress.getByName(host);</span><br><span class="line"><span class="comment">//构造发送的数据包对象,数据包中放入数据，目的地址，目的端口号</span></span><br><span class="line">DatagramPacket sendDp = <span class="keyword">new</span> DatagramPacket(byteToSend,byteToSend.length,serverIP,port);</span><br><span class="line"><span class="comment">//发送数据</span></span><br><span class="line">ds.send(sendDp);</span><br></pre></td></tr></table></figure><br>在该示例代码中，不管发送的数据内容是什么，都需要转换为byte数组，然后将服务器端的IP地址构造成InetAddress类型的对象，在准备完成以后，将这些信息构造成一个DatagramPacket类型的对象，发送的数据内容、服务器端的IP和端口号，都包含在DatagramPacket对象中。在准备完成以后，调用连接对象ds的send方法把DatagramPacket对象发送出去即可。</p><p>按照UDP协议的约定，在进行数据传输时，系统只是尽全力传输数据，但是并不保证数据一定被正确传输，<strong>如果数据在传输过程中丢失，那就丢失了。</strong></p><p>UDP方式在进行网络通讯时，也遵循“<strong>请求-响应</strong>”模型，<strong>在发送数据完成以后，就可以接收服务器端的反馈数据了。</strong></p><h3 id="客户端接收数据"><a href="#客户端接收数据" class="headerlink" title="客户端接收数据"></a>客户端接收数据</h3><p>下面介绍一下UDP客户端编程中接收数据的实现。当数据发送出去以后，就可以接收服务器端的反馈信息了。<strong>接收数据在Java语言中的实现是这样的：</strong></p><ul><li>首先构造一个数据缓冲数组，该数组用于存储接收的服务器端反馈数据，该数组的长度必须大于或等于服务器端反馈的实际有效数据的长度。</li><li>然后以该缓冲数组为基础构造一个DatagramPacket数据包对象，</li><li>最后调用连接对象的receive方法接收数据即可。</li></ul><p>接收到的服务器端反馈数据存储在DatagramPacket类型的对象内部。实现接收数据以及显示服务器端反馈内容的示例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一步,构造缓冲数组用于接收数据</span></span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="comment">//第二步,构造数据包对象</span></span><br><span class="line">DatagramPacket received = <span class="keyword">new</span> DatagramPacket(data,data.length);</span><br><span class="line"><span class="comment">//接收数据</span></span><br><span class="line">ds.receive(receiveDp);</span><br><span class="line"><span class="comment">//输出数据内容</span></span><br><span class="line"><span class="keyword">byte</span>[] b = receiveDp.getData(); <span class="comment">//获得缓冲数组</span></span><br><span class="line"><span class="keyword">int</span> len = receiveDp.getLength(); <span class="comment">//获得有效数据长度</span></span><br><span class="line">String s = <span class="keyword">new</span> String(b,<span class="number">0</span>,len);</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure><br>在该代码中，首先构造缓冲数组<code>data</code>，这里设置的长度<code>1024</code>是预估的接收到的数据长度，要求该长度必须大于或等于接收到的数据长度，然后以该缓冲数组为基础，构造数据包对象，使用连接对象<code>ds</code>的<code>receive</code>方法接收反馈数据，由于在<code>Java</code>语言中，除<code>String</code>以外的其它对象都是按照地址传递，所以在<code>receive</code>方法内部可以改变数据包对象<code>receiveDp</code>的内容，这里的<code>receiveDp</code>的功能和返回值类似。数据接收到以后，只需要从数据包对象中读取出来就可以了，使用<code>DatagramPacket</code>对象中的<code>getData</code>方法可以获得数据包对象的缓冲区数组，但是缓冲区数组的长度一般大于有效数据的长度，换句话说，也就是缓冲区数组中只有一部分数据是反馈数据，所以需要使用<code>DatagramPacket</code>对象中的<code>getLength</code>方法获得有效数据的长度，则有效数据就是缓冲数组中的前有效数据长度个内容，这些才是真正的服务器端反馈的数据的内容。</p><h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><p>UDP方式客户端网络编程的最后一个步骤就是关闭连接。虽然UDP方式不建立专用的虚拟连接，但是连接对象还是需要占用系统资源，所以在使用完成以后必须关闭连接。关闭连接使用连接对象中的close方法即可，实现的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ds.close();</span><br></pre></td></tr></table></figure><br>需要说明的是，和TCP建立连接的方式不同，UDP方式的同一个网络连接对象，可以发送到达不同服务器端IP或端口的数据包，这点是TCP方式无法做到的。</p><h2 id="UDP服务端网络编程"><a href="#UDP服务端网络编程" class="headerlink" title="UDP服务端网络编程"></a>UDP服务端网络编程</h2><p>介绍完了<code>UDP</code>方式客户端网络编程的基础知识以后，下面再来介绍一下<code>UDP</code>方式服务器端网络编程的基础知识。</p><p><code>UDP</code>方式网络编程的服务器端实现和<code>TCP</code>方式的服务器端实现类似，也是服务器端监听某个端口，然后获得数据包，进行逻辑处理以后将处理以后的结果反馈给客户端，最后关闭网络连接，下面依次进行介绍。</p><h3 id="第一步监听窗口，建立连接"><a href="#第一步监听窗口，建立连接" class="headerlink" title="第一步监听窗口，建立连接"></a>第一步监听窗口，建立连接</h3><p>首先<code>UDP</code>方式服务器端网络编程需要建立一个连接，该连接监听某个端口，实现的代码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DatagramSocket ds &#x3D; new DatagramSocket(10010);</span><br></pre></td></tr></table></figure><br>由于<strong>服务器端的端口需要固定，所以一般在建立服务器端连接时，都指定端口号。</strong>例如该示例代码中指定10010端口为服务器端使用的端口号，客户端端在连接服务器端时连接该端口号即可。</p><h3 id="第二步：接收客户端的数据"><a href="#第二步：接收客户端的数据" class="headerlink" title="第二步：接收客户端的数据"></a>第二步：接收客户端的数据</h3><p>接着服务器端就开始接收客户端发送过来的数据，其接收的方法和客户端接收的方法一直，其中<code>receive</code>方法的作用类似于<code>TCP</code>方式中<code>accept</code>方法的作用，该方法也是一个阻塞方法，其作用是接收数据。</p><h3 id="第三步：处理接收的数据，给出响应"><a href="#第三步：处理接收的数据，给出响应" class="headerlink" title="第三步：处理接收的数据，给出响应"></a>第三步：处理接收的数据，给出响应</h3><p>接收到客户端发送过来的数据以后，服务器端对该数据进行逻辑处理，然后将处理以后的结果再发送给客户端，<strong>在这里发送时就比客户端要麻烦一些，因为服务器端需要获得客户端的IP和客户端使用的端口号</strong>，这个都可以<code>从接收到的数据包中获得</code>。示例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得客户端的IP</span></span><br><span class="line">InetAddress clientIP = receiveDp.getAddress();</span><br><span class="line"><span class="comment">//获得客户端的端口号</span></span><br><span class="line">Int clientPort = receiveDp.getPort();</span><br></pre></td></tr></table></figure><br>使用以上代码，就可以从接收到的数据包对象<code>receiveDp</code>中获得客户端的<code>IP</code>地址和客户端的端口号，这样就可以在服务器端中将处理以后的数据构造成数据包对象，然后将处理以后的数据内容反馈给客户端了。</p><p>最后，当服务器端实现完成以后，关闭服务器端连接，实现的方式为调用连接对象的<code>close</code>方法，示例代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ds.close();</span><br></pre></td></tr></table></figure><br>介绍完了<code>UDP</code>方式下的客户端编程和服务器端编程的基础知识以后，下面通过一个简单的示例演示<code>UDP</code>网络编程的基本使用。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>该实例的功能是实现<strong>将客户端程序的系统时间发送给服务器端，服务器端接收到时间以后，向客户端反馈字符串“<code>OK</code>”。</strong>实现该功能的客户端代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> udp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单的UDP客户端，实现向服务器端发生系统时间功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleUDPClient</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        DatagramSocket ds = <span class="keyword">null</span>; <span class="comment">// 连接对象</span></span><br><span class="line">        DatagramPacket sendDp; <span class="comment">// 发送数据包对象</span></span><br><span class="line">        DatagramPacket receiveDp; <span class="comment">// 接收数据包对象</span></span><br><span class="line">        String serverHost = <span class="string">"127.0.0.1"</span>; <span class="comment">// 服务器IP</span></span><br><span class="line">        <span class="keyword">int</span> serverPort = <span class="number">10010</span>; <span class="comment">// 服务器端口号</span></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 建立连接,自动分配一个空闲端口</span></span><br><span class="line">            ds = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line">            <span class="comment">// 初始化发送数据</span></span><br><span class="line">            Date d = <span class="keyword">new</span> Date(); <span class="comment">// 当前时间</span></span><br><span class="line">            String content = d.toString(); <span class="comment">// 转换为字符串</span></span><br><span class="line">            <span class="keyword">byte</span>[] data = content.getBytes();</span><br><span class="line">            <span class="comment">// 初始化IP地址</span></span><br><span class="line">            InetAddress address = InetAddress.getByName(serverHost);</span><br><span class="line">            <span class="comment">// 初始化发送包对象 数据,数据的长度,IP地址,端口号</span></span><br><span class="line">            sendDp = <span class="keyword">new</span> DatagramPacket(data, data.length, address, serverPort);</span><br><span class="line">            <span class="comment">// 发送这个数据包</span></span><br><span class="line">            ds.send(sendDp);</span><br><span class="line">            <span class="comment">// 初始化接收数据</span></span><br><span class="line">            <span class="keyword">byte</span>[] receive = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            receiveDp = <span class="keyword">new</span> DatagramPacket(receive, receive.length);</span><br><span class="line">            <span class="comment">// 从服务器接收数据包,</span></span><br><span class="line">            ds.receive(receiveDp);</span><br><span class="line">            <span class="comment">// 读取反馈内容，并输出</span></span><br><span class="line">            <span class="keyword">byte</span>[] response = receiveDp.getData();</span><br><span class="line">            <span class="keyword">int</span> len = receiveDp.getLength();</span><br><span class="line">            String s = <span class="keyword">new</span> String(response, <span class="number">0</span>, len);</span><br><span class="line">            System.out.println(<span class="string">"服务器端反馈为："</span> + s);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 关闭连接</span></span><br><span class="line">                ds.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e)</span><br><span class="line">            &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在该示例代码中，首先建立<code>UDP</code>方式的网络连接，然后获得当前系统时间，这里获得的系统时间是客户端程序运行的本地计算机的时间，然后将时间字符串以及服务器端的<code>IP</code>和端口，构造成发送数据包对象，调用连接对象<code>ds</code>的<code>send</code>方法发送出去。在数据发送出去以后，构造接收数据的数据包对象，调用连接对象<code>ds</code>的<code>receive</code>方法接收服务器端的反馈，并输出在控制台。最后在<code>finally</code>语句块中关闭客户端网络连接。</p><p>和下面将要介绍的服务器端一起运行时，客户端程序的输出结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">服务器端反馈为：OK</span><br></pre></td></tr></table></figure><br>下面是该示例程序的服务器端代码实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> udp;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 简单UDP服务器端，实现功能是输出客户端发送数据，</span></span><br><span class="line"><span class="comment">并反馈字符串“OK"给客户端</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleUDPServer</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        DatagramSocket ds = <span class="keyword">null</span>; <span class="comment">//连接对象</span></span><br><span class="line">        DatagramPacket sendDp; <span class="comment">//发送数据包对象</span></span><br><span class="line">        DatagramPacket receiveDp; <span class="comment">//接收数据包对象</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">10010</span>; <span class="comment">//端口</span></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//建立连接，监听端口</span></span><br><span class="line">            ds = <span class="keyword">new</span> DatagramSocket(PORT);</span><br><span class="line">            System.out.println(<span class="string">"服务器端已启动："</span>);</span><br><span class="line">            <span class="comment">//初始化接收数据</span></span><br><span class="line">            <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            receiveDp = <span class="keyword">new</span> DatagramPacket(b,b.length);</span><br><span class="line">            <span class="comment">//接收</span></span><br><span class="line">            ds.receive(receiveDp);</span><br><span class="line">            <span class="comment">//读取反馈内容，并输出</span></span><br><span class="line">            InetAddress clientIP = receiveDp.getAddress();</span><br><span class="line">            <span class="keyword">int</span> clientPort = receiveDp.getPort();</span><br><span class="line">            <span class="keyword">byte</span>[] data = receiveDp.getData();</span><br><span class="line">            <span class="keyword">int</span> len = receiveDp.getLength();</span><br><span class="line">            System.out.println(<span class="string">"客户端IP："</span> + clientIP.getHostAddress());</span><br><span class="line">            System.out.println(<span class="string">"客户端端口："</span> + clientPort);</span><br><span class="line">            System.out.println(<span class="string">"客户端发送内容："</span> + <span class="keyword">new</span> String(data,<span class="number">0</span>,len));</span><br><span class="line">            <span class="comment">//发送反馈</span></span><br><span class="line">            String response = <span class="string">"OK"</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] bData = response.getBytes();</span><br><span class="line">            sendDp = <span class="keyword">new</span> DatagramPacket(bData,bData.length,clientIP,clientPort);</span><br><span class="line">            <span class="comment">//发送</span></span><br><span class="line">            ds.send(sendDp);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//关闭连接,释放占用的端口</span></span><br><span class="line">                ds.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在该服务器端实现中，首先监听<code>10010</code>号端口，和<code>TCP</code>方式的网络编程类似，服务器端的<code>receive</code>方法是阻塞方法，如果客户端不发送数据，则程序会在该方法处阻塞。</p><p>当客户端发送数据到达服务器端时，则接收客户端发送过来的数据，然后将客户端发送的数据内容读取出来，并在服务器端程序中打印客户端的相关信息，<strong>从客户端发送过来的数据包中可以读取出客户端的<code>IP</code>以及客户端端口号</strong>，将反馈数据字符串“<code>OK</code>”发送给客户端，最后关闭服务器端连接，释放占用的系统资源，完成程序功能示例。</p><p>运行结果：<br><img src="https://i.imgur.com/fzgDZkV.png" alt=""></p><p>和前面<code>TCP</code>方式中的网络编程类似，这个示例也仅仅是网络编程的功能示例，也存在前面介绍的客户端无法进行多次数据交换，以及服务器端不支持多个客户端的问题，这两个问题也需要对于代码进行处理才可以很方便的进行解决。</p><p>在解决该问题以前，需要特别指出的是<code>UDP</code>方式的网络编程由于不建立虚拟的连接，所以在实际使用时和<code>TCP</code>方式存在很多的不同，最大的一个不同就是“<code>无状态</code>”。该特点指每次服务器端都收到信息，但是这些信息和连接无关，换句话说，也就是服务器端只是从信息是无法识别出是谁发送的，这样就要求发送信息时的内容需要多一些，这个在后续的示例中可以看到。</p><h2 id="多次发送多次接收"><a href="#多次发送多次接收" class="headerlink" title="多次发送多次接收"></a>多次发送多次接收</h2><p>下面是实现客户端多次发送以及服务器端支持多个数据包同时处理的程序结构，实现的原理和<code>TCP</code>方式类似，在<strong>客户端将数据的发送和接收放入循环中，而服务器端则将接收到的每个数据包启动一个专门的线程进行处理。</strong>实现的代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> udp;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 简单的UDP客户端，实现向服务器端发生系统时间功能</span></span><br><span class="line"><span class="comment">* 该程序发送3次数据到服务器端</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MulUDPClient</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        DatagramSocket ds = <span class="keyword">null</span>; <span class="comment">//连接对象</span></span><br><span class="line">        DatagramPacket sendDp; <span class="comment">//发送数据包对象</span></span><br><span class="line">        DatagramPacket receiveDp; <span class="comment">//接收数据包对象</span></span><br><span class="line">        String serverHost = <span class="string">"127.0.0.1"</span>; <span class="comment">//服务器IP</span></span><br><span class="line">        <span class="keyword">int</span> serverPort = <span class="number">10012</span>; <span class="comment">//服务器端口号</span></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//建立连接</span></span><br><span class="line">            ds = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line">            <span class="comment">//初始化</span></span><br><span class="line">            InetAddress address = InetAddress.getByName(serverHost);</span><br><span class="line">            <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            receiveDp = <span class="keyword">new</span> DatagramPacket(b,b.length);</span><br><span class="line">            System.out.println(<span class="string">"客户端准备完成"</span>);</span><br><span class="line">            <span class="comment">//循环10次，每次间隔0.01秒</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//初始化发送数据</span></span><br><span class="line">                Date d = <span class="keyword">new</span> Date(); <span class="comment">//当前时间</span></span><br><span class="line">                String content = d.toString(); <span class="comment">//转换为字符串</span></span><br><span class="line">                <span class="keyword">byte</span>[] data = content.getBytes();</span><br><span class="line">                <span class="comment">//初始化发送包对象</span></span><br><span class="line">                sendDp = <span class="keyword">new</span> DatagramPacket(data,data.length,address, serverPort);</span><br><span class="line">                <span class="comment">//发送</span></span><br><span class="line">                ds.send(sendDp);</span><br><span class="line">                <span class="comment">//延迟</span></span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                <span class="comment">//接收</span></span><br><span class="line">                ds.receive(receiveDp);</span><br><span class="line">                <span class="comment">//读取反馈内容，并输出</span></span><br><span class="line">                <span class="keyword">byte</span>[] response = receiveDp.getData();</span><br><span class="line">                <span class="keyword">int</span> len = receiveDp.getLength();</span><br><span class="line">                String s = <span class="keyword">new</span> String(response,<span class="number">0</span>,len);</span><br><span class="line">                System.out.println(<span class="string">"服务器端反馈为："</span> + s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//关闭连接</span></span><br><span class="line">                ds.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在该示例中，将和服务器端进行数<strong>据交换的逻辑写在一个for循环的内部，这样就可以实现和服务器端的多次交换了</strong>，考虑到服务器端的响应速度，在每次发送之间加入0.01秒的时间间隔。最后当数据交换完成以后关闭连接，结束程序。</p><p>实现该逻辑的服务器端程序代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> udp;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 可以并发处理数据包的服务器端</span></span><br><span class="line"><span class="comment">* 功能为：显示客户端发送的内容，并向客户端反馈字符串“OK”</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MulUDPServer</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        DatagramSocket ds = <span class="keyword">null</span>; <span class="comment">//连接对象</span></span><br><span class="line">        DatagramPacket receiveDp; <span class="comment">//接收数据包对象</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">10012</span>; <span class="comment">//端口</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        receiveDp = <span class="keyword">new</span> DatagramPacket(b,b.length);</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//建立连接，监听端口</span></span><br><span class="line">            ds = <span class="keyword">new</span> DatagramSocket(PORT);</span><br><span class="line">            System.out.println(<span class="string">"服务器端已启动："</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//接收</span></span><br><span class="line">                ds.receive(receiveDp);</span><br><span class="line">                <span class="comment">//启动线程处理数据包</span></span><br><span class="line">                <span class="keyword">new</span> LogicThread(ds,receiveDp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//关闭连接</span></span><br><span class="line">                ds.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>该代码实现了服务器端的接收逻辑，使用一个循环来接收客户端发送过来的数据包，当接收到数据包以后启动一个LogicThread线程处理该数据包。这样服务器端就可以实现同时处理多个数据包了。</p><p>实现逻辑处理的线程代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> udp;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 逻辑处理线程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogicThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**连接对象*/</span></span><br><span class="line">    DatagramSocket ds;</span><br><span class="line">    <span class="comment">/**接收到的数据包*/</span></span><br><span class="line">    DatagramPacket dp;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LogicThread</span><span class="params">(DatagramSocket ds,DatagramPacket dp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ds = ds;</span><br><span class="line">        <span class="keyword">this</span>.dp = dp;</span><br><span class="line">        start(); <span class="comment">//启动线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//获得缓冲数组</span></span><br><span class="line">            <span class="keyword">byte</span>[] data = dp.getData();</span><br><span class="line">            <span class="comment">//获得有效数据长度</span></span><br><span class="line">            <span class="keyword">int</span> len = dp.getLength();</span><br><span class="line">            <span class="comment">//客户端IP</span></span><br><span class="line">            InetAddress clientAddress = dp.getAddress();</span><br><span class="line">            <span class="comment">//客户端端口</span></span><br><span class="line">            <span class="keyword">int</span> clientPort = dp.getPort();</span><br><span class="line">            <span class="comment">//输出</span></span><br><span class="line">            System.out.println(<span class="string">"客户端IP："</span> + clientAddress.getHostAddress());</span><br><span class="line">            System.out.println(<span class="string">"客户端端口号："</span> + clientPort);</span><br><span class="line">            System.out.println(<span class="string">"客户端发送内容："</span> + <span class="keyword">new</span> String(data,<span class="number">0</span>,len));</span><br><span class="line">            <span class="comment">//反馈到客户端</span></span><br><span class="line">            <span class="keyword">byte</span>[] b = <span class="string">"OK"</span>.getBytes();</span><br><span class="line">            DatagramPacket sendDp = <span class="keyword">new</span> DatagramPacket(b,b.length,clientAddress,clientPort);</span><br><span class="line">            <span class="comment">//发送</span></span><br><span class="line">            ds.send(sendDp);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在该线程中，只处理一次UDP通讯，当通讯结束以后线程死亡，在线程内部，每次获得客户端发送过来的信息，将获得的信息输出到服务器端程序的控制台，然后向客户端反馈字符串“OK”。</p><p><strong>由于UDP数据传输过程中可能存在丢失，所以在运行该程序时可能会出现程序阻塞的情况。</strong>如果需要避免该问题，可以<strong>将客户端的网络发送部分也修改成线程实现</strong>。</p><h3 id="情况：得不到服务器的响应，一直阻塞"><a href="#情况：得不到服务器的响应，一直阻塞" class="headerlink" title="情况：得不到服务器的响应，一直阻塞"></a>情况：得不到服务器的响应，一直阻塞</h3><p><img src="https://i.imgur.com/ONgEpnm.png" alt=""><br>正常运行的情况：<br><img src="https://i.imgur.com/gPAL9qU.png" alt=""><br>客户端接收响应的时候，设置超时时间，超时的时候停止等待接收。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">for(int i &#x3D; 0;i &lt; 10;i++)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;初始化发送数据</span><br><span class="line">    Date d &#x3D; new Date(); &#x2F;&#x2F;当前时间</span><br><span class="line">    String content &#x3D; d.toString(); &#x2F;&#x2F;转换为字符串</span><br><span class="line">    byte[] data &#x3D; content.getBytes();</span><br><span class="line">    &#x2F;&#x2F;初始化发送包对象</span><br><span class="line">    sendDp &#x3D; new DatagramPacket(data,data.length,address, serverPort);</span><br><span class="line">    &#x2F;&#x2F;发送</span><br><span class="line">    ds.send(sendDp);</span><br><span class="line">    &#x2F;&#x2F;设置接收的延时如果超过这个时间就不在等待接收</span><br><span class="line">    ds.setSoTimeout(3000);</span><br><span class="line">    &#x2F;&#x2F;接收</span><br><span class="line">    ds.receive(receiveDp);</span><br><span class="line">    &#x2F;&#x2F;读取反馈内容，并输出</span><br><span class="line">    byte[] response &#x3D; receiveDp.getData();</span><br><span class="line">    int len &#x3D; receiveDp.getLength();</span><br><span class="line">    String s &#x3D; new String(response,0,len);</span><br><span class="line">    System.out.println(&quot;服务器端反馈为：&quot; + s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这样当客户端长时间接收不到服务器的响应的时候，就会抛出<code>java.net.SocketTimeoutException</code>异常，客户端被终止运行。<br>超时的运行效果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">客户端准备完成</span><br><span class="line">服务器端反馈为：OK</span><br><span class="line">java.net.SocketTimeoutException: Receive timed out</span><br><span class="line">        at java.net.DualStackPlainDatagramSocketImpl.socketReceiveOrPeekData(Native Method)</span><br><span class="line">        at java.net.DualStackPlainDatagramSocketImpl.receive0(DualStackPlainDatagramSocketImpl.java:124)</span><br><span class="line">        at java.net.AbstractPlainDatagramSocketImpl.receive(AbstractPlainDatagramSocketImpl.java:143)</span><br><span class="line">        at java.net.DatagramSocket.receive(DatagramSocket.java:812)</span><br><span class="line">        at udp.MulUDPClient.main(MulUDPClient.java:40)</span><br></pre></td></tr></table></figure><br>关于基础的UDP网络编程就介绍这么多了，下面将介绍一下网络协议的概念。</p><blockquote><p>原文链接: <a href="https://www.lansheng.net.cn/blog/b6cecc51/" target="_blank" rel="noopener">UDP网络编程</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java 网络编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5TCP编程优化</title>
      <link href="/ReadingNotes//5eef6183/"/>
      <url>/ReadingNotes//5eef6183/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/5eef6183/#把客户端交换的逻辑写到循环中" class="header_2">把客户端交换的逻辑写到循环中</a>&nbsp;<br><a href="/ReadingNotes/5eef6183/#把服务器端的数据交换逻辑写在循环" class="header_2">把服务器端的数据交换逻辑写在循环</a>&nbsp;<br><a href="/ReadingNotes/5eef6183/#如何使服务器端支持多个客户端同时工作" class="header_1">如何使服务器端支持多个客户端同时工作</a>&nbsp;<br><a href="/ReadingNotes/5eef6183/#运行效果" class="header_3">运行效果</a>&nbsp;<br><a href="/ReadingNotes/5eef6183/#出现的问题" class="header_4">出现的问题</a>&nbsp;<br><a href="/ReadingNotes/5eef6183/#使用线程池" class="header_2">使用线程池</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><p>在前面的示例中，客户端中建立了一次连接，只发送一次数据就关闭了，这就相当于拨打电话时，电话打通了只对话一次就关闭了，其实更加常用的应该是拨通一次电话以后多次对话，这就是<strong>复用客户端连接</strong>。</p><h2 id="把客户端交换的逻辑写到循环中"><a href="#把客户端交换的逻辑写到循环中" class="headerlink" title="把客户端交换的逻辑写到循环中"></a>把客户端交换的逻辑写到循环中</h2><p>那 么<strong>如何实现建立一次连接，进行多次数据交换呢？其实很简单，建立连接以后，将数据交换的逻辑写到一个循环中就可以了</strong>。这样只要循环不结束则连接就不会被关 闭。按照这种思路，可以改造一下上面的代码，让该程序可以在建立连接一次以后，发送三次数据，当然这里的次数也可以是多次，示例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tcp;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 复用连接的Socket客户端</span></span><br><span class="line"><span class="comment">* 功能为：发送字符串“Hello”到服务器端，并打印出服务器端的反馈</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MulSocketClient</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//服务器端IP地址</span></span><br><span class="line">        String serverIP = <span class="string">"127.0.0.1"</span>;</span><br><span class="line">        <span class="comment">//服务器端端口号</span></span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">10000</span>;</span><br><span class="line">        <span class="comment">//发送内容</span></span><br><span class="line">        String data[] =&#123;<span class="string">"First"</span>,<span class="string">"Second"</span>,<span class="string">"Third"</span>&#125;;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//建立连接</span></span><br><span class="line">            socket = <span class="keyword">new</span> Socket(serverIP,port);</span><br><span class="line">            <span class="comment">//初始化流</span></span><br><span class="line">            os = socket.getOutputStream();</span><br><span class="line">            is = socket.getInputStream();</span><br><span class="line">            <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">//输出全部的数据</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; data.length;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//发送数据</span></span><br><span class="line">                os.write(data[i].getBytes());</span><br><span class="line">                <span class="comment">//接收数据</span></span><br><span class="line">                <span class="keyword">int</span> n = is.read(b);</span><br><span class="line">                <span class="comment">//输出反馈数据</span></span><br><span class="line">                System.out.println(<span class="string">"服务器反馈："</span> + <span class="keyword">new</span> String(b,<span class="number">0</span>,n));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace(); <span class="comment">//打印异常信息</span></span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//关闭流和连接</span></span><br><span class="line">                is.close();</span><br><span class="line">                os.close();</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e2) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>该示例程序和前面的代码相比，将数据交换部分的逻辑写在一个for循环的内容，这样就可以建立一次连接，依次将data数组中的数据按照顺序发送给服务器端了。</p><p>如果还是使用前面示例代码中的服务器端程序运行该程序，则该程序的结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">服务器反馈：First</span><br><span class="line">java.net.SocketException: Software caused connection abort: recv failed</span><br><span class="line">        at java.net.SocketInputStream.socketRead0(Native Method)</span><br><span class="line">        at java.net.SocketInputStream.socketRead(SocketInputStream.java:116)</span><br><span class="line">        at java.net.SocketInputStream.read(SocketInputStream.java:170)</span><br><span class="line">        at java.net.SocketInputStream.read(SocketInputStream.java:141)</span><br><span class="line">        at java.net.SocketInputStream.read(SocketInputStream.java:127)</span><br><span class="line">        at tcp.MulSocketClient.main(MulSocketClient.java:35)</span><br></pre></td></tr></table></figure><br>显然，客户端在实际运行时出现了异常，出现异常的原因是什么呢？如果仔细阅读前面的代码，应该还记得前面示例代码中的服务器端是对话一次数据以后就关闭了连接<strong>，如果服务器端程序关闭了，客户端继续发送数据肯定会出现异常</strong>，这就是出现该问题的原因。</p><p>按照客户端实现的逻辑，也可以复用服务器端的连接，实现的原理也是将服务器端的数据交换逻辑写在循环中即可，按照该种思路改造以后的服务器端代码为：</p><h2 id="把服务器端的数据交换逻辑写在循环"><a href="#把服务器端的数据交换逻辑写在循环" class="headerlink" title="把服务器端的数据交换逻辑写在循环"></a>把服务器端的数据交换逻辑写在循环</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tcp;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 复用连接的echo服务器</span></span><br><span class="line"><span class="comment">* 功能：将客户端发送的内容反馈给客户端</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MulSocketServer</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">null</span>;</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//监听端口号</span></span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">10000</span>;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//建立连接</span></span><br><span class="line">            serverSocket = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">            System.out.println(<span class="string">"服务器已启动："</span>);</span><br><span class="line">            <span class="comment">//获得连接</span></span><br><span class="line">            socket = serverSocket.accept();</span><br><span class="line">            <span class="comment">//初始化流</span></span><br><span class="line">            is = socket.getInputStream();</span><br><span class="line">            os = socket.getOutputStream();</span><br><span class="line">            <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> n = is.read(b);</span><br><span class="line">                <span class="comment">//输出</span></span><br><span class="line">                System.out.println(<span class="string">"客户端发送内容为："</span> + <span class="keyword">new</span> String(b,<span class="number">0</span>,n));</span><br><span class="line">                <span class="comment">//向客户端发送反馈内容</span></span><br><span class="line">                os.write(b, <span class="number">0</span>, n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//关闭流和连接</span></span><br><span class="line">                os.close();</span><br><span class="line">                is.close();</span><br><span class="line">                socket.close();</span><br><span class="line">                serverSocket.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该示例代码中，也将数据发送和接收的逻辑写在了一个for循环内部，只是在实现时硬性的将循环次数规定成了<code>3</code>次，这样代码虽然比较简单，但是通用性比较差。</p><p>服务器端程序的输出结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">服务器已启动：</span><br><span class="line">客户端发送内容为：First</span><br><span class="line">客户端发送内容为：Second</span><br><span class="line">客户端发送内容为：Third</span><br></pre></td></tr></table></figure><br>客户端的输出结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">服务器反馈：First</span><br><span class="line">服务器反馈：Second</span><br><span class="line">服务器反馈：Third</span><br></pre></td></tr></table></figure><br>在该程序中，比较明显的体现出了“<code>请求-响应</code>”模型，也就是在客户端发起连接以后，</p><p>首先发送字符串“<code>First</code>”给服务器端，服务器端输出客户端发送的内容“<code>First</code>”，然后将客户端发送的内容再反馈给客户端，这样客户端也输出服务器反馈“<code>First</code>”，这样就完成了客户端和服务器端的一次对话，</p><p>紧接着客户端发送“<code>Second</code>”给服务器端，服务端输出“<code>Second</code>”，然后将“<code>Second</code>”再反馈给客户端，客户端再输出“<code>Second</code>”，从而完成第二次对话，第三次会话的过程和这个一样。</p><p>在这个过程中，<strong>每次都是客户端程序首先发送数据给服务器端，服务器接收数据以后，将结果反馈给客户端，客户端接收到服务器端的反馈，从而完成一次通讯过程。</strong></p><p>在该示例中，虽然解决了多次发送的问题，但是客户端和服务器端的次数控制还不够灵活，如果客户端的次数不固定怎么办呢？是否可以使用某个特殊的字符串，例如quit，表示客户端退出呢,这就涉及到网络协议的内容了，会在后续的网络应用示例部分详细介绍。下面开始介绍另外一个网络编程的突出问题。</p><h1 id="如何使服务器端支持多个客户端同时工作"><a href="#如何使服务器端支持多个客户端同时工作" class="headerlink" title="如何使服务器端支持多个客户端同时工作"></a>如何使服务器端支持多个客户端同时工作</h1><p>前面介绍的服务器端程序，只是实现了概念上的服务器端，离实际的服务器端程序结构距离还很遥远，如果需要让服务器端能够实际使用，那么最需要解决的问题就是——如何支持多个客户端同时工作。</p><p><strong>一个服务器端一般都需要同时为多个客户端提供通讯，如果需要同时支持多个客户端，则必须使用前面介绍的线程的概念</strong>。简单来说，也就是<strong>当服务器端接收到一个连接时，启动一个专门的线程处理和该客户端的通讯。</strong></p><p>按照这个思路改写的服务端示例程序将由两个部分组成，<code>MulThreadSocketServer</code>类实现服务器端控制，实现<strong>接收客户端连接，然后开启专门的逻辑线程处理该连接</strong>，<code>LogicThread</code>类实现对于一个客户端连接的逻辑处理，<strong>将处理的逻辑放置在该类的<code>run</code>方法中</strong>。该示例的代码实现为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tcp;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 支持多客户端的服务器端实现</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MulThreadSocketServer</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">null</span>;</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//监听端口号</span></span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">10000</span>;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//建立连接</span></span><br><span class="line">            serverSocket = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">            System.out.println(<span class="string">"服务器已启动："</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//获得连接</span></span><br><span class="line">                socket = serverSocket.accept();</span><br><span class="line">                <span class="comment">//启动线程处理连接</span></span><br><span class="line">                <span class="keyword">new</span> LogicThread(socket);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//关闭连接</span></span><br><span class="line">                serverSocket.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在该示例代码中，实现了一个<code>while</code>形式的死循环，由于<code>accept</code>方法是阻塞方法，所以当客户端连接未到达时，将阻塞该程序的执行，当客户端到达时接收该连接，并启动一个新的<code>ResponseThread</code>线程处理该连接，然后按照循环的执行流程，继续等待下一个客户端连接。这样当任何一个客户端连接到达时，都开启一个专门的线程处理，通过多个线程支持多个客户端同时处理。<br>下面再看一下<code>ResponseThread</code>线程类的源代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">package tcp;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line">import java.net.*;</span><br><span class="line">&#x2F;**</span><br><span class="line">* 服务器端逻辑线程</span><br><span class="line">*&#x2F;</span><br><span class="line">public class ResponseThread extends Thread </span><br><span class="line">&#123;</span><br><span class="line">    Socket socket;</span><br><span class="line">    InputStream in;</span><br><span class="line">    OutputStream out;</span><br><span class="line">    public ResponseThread(Socket socket)</span><br><span class="line">    &#123;</span><br><span class="line">        this.socket &#x3D; socket;</span><br><span class="line">        start(); &#x2F;&#x2F;启动线程</span><br><span class="line">    &#125;</span><br><span class="line">    public void run()</span><br><span class="line">    &#123;</span><br><span class="line">        byte[] receive &#x3D; new byte[1024];</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            response(receive);</span><br><span class="line">        &#125;catch(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**   </span><br><span class="line">     * @param receive 接收到的数据</span><br><span class="line">     * @throws IOException  </span><br><span class="line">     *&#x2F;  </span><br><span class="line">    public void response(byte[] receive) throws IOException</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;初始化流</span><br><span class="line">        out &#x3D; socket.getOutputStream();</span><br><span class="line">        in &#x3D; socket.getInputStream();</span><br><span class="line">        for(int i &#x3D; 0;i &lt; 3;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;读取数据</span><br><span class="line">            int n &#x3D; in.read(receive);</span><br><span class="line">            &#x2F;&#x2F;反馈数据</span><br><span class="line">            out.write(receive,0,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">    * 关闭流和连接</span><br><span class="line">    *&#x2F;</span><br><span class="line">    private void close()</span><br><span class="line">    &#123;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;关闭流和连接</span><br><span class="line">            out.close();</span><br><span class="line">            in.close();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125;catch(Exception e)&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在该示例代码中，每次使用一个连接对象构造一个处理线程，该连接对象就是该线程需要处理的连接，在线程构造完成以后，该线程就被启动起来了，然后<strong>在<code>run</code>方法内部对客户端连接进行处理</strong>，数据交换的逻辑和前面的示例代码一致，只是这里将接收到客户端发送过来的数据并进行处理的逻辑封装成了<code>response</code>方法，实现的是<code>echo</code>服务的逻辑。</p><h3 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h3><h4 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -d . MulThreadSocketServer.java</span><br></pre></td></tr></table></figure><p>编译结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MulThreadSocketServer.java:26: 错误: 找不到符号</span><br><span class="line">                new ResponseThread(socket);</span><br><span class="line">                    ^</span><br><span class="line">  符号:   类 ResponseThread</span><br><span class="line">  位置: 类 MulThreadSocketServer</span><br><span class="line">1 个错误</span><br></pre></td></tr></table></figure><br>换到IDE中运行，运行起来是好好的，但是CMD中却报这样的错误。<br>这是怎么回事呢，这个其实是因为<code>ResponseThread.class</code>没有，所以应该先编译<code>ResponseThread</code>,然后再编译<code>MulThreadSocketServer</code><br>编译响应逻辑线程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -d . ResponseThread.java</span><br></pre></td></tr></table></figure><br>编译服务器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -d . MulThreadSocketServer.java</span><br></pre></td></tr></table></figure><br>运行服务器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java tcp.MulThreadSocketServer</span><br></pre></td></tr></table></figure><br>运行客户端1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java tcp.MulSocketClient</span><br></pre></td></tr></table></figure><br>运行客户端2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java tcp.MulSocketClient</span><br></pre></td></tr></table></figure><br>两个客户端的响应效果如下所示：</p><p><img src="https://i.imgur.com/DjjkjBK.png" alt="两个服务器的响应效果"></p><p>这里的示例还只是基础的服务器端实现，在实际的服务器端实现中，由于硬件和端口数的限制，所以不能无限制的创建线程对象，而且频繁的创建线程对象效率也比较低，所以程序中都实现了线程池来提高程序的执行效率。</p><h2 id="使用线程池"><a href="#使用线程池" class="headerlink" title="使用线程池"></a>使用线程池</h2><p>这里简单介绍一下线程池的概念，<strong>线程池(<code>Thread pool)</code>是池技术的一种，就是在程序启动时首先把需要的线程对象创建好</strong>，例如创建<code>5000</code>个线程对象，<strong>然后当客户端连接到达时从线程池中取出一个已经创建完成的线程对象使用即可</strong>。<strong>当客户端连接关闭以后，将该线程对象重新放入到线程池中供其它的客户端重复使用</strong>，这样可以提高程序的执行速度，优化程序对于内存的占用等。</p><p>关于基础的<code>TCP</code>方式的网络编程就介绍这么多，下面介绍<code>UDP</code>方式的网络编程在<code>Java</code>语言中的实现。</p><blockquote><p>原文链接: <a href="https://www.lansheng.net.cn/blog/5eef6183/" target="_blank" rel="noopener">5TCP编程优化</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java 网络编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4TCP编程</title>
      <link href="/ReadingNotes//dfafaccc/"/>
      <url>/ReadingNotes//dfafaccc/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/dfafaccc/#客户端网络编程" class="header_2">客户端网络编程</a>&nbsp;<br><a href="/ReadingNotes/dfafaccc/#第一步：建立连接" class="header_3">第一步：建立连接</a>&nbsp;<br><a href="/ReadingNotes/dfafaccc/#第二步-交换数据" class="header_3">第二步: 交换数据</a>&nbsp;<br><a href="/ReadingNotes/dfafaccc/#第三步：关闭网络连接" class="header_3">第三步：关闭网络连接</a>&nbsp;<br><a href="/ReadingNotes/dfafaccc/#实例" class="header_3">实例</a>&nbsp;<br><a href="/ReadingNotes/dfafaccc/#TCP客户端编程" class="header_2">TCP客户端编程</a>&nbsp;<br><a href="/ReadingNotes/dfafaccc/#第一步：监听窗口" class="header_3">第一步：监听窗口</a>&nbsp;<br><a href="/ReadingNotes/dfafaccc/#第二步：建立连接" class="header_3">第二步：建立连接</a>&nbsp;<br><a href="/ReadingNotes/dfafaccc/#第三步：交换数据" class="header_3">第三步：交换数据</a>&nbsp;<br><a href="/ReadingNotes/dfafaccc/#关闭连接" class="header_3">关闭连接</a>&nbsp;<br><a href="/ReadingNotes/dfafaccc/#运行客户端和服务端-###：" class="header_3">运行客户端和服务端 ###：</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><p>按照前面的介绍，<strong>网络通讯的方式有<code>TCP</code>和<code>UDP</code>两种</strong>，其中<code>TCP</code>方式的网络通讯是指在通讯的过程中保持连接，有点类似于打电话，只需要拨打一次号码(建立一次网络连接)，就可以多次通话(多次传输数据)。这样方式在实际的网络编程中，由于传输可靠，类似于打电话，如果甲给乙打电话，乙说没有听清楚让甲重复一遍，直到乙听清楚为止，实际的网络传输也是这样，如果发送的一方发送的数据接收方觉得有问题，则网络底层会自动要求发送方重发，直到接收方收到为止。</p><p>在<code>Java</code>语言中，对于<code>TCP</code>方式的网络编程提供了良好的支持，在实际实现时，<strong>以<code>java.net.Socket</code>类代表客户端连接，以<code>java.net.ServerSocket</code>类代表服务器端连接</strong>。在进行网络编程时，底层网络通讯的细节已经实现了比较高的封装，所以在程序员实际编程时，只需要指定<code>IP</code>地址和<code>端口号码</code>就可以建立连接了。正是由于这种高度的封装，一方面简化了<code>Java</code>语言网络编程的难度，另外也使得使用<code>Java</code>语言进行网络编程时无法深入到网络的底层，所以使用<code>Java</code>语言进行网络底层系统编程很困难，具体点说，<code>Java</code>语言无法实现底层的网络嗅探以及获得<code>IP</code>包结构等信息。但是由于<code>Java</code>语言的网络编程比较简单，所以还是获得了广泛的使用。</p><p>在使用<code>TCP</code>方式进行网络编程时，需要按照前面介绍的网络编程的步骤进行，下面分别介绍一下<strong>在<code>Java</code>语言中客户端和服务器端的实现步骤。</strong></p><h2 id="客户端网络编程"><a href="#客户端网络编程" class="headerlink" title="客户端网络编程"></a>客户端网络编程</h2><h3 id="第一步：建立连接"><a href="#第一步：建立连接" class="headerlink" title="第一步：建立连接"></a>第一步：建立连接</h3><p>在客户端网络编程中，首先需要建立连接，在<code>Java API</code>中以<code>java.net.Socket</code>类的对象代表网络连接，<strong>所以建立客户端网络连接，也就是创建<code>Socket</code>类型的对象</strong>，该对象代表网络连接，示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Socket socket1 = <span class="keyword">new</span> Socket(“<span class="number">192.168</span><span class="number">.1</span><span class="number">.103</span>”,<span class="number">10000</span>);</span><br><span class="line">Socket socket2 = <span class="keyword">new</span> Socket(“github.com”,<span class="number">80</span>);</span><br></pre></td></tr></table></figure><br>上面的代码中，<code>socket1</code>实现的是连接到<code>IP</code>地址是<code>192.168.1.103</code>的计算机的<code>10000</code>号端口，而<code>socket2</code>实现的是连接到域名是<code>www.sohu.com</code>的计算机的<code>80</code>号端口，至于底层网络如何实现建立连接，对于程序员来说是完全透明的。如果建立连接时，本机网络不通，或服务器端程序未开启，则会抛出异常。</p><h3 id="第二步-交换数据"><a href="#第二步-交换数据" class="headerlink" title="第二步: 交换数据"></a>第二步: 交换数据</h3><p>连接一旦建立，则完成了客户端编程的第一步，紧接着的步骤就是按照“请求-响应”模型进行网络数据交换，在<code>Java</code>语言中，<strong>数据传输功能由<code>Java IO</code>实现，也就是说只需要从连接中获得<code>输入流</code>和<code>输出流</code>即可</strong>，然后<code>将需要发送的数据写入连接对象的输出流</code>中，在发送完成以后<code>从输入流中读取数据</code>即可。示例代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OutputStream os &#x3D; socket1.getOutputStream(); &#x2F;&#x2F;获得输出流，用来想服务发送请求</span><br><span class="line">InputStream is &#x3D; socket1.getInputStream();     &#x2F;&#x2F;获得输入流,用来读取服务器的响应</span><br></pre></td></tr></table></figure><br>上面的代码中，分别从<code>socket1</code>这个连接对象获得了输出流和输入流对象，在整个网络编程中，后续的数据交换就变成了<code>IO</code>操作，也就是遵循“<code>请求-响应</code>”模型的规定，<strong>先向输出流中写入数据</strong>，这些数据会被系统发送出去，<strong>然后再从输入流中读取服务器端的反馈信息，这样就完成了一次数据交换过程</strong>，当然这个数据交换过程可以多次进行。</p><p>这里获得的只是最基本的输出流和输入流对象，还可以根据前面学习到的<code>IO</code>知识，<strong>使用流的嵌套将这些获得到的基本流对象转换成需要的装饰流对象，从而方便数据的操作。</strong></p><h3 id="第三步：关闭网络连接"><a href="#第三步：关闭网络连接" class="headerlink" title="第三步：关闭网络连接"></a>第三步：关闭网络连接</h3><p>最后当数据交换完成以后，关闭网络连接，释放网络连接占用的系统端口和内存等资源，完成网络操作，示例代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket1.close();</span><br></pre></td></tr></table></figure></p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>这就是最基本的网络编程功能介绍。下面是一个简单的网络客户端程序示例，该程序的作用是向服务器端发送一个字符串“Hello”，并将服务器端的响应显示到控制台，数据交换只进行一次，当数据交换进行完成以后关闭网络连接，程序结束。实现的代码如下：<br>实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">package tcp;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line">import java.net.*;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 简单的Socket客户端</span><br><span class="line"> * 功能为：发送字符串“Hello”到服务器端，并打印出服务器端的响应</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class SimpleSocketClient</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Socket socket &#x3D; null;</span><br><span class="line">        InputStream is &#x3D; null;</span><br><span class="line">        OutputStream os &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F; 服务器端IP地址</span><br><span class="line">        String serverIP &#x3D; &quot;127.0.0.1&quot;;</span><br><span class="line">        &#x2F;&#x2F; 服务器端端口号</span><br><span class="line">        int serverPort &#x3D; 10000;</span><br><span class="line">        &#x2F;&#x2F; 发送内容</span><br><span class="line">        String request &#x3D; &quot;Hello&quot;;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F; 第一步:建立连接</span><br><span class="line">            socket &#x3D; new Socket(serverIP, serverPort);</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; 第二步:交换数据</span><br><span class="line">            &#x2F;&#x2F; 获取输出流</span><br><span class="line">            os &#x3D; socket.getOutputStream();</span><br><span class="line">            &#x2F;&#x2F; 发送数据给服务器</span><br><span class="line">            os.write(request.getBytes());</span><br><span class="line">            &#x2F;&#x2F; 接收服务器的数据</span><br><span class="line">            is &#x3D; socket.getInputStream();</span><br><span class="line">            byte[] response &#x3D; new byte[1024];</span><br><span class="line">            int size &#x3D; is.read(response);</span><br><span class="line">            &#x2F;&#x2F; 输出反馈数据</span><br><span class="line">            System.out.println(&quot;服务器响应：&quot; + new String(response, 0, size));</span><br><span class="line">        &#125; catch (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace(); &#x2F;&#x2F; 打印异常信息</span><br><span class="line">        &#125; finally</span><br><span class="line">        &#123;</span><br><span class="line">            if(os!&#x3D;null)</span><br><span class="line">            &#123;</span><br><span class="line">                try</span><br><span class="line">                &#123;</span><br><span class="line">                    os.close();</span><br><span class="line">                &#125; catch (IOException e)</span><br><span class="line">                &#123;</span><br><span class="line">                    &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(is!&#x3D;null)</span><br><span class="line">            &#123;</span><br><span class="line">                try</span><br><span class="line">                &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; catch (IOException e)</span><br><span class="line">                &#123;</span><br><span class="line">                    &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(socket!&#x3D;null)</span><br><span class="line">            &#123;</span><br><span class="line">                try</span><br><span class="line">                &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; catch (IOException e)</span><br><span class="line">                &#123;</span><br><span class="line">                    &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在该示例代码中<code>建立了一个连接到</code>IP<code>地址为</code>127.0.0.1<code>，端口号码为</code>10000<code>的</code>TCP<code>类型的网络连接</code>，然后获得连接的输出流对象，将需要发送的字符串“<code>Hello</code>”转换为<code>byte</code>数组写入到输出流中，由系统自动完成将输出流中的数据发送出去，如果需要强制发送，可以调用输出流对象中的<code>flush</code>方法实现。在数据发送出去以后，从连接对象的输入流中读取服务器端的反馈信息，读取时可以使用<code>IO</code>中的各种读取方法进行读取，这里使用最简单的方法进行读取，<strong>从输入流中读取到的内容就是服务器端的响应</strong>，并将读取到的内容在客户端的控制台进行输出，最后依次关闭打开的流对象和网络连接对象。</p><p>这是一个简单的功能示例，在该示例中演示了<code>TCP</code>类型的<code>网络客户端</code>基本方法的使用，该代码只起演示目的，还无法达到实用的级别。</p><h2 id="TCP客户端编程"><a href="#TCP客户端编程" class="headerlink" title="TCP客户端编程"></a>TCP客户端编程</h2><p>介绍完一个简单的客户端编程的示例，下面接着介绍一下<code>TCP</code>类型的服务器端的编写。首先需要说明的是，<strong>客户端的步骤和服务器端的编写步骤不同</strong>，所以在学习服务器端编程时注意不要和客户端混淆起来。</p><h3 id="第一步：监听窗口"><a href="#第一步：监听窗口" class="headerlink" title="第一步：监听窗口"></a>第一步：监听窗口</h3><p>在服务器端程序编程中，由于服务器端实现的是被动等待连接，所以服<strong>务器端编程的第一个步骤是监听端口</strong>，也就是监听是否有客户端连接到达。实现服务器端监听的代码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerSocket ss &#x3D; new ServerSocket(10000);</span><br></pre></td></tr></table></figure><br>该代码实现的功能是监听当前计算机的<code>10000</code>号端口，如果在执行该代码时，<code>10000</code>号端口已经被别的程序占用，那么将抛出异常。否则将实现监听。</p><h3 id="第二步：建立连接"><a href="#第二步：建立连接" class="headerlink" title="第二步：建立连接"></a>第二步：建立连接</h3><p>服务器端编程的第二个步骤是获得连接<strong>。该步骤的作用是当有客户端连接到达时，建立一个和客户端连接对应的<code>Socket</code>连 接对象，从而释放客户端连接对于服务器端端口的占用</strong>。实现功能就像公司的前台一样，当一个客户到达公司时，会告诉前台我找某某某，然后前台就通知某某某， 然后就可以继续接待其它客户了。通过获得连接，使得客户端的连接在服务器端获得了保持，另外使得服务器端的端口释放出来，可以继续等待其它的客户端连接。 实现获得连接的代码是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Socket socket &#x3D; ss.accept();</span><br></pre></td></tr></table></figure><br>该代码实现的功能是<strong>获得当前连接到服务器端的客户端连接</strong>。需要说明的是<strong><code>accept</code>和<code>IO</code>部分介绍的<code>read</code>方法一样，都是一个阻塞方法，也就是当无连接时，该方法将阻塞程序的执行，直到连接到达时才执行该行代码。</strong>另外获得的连接会在服务器端的该端口注册，这样以后就可以通过在服务器端的注册信息直接通信，而注册以后服务器端的端口就被释放出来，又可以继续接受其它的连接了。</p><h3 id="第三步：交换数据"><a href="#第三步：交换数据" class="headerlink" title="第三步：交换数据"></a>第三步：交换数据</h3><p>连接获得以后，后续的编程就和客户端的网络编程类似了，这里获得的Socket类型的连接就和客户端的网络连接一样了，只是<strong>服务器端需要首先读取发送过来的数据，然后进行逻辑处理以后再发送给客户端，也就是交换数据的顺序和客户端交换数据的步骤刚好相反。</strong>这部分的内容和客户端很类似，所以就不重复了，如果还不熟悉，可以参看下面的示例代码。</p><h3 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h3><p>最后，在服务器端通信完成以后，关闭服务器端连接。实现的代码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss.close();</span><br></pre></td></tr></table></figure><br>这就是基本的<code>TCP</code>类型的服务器端编程步骤。下面以一个简单的<code>echo</code>服务实现为例子，介绍综合使用示例。<code>echo</code>的意思就是“回声”，<strong><code>echo</code>服务器端实现的功能就是将客户端发送的内容再原封不动的反馈给客户端。</strong>实现的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tcp;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * echo服务器 功能：将客户端发送的内容反馈给客户端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleSocketServer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">null</span>;</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        OutputStream out = <span class="keyword">null</span>;</span><br><span class="line">        InputStream in = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 监听端口号</span></span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">10000</span>;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 建立连接</span></span><br><span class="line">            serverSocket = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">            <span class="comment">// 获得连接</span></span><br><span class="line">            socket = serverSocket.accept();</span><br><span class="line">            <span class="comment">// 接收客户端发送内容</span></span><br><span class="line">            in = socket.getInputStream();</span><br><span class="line">            <span class="keyword">byte</span>[] recive = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> size = in.read(recive);</span><br><span class="line">            <span class="comment">// 输出</span></span><br><span class="line">            System.out.println(<span class="string">"客户端发送内容为："</span> + <span class="keyword">new</span> String(recive, <span class="number">0</span>, size));</span><br><span class="line">            <span class="comment">// 向客户端发送反馈内容</span></span><br><span class="line">            out = socket.getOutputStream();</span><br><span class="line">            out.write(recive, <span class="number">0</span>, size);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 关闭流和连接</span></span><br><span class="line">                out.close();</span><br><span class="line">                in.close();</span><br><span class="line">                socket.close();</span><br><span class="line">                serverSocket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e)</span><br><span class="line">            &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该示例代码中建立了一个监听当前计算机<code>10000</code>号端口的服务器端<code>Socket</code>连接，然后获得客户端发送过来的连接，如果有连接到达时，读取连接中发送过来的内容，并将发送的内容在控制台进行输出，输出完成以后将客户端发送的内容再反馈给客户端。最后关闭流和连接对象，结束程序。</p><h3 id="运行客户端和服务端-："><a href="#运行客户端和服务端-：" class="headerlink" title="运行客户端和服务端 ###："></a>运行客户端和服务端 ###：</h3><p>因为在IDE中只有一个控制台窗口，所以运行效果不明显，所以这里再cmd命令行中编译运行简单点。</p><ul><li>编译运行服务器<br>在cmd中编译服务器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -d . SimpleSocketServer.java</span><br></pre></td></tr></table></figure>在cmd中运行服务器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java tcp.SimpleSocketServer</span><br></pre></td></tr></table></figure>此时，服务器端将阻塞，等待客户端的连接。<br><img src="https://i.imgur.com/VcFSVEN.png" alt="服务器等待客户端的连接"></li><li>编译运行客户端<br>在cmd中编译客户端<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -d . SimpleSocketClient.java</span><br></pre></td></tr></table></figure>在cmd中运行客户端<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java tcp.SimpleSocketClient</span><br></pre></td></tr></table></figure><img src="https://i.imgur.com/SV1h4R1.png" alt="编译运行客户端"><br>运行结果：<br><img src="https://i.imgur.com/mEFqwtO.png" alt=""></li></ul><p>这样，就以一个很简单的示例演示了<code>TCP</code>类型的网络编程在<code>Java</code>语言中的基本实现，这个示例只是演示了网络编程的基本步骤以及各个功能方法的基本使用，只是为网络编程打下了一个基础，下面将就几个问题来深入介绍网络编程深层次的一些知识。<br>为了一步一步的掌握网络编程，下面再研究网络编程中的两个基本问题，通过解决这两个问题将对网络编程的认识深入一层。</p><blockquote><p>原文链接: <a href="https://www.lansheng.net.cn/blog/dfafaccc/" target="_blank" rel="noopener">4TCP编程</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java 网络编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3Java网络编程技术</title>
      <link href="/ReadingNotes//eadab85c/"/>
      <url>/ReadingNotes//eadab85c/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/eadab85c/#-InetAddress-类--代表一个-IP-地址" class="header_2">`InetAddress`类--代表一个`IP`地址</a>&nbsp;<br><a href="/ReadingNotes/eadab85c/#创建InetAddress类实例的方法" class="header_3">创建InetAddress类实例的方法</a>&nbsp;<br><a href="/ReadingNotes/eadab85c/#实例" class="header_4">实例</a>&nbsp;<br><a href="/ReadingNotes/eadab85c/#重写Object类的方法：" class="header_3">重写Object类的方法：</a>&nbsp;<br><a href="/ReadingNotes/eadab85c/#获取IP地址相关信息的方法" class="header_3">获取IP地址相关信息的方法</a>&nbsp;<br><a href="/ReadingNotes/eadab85c/#判断方法：" class="header_3">判断方法：</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><p><code>Java</code>语言是在网络环境下诞生的，所以<code>Java</code>语言虽然不能说是对于网络编程的支持最好的语言，但是必须说是一种对于网络编程提供良好支持的语言，使用<code>Java</code>语言进行网络编程将是一件比较轻松的工作。</p><p><strong>和网络编程有关的基本<code>API</code>位于<code>java.net</code>包中</strong>，该包中包含了基本的网络编程实现，该包是网络编程的基础。该包中既包含基础的网络编程类，也包含封装后的专门处理<code>WEB</code>相关的处理类。在本章中，将只介绍基础的网络编程类。</p><p>首先来介绍一个基础的网络类——<code>InetAddress</code>类。该类的功能是代表一个<code>IP</code>地址，是<code>ip</code>地址的<code>java</code>表示方式。并且将<code>IP</code>地址和域名相关的操作方法包含在该类的内部。</p><h2 id="InetAddress类—代表一个IP地址"><a href="#InetAddress类—代表一个IP地址" class="headerlink" title="InetAddress类—代表一个IP地址"></a><code>InetAddress</code>类—代表一个<code>IP</code>地址</h2><h3 id="创建InetAddress类实例的方法"><a href="#创建InetAddress类实例的方法" class="headerlink" title="创建InetAddress类实例的方法"></a>创建InetAddress类实例的方法</h3><p><strong><code>InetAddress</code>没有<code>public</code>构造器，必须通过一系列的静态方法获取实例。</strong>如下表所示。</p><div class="table-container"><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>static InetAddress[] getAllByName(String host)</code></td><td style="text-align:left">在给定主机名的情况下，根据系统上配置的名称服务返回其 IP 地址所组成的数组。</td></tr><tr><td style="text-align:left"><code>static InetAddress getByAddress(byte[] addr)</code></td><td style="text-align:left">在给定原始 IP 地址的情况下，返回 InetAddress 对象。</td></tr><tr><td style="text-align:left"><code>static InetAddress getByAddress(String host, byte[] addr)</code></td><td style="text-align:left">根据提供的主机名和 IP 地址创建 InetAddress。</td></tr><tr><td style="text-align:left"><code>static InetAddress getByName(String host)</code></td><td style="text-align:left">在给定主机名的情况下确定主机的 IP 地址。</td></tr><tr><td style="text-align:left"><code>static InetAddress getLocalHost()</code></td><td style="text-align:left">返回本地主机。</td></tr></tbody></table></div><p>在这些静态方法中，最为常用的应该是<code>getByName(String host)</code>方法，只需要传入目标主机的名字，</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>通过域名获取<code>InetAddress</code>对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用域名创建InetAddress对象</span></span><br><span class="line">InetAddress inetAddr = InetAddress.getByName(<span class="string">"github.com"</span>);</span><br></pre></td></tr></table></figure><br>通过IP地址获取InetAddress对象:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用点分十进制IP地址创建InetAddress对象</span></span><br><span class="line">InetAddress inetAddr = InetAddress.getByName(<span class="string">"52.74.223.119"</span>);</span><br></pre></td></tr></table></figure><br>获取本机的InetAddress对象:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InetAddress address = InetAddress.getLocalHost();</span><br></pre></td></tr></table></figure></p><h3 id="重写Object类的方法："><a href="#重写Object类的方法：" class="headerlink" title="重写Object类的方法："></a>重写Object类的方法：</h3><div class="table-container"><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>boolean equals(Object obj)</code></td><td style="text-align:left">将此对象与指定对象比较。</td></tr><tr><td style="text-align:left"><code>int hashCode()</code></td><td style="text-align:left">返回此 IP 地址的哈希码。</td></tr><tr><td style="text-align:left"><code>String toString()</code></td><td style="text-align:left">将此 IP 地址转换为 String。</td></tr></tbody></table></div><p>实例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据域名生成实例</span></span><br><span class="line">InetAddress inetAddr=InetAddress.getByName(<span class="string">"github.com"</span>);</span><br><span class="line">System.out.println(inetAddr.toString());</span><br><span class="line"><span class="comment">//根据IP地址生产实例</span></span><br><span class="line">inetAddr=InetAddress.getByName(<span class="string">"13.250.177.223"</span>);</span><br><span class="line">System.out.println(inetAddr.toString());</span><br><span class="line"><span class="comment">//获取本机</span></span><br><span class="line">inetAddr=InetAddress.getLocalHost();</span><br><span class="line">System.out.println(inetAddr.toString());</span><br></pre></td></tr></table></figure><br>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">github.com&#x2F;13.250.177.223</span><br><span class="line">&#x2F;13.250.177.223</span><br><span class="line">DESKTOP-9H231R6&#x2F;192.168.233.233</span><br></pre></td></tr></table></figure></p><h3 id="获取IP地址相关信息的方法"><a href="#获取IP地址相关信息的方法" class="headerlink" title="获取IP地址相关信息的方法"></a>获取IP地址相关信息的方法</h3><div class="table-container"><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>String getCanonicalHostName()</code></td><td style="text-align:left">获取此 IP 地址的完全限定域名。</td></tr><tr><td style="text-align:left"><code>String getHostAddress()</code></td><td style="text-align:left">获取点分十进制表示的ip地址</td></tr><tr><td style="text-align:left"><code>byte[] getAddress()</code></td><td style="text-align:left">获取字节数组表示的ip地址</td></tr><tr><td style="text-align:left"><code>String getHostName()</code></td><td style="text-align:left">获取此 IP 地址的主机名。</td></tr></tbody></table></div><p>实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; 使用域名创建对象</span><br><span class="line">        InetAddress inetAddr &#x3D; InetAddress.getByName(&quot;github.com&quot;);</span><br><span class="line">        System.out.println(&quot;IP地址的完全限定域名：&quot; + inetAddr.getCanonicalHostName());</span><br><span class="line">        System.out.println(&quot;主机IP地址为：&quot; + inetAddr.getHostAddress());</span><br><span class="line">        System.out.println(&quot;主机名称为：&quot; + inetAddr.getHostName());</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; byte[] getAddress() 返回此 InetAddress 对象的原始 IP 地址。</span><br><span class="line">        byte[] ipbyte &#x3D; inetAddr.getAddress();&#x2F;&#x2F; 获取原始IP地址</span><br><span class="line">        System.out.println(&quot;字节数组表示的ip地址：&quot; + Arrays.toString(ipbyte));</span><br><span class="line">        System.out.print(&quot;字节地址转为点分十进制表示:&quot;);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; ipbyte.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (i !&#x3D; 0)</span><br><span class="line">                System.out.print(&quot;.&quot;);</span><br><span class="line">            System.out.print(Byte.toUnsignedInt(ipbyte[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125; catch (Exception e)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IP地址的完全限定域名：ec2-52-74-223-119.ap-southeast-1.compute.amazonaws.com</span><br><span class="line">主机IP地址为：52.74.223.119</span><br><span class="line">主机名称为：github.com</span><br><span class="line">字节数组表示的ip地址：[52, 74, -33, 119]</span><br><span class="line">字节地址转为点分十进制表示:52.74.223.119</span><br></pre></td></tr></table></figure><br>从运行结果中可以看到<code>getHostAddress()</code>方法获取的是字符串表示的IP地址(点分十进制)，而<code>getAddress()</code>获取的是字节数组表示的IP地址，这两者只是表示方式不同而已，两者之间可以相互转化。</p><h3 id="判断方法："><a href="#判断方法：" class="headerlink" title="判断方法："></a>判断方法：</h3><div class="table-container"><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>boolean isAnyLocalAddress()</code></td><td style="text-align:left">检查 InetAddress 是否是通配符地址的实用例行程序。</td></tr><tr><td style="text-align:left"><code>boolean isLinkLocalAddress()</code></td><td style="text-align:left">检查 InetAddress 是否是链接本地地址的实用例行程序。</td></tr><tr><td style="text-align:left"><code>boolean isLoopbackAddress()</code></td><td style="text-align:left">检查 InetAddress 是否是回送地址的实用例行程序。</td></tr><tr><td style="text-align:left"><code>boolean isMCGlobal()</code></td><td style="text-align:left">检查多播地址是否具有全局域的实用例行程序。</td></tr><tr><td style="text-align:left"><code>boolean isMCLinkLocal()</code></td><td style="text-align:left">检查多播地址是否具有链接范围的实用例行程序。</td></tr><tr><td style="text-align:left"><code>boolean isMCNodeLocal()</code></td><td style="text-align:left">检查多播地址是否具有节点范围的实用例行程序。</td></tr><tr><td style="text-align:left"><code>boolean isMCOrgLocal()</code></td><td style="text-align:left">检查多播地址是否具有组织范围的实用例行程序。</td></tr><tr><td style="text-align:left"><code>boolean isMCSiteLocal()</code></td><td style="text-align:left">检查多播地址是否具有站点范围的实用例行程序。</td></tr><tr><td style="text-align:left"><code>boolean isMulticastAddress()</code></td><td style="text-align:left">检查 InetAddress 是否是 IP 多播地址的实用例行程序。</td></tr><tr><td style="text-align:left"><code>boolean isReachable(int timeout)</code></td><td style="text-align:left">测试是否可以达到该地址。</td></tr><tr><td style="text-align:left"><code>boolean isReachable(NetworkInterface netif,int ttl, int timeout)</code></td><td style="text-align:left">测试是否可以达到该地址。</td></tr><tr><td style="text-align:left"><code>boolean isSiteLocalAddress()</code></td><td style="text-align:left">检查 InetAddress 是否是站点本地地址的实用例行程序。</td></tr></tbody></table></div><blockquote><p>原文链接: <a href="https://www.lansheng.net.cn/blog/eadab85c/" target="_blank" rel="noopener">3Java网络编程技术</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java 网络编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2网络编程技术</title>
      <link href="/ReadingNotes//20535608/"/>
      <url>/ReadingNotes//20535608/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/20535608/#网络编程步骤" class="header_2">网络编程步骤</a>&nbsp;<br><a href="/ReadingNotes/20535608/#客户端网络编程步骤" class="header_3">客户端网络编程步骤</a>&nbsp;<br><a href="/ReadingNotes/20535608/#建立网络连接" class="header_4">建立网络连接</a>&nbsp;<br><a href="/ReadingNotes/20535608/#交换数据" class="header_4">交换数据</a>&nbsp;<br><a href="/ReadingNotes/20535608/#关闭网络连接" class="header_4">关闭网络连接</a>&nbsp;<br><a href="/ReadingNotes/20535608/#服务器端网络编程步骤" class="header_2">服务器端网络编程步骤</a>&nbsp;<br><a href="/ReadingNotes/20535608/#监听端口" class="header_3">监听端口</a>&nbsp;<br><a href="/ReadingNotes/20535608/#获得连接" class="header_3">获得连接</a>&nbsp;<br><a href="/ReadingNotes/20535608/#交换数据" class="header_3">交换数据</a>&nbsp;<br><a href="/ReadingNotes/20535608/#关闭连接" class="header_3">关闭连接</a>&nbsp;<br><a href="/ReadingNotes/20535608/#现实的例子" class="header_3">现实的例子</a>&nbsp;<br><a href="/ReadingNotes/20535608/#小结" class="header_2">小结</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><p>原文:<a href="https://blog.csdn.net/sihai12345/article/details/79334299" target="_blank" rel="noopener">https://blog.csdn.net/sihai12345/article/details/79334299</a></p><p>前面介绍了网络编程的相关基础知识，初步建立了网络编程的概念，但是实际学习网络编程还必须使用某种程序设计语言进行代码实现，下面就介绍一下网络编程的代码实现。</p><h2 id="网络编程步骤"><a href="#网络编程步骤" class="headerlink" title="网络编程步骤"></a>网络编程步骤</h2><p>按照前面的基础知识介绍，<strong>无论使用TCP方式还是UDP方式进行网络通讯，网络编程都是由客户端和服务器端组成。</strong>当然<strong>，B/S结构的编程中只需要实现服务器端即可</strong>。所以，下面介绍网络编程的步骤时，均以C/S结构为基础进行介绍。</p><p>说明：这里的步骤实现和语言无关，也就是说，这个步骤适用于各种语言实现，不局限于Java语言。</p><h3 id="客户端网络编程步骤"><a href="#客户端网络编程步骤" class="headerlink" title="客户端网络编程步骤"></a>客户端网络编程步骤</h3><p><strong>客户端(Client)是指网络编程中首先发起连接的程序</strong>，客户端一般实现程序界面和基本逻辑实现，在进行实际的客户端编程时，无论客户端复杂还是简单，以及客户端实现的方式，客户端的编程主要由三个步骤实现：</p><h4 id="建立网络连接"><a href="#建立网络连接" class="headerlink" title="建立网络连接"></a>建立网络连接</h4><p><strong>客户端网络编程的第一步都是建立网络连接</strong>。<strong>在建立网络连接时需要指定连接到的服务器的IP地址和端口号</strong>，建立完成以后，会形成一条虚拟的连接，后续的操作就可以通过该连接实现数据交换了。</p><h4 id="交换数据"><a href="#交换数据" class="headerlink" title="交换数据"></a>交换数据</h4><p>连接建立以后，就可以通过这个连接交换数据了。<strong>交换数据严格按照请求响应模型进行，由客户端发送一个请求数据到服务器，服务器反馈一个响应数据给客户端</strong>，如果客户端不发送请求则服务器端就不响应。</p><p>根据逻辑需要，可以多次交换数据，但是还是必须遵循请求响应模型。</p><h4 id="关闭网络连接"><a href="#关闭网络连接" class="headerlink" title="关闭网络连接"></a>关闭网络连接</h4><p>在数据交换完成以后，关闭网络连接，释放程序占用的端口、内存等系统资源，结束网络编程。</p><p>最基本的步骤一般都是这三个步骤，在实际实现时，步骤2会出现重复，在进行代码组织时，由于网络编程是比较耗时的操作，所以一般开启专门的现场进行网络通讯。</p><h2 id="服务器端网络编程步骤"><a href="#服务器端网络编程步骤" class="headerlink" title="服务器端网络编程步骤"></a>服务器端网络编程步骤</h2><p><strong>服务器端(Server)是指在网络编程中被动等待连接的程序</strong>，服务器端一般实现程序的核心逻辑以及数据存储等核心功能。服务器端的编程步骤和客户端不同，是<strong>由四个步骤实现</strong>，依次是：</p><h3 id="监听端口"><a href="#监听端口" class="headerlink" title="监听端口"></a>监听端口</h3><p>服务器端属于被动等待连接，所以服务器端启动以后，不需要发起连接，而只需要监听本地计算机的某个固定端口即可。</p><p>这个端口就是服务器端开放给客户端的端口，服务器端程序运行的本地计算机的IP地址就是服务器端程序的IP地址。</p><h3 id="获得连接"><a href="#获得连接" class="headerlink" title="获得连接"></a>获得连接</h3><p>当客户端连接到服务器端时，服务器端就可以获得一个连接，这个连接包含客户端的信息，例如客户端IP地址等等，服务器端和客户端也通过该连接进行数据交换。</p><p>一般在服务器端编程中，当获得连接时，需要开启专门的线程处理该连接，每个连接都由独立的线程实现。</p><h3 id="交换数据-1"><a href="#交换数据-1" class="headerlink" title="交换数据"></a>交换数据</h3><p>服务器端通过获得的连接进行数据交换。<strong>服务器端的数据交换步骤是首先接收客户端发送过来的数据，然后进行逻辑处理，再把处理以后的结果数据发送给客户端</strong>。简单来说，就是<strong>先接收请求再发送处理结果(响应)</strong>，这个和客户端的数据交换数序不同。</p><p>其实，服务器端获得的连接和客户端连接是一样的，只是数据交换的步骤不同。</p><p>当然，服务器端的数据交换也是可以多次进行的。</p><p>在数据交换完成以后，关闭和客户端的连接。</p><h3 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h3><p>当服务器程序关闭时，需要关闭服务器端，通过关闭服务器端使得服务器监听的端口以及占用的内存可以释放出来，实现了连接的关闭。</p><h3 id="现实的例子"><a href="#现实的例子" class="headerlink" title="现实的例子"></a>现实的例子</h3><p>其实<strong>服务器端编程的模型和呼叫中心的实现是类似的</strong>，例如移动的客服电话10086就是典型的呼叫中心，当一个用户拨打10086时，转接给一个专门的客服人员，由该客服实现和该用户的问题解决，当另外一个用户拨打10086时，则转接给另一个客服，实现问题解决，依次类推。</p><p>在服务器端编程时，10086这个电话号码就类似于服务器端的端口号码，每个用户就相当于一个客户端程序，每个客服人员就相当于服务器端启动的专门和客户端连接的线程，每个线程都是独立进行交互的。</p><p>这就是服务器端编程的模型，<strong>只是TCP方式是需要建立连接的，对于服务器端的压力比较大，而UDP是不需要建立连接的，对于服务器端的压力比较小罢了</strong>。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>总之，<strong>无论使用任何语言，任何方式进行基础的网络编程，都必须遵循固定的步骤进行操作</strong>，在熟悉了这些步骤以后，可以根据需要进行逻辑上的处理，但是还是必须遵循固定的步骤进行。</p><p>其实，基础的网络编程本身不难，也不需要很多的基础网络知识，只是由于编程的基础功能都已经由API实现，而且需要按照固定的步骤进行，所以在入门时有一定的门槛，希望下面的内容能够将你快速的带入网络编程技术的大门。</p><blockquote><p>原文链接: <a href="https://www.lansheng.net.cn/blog/20535608/" target="_blank" rel="noopener">2网络编程技术</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java 网络编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1网络概述</title>
      <link href="/ReadingNotes//d9a41e7d/"/>
      <url>/ReadingNotes//d9a41e7d/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/ReadingNotes/d9a41e7d/#网络概述" class="header_2">网络概述</a>&nbsp;<br><a href="/ReadingNotes/d9a41e7d/#计算机网络概述" class="header_3">计算机网络概述</a>&nbsp;<br><a href="/ReadingNotes/d9a41e7d/#从网络中找到一个计算机--IP地址" class="header_4">从网络中找到一个计算机--IP地址</a>&nbsp;<br><a href="/ReadingNotes/d9a41e7d/#域名--方便记忆" class="header_4">域名--方便记忆</a>&nbsp;<br><a href="/ReadingNotes/d9a41e7d/#域名和IP地址的区别" class="header_4">域名和IP地址的区别</a>&nbsp;<br><a href="/ReadingNotes/d9a41e7d/#在一个计算机中找到一个程序--端口" class="header_4">在一个计算机中找到一个程序--端口</a>&nbsp;<br><a href="/ReadingNotes/d9a41e7d/#在网络上找到一个程序：IP地址-端口号" class="header_4">在网络上找到一个程序：IP地址+端口号</a>&nbsp;<br><a href="/ReadingNotes/d9a41e7d/#网络编程概述" class="header_1">网络编程概述</a>&nbsp;<br><a href="/ReadingNotes/d9a41e7d/#请求响应模型" class="header_2">请求响应模型</a>&nbsp;<br><a href="/ReadingNotes/d9a41e7d/#请求响应模型" class="header_2">请求响应模型</a>&nbsp;<br><a href="/ReadingNotes/d9a41e7d/#客户端/服务器结构" class="header_2">客户端/服务器结构</a>&nbsp;<br><a href="/ReadingNotes/d9a41e7d/#优缺点" class="header_3">优缺点</a>&nbsp;<br><a href="/ReadingNotes/d9a41e7d/#浏览器/服务器结构" class="header_2">浏览器/服务器结构</a>&nbsp;<br><a href="/ReadingNotes/d9a41e7d/#优点：" class="header_3">优点：</a>&nbsp;<br><a href="/ReadingNotes/d9a41e7d/#缺点" class="header_3">缺点</a>&nbsp;<br><a href="/ReadingNotes/d9a41e7d/#P2P-Point-to-Point-程序" class="header_2">P2P(Point to Point)程序</a>&nbsp;<br><a href="/ReadingNotes/d9a41e7d/#协议-Protocol" class="header_2">协议(Protocol)</a>&nbsp;<br><a href="/ReadingNotes/d9a41e7d/#协议的列子" class="header_3">协议的列子</a>&nbsp;<br><a href="/ReadingNotes/d9a41e7d/#网络通讯方式" class="header_1">网络通讯方式</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><ul><li><a href="/blog/d9a41e7d/#网络概述">网络概述</a><ul><li><a href="/blog/d9a41e7d/#计算机网络概述">计算机网络概述</a><ul><li><a href="/blog/d9a41e7d/#从网络中找到一个计算机-IP地址">从网络中找到一个计算机—IP地址</a></li><li><a href="/blog/d9a41e7d/#域名-方便记忆">域名—方便记忆</a></li><li><a href="/blog/d9a41e7d/#域名和IP地址的区别">域名和IP地址的区别</a></li><li><a href="/blog/d9a41e7d/#在一个计算机中找到一个程序-端口">在一个计算机中找到一个程序—端口</a></li><li><a href="/blog/d9a41e7d/#在网络上找到一个程序：IP地址-端口号">在网络上找到一个程序：IP地址+端口号</a></li></ul></li></ul></li><li><a href="/blog/d9a41e7d/#网络编程概述">网络编程概述</a></li><li><a href="/blog/d9a41e7d/#请求响应模型">请求响应模型</a></li><li><a href="/blog/d9a41e7d/#请求响应模型">请求响应模型</a></li><li><a href="/blog/d9a41e7d/#客户端-服务器结构">客户端/服务器结构</a><ul><li><a href="/blog/d9a41e7d/#优缺点">优缺点</a></li></ul></li><li><a href="/blog/d9a41e7d/#浏览器-服务器结构">浏览器/服务器结构</a><ul><li><a href="/blog/d9a41e7d/#优点：">优点：</a></li><li><a href="/blog/d9a41e7d/#缺点">缺点</a></li></ul></li><li><a href="/blog/d9a41e7d/#P2P-Point-to-Point-程序">P2P(Point to Point)程序</a></li><li><a href="/blog/d9a41e7d/#协议-Protocol-">协议(Protocol)</a><ul><li><a href="/blog/d9a41e7d/#协议的列子">协议的列子</a></li></ul></li><li><a href="/blog/d9a41e7d/#网络通讯方式">网络通讯方式</a></li></ul><!--more--><h2 id="网络概述"><a href="#网络概述" class="headerlink" title="网络概述"></a>网络概述</h2><p><strong>网络编程就是在两个或两个以上的设备(例如计算机)之间传输数据。</strong><br><strong>程序员所作的事情就是把数据发送到指定的位置，或者接收到指定的数据，这个就是狭义的网络编程范畴。</strong><br>在发送和接收数据时，大部分的程序设计语言都设计了专门的API实现这些功能，程序员只需要调用即可。所以，基础的网络编程可以和打电话一样简单。</p><h3 id="计算机网络概述"><a href="#计算机网络概述" class="headerlink" title="计算机网络概述"></a>计算机网络概述</h3><p><strong>网络编程的实质就是两个(或多个)设备(例如计算机)之间的数据传输。</strong></p><p><strong>网络最主要的优势在于共享</strong>：共享设备和数据，现在共享设备最常见的是打印机，一个公司一般一个打印机即可，共享数据就是将大量的数据存储在一组机器中，其它的计算机通过网络访问这些数据，例如网站、银行服务器等等。</p><p><strong>对于网络编程来说，最主要的是计算机和计算机之间的通信</strong>，这样首要的问题就是如何找到网络上的计算机呢？这就需要了解IP地址的概念。</p><h4 id="从网络中找到一个计算机—IP地址"><a href="#从网络中找到一个计算机—IP地址" class="headerlink" title="从网络中找到一个计算机—IP地址"></a>从网络中找到一个计算机—IP地址</h4><p><strong>为了能够方便的识别网络上的每个设备，网络中的每个设备都会有一个唯一的数字标识，这个就是IP地址。</strong>在计算机网络中,现在命名IP地址的规定是IPv4协议，该协议规定每个IP地址由4个0-255之间的数字组成，例如10.0.120.34。每个接入网络的计算机都拥有唯一的IP地址，这个IP地址可能是固定的，例如网络上各种各样的服务器，也可以是动态的，例如使用ADSL拨号上网的宽带用户，无论以何种方式获得或是否是固定的，<strong>每个计算机在联网以后都拥有一个唯一的合法IP地址</strong>，就像每个手机号码一样。</p><h4 id="域名—方便记忆"><a href="#域名—方便记忆" class="headerlink" title="域名—方便记忆"></a>域名—方便记忆</h4><p>但是由于IP地址不容易记忆，所以为了方便记忆，有创造了另外一个概念——域名(Domain Name)，例如sohu.com等。<strong>一个IP地址可以对应多个域名，一个域名只能对应一个IP地址。</strong>域名的概念可以类比手机中的通讯簿，由于手机号码不方便记忆，所以添加一个姓名标识号码，在实际拨打电话时可以选择该姓名，然后拨打即可。</p><p><strong>在网络中传输的数据，全部是以IP地址作为地址标识，所以在实际传输数据以前需要将域名转换为IP地址，实现这种功能的服务器称之为DNS服务器</strong>，也就是通俗的说法叫做域名解析。例如当用户在浏览器输入域名时，浏览器首先请求DNS服务器，将域名转换为IP地址，然后将转换后的IP地址反馈给浏览器，然后再进行实际的数据传输。</p><h4 id="域名和IP地址的区别"><a href="#域名和IP地址的区别" class="headerlink" title="域名和IP地址的区别"></a>域名和IP地址的区别</h4><p>当DNS服务器正常工作时，使用IP地址或域名都可以很方便的找到计算机网络中的某个设备，例如服务器计算机。<strong>当DNS不正常工作时，只能通过IP地址访问该设备。所以IP地址的使用要比域名通用一些。</strong></p><h4 id="在一个计算机中找到一个程序—端口"><a href="#在一个计算机中找到一个程序—端口" class="headerlink" title="在一个计算机中找到一个程序—端口"></a>在一个计算机中找到一个程序—端口</h4><p><strong>IP地址和域名很好的解决了在网络中找到一个计算机的问题</strong>，但是为了让一个计算机可以同时运行多个网络程序，就引入了另外一个概念——端口(port)。</p><p>在介绍端口的概念以前，首先来看一个例子，一般一个公司前台会有一个电话，每个员工会有一个分机，这样如果需要找到这个员工的话，需要首先拨打前台总机，然后转该分机号即可。这样减少了公司的开销，也方便了每个员工。在该示例中<strong>前台总机的电话号码就相当于IP地址，而每个员工的分机号就相当于端口。</strong></p><p>有了端口的概念以后，<strong>在同一个计算机中每个程序对应唯一的端口，这样一个计算机上就可以通过端口区分发送给每个端口的数据了</strong>，换句话说，也就是一个计算机上可以并发运行多个网络程序，而不会在互相之间产生干扰。</p><p>在硬件上规定<strong>，端口的号码必须位于0-65535之间，每个端口唯一的对应一个网络程序，一个网络程序可以使用多个端口。</strong>这样一个网络程序运行在一台计算上时，不管是客户端还是服务器，都是至少占用一个端口进行网络通讯。<strong>在接收数据时，首先发送给对应的计算机，然后计算机根据端口把数据转发给对应的程序。</strong></p><h4 id="在网络上找到一个程序：IP地址-端口号"><a href="#在网络上找到一个程序：IP地址-端口号" class="headerlink" title="在网络上找到一个程序：IP地址+端口号"></a>在网络上找到一个程序：IP地址+端口号</h4><p>有了IP地址和端口的概念以后，<strong>在进行网络通讯交换时，就可以通过IP地址查找到该台计算机，然后通过端口标识这台计算机上的一个唯一的程序</strong>。这样就可以进行网络数据的交换了。</p><p>但是，进行网络编程时，只有IP地址和端口的概念还是不够的，下面就介绍一下基础的网络编程相关的软件基础知识。</p><h1 id="网络编程概述"><a href="#网络编程概述" class="headerlink" title="网络编程概述"></a>网络编程概述</h1><p>按照前面的介绍，<strong>网络编程就是两个或多个设备之间的数据交换</strong>，<strong>其实更具体的说，网络编程就是两个或多个程序之间的数据交换</strong>，和普通的单机程序相比，网络程序最大的不同就是需要交换数据的程序运行在不同的计算机上，这样就造成了数据交换的复杂。虽然通过IP地址和端口可以找到网络上运行的一个程序，但是如果需要进行网络编程，则还需要了解网络通讯的过程。</p><h2 id="请求响应模型"><a href="#请求响应模型" class="headerlink" title="请求响应模型"></a>请求响应模型</h2><p>网络通讯基于“请求-响应”模型。为了理解这个模型，先来看一个例子，经常看电视的人肯定见过审讯的场面吧，一般是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">警察：姓名</span><br><span class="line">嫌疑犯：XXX</span><br><span class="line">警察：性别</span><br><span class="line">嫌疑犯：男</span><br><span class="line">警察：年龄</span><br><span class="line">嫌疑犯：29</span><br><span class="line">……</span><br></pre></td></tr></table></figure><h2 id="请求响应模型-1"><a href="#请求响应模型-1" class="headerlink" title="请求响应模型"></a>请求响应模型</h2><p>在这个例子中，警察问一句，嫌疑犯回答一句，如果警察不问，则嫌疑犯保持沉默。<strong>这种一问一答的形式就是网络中的“请求-响应”模型</strong>。也就是通讯的一端发送数据，另外一端反馈数据，网络通讯都基于该模型。</p><p>在网络通讯中，<strong>第一次主动发起通讯的程序被称作客户端(Client)程序，简称客户端</strong>，而<strong>在第一次通讯中等待连接的程序被称作服务器端(Server)程序，简称服务器</strong>。<strong>一旦通讯建立，则客户端和服务器端完全一样，没有本质的区别。</strong></p><h2 id="客户端-服务器结构"><a href="#客户端-服务器结构" class="headerlink" title="客户端/服务器结构"></a>客户端/服务器结构</h2><p>由此<strong>，网络编程中的两种程序就分别是客户端和服务器端</strong>，例如QQ程序，每个QQ用户安装的都是QQ客户端程序，而QQ服务器端程序则运行在腾讯公司的机房中，为大量的QQ用户提供服务。这种网络编程的结构被称作<strong>客户端/服务器结构</strong>，也叫做Client/Server结构，简称<strong>C/S结构</strong>。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>使用C/S结 构的程序，在开发时需要分别开发客户端和服务器端，这种结构的优势在于由于客户端是专门开发的，所以根据需要实现各种效果，专业点说就是表现力丰富，而服 务器端也需要专门进行开发。但是这种结构也存在着很多不足，例如通用性差，几乎不能通用等，也就是说<strong>一种程序的客户端只能和对应的服务器端通讯，而不能和 其它服务器端通讯，在实际维护时，也需要维护专门的客户端和服务器端，维护的压力比较大。</strong></p><h2 id="浏览器-服务器结构"><a href="#浏览器-服务器结构" class="headerlink" title="浏览器/服务器结构"></a>浏览器/服务器结构</h2><p>其实在运行很多程序时，没有必要使用专用的客户端，而需要使用通用的客户端，例如浏览器，使用<strong>浏览器作为客户端的结构被称作浏览器/服务器结构，也叫做Browser/Server结构，简称为B/S结构。</strong></p><p><strong>使用B/S结构的程序，在开发时只需要开发服务器端即可</strong></p><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>这种结构的优势在于开发的压力比较小，不需要维护客户端。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>但是这种结构也存在着很多不足，例如浏览器的限制比较大，表现力不强，无法进行系统级操作等。</p><p>总之C/S结构和B/S结构是现在网络编程中常见的两种结构，B/S结构其实也就是一种特殊的C/S结构。</p><h2 id="P2P-Point-to-Point-程序"><a href="#P2P-Point-to-Point-程序" class="headerlink" title="P2P(Point to Point)程序"></a>P2P(Point to Point)程序</h2><p>另外简单的介绍一下P2P(Point to Point)程序，常见的如BT、电驴等。<strong>P2P程序是一种特殊的程序，应该一个P2P程序中既包含客户端程序，也包含服务器端程序</strong>，例如BT，使用客户端程序部分连接其它的种子(服务器端)，而使用服务器端向其它的BT客户端传输数据。如果这个还不是很清楚，其实P2P程序和手机是一样的，当手机拨打电话时就是使用客户端的作用，而手机处于待机状态时，可以接收到其它用户拨打的电话则起的就是服务器端的功能，只是一般的手机不能同时使用拨打电话和接听电话的功能，而P2P程序实现了该功能。</p><h2 id="协议-Protocol"><a href="#协议-Protocol" class="headerlink" title="协议(Protocol)"></a>协议(Protocol)</h2><p>最后再介绍一个网络编程中最重要，也是最复杂的概念——协议(Protocol)。按照前面的介绍，<strong>网络编程就是运行在不同计算机中两个程序之间的数据交换</strong>。在实际进行数据交换时，<strong>为了让接收端理解该数据</strong>，计算机比较笨，什么都不懂的，那么<strong>就需要规定该数据的格式，这个数据的格式就是协议。</strong></p><h3 id="协议的列子"><a href="#协议的列子" class="headerlink" title="协议的列子"></a>协议的列子</h3><p>如 果没有理解协议的概念，那么再举一个例子，记得有个电影叫《永不消逝的电波》，讲述的是地下党通过电台发送情报的故事，这里我们不探讨电影的剧情，而只关 心电台发送的数据。在<strong>实际发报时，需要首先将需要发送的内容转换为电报编码，然后将电报编码发送出去，而接收端接收的是电报编码，如果需要理解电报的内容 则需要根据密码本翻译出该电报的内容</strong>。<strong>这里的密码本就规定了一种数据格式，这种对于网络中传输的数据格式在网络编程中就被称作协议。</strong></p><p>那么如何来编写协议格式呢？答案是随意。只要按照这种协议格式能够生成唯一的编码，按照该编码可以唯一的解析出发送数据的内容即可。也正因为各个网络程序之间协议格式的不同，所以才导致了客户端程序都是专用的结构。</p><p>在实际的网络程序编程中，最麻烦的内容不是数据的发送和接收，因为这个功能在几乎所有的程序语言中都提供了封装好的API进行调用，最麻烦的内容就是协议的设计以及协议的生产和解析，这个才是网络编程中最核心的内容。</p><p>关于网络编程的基础知识，就介绍这里，深刻理解IP地址、端口和协议等概念，将会极大的有助于后续知识的学习。 </p><h1 id="网络通讯方式"><a href="#网络通讯方式" class="headerlink" title="网络通讯方式"></a>网络通讯方式</h1><p>在现有的网络中，网络通讯的方式主要有两种：</p><ul><li>TCP(传输控制协议)方式</li><li>UDP(用户数据报协议)方式</li></ul><p>为 了方便理解这两种方式，还是先来看一个例子。大家使用手机时，向别人传递信息时有两种方式：拨打电话和发送短信。使用拨打电话的方式可以保证将信息传递给 别人，因为别人接听电话时本身就确认接收到了该信息。而发送短信的方式价格低廉，使用方便，但是接收人有可能接收不到。</p><p>在网络通讯中，<strong>TCP方式就类似于拨打电话</strong>，使用该种方式进行网络通讯时，<strong>需要建立专门的虚拟连接，然后进行可靠的数据传输，如果数据发送失败，则客户端会自动重发该数据。</strong></p><p>而<strong>UDP方式就类似于发送短信</strong>，使用这种方式进行网络通讯时，不需要建立专门的虚拟连接，传输也不是很可靠，如果发送失败则客户端无法获得。</p><p>这两种传输方式都是实际的网络编程中进行使用，<strong>重要的数据一般使用TCP方式进行数据传输</strong>，而大量的<strong>非核心数据则都通过UDP方式进行传递</strong>，在一些程序中甚至结合使用这两种方式进行数据的传递。</p><p>由于TCP需要建立专用的虚拟连接以及确认传输是否正确，所以使用TCP方式的速度稍微慢一些，而且传输时产生的数据量要比UDP稍微大一些。</p><p>关于网络编程的基础知识就介绍这么多，如果需要深入了解相关知识请阅读专门的计算机网络书籍，下面开始介绍Java语言中网络编程的相关技术。</p><blockquote><p>原文链接: <a href="https://www.lansheng.net.cn/blog/d9a41e7d/" target="_blank" rel="noopener">1网络概述</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java 网络编程 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
